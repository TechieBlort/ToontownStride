/*
 * This file was generated by:
 * built/bin/interrogate -srcdir panda/src/pnmtext -Ipanda/src/pnmtext -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3pnmtext_igate.cxx -od built/pandac/input/libp3pnmtext.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/pnmtext -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -S/usr/include/freetype2 -S/usr/include/libpng16 -S/usr/include/harfbuzz -S/usr/include/glib-2.0 -S/usr/lib/glib-2.0/include -module panda3d.core -library libp3pnmtext config_pnmtext.h freetypeFace.h freetypeFont.h p3pnmtext_composite1.cxx pnmTextGlyph.h pnmTextMaker.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "configVariableBool.h"
#include "configVariableDouble.h"
#include "config_pnmtext.h"
#include "filename.h"
#include "freetypeFace.h"
#include "freetypeFont.h"
#include <ft2build.h>
#include "mutexHolder.h"
#include "namable.h"
#include "notifyCategoryProxy.h"
#include "pandabase.h"
#include "pmap.h"
#include "pmutex.h"
#include "pnmImage.h"
#include "pnmTextGlyph.h"
#include "pnmTextMaker.h"
#include "pvector.h"
#include "typedReferenceCount.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class FreetypeFont
 */
typedef FreetypeFont FreetypeFont_localtype;
Define_Module_Class(panda3d.core, FreetypeFont, FreetypeFont_localtype, FreetypeFont);
static struct Dtool_PyTypedObject *const Dtool_Ptr_FreetypeFont = &Dtool_FreetypeFont;
static void Dtool_PyModuleClassInit_FreetypeFont(PyObject *module);

/**
 * Forward declarations for top-level class PNMTextGlyph
 */
typedef PNMTextGlyph PNMTextGlyph_localtype;
Define_Module_Class(panda3d.core, PNMTextGlyph, PNMTextGlyph_localtype, PNMTextGlyph);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PNMTextGlyph = &Dtool_PNMTextGlyph;
static void Dtool_PyModuleClassInit_PNMTextGlyph(PyObject *module);

/**
 * Forward declarations for top-level class PNMTextMaker
 */
typedef PNMTextMaker PNMTextMaker_localtype;
Define_Module_Class(panda3d.core, PNMTextMaker, PNMTextMaker_localtype, PNMTextMaker);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PNMTextMaker = &Dtool_PNMTextMaker;
static void Dtool_PyModuleClassInit_PNMTextMaker(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"FreetypeFont", &Dtool_FreetypeFont},
  {"PNMTextGlyph", &Dtool_PNMTextGlyph},
  {"PNMTextMaker", &Dtool_PNMTextMaker},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"Filename", nullptr},
#define Dtool_Ptr_Filename (imports[0].type)
  {"Namable", nullptr},
#define Dtool_Ptr_Namable (imports[1].type)
  {"LVecBase4f", nullptr},
#define Dtool_Ptr_LVecBase4f (imports[2].type)
  {"PNMImage", nullptr},
#define Dtool_Ptr_PNMImage (imports[3].type)
  {nullptr, nullptr},
};
#endif

// Filename
#ifndef LINK_ALL_STATIC
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != nullptr, nullptr);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != nullptr, nullptr);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// Namable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// PNMImage
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_PNMImage;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PNMImage = &Dtool_PNMImage;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class FreetypeFont
 */
/**
 * Python function wrapper for:
 * inline bool FreetypeFont::set_point_size(PN_stdfloat point_size)
 */
static PyObject *Dtool_FreetypeFont_set_point_size_5(PyObject *self, PyObject *arg) {
  FreetypeFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FreetypeFont, (void **)&local_this, "FreetypeFont.set_point_size")) {
    return nullptr;
  }
  // 1-inline bool FreetypeFont::set_point_size(PN_stdfloat point_size)
  if (PyNumber_Check(arg)) {
    bool return_value = ((*local_this).set_point_size)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_point_size(const FreetypeFont self, float point_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FreetypeFont_set_point_size_5_comment =
  "C++ Interface:\n"
  "set_point_size(const FreetypeFont self, float point_size)\n"
  "\n"
  "/**\n"
  " * Sets the point size of the font.  This controls the apparent size of the\n"
  " * font onscreen.  By convention, a 10 point font is about 1 screen unit high.\n"
  " *\n"
  " * This should only be called before any characters have been requested out of\n"
  " * the font, or immediately after calling clear().\n"
  " */";
#else
static const char *Dtool_FreetypeFont_set_point_size_5_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat FreetypeFont::get_point_size(void) const
 */
static PyObject *Dtool_FreetypeFont_get_point_size_6(PyObject *self, PyObject *) {
  FreetypeFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FreetypeFont)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat FreetypeFont::get_point_size(void) const
  PN_stdfloat return_value = ((*(const FreetypeFont*)local_this).get_point_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FreetypeFont_get_point_size_6_comment =
  "C++ Interface:\n"
  "get_point_size(FreetypeFont self)\n"
  "\n"
  "/**\n"
  " * Returns the point size of the font.\n"
  " */";
#else
static const char *Dtool_FreetypeFont_get_point_size_6_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool FreetypeFont::set_pixels_per_unit(PN_stdfloat pixels_per_unit)
 */
static PyObject *Dtool_FreetypeFont_set_pixels_per_unit_7(PyObject *self, PyObject *arg) {
  FreetypeFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FreetypeFont, (void **)&local_this, "FreetypeFont.set_pixels_per_unit")) {
    return nullptr;
  }
  // 1-inline bool FreetypeFont::set_pixels_per_unit(PN_stdfloat pixels_per_unit)
  if (PyNumber_Check(arg)) {
    bool return_value = ((*local_this).set_pixels_per_unit)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pixels_per_unit(const FreetypeFont self, float pixels_per_unit)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FreetypeFont_set_pixels_per_unit_7_comment =
  "C++ Interface:\n"
  "set_pixels_per_unit(const FreetypeFont self, float pixels_per_unit)\n"
  "\n"
  "/**\n"
  " * Set the resolution of the texture map, and hence the clarity of the\n"
  " * resulting font.  This sets the number of pixels in the texture map that are\n"
  " * used for each onscreen unit.\n"
  " *\n"
  " * Setting this number larger results in an easier to read font, but at the\n"
  " * cost of more texture memory.\n"
  " *\n"
  " * This should only be called before any characters have been requested out of\n"
  " * the font, or immediately after calling clear().\n"
  " */";
#else
static const char *Dtool_FreetypeFont_set_pixels_per_unit_7_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat FreetypeFont::get_pixels_per_unit(void) const
 */
static PyObject *Dtool_FreetypeFont_get_pixels_per_unit_8(PyObject *self, PyObject *) {
  FreetypeFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FreetypeFont)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat FreetypeFont::get_pixels_per_unit(void) const
  PN_stdfloat return_value = ((*(const FreetypeFont*)local_this).get_pixels_per_unit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FreetypeFont_get_pixels_per_unit_8_comment =
  "C++ Interface:\n"
  "get_pixels_per_unit(FreetypeFont self)\n"
  "\n"
  "/**\n"
  " * Returns the resolution of the texture map.  See set_pixels_per_unit().\n"
  " */";
#else
static const char *Dtool_FreetypeFont_get_pixels_per_unit_8_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool FreetypeFont::set_pixel_size(PN_stdfloat pixel_size)
 */
static PyObject *Dtool_FreetypeFont_set_pixel_size_9(PyObject *self, PyObject *arg) {
  FreetypeFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FreetypeFont, (void **)&local_this, "FreetypeFont.set_pixel_size")) {
    return nullptr;
  }
  // 1-inline bool FreetypeFont::set_pixel_size(PN_stdfloat pixel_size)
  if (PyNumber_Check(arg)) {
    bool return_value = ((*local_this).set_pixel_size)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pixel_size(const FreetypeFont self, float pixel_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FreetypeFont_set_pixel_size_9_comment =
  "C++ Interface:\n"
  "set_pixel_size(const FreetypeFont self, float pixel_size)\n"
  "\n"
  "/**\n"
  " * Computes the appropriate pixels_per_unit value to set the size of the font\n"
  " * in the texture to the indicated number of pixels.  This is just another way\n"
  " * to specify pixels_per_unit().\n"
  " */";
#else
static const char *Dtool_FreetypeFont_set_pixel_size_9_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat FreetypeFont::get_pixel_size(void) const
 */
static PyObject *Dtool_FreetypeFont_get_pixel_size_10(PyObject *self, PyObject *) {
  FreetypeFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FreetypeFont)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat FreetypeFont::get_pixel_size(void) const
  PN_stdfloat return_value = ((*(const FreetypeFont*)local_this).get_pixel_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FreetypeFont_get_pixel_size_10_comment =
  "C++ Interface:\n"
  "get_pixel_size(FreetypeFont self)\n"
  "\n"
  "/**\n"
  " * Returns the size of the font in pixels, as it appears in the texture.\n"
  " */";
#else
static const char *Dtool_FreetypeFont_get_pixel_size_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool FreetypeFont::set_scale_factor(PN_stdfloat scale_factor)
 */
static PyObject *Dtool_FreetypeFont_set_scale_factor_11(PyObject *self, PyObject *arg) {
  FreetypeFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FreetypeFont, (void **)&local_this, "FreetypeFont.set_scale_factor")) {
    return nullptr;
  }
  // 1-inline bool FreetypeFont::set_scale_factor(PN_stdfloat scale_factor)
  if (PyNumber_Check(arg)) {
    bool return_value = ((*local_this).set_scale_factor)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scale_factor(const FreetypeFont self, float scale_factor)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FreetypeFont_set_scale_factor_11_comment =
  "C++ Interface:\n"
  "set_scale_factor(const FreetypeFont self, float scale_factor)\n"
  "\n"
  "/**\n"
  " * Sets the factor by which the font is rendered larger by the FreeType\n"
  " * library before being filtered down to its actual size in the texture as\n"
  " * specified by set_pixels_per_unit().  This may be set to a number larger\n"
  " * than 1.0 to improve the font's antialiasing (since FreeType doesn't really\n"
  " * do a swell job of antialiasing by itself).  There is some performance\n"
  " * implication for setting this different than 1.0.\n"
  " *\n"
  " * This should only be called before any characters have been requested out of\n"
  " * the font, or immediately after calling clear().\n"
  " */";
#else
static const char *Dtool_FreetypeFont_set_scale_factor_11_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat FreetypeFont::get_scale_factor(void) const
 */
static PyObject *Dtool_FreetypeFont_get_scale_factor_12(PyObject *self, PyObject *) {
  FreetypeFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FreetypeFont)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat FreetypeFont::get_scale_factor(void) const
  PN_stdfloat return_value = ((*(const FreetypeFont*)local_this).get_scale_factor)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FreetypeFont_get_scale_factor_12_comment =
  "C++ Interface:\n"
  "get_scale_factor(FreetypeFont self)\n"
  "\n"
  "/**\n"
  " * Returns the antialiasing scale factor.  See set_scale_factor().\n"
  " */";
#else
static const char *Dtool_FreetypeFont_get_scale_factor_12_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FreetypeFont::set_native_antialias(bool native_antialias)
 */
static PyObject *Dtool_FreetypeFont_set_native_antialias_13(PyObject *self, PyObject *arg) {
  FreetypeFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FreetypeFont, (void **)&local_this, "FreetypeFont.set_native_antialias")) {
    return nullptr;
  }
  // 1-inline void FreetypeFont::set_native_antialias(bool native_antialias)
  ((*local_this).set_native_antialias)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_native_antialias(const FreetypeFont self, bool native_antialias)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FreetypeFont_set_native_antialias_13_comment =
  "C++ Interface:\n"
  "set_native_antialias(const FreetypeFont self, bool native_antialias)\n"
  "\n"
  "/**\n"
  " * Sets whether the Freetype library's built-in antialias mode is enabled.\n"
  " * There are two unrelated ways to achieve antialiasing: with Freetype's\n"
  " * native antialias mode, and with the use of a scale_factor greater than one.\n"
  " * By default, both modes are enabled.\n"
  " *\n"
  " * At low resolutions, some fonts may do better with one mode or the other.\n"
  " * In general, Freetype's native antialiasing will produce less blurry\n"
  " * results, but may introduce more artifacts.\n"
  " */";
#else
static const char *Dtool_FreetypeFont_set_native_antialias_13_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool FreetypeFont::get_native_antialias(void) const
 */
static PyObject *Dtool_FreetypeFont_get_native_antialias_14(PyObject *self, PyObject *) {
  FreetypeFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FreetypeFont)) {
    return nullptr;
  }
  // 1-inline bool FreetypeFont::get_native_antialias(void) const
  bool return_value = ((*(const FreetypeFont*)local_this).get_native_antialias)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FreetypeFont_get_native_antialias_14_comment =
  "C++ Interface:\n"
  "get_native_antialias(FreetypeFont self)\n"
  "\n"
  "/**\n"
  " * Returns whether Freetype's built-in antialias mode is enabled.  See\n"
  " * set_native_antialias().\n"
  " */";
#else
static const char *Dtool_FreetypeFont_get_native_antialias_14_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int FreetypeFont::get_font_pixel_size(void) const
 */
static PyObject *Dtool_FreetypeFont_get_font_pixel_size_15(PyObject *self, PyObject *) {
  FreetypeFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FreetypeFont)) {
    return nullptr;
  }
  // 1-inline int FreetypeFont::get_font_pixel_size(void) const
  int return_value = ((*(const FreetypeFont*)local_this).get_font_pixel_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FreetypeFont_get_font_pixel_size_15_comment =
  "C++ Interface:\n"
  "get_font_pixel_size(FreetypeFont self)\n"
  "\n"
  "/**\n"
  " * This is used to report whether the requested pixel size is being only\n"
  " * approximated by a fixed-pixel-size font.  This returns 0 in the normal\n"
  " * case, in which a scalable font is used, or the fixed-pixel-size font has\n"
  " * exactly the requested pixel size.\n"
  " *\n"
  " * If this returns non-zero, it is the pixel size of the font that we are\n"
  " * using to approximate our desired size.\n"
  " */";
#else
static const char *Dtool_FreetypeFont_get_font_pixel_size_15_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat FreetypeFont::get_line_height(void) const
 */
static PyObject *Dtool_FreetypeFont_get_line_height_16(PyObject *self, PyObject *) {
  FreetypeFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FreetypeFont)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat FreetypeFont::get_line_height(void) const
  PN_stdfloat return_value = ((*(const FreetypeFont*)local_this).get_line_height)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FreetypeFont_get_line_height_16_comment =
  "C++ Interface:\n"
  "get_line_height(FreetypeFont self)\n"
  "\n"
  "/**\n"
  " * Returns the number of units high each line of text is.\n"
  " */";
#else
static const char *Dtool_FreetypeFont_get_line_height_16_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat FreetypeFont::get_space_advance(void) const
 */
static PyObject *Dtool_FreetypeFont_get_space_advance_17(PyObject *self, PyObject *) {
  FreetypeFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FreetypeFont)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat FreetypeFont::get_space_advance(void) const
  PN_stdfloat return_value = ((*(const FreetypeFont*)local_this).get_space_advance)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FreetypeFont_get_space_advance_17_comment =
  "C++ Interface:\n"
  "get_space_advance(FreetypeFont self)\n"
  "\n"
  "/**\n"
  " * Returns the number of units wide a space is.\n"
  " */";
#else
static const char *Dtool_FreetypeFont_get_space_advance_17_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline PN_stdfloat FreetypeFont::get_points_per_unit(void)
 */
static PyObject *Dtool_FreetypeFont_get_points_per_unit_18(PyObject *, PyObject *) {
  // 1-static inline PN_stdfloat FreetypeFont::get_points_per_unit(void)
  PN_stdfloat return_value = (FreetypeFont::get_points_per_unit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FreetypeFont_get_points_per_unit_18_comment =
  "C++ Interface:\n"
  "get_points_per_unit()\n"
  "\n"
  "/**\n"
  " * Returns the point size of the font that is one Panda unit high.  This is an\n"
  " * arbitrary Panda convention for text, and is set to 10.0.\n"
  " */";
#else
static const char *Dtool_FreetypeFont_get_points_per_unit_18_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline PN_stdfloat FreetypeFont::get_points_per_inch(void)
 */
static PyObject *Dtool_FreetypeFont_get_points_per_inch_19(PyObject *, PyObject *) {
  // 1-static inline PN_stdfloat FreetypeFont::get_points_per_inch(void)
  PN_stdfloat return_value = (FreetypeFont::get_points_per_inch)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FreetypeFont_get_points_per_inch_19_comment =
  "C++ Interface:\n"
  "get_points_per_inch()\n"
  "\n"
  "/**\n"
  " * Returns the number of points in one inch.  This is a universal typographic\n"
  " * convention.\n"
  " */";
#else
static const char *Dtool_FreetypeFont_get_points_per_inch_19_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FreetypeFont::set_winding_order(FreetypeFont::WindingOrder winding_order)
 */
static PyObject *Dtool_FreetypeFont_set_winding_order_20(PyObject *self, PyObject *arg) {
  FreetypeFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FreetypeFont, (void **)&local_this, "FreetypeFont.set_winding_order")) {
    return nullptr;
  }
  // 1-inline void FreetypeFont::set_winding_order(FreetypeFont::WindingOrder winding_order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_winding_order)((FreetypeFont::WindingOrder)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_winding_order(const FreetypeFont self, int winding_order)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FreetypeFont_set_winding_order_20_comment =
  "C++ Interface:\n"
  "set_winding_order(const FreetypeFont self, int winding_order)\n"
  "\n"
  "/**\n"
  " * Specifies an explicitly winding order on this particular font.  This is\n"
  " * only necessary if the render_mode is RM_polygon or RM_solid, and only if\n"
  " * FreeType appears to guess wrong on this font.  Normally, you should leave\n"
  " * this at WO_default.\n"
  " */";
#else
static const char *Dtool_FreetypeFont_set_winding_order_20_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline FreetypeFont::WindingOrder FreetypeFont::get_winding_order(void) const
 */
static PyObject *Dtool_FreetypeFont_get_winding_order_21(PyObject *self, PyObject *) {
  FreetypeFont *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FreetypeFont)) {
    return nullptr;
  }
  // 1-inline FreetypeFont::WindingOrder FreetypeFont::get_winding_order(void) const
  FreetypeFont::WindingOrder return_value = ((*(const FreetypeFont*)local_this).get_winding_order)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FreetypeFont_get_winding_order_21_comment =
  "C++ Interface:\n"
  "get_winding_order(FreetypeFont self)\n"
  "\n"
  "/**\n"
  " * Returns the winding order set via set_winding_order().\n"
  " */";
#else
static const char *Dtool_FreetypeFont_get_winding_order_21_comment = nullptr;
#endif

static PyObject *Dtool_FreetypeFont_winding_order_Getter(PyObject *self, void *) {
  const FreetypeFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FreetypeFont, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline FreetypeFont::WindingOrder FreetypeFont::get_winding_order(void) const
  FreetypeFont::WindingOrder return_value = ((*(const FreetypeFont*)local_this).get_winding_order)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_FreetypeFont_winding_order_Setter(PyObject *self, PyObject *arg, void *) {
  FreetypeFont *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FreetypeFont, (void **)&local_this, "FreetypeFont.winding_order")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete winding_order attribute");
    return -1;
  }
  // 1-inline void FreetypeFont::set_winding_order(FreetypeFont::WindingOrder winding_order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_winding_order)((FreetypeFont::WindingOrder)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_winding_order(const FreetypeFont self, int winding_order)\n");
  }
  return -1;
}

static int Dtool_Init_FreetypeFont(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_FreetypeFont(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_FreetypeFont) {
    printf("FreetypeFont ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  FreetypeFont *local_this = (FreetypeFont *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_FreetypeFont) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_FreetypeFont(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_FreetypeFont) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (FreetypeFont*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PNMTextGlyph
 */
/**
 * Python function wrapper for:
 * inline int PNMTextGlyph::get_advance(void) const
 */
static PyObject *Dtool_PNMTextGlyph_get_advance_26(PyObject *self, PyObject *) {
  PNMTextGlyph *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMTextGlyph)) {
    return nullptr;
  }
  // 1-inline int PNMTextGlyph::get_advance(void) const
  int return_value = ((*(const PNMTextGlyph*)local_this).get_advance)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMTextGlyph_get_advance_26_comment =
  "C++ Interface:\n"
  "get_advance(PNMTextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the number of pixels by which the pen should be advanced after\n"
  " * rendering this glyph.\n"
  " */";
#else
static const char *Dtool_PNMTextGlyph_get_advance_26_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMTextGlyph::place(PNMImage &dest_image, int xp, int yp, LColor const &fg)
 * void PNMTextGlyph::place(PNMImage &dest_image, int xp, int yp, LColor const &fg, LColor const &interior)
 */
static PyObject *Dtool_PNMTextGlyph_place_27(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMTextGlyph *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMTextGlyph, (void **)&local_this, "PNMTextGlyph.place")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 4:
    {
      // 1-void PNMTextGlyph::place(PNMImage &dest_image, int xp, int yp, LColor const &fg)
      PyObject *param1;
      int param2;
      int param3;
      PyObject *param4;
      static const char *keyword_list[] = {"dest_image", "xp", "yp", "fg", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OiiO:place", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PNMTextGlyph.place", false, true);
        LVecBase4f param4_local;
        LColor const *param4_this = Dtool_Coerce_LVecBase4f(param4, param4_local);
        if (!(param4_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param4, 4, "PNMTextGlyph.place", "LVecBase4f");
        }
        if (param1_this != nullptr) {
          ((*local_this).place)(*param1_this, (int)param2, (int)param3, *param4_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 5:
    {
      // 1-void PNMTextGlyph::place(PNMImage &dest_image, int xp, int yp, LColor const &fg, LColor const &interior)
      PyObject *param1;
      int param2;
      int param3;
      PyObject *param4;
      PyObject *param5;
      static const char *keyword_list[] = {"dest_image", "xp", "yp", "fg", "interior", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OiiOO:place", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
        PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PNMTextGlyph.place", false, true);
        LVecBase4f param4_local;
        LColor const *param4_this = Dtool_Coerce_LVecBase4f(param4, param4_local);
        if (!(param4_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param4, 4, "PNMTextGlyph.place", "LVecBase4f");
        }
        LVecBase4f param5_local;
        LColor const *param5_this = Dtool_Coerce_LVecBase4f(param5, param5_local);
        if (!(param5_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param5, 5, "PNMTextGlyph.place", "LVecBase4f");
        }
        if (param1_this != nullptr) {
          ((*local_this).place)(*param1_this, (int)param2, (int)param3, *param4_this, *param5_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "place() takes 5 or 6 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "place(const PNMTextGlyph self, PNMImage dest_image, int xp, int yp, const LVecBase4f fg)\n"
      "place(const PNMTextGlyph self, PNMImage dest_image, int xp, int yp, const LVecBase4f fg, const LVecBase4f interior)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMTextGlyph_place_27_comment =
  "C++ Interface:\n"
  "place(const PNMTextGlyph self, PNMImage dest_image, int xp, int yp, const LVecBase4f fg)\n"
  "place(const PNMTextGlyph self, PNMImage dest_image, int xp, int yp, const LVecBase4f fg, const LVecBase4f interior)\n"
  "\n"
  "/**\n"
  " * Copies the glyph to the indicated destination image at the indicated\n"
  " * origin.  It colors the glyph pixels the indicated foreground color, blends\n"
  " * antialiased pixels with the appropriate amount of the foreground color and\n"
  " * the existing background color, and leaves other pixels alone.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This flavor of place() also fills in the interior color.  This requires\n"
  " * that determine_interior was called earlier.\n"
  " */";
#else
static const char *Dtool_PNMTextGlyph_place_27_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PNMTextGlyph::get_left(void) const
 */
static PyObject *Dtool_PNMTextGlyph_get_left_28(PyObject *self, PyObject *) {
  PNMTextGlyph *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMTextGlyph)) {
    return nullptr;
  }
  // 1-inline int PNMTextGlyph::get_left(void) const
  int return_value = ((*(const PNMTextGlyph*)local_this).get_left)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMTextGlyph_get_left_28_comment =
  "C++ Interface:\n"
  "get_left(PNMTextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the x coordinate of the leftmost pixel in the glyph.\n"
  " */";
#else
static const char *Dtool_PNMTextGlyph_get_left_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PNMTextGlyph::get_right(void) const
 */
static PyObject *Dtool_PNMTextGlyph_get_right_29(PyObject *self, PyObject *) {
  PNMTextGlyph *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMTextGlyph)) {
    return nullptr;
  }
  // 1-inline int PNMTextGlyph::get_right(void) const
  int return_value = ((*(const PNMTextGlyph*)local_this).get_right)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMTextGlyph_get_right_29_comment =
  "C++ Interface:\n"
  "get_right(PNMTextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the x coordinate of the rightmost pixel in the glyph.\n"
  " */";
#else
static const char *Dtool_PNMTextGlyph_get_right_29_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PNMTextGlyph::get_bottom(void) const
 */
static PyObject *Dtool_PNMTextGlyph_get_bottom_30(PyObject *self, PyObject *) {
  PNMTextGlyph *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMTextGlyph)) {
    return nullptr;
  }
  // 1-inline int PNMTextGlyph::get_bottom(void) const
  int return_value = ((*(const PNMTextGlyph*)local_this).get_bottom)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMTextGlyph_get_bottom_30_comment =
  "C++ Interface:\n"
  "get_bottom(PNMTextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the y coordinate of the bottommost pixel in the glyph.\n"
  " */";
#else
static const char *Dtool_PNMTextGlyph_get_bottom_30_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PNMTextGlyph::get_top(void) const
 */
static PyObject *Dtool_PNMTextGlyph_get_top_31(PyObject *self, PyObject *) {
  PNMTextGlyph *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMTextGlyph)) {
    return nullptr;
  }
  // 1-inline int PNMTextGlyph::get_top(void) const
  int return_value = ((*(const PNMTextGlyph*)local_this).get_top)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMTextGlyph_get_top_31_comment =
  "C++ Interface:\n"
  "get_top(PNMTextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the y coordinate of the topmost pixel in the glyph.\n"
  " */";
#else
static const char *Dtool_PNMTextGlyph_get_top_31_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PNMTextGlyph::get_height(void) const
 */
static PyObject *Dtool_PNMTextGlyph_get_height_32(PyObject *self, PyObject *) {
  PNMTextGlyph *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMTextGlyph)) {
    return nullptr;
  }
  // 1-inline int PNMTextGlyph::get_height(void) const
  int return_value = ((*(const PNMTextGlyph*)local_this).get_height)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMTextGlyph_get_height_32_comment =
  "C++ Interface:\n"
  "get_height(PNMTextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the height of the glyph in pixels.\n"
  " */";
#else
static const char *Dtool_PNMTextGlyph_get_height_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PNMTextGlyph::get_width(void) const
 */
static PyObject *Dtool_PNMTextGlyph_get_width_33(PyObject *self, PyObject *) {
  PNMTextGlyph *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMTextGlyph)) {
    return nullptr;
  }
  // 1-inline int PNMTextGlyph::get_width(void) const
  int return_value = ((*(const PNMTextGlyph*)local_this).get_width)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMTextGlyph_get_width_33_comment =
  "C++ Interface:\n"
  "get_width(PNMTextGlyph self)\n"
  "\n"
  "/**\n"
  " * Returns the width of the glyph in pixels.\n"
  " */";
#else
static const char *Dtool_PNMTextGlyph_get_width_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double PNMTextGlyph::get_value(int x, int y) const
 */
static PyObject *Dtool_PNMTextGlyph_get_value_34(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMTextGlyph *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMTextGlyph)) {
    return nullptr;
  }
  // 1-inline double PNMTextGlyph::get_value(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_value", (char **)keyword_list, &param1, &param2)) {
    double return_value = ((*(const PNMTextGlyph*)local_this).get_value)((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_value(PNMTextGlyph self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMTextGlyph_get_value_34_comment =
  "C++ Interface:\n"
  "get_value(PNMTextGlyph self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the value of the indicated pixel of the glyph.  The result is in\n"
  " * the range [0, 1], where 0 indicates the pixel is not part of the glyph, and\n"
  " * 1 indicates it is.  Intermediate values are used to represent antialiasing.\n"
  " */";
#else
static const char *Dtool_PNMTextGlyph_get_value_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PNMTextGlyph::get_interior_flag(int x, int y) const
 */
static PyObject *Dtool_PNMTextGlyph_get_interior_flag_35(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMTextGlyph *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMTextGlyph)) {
    return nullptr;
  }
  // 1-inline bool PNMTextGlyph::get_interior_flag(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_interior_flag", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*(const PNMTextGlyph*)local_this).get_interior_flag)((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_interior_flag(PNMTextGlyph self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMTextGlyph_get_interior_flag_35_comment =
  "C++ Interface:\n"
  "get_interior_flag(PNMTextGlyph self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated pixel represents a pixel in the interior of a\n"
  " * hollow font, false otherwise.\n"
  " */";
#else
static const char *Dtool_PNMTextGlyph_get_interior_flag_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PNMTextGlyph::PNMTextGlyph(PNMTextGlyph const &) = default
 * explicit PNMTextGlyph::PNMTextGlyph(double advance)
 */
static int Dtool_Init_PNMTextGlyph(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "PNMTextGlyph() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline PNMTextGlyph::PNMTextGlyph(PNMTextGlyph const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      PNMTextGlyph const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_PNMTextGlyph);
      if (param0_this != nullptr) {
        PNMTextGlyph *return_value = new PNMTextGlyph(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMTextGlyph, true, false);
      }
    }
  }

  {
    // -2 explicit PNMTextGlyph::PNMTextGlyph(double advance)
    double param0;
    static const char *keyword_list[] = {"advance", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "d:PNMTextGlyph", (char **)keyword_list, &param0)) {
      PNMTextGlyph *return_value = new PNMTextGlyph((double)param0);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMTextGlyph, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: inline PNMTextGlyph::PNMTextGlyph(PNMTextGlyph const &) = default
  // No coercion possible: explicit PNMTextGlyph::PNMTextGlyph(double advance)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PNMTextGlyph(const PNMTextGlyph param0)\n"
      "PNMTextGlyph(double advance)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PNMTextGlyph(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PNMTextGlyph) {
    printf("PNMTextGlyph ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PNMTextGlyph *local_this = (PNMTextGlyph *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PNMTextGlyph) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PNMTextGlyph(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PNMTextGlyph) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PNMTextMaker
 */
/**
 * Python function wrapper for:
 * inline bool PNMTextMaker::is_valid(void) const
 */
static PyObject *Dtool_PNMTextMaker_is_valid_40(PyObject *self, PyObject *) {
  PNMTextMaker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMTextMaker)) {
    return nullptr;
  }
  // 1-inline bool PNMTextMaker::is_valid(void) const
  bool return_value = ((*(const PNMTextMaker*)local_this).is_valid)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMTextMaker_is_valid_40_comment =
  "C++ Interface:\n"
  "is_valid(PNMTextMaker self)\n"
  "\n"
  "/**\n"
  " * Returns true if the PNMTextMaker is valid and ready to generate text, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_PNMTextMaker_is_valid_40_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMTextMaker::set_align(PNMTextMaker::Alignment align_type)
 */
static PyObject *Dtool_PNMTextMaker_set_align_41(PyObject *self, PyObject *arg) {
  PNMTextMaker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMTextMaker, (void **)&local_this, "PNMTextMaker.set_align")) {
    return nullptr;
  }
  // 1-inline void PNMTextMaker::set_align(PNMTextMaker::Alignment align_type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_align)((PNMTextMaker::Alignment)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_align(const PNMTextMaker self, int align_type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMTextMaker_set_align_41_comment =
  "C++ Interface:\n"
  "set_align(const PNMTextMaker self, int align_type)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PNMTextMaker_set_align_41_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PNMTextMaker::Alignment PNMTextMaker::get_align(void) const
 */
static PyObject *Dtool_PNMTextMaker_get_align_42(PyObject *self, PyObject *) {
  PNMTextMaker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMTextMaker)) {
    return nullptr;
  }
  // 1-inline PNMTextMaker::Alignment PNMTextMaker::get_align(void) const
  PNMTextMaker::Alignment return_value = ((*(const PNMTextMaker*)local_this).get_align)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMTextMaker_get_align_42_comment =
  "C++ Interface:\n"
  "get_align(PNMTextMaker self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PNMTextMaker_get_align_42_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMTextMaker::set_interior_flag(bool interior_flag)
 */
static PyObject *Dtool_PNMTextMaker_set_interior_flag_43(PyObject *self, PyObject *arg) {
  PNMTextMaker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMTextMaker, (void **)&local_this, "PNMTextMaker.set_interior_flag")) {
    return nullptr;
  }
  // 1-inline void PNMTextMaker::set_interior_flag(bool interior_flag)
  ((*local_this).set_interior_flag)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_interior_flag(const PNMTextMaker self, bool interior_flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMTextMaker_set_interior_flag_43_comment =
  "C++ Interface:\n"
  "set_interior_flag(const PNMTextMaker self, bool interior_flag)\n"
  "\n"
  "/**\n"
  " * Sets the flag that indicates whether the interior of hollow fonts is\n"
  " * identified as a preprocess as each glyph is loaded.  If this flag is true,\n"
  " * you may specify an interior color along with a fg and bg color when you\n"
  " * place text; if the flag is false, the interior color is ignored.\n"
  " *\n"
  " * It is generally best to set_native_antialias(0) when using this feature.\n"
  " * Also, this works best when the pixel size is not very small.\n"
  " */";
#else
static const char *Dtool_PNMTextMaker_set_interior_flag_43_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PNMTextMaker::get_interior_flag(void) const
 */
static PyObject *Dtool_PNMTextMaker_get_interior_flag_44(PyObject *self, PyObject *) {
  PNMTextMaker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMTextMaker)) {
    return nullptr;
  }
  // 1-inline bool PNMTextMaker::get_interior_flag(void) const
  bool return_value = ((*(const PNMTextMaker*)local_this).get_interior_flag)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMTextMaker_get_interior_flag_44_comment =
  "C++ Interface:\n"
  "get_interior_flag(PNMTextMaker self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PNMTextMaker_get_interior_flag_44_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMTextMaker::set_fg(LColor const &fg)
 */
static PyObject *Dtool_PNMTextMaker_set_fg_45(PyObject *self, PyObject *arg) {
  PNMTextMaker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMTextMaker, (void **)&local_this, "PNMTextMaker.set_fg")) {
    return nullptr;
  }
  // 1-inline void PNMTextMaker::set_fg(LColor const &fg)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PNMTextMaker.set_fg", "LVecBase4f");
  }
  ((*local_this).set_fg)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fg(const PNMTextMaker self, const LVecBase4f fg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMTextMaker_set_fg_45_comment =
  "C++ Interface:\n"
  "set_fg(const PNMTextMaker self, const LVecBase4f fg)\n"
  "\n"
  "/**\n"
  " * Sets the foreground color of text that will be generated by future calls to\n"
  " * generate_into().  This is the color that all of the \"on\" pixels in the font\n"
  " * will show as.\n"
  " */";
#else
static const char *Dtool_PNMTextMaker_set_fg_45_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &PNMTextMaker::get_fg(void) const
 */
static PyObject *Dtool_PNMTextMaker_get_fg_46(PyObject *self, PyObject *) {
  PNMTextMaker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMTextMaker)) {
    return nullptr;
  }
  // 1-inline LColor const &PNMTextMaker::get_fg(void) const
  LColor const *return_value = &(((*(const PNMTextMaker*)local_this).get_fg)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_PNMTextMaker_get_fg_46_comment =
  "C++ Interface:\n"
  "get_fg(PNMTextMaker self)\n"
  "\n"
  "/**\n"
  " * Returns the foreground color of text that will be generated by future calls\n"
  " * to generate_into().\n"
  " */";
#else
static const char *Dtool_PNMTextMaker_get_fg_46_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMTextMaker::set_interior(LColor const &interior)
 */
static PyObject *Dtool_PNMTextMaker_set_interior_47(PyObject *self, PyObject *arg) {
  PNMTextMaker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMTextMaker, (void **)&local_this, "PNMTextMaker.set_interior")) {
    return nullptr;
  }
  // 1-inline void PNMTextMaker::set_interior(LColor const &interior)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PNMTextMaker.set_interior", "LVecBase4f");
  }
  ((*local_this).set_interior)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_interior(const PNMTextMaker self, const LVecBase4f interior)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMTextMaker_set_interior_47_comment =
  "C++ Interface:\n"
  "set_interior(const PNMTextMaker self, const LVecBase4f interior)\n"
  "\n"
  "/**\n"
  " * Sets the color that will be used to render the interior portions of hollow\n"
  " * fonts in future calls to generate_into().  This is respected only if\n"
  " * interior_flag is true.\n"
  " */";
#else
static const char *Dtool_PNMTextMaker_set_interior_47_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &PNMTextMaker::get_interior(void) const
 */
static PyObject *Dtool_PNMTextMaker_get_interior_48(PyObject *self, PyObject *) {
  PNMTextMaker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMTextMaker)) {
    return nullptr;
  }
  // 1-inline LColor const &PNMTextMaker::get_interior(void) const
  LColor const *return_value = &(((*(const PNMTextMaker*)local_this).get_interior)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_PNMTextMaker_get_interior_48_comment =
  "C++ Interface:\n"
  "get_interior(PNMTextMaker self)\n"
  "\n"
  "/**\n"
  " * Returns the color that will be used to render the interior portions of\n"
  " * hollow fonts.\n"
  " */";
#else
static const char *Dtool_PNMTextMaker_get_interior_48_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMTextMaker::set_distance_field_radius(int radius)
 */
static PyObject *Dtool_PNMTextMaker_set_distance_field_radius_49(PyObject *self, PyObject *arg) {
  PNMTextMaker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMTextMaker, (void **)&local_this, "PNMTextMaker.set_distance_field_radius")) {
    return nullptr;
  }
  // 1-inline void PNMTextMaker::set_distance_field_radius(int radius)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_distance_field_radius)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_distance_field_radius(const PNMTextMaker self, int radius)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMTextMaker_set_distance_field_radius_49_comment =
  "C++ Interface:\n"
  "set_distance_field_radius(const PNMTextMaker self, int radius)\n"
  "\n"
  "/**\n"
  " * If this is set to something other than 0, Panda will generate a signed\n"
  " * distance field with the given radius.\n"
  " */";
#else
static const char *Dtool_PNMTextMaker_set_distance_field_radius_49_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PNMTextMaker::get_distance_field_radius(void) const
 */
static PyObject *Dtool_PNMTextMaker_get_distance_field_radius_50(PyObject *self, PyObject *) {
  PNMTextMaker *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMTextMaker)) {
    return nullptr;
  }
  // 1-inline int PNMTextMaker::get_distance_field_radius(void) const
  int return_value = ((*(const PNMTextMaker*)local_this).get_distance_field_radius)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMTextMaker_get_distance_field_radius_50_comment =
  "C++ Interface:\n"
  "get_distance_field_radius(PNMTextMaker self)\n"
  "\n"
  "/**\n"
  " * Returns the radius previously set with set_distance_field_radius, or 0\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_PNMTextMaker_get_distance_field_radius_50_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PNMTextMaker::generate_into(std::string const &text, PNMImage &dest_image, int x, int y)
 * int PNMTextMaker::generate_into(std::wstring const &text, PNMImage &dest_image, int x, int y)
 */
static PyObject *Dtool_PNMTextMaker_generate_into_51(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMTextMaker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMTextMaker, (void **)&local_this, "PNMTextMaker.generate_into")) {
    return nullptr;
  }
  {
    // -2 int PNMTextMaker::generate_into(std::wstring const &text, PNMImage &dest_image, int x, int y)
#if PY_VERSION_HEX >= 0x03020000
    PyObject *param1;
#else
    PyUnicodeObject *param1;
#endif
    PyObject *param2;
    int param3;
    int param4;
    static const char *keyword_list[] = {"text", "dest_image", "x", "y", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "UOii:generate_into", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
#if PY_VERSION_HEX >= 0x03030000
      Py_ssize_t param1_len;
      wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
      Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
      wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
      PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
      PNMImage *param2_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PNMImage, 2, "PNMTextMaker.generate_into", false, false);
      if (param2_this != nullptr) {
        int return_value = ((*local_this).generate_into)(std::wstring(param1_str, param1_len), *param2_this, (int)param3, (int)param4);
#if PY_VERSION_HEX >= 0x03030000
        PyMem_Free(param1_str);
#endif
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline int PNMTextMaker::generate_into(std::string const &text, PNMImage &dest_image, int x, int y)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
    PyObject *param2;
    int param3;
    int param4;
    static const char *keyword_list[] = {"text", "dest_image", "x", "y", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#Oii:generate_into", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3, &param4)) {
      PNMImage *param2_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PNMImage, 2, "PNMTextMaker.generate_into", false, false);
      if (param2_this != nullptr) {
        int return_value = ((*local_this).generate_into)(std::string(param1_str, param1_len), *param2_this, (int)param3, (int)param4);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: int PNMTextMaker::generate_into(std::wstring const &text, PNMImage &dest_image, int x, int y)
  // No coercion possible: inline int PNMTextMaker::generate_into(std::string const &text, PNMImage &dest_image, int x, int y)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "generate_into(const PNMTextMaker self, unicode text, PNMImage dest_image, int x, int y)\n"
      "generate_into(const PNMTextMaker self, str text, PNMImage dest_image, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMTextMaker_generate_into_51_comment =
  "C++ Interface:\n"
  "generate_into(const PNMTextMaker self, unicode text, PNMImage dest_image, int x, int y)\n"
  "generate_into(const PNMTextMaker self, str text, PNMImage dest_image, int x, int y)\n"
  "\n"
  "/**\n"
  " * Generates a single line of text into the indicated image at the indicated\n"
  " * position; the return value is the total width in pixels.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Generates a single line of text into the indicated image at the indicated\n"
  " * position; the return value is the total width in pixels.\n"
  " */";
#else
static const char *Dtool_PNMTextMaker_generate_into_51_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PNMTextMaker::calc_width(std::string const &text)
 * int PNMTextMaker::calc_width(std::wstring const &text)
 */
static PyObject *Dtool_PNMTextMaker_calc_width_52(PyObject *self, PyObject *arg) {
  PNMTextMaker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMTextMaker, (void **)&local_this, "PNMTextMaker.calc_width")) {
    return nullptr;
  }
  {
    // -2 int PNMTextMaker::calc_width(std::wstring const &text)
#if PY_VERSION_HEX >= 0x03020000
    PyObject *param1;
#else
    PyUnicodeObject *param1;
#endif
    if (PyArg_Parse(arg, "U:calc_width", &param1)) {
#if PY_VERSION_HEX >= 0x03030000
      Py_ssize_t param1_len;
      wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
      Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
      wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
      PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
      int return_value = ((*local_this).calc_width)(std::wstring(param1_str, param1_len));
#if PY_VERSION_HEX >= 0x03030000
      PyMem_Free(param1_str);
#endif
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    PyErr_Clear();
  }

  {
    // -2 inline int PNMTextMaker::calc_width(std::string const &text)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      int return_value = ((*local_this).calc_width)(std::string(param1_str, param1_len));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    PyErr_Clear();
  }

  // No coercion possible: int PNMTextMaker::calc_width(std::wstring const &text)
  // No coercion possible: inline int PNMTextMaker::calc_width(std::string const &text)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_width(const PNMTextMaker self, unicode text)\n"
      "calc_width(const PNMTextMaker self, str text)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMTextMaker_calc_width_52_comment =
  "C++ Interface:\n"
  "calc_width(const PNMTextMaker self, unicode text)\n"
  "calc_width(const PNMTextMaker self, str text)\n"
  "\n"
  "/**\n"
  " * Returns the width in pixels of the indicated line of text.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the width in pixels of the indicated line of text.\n"
  " */";
#else
static const char *Dtool_PNMTextMaker_calc_width_52_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PNMTextGlyph *PNMTextMaker::get_glyph(int character)
 */
static PyObject *Dtool_PNMTextMaker_get_glyph_53(PyObject *self, PyObject *arg) {
  PNMTextMaker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMTextMaker, (void **)&local_this, "PNMTextMaker.get_glyph")) {
    return nullptr;
  }
  // 1-PNMTextGlyph *PNMTextMaker::get_glyph(int character)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PNMTextGlyph *return_value = ((*local_this).get_glyph)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMTextGlyph, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_glyph(const PNMTextMaker self, int character)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMTextMaker_get_glyph_53_comment =
  "C++ Interface:\n"
  "get_glyph(const PNMTextMaker self, int character)\n"
  "\n"
  "/**\n"
  " * Returns the glyph for the indicated index, or NULL if it is not defined in\n"
  " * the font.\n"
  " */";
#else
static const char *Dtool_PNMTextMaker_get_glyph_53_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit PNMTextMaker::PNMTextMaker(Filename const &font_filename, int face_index)
 * explicit PNMTextMaker::PNMTextMaker(FreetypeFont const &copy)
 * PNMTextMaker::PNMTextMaker(PNMTextMaker const &copy)
 * explicit PNMTextMaker::PNMTextMaker(char const *font_data, int data_length, int face_index)
 */
static int Dtool_Init_PNMTextMaker(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        {
          // -2 PNMTextMaker::PNMTextMaker(PNMTextMaker const &copy)
          PNMTextMaker const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PNMTextMaker);
          if (arg_this != nullptr) {
            PNMTextMaker *return_value = new PNMTextMaker(*arg_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMTextMaker, true, false);
          }
        }

        {
          // -2 explicit PNMTextMaker::PNMTextMaker(FreetypeFont const &copy)
          FreetypeFont const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_FreetypeFont);
          if (arg_this != nullptr) {
            PNMTextMaker *return_value = new PNMTextMaker(*arg_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMTextMaker, true, false);
          }
        }

        // No coercion possible: PNMTextMaker::PNMTextMaker(PNMTextMaker const &copy)
        // No coercion possible: explicit PNMTextMaker::PNMTextMaker(FreetypeFont const &copy)
      }
    }
    break;
  case 2:
    {
      // 1-explicit PNMTextMaker::PNMTextMaker(Filename const &font_filename, int face_index)
      PyObject *param0;
      int param1;
      static const char *keyword_list[] = {"font_filename", "face_index", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:PNMTextMaker", (char **)keyword_list, &param0, &param1)) {
        Filename param0_local;
        Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
        if (!(param0_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param0, 0, "PNMTextMaker.PNMTextMaker", "Filename");
          return -1;
        }
        PNMTextMaker *return_value = new PNMTextMaker(*param0_this, (int)param1);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMTextMaker, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-explicit PNMTextMaker::PNMTextMaker(char const *font_data, int data_length, int face_index)
      char const *param0;
      int param1;
      int param2;
      static const char *keyword_list[] = {"font_data", "data_length", "face_index", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "zii:PNMTextMaker", (char **)keyword_list, &param0, &param1, &param2)) {
        PNMTextMaker *return_value = new PNMTextMaker((char const *)param0, (int)param1, (int)param2);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMTextMaker, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PNMTextMaker() takes 1, 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PNMTextMaker(const PNMTextMaker copy)\n"
      "PNMTextMaker(const FreetypeFont copy)\n"
      "PNMTextMaker(const Filename font_filename, int face_index)\n"
      "PNMTextMaker(str font_data, int data_length, int face_index)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PNMTextMaker(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PNMTextMaker) {
    printf("PNMTextMaker ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PNMTextMaker *local_this = (PNMTextMaker *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PNMTextMaker) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_FreetypeFont) {
    return (FreetypeFont *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(FreetypeFont *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PNMTextMaker(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PNMTextMaker) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_FreetypeFont) {
    FreetypeFont* other_this = (FreetypeFont*)from_this;
    return (PNMTextMaker*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PNMTextMaker*)other_this;
  }
  return nullptr;
}

/**
 * Python method tables for FreetypeFont (FreetypeFont)
 */
static PyMethodDef Dtool_Methods_FreetypeFont[] = {
  {"set_point_size", &Dtool_FreetypeFont_set_point_size_5, METH_O, (const char *)Dtool_FreetypeFont_set_point_size_5_comment},
  {"setPointSize", &Dtool_FreetypeFont_set_point_size_5, METH_O, (const char *)Dtool_FreetypeFont_set_point_size_5_comment},
  {"get_point_size", &Dtool_FreetypeFont_get_point_size_6, METH_NOARGS, (const char *)Dtool_FreetypeFont_get_point_size_6_comment},
  {"getPointSize", &Dtool_FreetypeFont_get_point_size_6, METH_NOARGS, (const char *)Dtool_FreetypeFont_get_point_size_6_comment},
  {"set_pixels_per_unit", &Dtool_FreetypeFont_set_pixels_per_unit_7, METH_O, (const char *)Dtool_FreetypeFont_set_pixels_per_unit_7_comment},
  {"setPixelsPerUnit", &Dtool_FreetypeFont_set_pixels_per_unit_7, METH_O, (const char *)Dtool_FreetypeFont_set_pixels_per_unit_7_comment},
  {"get_pixels_per_unit", &Dtool_FreetypeFont_get_pixels_per_unit_8, METH_NOARGS, (const char *)Dtool_FreetypeFont_get_pixels_per_unit_8_comment},
  {"getPixelsPerUnit", &Dtool_FreetypeFont_get_pixels_per_unit_8, METH_NOARGS, (const char *)Dtool_FreetypeFont_get_pixels_per_unit_8_comment},
  {"set_pixel_size", &Dtool_FreetypeFont_set_pixel_size_9, METH_O, (const char *)Dtool_FreetypeFont_set_pixel_size_9_comment},
  {"setPixelSize", &Dtool_FreetypeFont_set_pixel_size_9, METH_O, (const char *)Dtool_FreetypeFont_set_pixel_size_9_comment},
  {"get_pixel_size", &Dtool_FreetypeFont_get_pixel_size_10, METH_NOARGS, (const char *)Dtool_FreetypeFont_get_pixel_size_10_comment},
  {"getPixelSize", &Dtool_FreetypeFont_get_pixel_size_10, METH_NOARGS, (const char *)Dtool_FreetypeFont_get_pixel_size_10_comment},
  {"set_scale_factor", &Dtool_FreetypeFont_set_scale_factor_11, METH_O, (const char *)Dtool_FreetypeFont_set_scale_factor_11_comment},
  {"setScaleFactor", &Dtool_FreetypeFont_set_scale_factor_11, METH_O, (const char *)Dtool_FreetypeFont_set_scale_factor_11_comment},
  {"get_scale_factor", &Dtool_FreetypeFont_get_scale_factor_12, METH_NOARGS, (const char *)Dtool_FreetypeFont_get_scale_factor_12_comment},
  {"getScaleFactor", &Dtool_FreetypeFont_get_scale_factor_12, METH_NOARGS, (const char *)Dtool_FreetypeFont_get_scale_factor_12_comment},
  {"set_native_antialias", &Dtool_FreetypeFont_set_native_antialias_13, METH_O, (const char *)Dtool_FreetypeFont_set_native_antialias_13_comment},
  {"setNativeAntialias", &Dtool_FreetypeFont_set_native_antialias_13, METH_O, (const char *)Dtool_FreetypeFont_set_native_antialias_13_comment},
  {"get_native_antialias", &Dtool_FreetypeFont_get_native_antialias_14, METH_NOARGS, (const char *)Dtool_FreetypeFont_get_native_antialias_14_comment},
  {"getNativeAntialias", &Dtool_FreetypeFont_get_native_antialias_14, METH_NOARGS, (const char *)Dtool_FreetypeFont_get_native_antialias_14_comment},
  {"get_font_pixel_size", &Dtool_FreetypeFont_get_font_pixel_size_15, METH_NOARGS, (const char *)Dtool_FreetypeFont_get_font_pixel_size_15_comment},
  {"getFontPixelSize", &Dtool_FreetypeFont_get_font_pixel_size_15, METH_NOARGS, (const char *)Dtool_FreetypeFont_get_font_pixel_size_15_comment},
  {"get_line_height", &Dtool_FreetypeFont_get_line_height_16, METH_NOARGS, (const char *)Dtool_FreetypeFont_get_line_height_16_comment},
  {"getLineHeight", &Dtool_FreetypeFont_get_line_height_16, METH_NOARGS, (const char *)Dtool_FreetypeFont_get_line_height_16_comment},
  {"get_space_advance", &Dtool_FreetypeFont_get_space_advance_17, METH_NOARGS, (const char *)Dtool_FreetypeFont_get_space_advance_17_comment},
  {"getSpaceAdvance", &Dtool_FreetypeFont_get_space_advance_17, METH_NOARGS, (const char *)Dtool_FreetypeFont_get_space_advance_17_comment},
  {"get_points_per_unit", &Dtool_FreetypeFont_get_points_per_unit_18, METH_NOARGS | METH_STATIC, (const char *)Dtool_FreetypeFont_get_points_per_unit_18_comment},
  {"getPointsPerUnit", &Dtool_FreetypeFont_get_points_per_unit_18, METH_NOARGS | METH_STATIC, (const char *)Dtool_FreetypeFont_get_points_per_unit_18_comment},
  {"get_points_per_inch", &Dtool_FreetypeFont_get_points_per_inch_19, METH_NOARGS | METH_STATIC, (const char *)Dtool_FreetypeFont_get_points_per_inch_19_comment},
  {"getPointsPerInch", &Dtool_FreetypeFont_get_points_per_inch_19, METH_NOARGS | METH_STATIC, (const char *)Dtool_FreetypeFont_get_points_per_inch_19_comment},
  {"set_winding_order", &Dtool_FreetypeFont_set_winding_order_20, METH_O, (const char *)Dtool_FreetypeFont_set_winding_order_20_comment},
  {"setWindingOrder", &Dtool_FreetypeFont_set_winding_order_20, METH_O, (const char *)Dtool_FreetypeFont_set_winding_order_20_comment},
  {"get_winding_order", &Dtool_FreetypeFont_get_winding_order_21, METH_NOARGS, (const char *)Dtool_FreetypeFont_get_winding_order_21_comment},
  {"getWindingOrder", &Dtool_FreetypeFont_get_winding_order_21, METH_NOARGS, (const char *)Dtool_FreetypeFont_get_winding_order_21_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_FreetypeFont[] = {
  {(char *)"winding_order", &Dtool_FreetypeFont_winding_order_Getter, &Dtool_FreetypeFont_winding_order_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_FreetypeFont = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_FreetypeFont = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_FreetypeFont = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_FreetypeFont = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_FreetypeFont = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_FreetypeFont = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.FreetypeFont",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_FreetypeFont,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_FreetypeFont,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_FreetypeFont,
    &Dtool_SequenceMethods_FreetypeFont,
    &Dtool_MappingMethods_FreetypeFont,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_FreetypeFont,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a common base class for both DynamicTextFont and PNMTextMaker.\n"
    " * Both of these are utility classes that use the FreeType library to generate\n"
    " * glyphs from fonts; this class abstracts out that common wrapper around\n"
    " * FreeType.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_FreetypeFont,
    nullptr, // tp_members
    Dtool_Properties_FreetypeFont,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_FreetypeFont,
    PyType_GenericAlloc,
    Dtool_new_FreetypeFont,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_FreetypeFont,
  Dtool_UpcastInterface_FreetypeFont,
  Dtool_DowncastInterface_FreetypeFont,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_FreetypeFont(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_Namable != nullptr);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(nullptr);
    Dtool_FreetypeFont._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_Namable);
    Dtool_FreetypeFont._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(9);
    Dtool_FreetypeFont._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum FreetypeFont::WindingOrder;
    PyDict_SetItemString(dict, "WO_default", Dtool_WrapValue(FreetypeFont::WO_default));
    PyDict_SetItemString(dict, "WODefault", Dtool_WrapValue(FreetypeFont::WO_default));
    PyDict_SetItemString(dict, "WO_left", Dtool_WrapValue(FreetypeFont::WO_left));
    PyDict_SetItemString(dict, "WOLeft", Dtool_WrapValue(FreetypeFont::WO_left));
    PyDict_SetItemString(dict, "WO_right", Dtool_WrapValue(FreetypeFont::WO_right));
    PyDict_SetItemString(dict, "WORight", Dtool_WrapValue(FreetypeFont::WO_right));
    PyDict_SetItemString(dict, "WO_invalid", Dtool_WrapValue(FreetypeFont::WO_invalid));
    PyDict_SetItemString(dict, "WOInvalid", Dtool_WrapValue(FreetypeFont::WO_invalid));
    if (PyType_Ready((PyTypeObject *)&Dtool_FreetypeFont) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(FreetypeFont)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_FreetypeFont);
  }
}

/**
 * Python method tables for PNMTextGlyph (PNMTextGlyph)
 */
static PyMethodDef Dtool_Methods_PNMTextGlyph[] = {
  {"get_advance", &Dtool_PNMTextGlyph_get_advance_26, METH_NOARGS, (const char *)Dtool_PNMTextGlyph_get_advance_26_comment},
  {"getAdvance", &Dtool_PNMTextGlyph_get_advance_26, METH_NOARGS, (const char *)Dtool_PNMTextGlyph_get_advance_26_comment},
  {"place", (PyCFunction) &Dtool_PNMTextGlyph_place_27, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMTextGlyph_place_27_comment},
  {"get_left", &Dtool_PNMTextGlyph_get_left_28, METH_NOARGS, (const char *)Dtool_PNMTextGlyph_get_left_28_comment},
  {"getLeft", &Dtool_PNMTextGlyph_get_left_28, METH_NOARGS, (const char *)Dtool_PNMTextGlyph_get_left_28_comment},
  {"get_right", &Dtool_PNMTextGlyph_get_right_29, METH_NOARGS, (const char *)Dtool_PNMTextGlyph_get_right_29_comment},
  {"getRight", &Dtool_PNMTextGlyph_get_right_29, METH_NOARGS, (const char *)Dtool_PNMTextGlyph_get_right_29_comment},
  {"get_bottom", &Dtool_PNMTextGlyph_get_bottom_30, METH_NOARGS, (const char *)Dtool_PNMTextGlyph_get_bottom_30_comment},
  {"getBottom", &Dtool_PNMTextGlyph_get_bottom_30, METH_NOARGS, (const char *)Dtool_PNMTextGlyph_get_bottom_30_comment},
  {"get_top", &Dtool_PNMTextGlyph_get_top_31, METH_NOARGS, (const char *)Dtool_PNMTextGlyph_get_top_31_comment},
  {"getTop", &Dtool_PNMTextGlyph_get_top_31, METH_NOARGS, (const char *)Dtool_PNMTextGlyph_get_top_31_comment},
  {"get_height", &Dtool_PNMTextGlyph_get_height_32, METH_NOARGS, (const char *)Dtool_PNMTextGlyph_get_height_32_comment},
  {"getHeight", &Dtool_PNMTextGlyph_get_height_32, METH_NOARGS, (const char *)Dtool_PNMTextGlyph_get_height_32_comment},
  {"get_width", &Dtool_PNMTextGlyph_get_width_33, METH_NOARGS, (const char *)Dtool_PNMTextGlyph_get_width_33_comment},
  {"getWidth", &Dtool_PNMTextGlyph_get_width_33, METH_NOARGS, (const char *)Dtool_PNMTextGlyph_get_width_33_comment},
  {"get_value", (PyCFunction) &Dtool_PNMTextGlyph_get_value_34, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMTextGlyph_get_value_34_comment},
  {"getValue", (PyCFunction) &Dtool_PNMTextGlyph_get_value_34, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMTextGlyph_get_value_34_comment},
  {"get_interior_flag", (PyCFunction) &Dtool_PNMTextGlyph_get_interior_flag_35, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMTextGlyph_get_interior_flag_35_comment},
  {"getInteriorFlag", (PyCFunction) &Dtool_PNMTextGlyph_get_interior_flag_35, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMTextGlyph_get_interior_flag_35_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PNMTextGlyph = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_PNMTextGlyph = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PNMTextGlyph",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PNMTextGlyph,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PNMTextGlyph,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A single glyph in a PNMTextMaker.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PNMTextGlyph,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PNMTextGlyph,
    PyType_GenericAlloc,
    Dtool_new_PNMTextGlyph,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PNMTextGlyph,
  Dtool_UpcastInterface_PNMTextGlyph,
  Dtool_DowncastInterface_PNMTextGlyph,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PNMTextGlyph(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PNMTextGlyph._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PNMTextGlyph._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PNMTextGlyph) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PNMTextGlyph)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PNMTextGlyph);
  }
}

/**
 * Python method tables for PNMTextMaker (PNMTextMaker)
 */
static PyMethodDef Dtool_Methods_PNMTextMaker[] = {
  {"is_valid", &Dtool_PNMTextMaker_is_valid_40, METH_NOARGS, (const char *)Dtool_PNMTextMaker_is_valid_40_comment},
  {"isValid", &Dtool_PNMTextMaker_is_valid_40, METH_NOARGS, (const char *)Dtool_PNMTextMaker_is_valid_40_comment},
  {"set_align", &Dtool_PNMTextMaker_set_align_41, METH_O, (const char *)Dtool_PNMTextMaker_set_align_41_comment},
  {"setAlign", &Dtool_PNMTextMaker_set_align_41, METH_O, (const char *)Dtool_PNMTextMaker_set_align_41_comment},
  {"get_align", &Dtool_PNMTextMaker_get_align_42, METH_NOARGS, (const char *)Dtool_PNMTextMaker_get_align_42_comment},
  {"getAlign", &Dtool_PNMTextMaker_get_align_42, METH_NOARGS, (const char *)Dtool_PNMTextMaker_get_align_42_comment},
  {"set_interior_flag", &Dtool_PNMTextMaker_set_interior_flag_43, METH_O, (const char *)Dtool_PNMTextMaker_set_interior_flag_43_comment},
  {"setInteriorFlag", &Dtool_PNMTextMaker_set_interior_flag_43, METH_O, (const char *)Dtool_PNMTextMaker_set_interior_flag_43_comment},
  {"get_interior_flag", &Dtool_PNMTextMaker_get_interior_flag_44, METH_NOARGS, (const char *)Dtool_PNMTextMaker_get_interior_flag_44_comment},
  {"getInteriorFlag", &Dtool_PNMTextMaker_get_interior_flag_44, METH_NOARGS, (const char *)Dtool_PNMTextMaker_get_interior_flag_44_comment},
  {"set_fg", &Dtool_PNMTextMaker_set_fg_45, METH_O, (const char *)Dtool_PNMTextMaker_set_fg_45_comment},
  {"setFg", &Dtool_PNMTextMaker_set_fg_45, METH_O, (const char *)Dtool_PNMTextMaker_set_fg_45_comment},
  {"get_fg", &Dtool_PNMTextMaker_get_fg_46, METH_NOARGS, (const char *)Dtool_PNMTextMaker_get_fg_46_comment},
  {"getFg", &Dtool_PNMTextMaker_get_fg_46, METH_NOARGS, (const char *)Dtool_PNMTextMaker_get_fg_46_comment},
  {"set_interior", &Dtool_PNMTextMaker_set_interior_47, METH_O, (const char *)Dtool_PNMTextMaker_set_interior_47_comment},
  {"setInterior", &Dtool_PNMTextMaker_set_interior_47, METH_O, (const char *)Dtool_PNMTextMaker_set_interior_47_comment},
  {"get_interior", &Dtool_PNMTextMaker_get_interior_48, METH_NOARGS, (const char *)Dtool_PNMTextMaker_get_interior_48_comment},
  {"getInterior", &Dtool_PNMTextMaker_get_interior_48, METH_NOARGS, (const char *)Dtool_PNMTextMaker_get_interior_48_comment},
  {"set_distance_field_radius", &Dtool_PNMTextMaker_set_distance_field_radius_49, METH_O, (const char *)Dtool_PNMTextMaker_set_distance_field_radius_49_comment},
  {"setDistanceFieldRadius", &Dtool_PNMTextMaker_set_distance_field_radius_49, METH_O, (const char *)Dtool_PNMTextMaker_set_distance_field_radius_49_comment},
  {"get_distance_field_radius", &Dtool_PNMTextMaker_get_distance_field_radius_50, METH_NOARGS, (const char *)Dtool_PNMTextMaker_get_distance_field_radius_50_comment},
  {"getDistanceFieldRadius", &Dtool_PNMTextMaker_get_distance_field_radius_50, METH_NOARGS, (const char *)Dtool_PNMTextMaker_get_distance_field_radius_50_comment},
  {"generate_into", (PyCFunction) &Dtool_PNMTextMaker_generate_into_51, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMTextMaker_generate_into_51_comment},
  {"generateInto", (PyCFunction) &Dtool_PNMTextMaker_generate_into_51, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMTextMaker_generate_into_51_comment},
  {"calc_width", &Dtool_PNMTextMaker_calc_width_52, METH_O, (const char *)Dtool_PNMTextMaker_calc_width_52_comment},
  {"calcWidth", &Dtool_PNMTextMaker_calc_width_52, METH_O, (const char *)Dtool_PNMTextMaker_calc_width_52_comment},
  {"get_glyph", &Dtool_PNMTextMaker_get_glyph_53, METH_O, (const char *)Dtool_PNMTextMaker_get_glyph_53_comment},
  {"getGlyph", &Dtool_PNMTextMaker_get_glyph_53, METH_O, (const char *)Dtool_PNMTextMaker_get_glyph_53_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PNMTextMaker = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PNMTextMaker = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PNMTextMaker = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PNMTextMaker = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PNMTextMaker = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PNMTextMaker = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PNMTextMaker",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PNMTextMaker,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PNMTextMaker,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PNMTextMaker,
    &Dtool_SequenceMethods_PNMTextMaker,
    &Dtool_MappingMethods_PNMTextMaker,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PNMTextMaker,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This object uses the Freetype library to generate text directly into an\n"
    " * image.  It is different from the TextNode/DynamicTextFont interface, which\n"
    " * use the Freetype library to generate text in the scene graph, to be\n"
    " * rendered onscreen via the Panda render traversal.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PNMTextMaker,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PNMTextMaker,
    PyType_GenericAlloc,
    Dtool_new_PNMTextMaker,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PNMTextMaker,
  Dtool_UpcastInterface_PNMTextMaker,
  Dtool_DowncastInterface_PNMTextMaker,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PNMTextMaker(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_FreetypeFont(nullptr);
    Dtool_PNMTextMaker._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_FreetypeFont);
    Dtool_PNMTextMaker._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(7);
    Dtool_PNMTextMaker._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum PNMTextMaker::Alignment;
    PyDict_SetItemString(dict, "A_left", Dtool_WrapValue(PNMTextMaker::A_left));
    PyDict_SetItemString(dict, "ALeft", Dtool_WrapValue(PNMTextMaker::A_left));
    PyDict_SetItemString(dict, "A_right", Dtool_WrapValue(PNMTextMaker::A_right));
    PyDict_SetItemString(dict, "ARight", Dtool_WrapValue(PNMTextMaker::A_right));
    PyDict_SetItemString(dict, "A_center", Dtool_WrapValue(PNMTextMaker::A_center));
    PyDict_SetItemString(dict, "ACenter", Dtool_WrapValue(PNMTextMaker::A_center));
    if (PyType_Ready((PyTypeObject *)&Dtool_PNMTextMaker) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PNMTextMaker)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PNMTextMaker);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3pnmtext_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
}

void Dtool_libp3pnmtext_BuildInstants(PyObject *module) {
  (void) module;
  // FreetypeFont
  Dtool_PyModuleClassInit_FreetypeFont(module);
  PyModule_AddObject(module, "FreetypeFont", (PyObject *)&Dtool_FreetypeFont);
  // PNMTextGlyph
  Dtool_PyModuleClassInit_PNMTextGlyph(module);
  PyModule_AddObject(module, "PNMTextGlyph", (PyObject *)&Dtool_PNMTextGlyph);
  // PNMTextMaker
  Dtool_PyModuleClassInit_PNMTextMaker(module);
  PyModule_AddObject(module, "PNMTextMaker", (PyObject *)&Dtool_PNMTextMaker);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3pnmtext_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3pnmtext_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583613644,  /* file_identifier */
  "libp3pnmtext",  /* library_name */
  "g64k",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3pnmtext.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  130  /* next_index */
};

Configure(_in_configure_libp3pnmtext);
ConfigureFn(_in_configure_libp3pnmtext) {
  interrogate_request_module(&_in_module_def);
}

