/*
 * This file was generated by:
 * built/bin/interrogate -srcdir panda/src/egg -Ipanda/src/egg -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3egg_igate.cxx -od built/pandac/input/libp3egg.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/egg -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.egg -library libp3egg config_egg.h eggAnimData.h eggAnimPreload.h eggAttributes.h eggBin.h eggBinMaker.h eggComment.h eggCompositePrimitive.h eggCoordinateSystem.h eggCurve.h eggData.h eggExternalReference.h eggFilenameNode.h eggGroup.h eggGroupNode.h eggGroupNode_ext.h eggGroupUniquifier.h eggLine.h eggMaterial.h eggMaterialCollection.h eggMesher.h eggMesherEdge.h eggMesherFanMaker.h eggMesherStrip.h eggMiscFuncs.h eggMorph.h eggMorphList.h eggNameUniquifier.h eggNamedObject.h eggNode.h eggNurbsCurve.h eggNurbsSurface.h eggObject.h eggParameters.h eggPatch.h eggPoint.h eggPolygon.h eggPolysetMaker.h eggPoolUniquifier.h eggPrimitive.h eggRenderMode.h eggSAnimData.h eggSurface.h eggSwitchCondition.h eggTable.h eggTexture.h eggTextureCollection.h eggTransform.h eggTriangleFan.h eggTriangleStrip.h eggUserData.h eggUtilities.h eggVertex.h eggVertexAux.h eggVertexPool.h eggVertexUV.h eggXfmAnimData.h eggXfmSAnim.h lexerDefs.h p3egg_composite1.cxx p3egg_composite2.cxx parserDefs.h pt_EggMaterial.h pt_EggTexture.h pt_EggVertex.h vector_PT_EggMaterial.h vector_PT_EggTexture.h vector_PT_EggVertex.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include <algorithm>
#include "configVariableBool.h"
#include "configVariableDouble.h"
#include "configVariableEnum.h"
#include "configVariableInt.h"
#include "configVariableSearchPath.h"
#include "config_egg.h"
#include "coordinateSystem.h"
#include "dcast.h"
#include "dtoolbase.h"
#include "eggAnimData.h"
#include "eggAnimPreload.h"
#include "eggAttributes.h"
#include "eggBin.h"
#include "eggBinMaker.h"
#include "eggComment.h"
#include "eggCompositePrimitive.h"
#include "eggCoordinateSystem.h"
#include "eggCurve.h"
#include "eggData.h"
#include "eggExternalReference.h"
#include "eggFilenameNode.h"
#include "eggGroup.h"
#include "eggGroupNode.h"
#include "eggGroupNode_ext.h"
#include "eggGroupUniquifier.h"
#include "eggLine.h"
#include "eggMaterial.h"
#include "eggMaterialCollection.h"
#include "eggMesher.h"
#include "eggMesherEdge.h"
#include "eggMesherFanMaker.h"
#include "eggMesherStrip.h"
#include "eggMiscFuncs.h"
#include "eggMorph.h"
#include "eggMorphList.h"
#include "eggNameUniquifier.h"
#include "eggNamedObject.h"
#include "eggNode.h"
#include "eggNurbsCurve.h"
#include "eggNurbsSurface.h"
#include "eggObject.h"
#include "eggParameters.h"
#include "eggPatch.h"
#include "eggPoint.h"
#include "eggPolygon.h"
#include "eggPolysetMaker.h"
#include "eggPoolUniquifier.h"
#include "eggPrimitive.h"
#include "eggRenderMode.h"
#include "eggSAnimData.h"
#include "eggSurface.h"
#include "eggSwitchCondition.h"
#include "eggTable.h"
#include "eggTexture.h"
#include "eggTextureCollection.h"
#include "eggTransform.h"
#include "eggTriangleFan.h"
#include "eggTriangleStrip.h"
#include "eggUserData.h"
#include "eggUtilities.h"
#include "eggVertex.h"
#include "eggVertexAux.h"
#include "eggVertexPool.h"
#include "eggVertexUV.h"
#include "eggXfmAnimData.h"
#include "eggXfmSAnim.h"
#include "extension.h"
#include "filename.h"
#include "lexerDefs.h"
#include "lmatrix.h"
#include "luse.h"
#include <math.h>
#include "mathNumbers.h"
#include "notifyCategoryProxy.h"
#include "pandabase.h"
#include "parserDefs.h"
#include "plist.h"
#include "pmap.h"
#include "pnotify.h"
#include "pointerTo.h"
#include "pointerToArray.h"
#include "pset.h"
#include "pt_EggMaterial.h"
#include "pt_EggTexture.h"
#include "pt_EggVertex.h"
#include "pta_double.h"
#include "pvector.h"
#include "py_panda.h"
#include <string>
#include "typedObject.h"
#include "typedef.h"
#include "vector_PT_EggMaterial.h"
#include "vector_PT_EggTexture.h"
#include "vector_PT_EggVertex.h"
#include "vector_double.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class EggUserData
 */
typedef EggUserData EggUserData_localtype;
Define_Module_ClassRef(panda3d.egg, EggUserData, EggUserData_localtype, EggUserData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggUserData = &Dtool_EggUserData;
static void Dtool_PyModuleClassInit_EggUserData(PyObject *module);

/**
 * Forward declarations for top-level class EggObject
 */
typedef EggObject EggObject_localtype;
Define_Module_ClassRef(panda3d.egg, EggObject, EggObject_localtype, EggObject);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggObject = &Dtool_EggObject;
static void Dtool_PyModuleClassInit_EggObject(PyObject *module);

/**
 * Forward declarations for top-level class EggNamedObject
 */
typedef EggNamedObject EggNamedObject_localtype;
Define_Module_ClassRef(panda3d.egg, EggNamedObject, EggNamedObject_localtype, EggNamedObject);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggNamedObject = &Dtool_EggNamedObject;
static void Dtool_PyModuleClassInit_EggNamedObject(PyObject *module);

/**
 * Forward declarations for top-level class EggNode
 */
typedef EggNode EggNode_localtype;
Define_Module_ClassRef(panda3d.egg, EggNode, EggNode_localtype, EggNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggNode = &Dtool_EggNode;
static void Dtool_PyModuleClassInit_EggNode(PyObject *module);

/**
 * Forward declarations for top-level class EggGroupNode
 */
typedef EggGroupNode EggGroupNode_localtype;
Define_Module_ClassRef(panda3d.egg, EggGroupNode, EggGroupNode_localtype, EggGroupNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggGroupNode = &Dtool_EggGroupNode;
static void Dtool_PyModuleClassInit_EggGroupNode(PyObject *module);

/**
 * Forward declarations for top-level class EggAnimData
 */
typedef EggAnimData EggAnimData_localtype;
Define_Module_ClassRef(panda3d.egg, EggAnimData, EggAnimData_localtype, EggAnimData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggAnimData = &Dtool_EggAnimData;
static void Dtool_PyModuleClassInit_EggAnimData(PyObject *module);

/**
 * Forward declarations for top-level class EggAnimPreload
 */
typedef EggAnimPreload EggAnimPreload_localtype;
Define_Module_ClassRef(panda3d.egg, EggAnimPreload, EggAnimPreload_localtype, EggAnimPreload);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggAnimPreload = &Dtool_EggAnimPreload;
static void Dtool_PyModuleClassInit_EggAnimPreload(PyObject *module);

/**
 * Forward declarations for top-level class EggAttributes
 */
typedef EggAttributes EggAttributes_localtype;
Define_Module_Class(panda3d.egg, EggAttributes, EggAttributes_localtype, EggAttributes);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggAttributes = &Dtool_EggAttributes;
static void Dtool_PyModuleClassInit_EggAttributes(PyObject *module);

/**
 * Forward declarations for top-level class EggVertexUV
 */
typedef EggVertexUV EggVertexUV_localtype;
Define_Module_ClassRef(panda3d.egg, EggVertexUV, EggVertexUV_localtype, EggVertexUV);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggVertexUV = &Dtool_EggVertexUV;
static void Dtool_PyModuleClassInit_EggVertexUV(PyObject *module);

/**
 * Forward declarations for top-level class EggVertexAux
 */
typedef EggVertexAux EggVertexAux_localtype;
Define_Module_ClassRef(panda3d.egg, EggVertexAux, EggVertexAux_localtype, EggVertexAux);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggVertexAux = &Dtool_EggVertexAux;
static void Dtool_PyModuleClassInit_EggVertexAux(PyObject *module);

/**
 * Forward declarations for top-level class EggVertex
 */
typedef EggVertex EggVertex_localtype;
Define_Module_ClassRef(panda3d.egg, EggVertex, EggVertex_localtype, EggVertex);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggVertex = &Dtool_EggVertex;
static void Dtool_PyModuleClassInit_EggVertex(PyObject *module);

/**
 * Forward declarations for top-level class EggVertexPool
 */
typedef EggVertexPool EggVertexPool_localtype;
Define_Module_ClassRef(panda3d.egg, EggVertexPool, EggVertexPool_localtype, EggVertexPool);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggVertexPool = &Dtool_EggVertexPool;
static void Dtool_PyModuleClassInit_EggVertexPool(PyObject *module);

/**
 * Forward declarations for top-level class EggRenderMode
 */
typedef EggRenderMode EggRenderMode_localtype;
Define_Module_Class(panda3d.egg, EggRenderMode, EggRenderMode_localtype, EggRenderMode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggRenderMode = &Dtool_EggRenderMode;
static void Dtool_PyModuleClassInit_EggRenderMode(PyObject *module);

/**
 * Forward declarations for top-level class EggTransform
 */
typedef EggTransform EggTransform_localtype;
Define_Module_Class(panda3d.egg, EggTransform, EggTransform_localtype, EggTransform);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggTransform = &Dtool_EggTransform;
static void Dtool_PyModuleClassInit_EggTransform(PyObject *module);

/**
 * Forward declarations for top-level class EggSwitchCondition
 */
typedef EggSwitchCondition EggSwitchCondition_localtype;
Define_Module_ClassRef(panda3d.egg, EggSwitchCondition, EggSwitchCondition_localtype, EggSwitchCondition);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggSwitchCondition = &Dtool_EggSwitchCondition;
static void Dtool_PyModuleClassInit_EggSwitchCondition(PyObject *module);

/**
 * Forward declarations for top-level class EggSwitchConditionDistance
 */
typedef EggSwitchConditionDistance EggSwitchConditionDistance_localtype;
Define_Module_ClassRef(panda3d.egg, EggSwitchConditionDistance, EggSwitchConditionDistance_localtype, EggSwitchConditionDistance);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggSwitchConditionDistance = &Dtool_EggSwitchConditionDistance;
static void Dtool_PyModuleClassInit_EggSwitchConditionDistance(PyObject *module);

/**
 * Forward declarations for top-level class EggGroup
 */
typedef EggGroup EggGroup_localtype;
Define_Module_ClassRef(panda3d.egg, EggGroup, EggGroup_localtype, EggGroup);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggGroup = &Dtool_EggGroup;
static void Dtool_PyModuleClassInit_EggGroup(PyObject *module);

/**
 * Forward declarations for top-level class EggBin
 */
typedef EggBin EggBin_localtype;
Define_Module_ClassRef(panda3d.egg, EggBin, EggBin_localtype, EggBin);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggBin = &Dtool_EggBin;
static void Dtool_PyModuleClassInit_EggBin(PyObject *module);
bool Dtool_ConstCoerce_EggBin(PyObject *args, CPT(EggBin) &coerced);
bool Dtool_Coerce_EggBin(PyObject *args, PT(EggBin) &coerced);

/**
 * Forward declarations for top-level class EggBinMaker
 */
typedef EggBinMaker EggBinMaker_localtype;
Define_Module_ClassRef(panda3d.egg, EggBinMaker, EggBinMaker_localtype, EggBinMaker);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggBinMaker = &Dtool_EggBinMaker;
static void Dtool_PyModuleClassInit_EggBinMaker(PyObject *module);

/**
 * Forward declarations for top-level class EggComment
 */
typedef EggComment EggComment_localtype;
Define_Module_ClassRef(panda3d.egg, EggComment, EggComment_localtype, EggComment);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggComment = &Dtool_EggComment;
static void Dtool_PyModuleClassInit_EggComment(PyObject *module);

/**
 * Forward declarations for top-level class EggFilenameNode
 */
typedef EggFilenameNode EggFilenameNode_localtype;
Define_Module_ClassRef(panda3d.egg, EggFilenameNode, EggFilenameNode_localtype, EggFilenameNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggFilenameNode = &Dtool_EggFilenameNode;
static void Dtool_PyModuleClassInit_EggFilenameNode(PyObject *module);

/**
 * Forward declarations for top-level class EggTexture
 */
typedef EggTexture EggTexture_localtype;
Define_Module_ClassRef(panda3d.egg, EggTexture, EggTexture_localtype, EggTexture);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggTexture = &Dtool_EggTexture;
static void Dtool_PyModuleClassInit_EggTexture(PyObject *module);

/**
 * Forward declarations for top-level class EggMaterial
 */
typedef EggMaterial EggMaterial_localtype;
Define_Module_ClassRef(panda3d.egg, EggMaterial, EggMaterial_localtype, EggMaterial);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggMaterial = &Dtool_EggMaterial;
static void Dtool_PyModuleClassInit_EggMaterial(PyObject *module);

/**
 * Forward declarations for top-level class EggPrimitive
 */
typedef EggPrimitive EggPrimitive_localtype;
Define_Module_ClassRef(panda3d.egg, EggPrimitive, EggPrimitive_localtype, EggPrimitive);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggPrimitive = &Dtool_EggPrimitive;
static void Dtool_PyModuleClassInit_EggPrimitive(PyObject *module);

/**
 * Forward declarations for top-level class EggCompositePrimitive
 */
typedef EggCompositePrimitive EggCompositePrimitive_localtype;
Define_Module_ClassRef(panda3d.egg, EggCompositePrimitive, EggCompositePrimitive_localtype, EggCompositePrimitive);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggCompositePrimitive = &Dtool_EggCompositePrimitive;
static void Dtool_PyModuleClassInit_EggCompositePrimitive(PyObject *module);

/**
 * Forward declarations for top-level class EggData
 */
typedef EggData EggData_localtype;
Define_Module_ClassRef(panda3d.egg, EggData, EggData_localtype, EggData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggData = &Dtool_EggData;
static void Dtool_PyModuleClassInit_EggData(PyObject *module);

/**
 * Forward declarations for top-level class EggCoordinateSystem
 */
typedef EggCoordinateSystem EggCoordinateSystem_localtype;
Define_Module_ClassRef(panda3d.egg, EggCoordinateSystem, EggCoordinateSystem_localtype, EggCoordinateSystem);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggCoordinateSystem = &Dtool_EggCoordinateSystem;
static void Dtool_PyModuleClassInit_EggCoordinateSystem(PyObject *module);
bool Dtool_ConstCoerce_EggCoordinateSystem(PyObject *args, CPT(EggCoordinateSystem) &coerced);
bool Dtool_Coerce_EggCoordinateSystem(PyObject *args, PT(EggCoordinateSystem) &coerced);

/**
 * Forward declarations for top-level class EggCurve
 */
typedef EggCurve EggCurve_localtype;
Define_Module_ClassRef(panda3d.egg, EggCurve, EggCurve_localtype, EggCurve);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggCurve = &Dtool_EggCurve;
static void Dtool_PyModuleClassInit_EggCurve(PyObject *module);

/**
 * Forward declarations for top-level class EggExternalReference
 */
typedef EggExternalReference EggExternalReference_localtype;
Define_Module_ClassRef(panda3d.egg, EggExternalReference, EggExternalReference_localtype, EggExternalReference);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggExternalReference = &Dtool_EggExternalReference;
static void Dtool_PyModuleClassInit_EggExternalReference(PyObject *module);

/**
 * Forward declarations for top-level class EggNameUniquifier
 */
typedef EggNameUniquifier EggNameUniquifier_localtype;
Define_Module_ClassRef(panda3d.egg, EggNameUniquifier, EggNameUniquifier_localtype, EggNameUniquifier);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggNameUniquifier = &Dtool_EggNameUniquifier;
static void Dtool_PyModuleClassInit_EggNameUniquifier(PyObject *module);

/**
 * Forward declarations for top-level class EggGroupUniquifier
 */
typedef EggGroupUniquifier EggGroupUniquifier_localtype;
Define_Module_ClassRef(panda3d.egg, EggGroupUniquifier, EggGroupUniquifier_localtype, EggGroupUniquifier);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggGroupUniquifier = &Dtool_EggGroupUniquifier;
static void Dtool_PyModuleClassInit_EggGroupUniquifier(PyObject *module);

/**
 * Forward declarations for top-level class EggLine
 */
typedef EggLine EggLine_localtype;
Define_Module_ClassRef(panda3d.egg, EggLine, EggLine_localtype, EggLine);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggLine = &Dtool_EggLine;
static void Dtool_PyModuleClassInit_EggLine(PyObject *module);

/**
 * Forward declarations for top-level class EggMaterialCollection
 */
typedef EggMaterialCollection EggMaterialCollection_localtype;
Define_Module_Class(panda3d.egg, EggMaterialCollection, EggMaterialCollection_localtype, EggMaterialCollection);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggMaterialCollection = &Dtool_EggMaterialCollection;
static void Dtool_PyModuleClassInit_EggMaterialCollection(PyObject *module);

/**
 * Forward declarations for top-level class EggPolygon
 */
typedef EggPolygon EggPolygon_localtype;
Define_Module_ClassRef(panda3d.egg, EggPolygon, EggPolygon_localtype, EggPolygon);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggPolygon = &Dtool_EggPolygon;
static void Dtool_PyModuleClassInit_EggPolygon(PyObject *module);

/**
 * Forward declarations for top-level class EggNurbsCurve
 */
typedef EggNurbsCurve EggNurbsCurve_localtype;
Define_Module_ClassRef(panda3d.egg, EggNurbsCurve, EggNurbsCurve_localtype, EggNurbsCurve);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggNurbsCurve = &Dtool_EggNurbsCurve;
static void Dtool_PyModuleClassInit_EggNurbsCurve(PyObject *module);

/**
 * Forward declarations for top-level class EggSurface
 */
typedef EggSurface EggSurface_localtype;
Define_Module_ClassRef(panda3d.egg, EggSurface, EggSurface_localtype, EggSurface);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggSurface = &Dtool_EggSurface;
static void Dtool_PyModuleClassInit_EggSurface(PyObject *module);

/**
 * Forward declarations for top-level class EggNurbsSurface
 */
typedef EggNurbsSurface EggNurbsSurface_localtype;
Define_Module_ClassRef(panda3d.egg, EggNurbsSurface, EggNurbsSurface_localtype, EggNurbsSurface);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggNurbsSurface = &Dtool_EggNurbsSurface;
static void Dtool_PyModuleClassInit_EggNurbsSurface(PyObject *module);

/**
 * Forward declarations for top-level class EggPatch
 */
typedef EggPatch EggPatch_localtype;
Define_Module_ClassRef(panda3d.egg, EggPatch, EggPatch_localtype, EggPatch);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggPatch = &Dtool_EggPatch;
static void Dtool_PyModuleClassInit_EggPatch(PyObject *module);

/**
 * Forward declarations for top-level class EggPoint
 */
typedef EggPoint EggPoint_localtype;
Define_Module_ClassRef(panda3d.egg, EggPoint, EggPoint_localtype, EggPoint);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggPoint = &Dtool_EggPoint;
static void Dtool_PyModuleClassInit_EggPoint(PyObject *module);

/**
 * Forward declarations for top-level class EggPolysetMaker
 */
typedef EggPolysetMaker EggPolysetMaker_localtype;
Define_Module_ClassRef(panda3d.egg, EggPolysetMaker, EggPolysetMaker_localtype, EggPolysetMaker);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggPolysetMaker = &Dtool_EggPolysetMaker;
static void Dtool_PyModuleClassInit_EggPolysetMaker(PyObject *module);

/**
 * Forward declarations for top-level class EggPoolUniquifier
 */
typedef EggPoolUniquifier EggPoolUniquifier_localtype;
Define_Module_ClassRef(panda3d.egg, EggPoolUniquifier, EggPoolUniquifier_localtype, EggPoolUniquifier);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggPoolUniquifier = &Dtool_EggPoolUniquifier;
static void Dtool_PyModuleClassInit_EggPoolUniquifier(PyObject *module);

/**
 * Forward declarations for top-level class EggSAnimData
 */
typedef EggSAnimData EggSAnimData_localtype;
Define_Module_ClassRef(panda3d.egg, EggSAnimData, EggSAnimData_localtype, EggSAnimData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggSAnimData = &Dtool_EggSAnimData;
static void Dtool_PyModuleClassInit_EggSAnimData(PyObject *module);

/**
 * Forward declarations for top-level class EggTable
 */
typedef EggTable EggTable_localtype;
Define_Module_ClassRef(panda3d.egg, EggTable, EggTable_localtype, EggTable);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggTable = &Dtool_EggTable;
static void Dtool_PyModuleClassInit_EggTable(PyObject *module);

/**
 * Forward declarations for top-level class EggTextureCollection
 */
typedef EggTextureCollection EggTextureCollection_localtype;
Define_Module_Class(panda3d.egg, EggTextureCollection, EggTextureCollection_localtype, EggTextureCollection);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggTextureCollection = &Dtool_EggTextureCollection;
static void Dtool_PyModuleClassInit_EggTextureCollection(PyObject *module);

/**
 * Forward declarations for top-level class EggTriangleFan
 */
typedef EggTriangleFan EggTriangleFan_localtype;
Define_Module_ClassRef(panda3d.egg, EggTriangleFan, EggTriangleFan_localtype, EggTriangleFan);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggTriangleFan = &Dtool_EggTriangleFan;
static void Dtool_PyModuleClassInit_EggTriangleFan(PyObject *module);

/**
 * Forward declarations for top-level class EggTriangleStrip
 */
typedef EggTriangleStrip EggTriangleStrip_localtype;
Define_Module_ClassRef(panda3d.egg, EggTriangleStrip, EggTriangleStrip_localtype, EggTriangleStrip);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggTriangleStrip = &Dtool_EggTriangleStrip;
static void Dtool_PyModuleClassInit_EggTriangleStrip(PyObject *module);

/**
 * Forward declarations for top-level class EggXfmSAnim
 */
typedef EggXfmSAnim EggXfmSAnim_localtype;
Define_Module_ClassRef(panda3d.egg, EggXfmSAnim, EggXfmSAnim_localtype, EggXfmSAnim);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggXfmSAnim = &Dtool_EggXfmSAnim;
static void Dtool_PyModuleClassInit_EggXfmSAnim(PyObject *module);
bool Dtool_ConstCoerce_EggXfmSAnim(PyObject *args, CPT(EggXfmSAnim) &coerced);
bool Dtool_Coerce_EggXfmSAnim(PyObject *args, PT(EggXfmSAnim) &coerced);

/**
 * Forward declarations for top-level class EggXfmAnimData
 */
typedef EggXfmAnimData EggXfmAnimData_localtype;
Define_Module_ClassRef(panda3d.egg, EggXfmAnimData, EggXfmAnimData_localtype, EggXfmAnimData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EggXfmAnimData = &Dtool_EggXfmAnimData;
static void Dtool_PyModuleClassInit_EggXfmAnimData(PyObject *module);
bool Dtool_ConstCoerce_EggXfmAnimData(PyObject *args, CPT(EggXfmAnimData) &coerced);
bool Dtool_Coerce_EggXfmAnimData(PyObject *args, PT(EggXfmAnimData) &coerced);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"EggUserData", &Dtool_EggUserData},
  {"EggObject", &Dtool_EggObject},
  {"EggNamedObject", &Dtool_EggNamedObject},
  {"EggNode", &Dtool_EggNode},
  {"EggGroupNode", &Dtool_EggGroupNode},
  {"EggAnimData", &Dtool_EggAnimData},
  {"EggAnimPreload", &Dtool_EggAnimPreload},
  {"EggAttributes", &Dtool_EggAttributes},
  {"EggVertexUV", &Dtool_EggVertexUV},
  {"EggVertexAux", &Dtool_EggVertexAux},
  {"EggVertex", &Dtool_EggVertex},
  {"EggVertexPool", &Dtool_EggVertexPool},
  {"EggRenderMode", &Dtool_EggRenderMode},
  {"EggTransform", &Dtool_EggTransform},
  {"EggSwitchCondition", &Dtool_EggSwitchCondition},
  {"EggSwitchConditionDistance", &Dtool_EggSwitchConditionDistance},
  {"EggGroup", &Dtool_EggGroup},
  {"EggBin", &Dtool_EggBin},
  {"EggBinMaker", &Dtool_EggBinMaker},
  {"EggComment", &Dtool_EggComment},
  {"EggFilenameNode", &Dtool_EggFilenameNode},
  {"EggTexture", &Dtool_EggTexture},
  {"EggMaterial", &Dtool_EggMaterial},
  {"EggPrimitive", &Dtool_EggPrimitive},
  {"EggCompositePrimitive", &Dtool_EggCompositePrimitive},
  {"EggData", &Dtool_EggData},
  {"EggCoordinateSystem", &Dtool_EggCoordinateSystem},
  {"EggCurve", &Dtool_EggCurve},
  {"EggExternalReference", &Dtool_EggExternalReference},
  {"EggNameUniquifier", &Dtool_EggNameUniquifier},
  {"EggGroupUniquifier", &Dtool_EggGroupUniquifier},
  {"EggLine", &Dtool_EggLine},
  {"EggMaterialCollection", &Dtool_EggMaterialCollection},
  {"EggPolygon", &Dtool_EggPolygon},
  {"EggNurbsCurve", &Dtool_EggNurbsCurve},
  {"EggSurface", &Dtool_EggSurface},
  {"EggNurbsSurface", &Dtool_EggNurbsSurface},
  {"EggPatch", &Dtool_EggPatch},
  {"EggPoint", &Dtool_EggPoint},
  {"EggPolysetMaker", &Dtool_EggPolysetMaker},
  {"EggPoolUniquifier", &Dtool_EggPoolUniquifier},
  {"EggSAnimData", &Dtool_EggSAnimData},
  {"EggTable", &Dtool_EggTable},
  {"EggTextureCollection", &Dtool_EggTextureCollection},
  {"EggTriangleFan", &Dtool_EggTriangleFan},
  {"EggTriangleStrip", &Dtool_EggTriangleStrip},
  {"EggXfmSAnim", &Dtool_EggXfmSAnim},
  {"EggXfmAnimData", &Dtool_EggXfmAnimData},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"std::ostream", nullptr},
#define Dtool_Ptr_std_ostream (imports[0].type)
  {"std::istream", nullptr},
#define Dtool_Ptr_std_istream (imports[1].type)
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[2].type)
  {"Filename", nullptr},
#define Dtool_Ptr_Filename (imports[3].type)
  {"DSearchPath", nullptr},
#define Dtool_Ptr_DSearchPath (imports[4].type)
  {"GlobPattern", nullptr},
#define Dtool_Ptr_GlobPattern (imports[5].type)
  {"TypedObject", nullptr},
#define Dtool_Ptr_TypedObject (imports[6].type)
  {"ReferenceCount", nullptr},
#define Dtool_Ptr_ReferenceCount (imports[7].type)
  {"TypedReferenceCount", nullptr},
#define Dtool_Ptr_TypedReferenceCount (imports[8].type)
  {"Namable", nullptr},
#define Dtool_Ptr_Namable (imports[9].type)
  {"LVecBase2d", nullptr},
#define Dtool_Ptr_LVecBase2d (imports[10].type)
  {"LVecBase3d", nullptr},
#define Dtool_Ptr_LVecBase3d (imports[11].type)
  {"LVector2d", nullptr},
#define Dtool_Ptr_LVector2d (imports[12].type)
  {"LVector3d", nullptr},
#define Dtool_Ptr_LVector3d (imports[13].type)
  {"LPoint2d", nullptr},
#define Dtool_Ptr_LPoint2d (imports[14].type)
  {"LPoint3d", nullptr},
#define Dtool_Ptr_LPoint3d (imports[15].type)
  {"LVecBase4f", nullptr},
#define Dtool_Ptr_LVecBase4f (imports[16].type)
  {"LVecBase4d", nullptr},
#define Dtool_Ptr_LVecBase4d (imports[17].type)
  {"LMatrix3d", nullptr},
#define Dtool_Ptr_LMatrix3d (imports[18].type)
  {"LMatrix4d", nullptr},
#define Dtool_Ptr_LMatrix4d (imports[19].type)
  {"LPoint4d", nullptr},
#define Dtool_Ptr_LPoint4d (imports[20].type)
  {"LQuaterniond", nullptr},
#define Dtool_Ptr_LQuaterniond (imports[21].type)
  {"BamCacheRecord", nullptr},
#define Dtool_Ptr_BamCacheRecord (imports[22].type)
  {"BitMask< uint32_t, 32 >", nullptr},
#define Dtool_Ptr_BitMask_uint32_t_32 (imports[23].type)
  {nullptr, nullptr},
};
#endif

// std::ostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
#endif
// std::istream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_istream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_istream = &Dtool_std_istream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// Filename
#ifndef LINK_ALL_STATIC
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != nullptr, nullptr);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != nullptr, nullptr);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// DSearchPath
#ifndef LINK_ALL_STATIC
inline static DSearchPath *Dtool_Coerce_DSearchPath(PyObject *args, DSearchPath &coerced) {
  nassertr(Dtool_Ptr_DSearchPath != nullptr, nullptr);
  nassertr(Dtool_Ptr_DSearchPath->_Dtool_Coerce != nullptr, nullptr);
  return ((DSearchPath *(*)(PyObject *, DSearchPath &))Dtool_Ptr_DSearchPath->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_DSearchPath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DSearchPath = &Dtool_DSearchPath;
extern DSearchPath *Dtool_Coerce_DSearchPath(PyObject *args, DSearchPath &coerced);
#endif
// GlobPattern
#ifndef LINK_ALL_STATIC
inline static GlobPattern *Dtool_Coerce_GlobPattern(PyObject *args, GlobPattern &coerced) {
  nassertr(Dtool_Ptr_GlobPattern != nullptr, nullptr);
  nassertr(Dtool_Ptr_GlobPattern->_Dtool_Coerce != nullptr, nullptr);
  return ((GlobPattern *(*)(PyObject *, GlobPattern &))Dtool_Ptr_GlobPattern->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_GlobPattern;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GlobPattern = &Dtool_GlobPattern;
extern GlobPattern *Dtool_Coerce_GlobPattern(PyObject *args, GlobPattern &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// Namable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// LVecBase2d
#ifndef LINK_ALL_STATIC
inline static LVecBase2d *Dtool_Coerce_LVecBase2d(PyObject *args, LVecBase2d &coerced) {
  nassertr(Dtool_Ptr_LVecBase2d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase2d->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase2d *(*)(PyObject *, LVecBase2d &))Dtool_Ptr_LVecBase2d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2d = &Dtool_LVecBase2d;
extern LVecBase2d *Dtool_Coerce_LVecBase2d(PyObject *args, LVecBase2d &coerced);
#endif
// LVecBase3d
#ifndef LINK_ALL_STATIC
inline static LVecBase3d *Dtool_Coerce_LVecBase3d(PyObject *args, LVecBase3d &coerced) {
  nassertr(Dtool_Ptr_LVecBase3d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase3d->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase3d *(*)(PyObject *, LVecBase3d &))Dtool_Ptr_LVecBase3d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3d = &Dtool_LVecBase3d;
extern LVecBase3d *Dtool_Coerce_LVecBase3d(PyObject *args, LVecBase3d &coerced);
#endif
// LVector2d
#ifndef LINK_ALL_STATIC
inline static LVector2d *Dtool_Coerce_LVector2d(PyObject *args, LVector2d &coerced) {
  nassertr(Dtool_Ptr_LVector2d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVector2d->_Dtool_Coerce != nullptr, nullptr);
  return ((LVector2d *(*)(PyObject *, LVector2d &))Dtool_Ptr_LVector2d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector2d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector2d = &Dtool_LVector2d;
extern LVector2d *Dtool_Coerce_LVector2d(PyObject *args, LVector2d &coerced);
#endif
// LVector3d
#ifndef LINK_ALL_STATIC
inline static LVector3d *Dtool_Coerce_LVector3d(PyObject *args, LVector3d &coerced) {
  nassertr(Dtool_Ptr_LVector3d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVector3d->_Dtool_Coerce != nullptr, nullptr);
  return ((LVector3d *(*)(PyObject *, LVector3d &))Dtool_Ptr_LVector3d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector3d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector3d = &Dtool_LVector3d;
extern LVector3d *Dtool_Coerce_LVector3d(PyObject *args, LVector3d &coerced);
#endif
// LPoint2d
#ifndef LINK_ALL_STATIC
inline static LPoint2d *Dtool_Coerce_LPoint2d(PyObject *args, LPoint2d &coerced) {
  nassertr(Dtool_Ptr_LPoint2d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint2d->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint2d *(*)(PyObject *, LPoint2d &))Dtool_Ptr_LPoint2d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint2d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint2d = &Dtool_LPoint2d;
extern LPoint2d *Dtool_Coerce_LPoint2d(PyObject *args, LPoint2d &coerced);
#endif
// LPoint3d
#ifndef LINK_ALL_STATIC
inline static LPoint3d *Dtool_Coerce_LPoint3d(PyObject *args, LPoint3d &coerced) {
  nassertr(Dtool_Ptr_LPoint3d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint3d->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint3d *(*)(PyObject *, LPoint3d &))Dtool_Ptr_LPoint3d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3d = &Dtool_LPoint3d;
extern LPoint3d *Dtool_Coerce_LPoint3d(PyObject *args, LPoint3d &coerced);
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// LVecBase4d
#ifndef LINK_ALL_STATIC
inline static LVecBase4d *Dtool_Coerce_LVecBase4d(PyObject *args, LVecBase4d &coerced) {
  nassertr(Dtool_Ptr_LVecBase4d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase4d->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase4d *(*)(PyObject *, LVecBase4d &))Dtool_Ptr_LVecBase4d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4d = &Dtool_LVecBase4d;
extern LVecBase4d *Dtool_Coerce_LVecBase4d(PyObject *args, LVecBase4d &coerced);
#endif
// LMatrix3d
#ifndef LINK_ALL_STATIC
inline static LMatrix3d *Dtool_Coerce_LMatrix3d(PyObject *args, LMatrix3d &coerced) {
  nassertr(Dtool_Ptr_LMatrix3d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LMatrix3d->_Dtool_Coerce != nullptr, nullptr);
  return ((LMatrix3d *(*)(PyObject *, LMatrix3d &))Dtool_Ptr_LMatrix3d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix3d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix3d = &Dtool_LMatrix3d;
extern LMatrix3d *Dtool_Coerce_LMatrix3d(PyObject *args, LMatrix3d &coerced);
#endif
// LMatrix4d
#ifndef LINK_ALL_STATIC
inline static LMatrix4d *Dtool_Coerce_LMatrix4d(PyObject *args, LMatrix4d &coerced) {
  nassertr(Dtool_Ptr_LMatrix4d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LMatrix4d->_Dtool_Coerce != nullptr, nullptr);
  return ((LMatrix4d *(*)(PyObject *, LMatrix4d &))Dtool_Ptr_LMatrix4d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4d = &Dtool_LMatrix4d;
extern LMatrix4d *Dtool_Coerce_LMatrix4d(PyObject *args, LMatrix4d &coerced);
#endif
// LPoint4d
#ifndef LINK_ALL_STATIC
inline static LPoint4d *Dtool_Coerce_LPoint4d(PyObject *args, LPoint4d &coerced) {
  nassertr(Dtool_Ptr_LPoint4d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint4d->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint4d *(*)(PyObject *, LPoint4d &))Dtool_Ptr_LPoint4d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint4d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint4d = &Dtool_LPoint4d;
extern LPoint4d *Dtool_Coerce_LPoint4d(PyObject *args, LPoint4d &coerced);
#endif
// LQuaterniond
#ifndef LINK_ALL_STATIC
inline static LQuaterniond *Dtool_Coerce_LQuaterniond(PyObject *args, LQuaterniond &coerced) {
  nassertr(Dtool_Ptr_LQuaterniond != nullptr, nullptr);
  nassertr(Dtool_Ptr_LQuaterniond->_Dtool_Coerce != nullptr, nullptr);
  return ((LQuaterniond *(*)(PyObject *, LQuaterniond &))Dtool_Ptr_LQuaterniond->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LQuaterniond;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LQuaterniond = &Dtool_LQuaterniond;
extern LQuaterniond *Dtool_Coerce_LQuaterniond(PyObject *args, LQuaterniond &coerced);
#endif
// BamCacheRecord
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_BamCacheRecord;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BamCacheRecord = &Dtool_BamCacheRecord;
#endif
// BitMask< uint32_t, 32 >
#ifndef LINK_ALL_STATIC
inline static BitMask< uint32_t, 32 > *Dtool_Coerce_BitMask_uint32_t_32(PyObject *args, BitMask< uint32_t, 32 > &coerced) {
  nassertr(Dtool_Ptr_BitMask_uint32_t_32 != nullptr, nullptr);
  nassertr(Dtool_Ptr_BitMask_uint32_t_32->_Dtool_Coerce != nullptr, nullptr);
  return ((BitMask< uint32_t, 32 > *(*)(PyObject *, BitMask< uint32_t, 32 > &))Dtool_Ptr_BitMask_uint32_t_32->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_BitMask_uint32_t_32;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BitMask_uint32_t_32 = &Dtool_BitMask_uint32_t_32;
extern BitMask< uint32_t, 32 > *Dtool_Coerce_BitMask_uint32_t_32(PyObject *args, BitMask< uint32_t, 32 > &coerced);
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class EggUserData
 */
/**
 * Python function wrapper for:
 * inline void EggUserData::operator =(EggUserData const &copy)
 */
static PyObject *Dtool_EggUserData_operator_4(PyObject *self, PyObject *arg) {
  EggUserData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggUserData, (void **)&local_this, "EggUserData.assign")) {
    return nullptr;
  }
  // 1-inline void EggUserData::operator =(EggUserData const &copy)
  EggUserData const *arg_this = (EggUserData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggUserData, 1, "EggUserData.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggUserData *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggUserData, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggUserData self, const EggUserData copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggUserData_operator_4_comment =
  "C++ Interface:\n"
  "assign(const EggUserData self, const EggUserData copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggUserData_operator_4_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggUserData::get_class_type(void)
 */
static PyObject *Dtool_EggUserData_get_class_type_5(PyObject *, PyObject *) {
  // 1-static TypeHandle EggUserData::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggUserData::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggUserData_get_class_type_5_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggUserData_get_class_type_5_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggUserData::EggUserData(void)
 * inline EggUserData::EggUserData(EggUserData const &copy)
 */
static int Dtool_Init_EggUserData(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline EggUserData::EggUserData(void)
      EggUserData *return_value = new EggUserData();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggUserData, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-inline EggUserData::EggUserData(EggUserData const &copy)
        EggUserData const *arg_this = (EggUserData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggUserData, 0, "EggUserData.EggUserData", true, true);
        if (arg_this != nullptr) {
          EggUserData *return_value = new EggUserData(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggUserData, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggUserData() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggUserData()\n"
      "EggUserData(const EggUserData copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggUserData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggUserData) {
    printf("EggUserData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggUserData *local_this = (EggUserData *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggUserData) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggUserData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggUserData) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggUserData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggUserData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggUserData*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggObject
 */
/**
 * Python function wrapper for:
 * void EggObject::operator =(EggObject const &copy)
 */
static PyObject *Dtool_EggObject_operator_8(PyObject *self, PyObject *arg) {
  EggObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggObject, (void **)&local_this, "EggObject.assign")) {
    return nullptr;
  }
  // 1-void EggObject::operator =(EggObject const &copy)
  EggObject const *arg_this = (EggObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggObject, 1, "EggObject.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggObject *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggObject, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggObject self, const EggObject copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggObject_operator_8_comment =
  "C++ Interface:\n"
  "assign(const EggObject self, const EggObject copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggObject_operator_8_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggObject::set_user_data(EggUserData *user_data)
 */
static PyObject *Dtool_EggObject_set_user_data_9(PyObject *self, PyObject *arg) {
  EggObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggObject, (void **)&local_this, "EggObject.set_user_data")) {
    return nullptr;
  }
  // 1-void EggObject::set_user_data(EggUserData *user_data)
  EggUserData *arg_this = (EggUserData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggUserData, 1, "EggObject.set_user_data", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_user_data)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_user_data(const EggObject self, EggUserData user_data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggObject_set_user_data_9_comment =
  "C++ Interface:\n"
  "set_user_data(const EggObject self, EggUserData user_data)\n"
  "\n"
  "/**\n"
  " * Sets the user data associated with this object.  This may be any\n"
  " * EggUserData-derived object.  The egg library will do nothing with this\n"
  " * pointer, except to hold its reference count and return the pointer on\n"
  " * request.\n"
  " *\n"
  " * The EggObject maintains multiple different EggUserData pointers, one for\n"
  " * each unique type (as reported by get_type()).  If you know that only one\n"
  " * type of EggUserData object will be added in your application, you may use\n"
  " * the query functions that accept no parameters, but it is recommended that\n"
  " * in general you pass in the type of your particular user data, to allow\n"
  " * multiple applications to coexist in the same egg data.\n"
  " *\n"
  " * This pointer is also copied by the copy assignment operator and copy\n"
  " * constructor.\n"
  " */";
#else
static const char *Dtool_EggObject_set_user_data_9_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggUserData *EggObject::get_user_data(void) const
 * EggUserData *EggObject::get_user_data(TypeHandle type) const
 */
static PyObject *Dtool_EggObject_get_user_data_10(PyObject *self, PyObject *args) {
  EggObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggObject)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-EggUserData *EggObject::get_user_data(void) const
      EggUserData *return_value = ((*(const EggObject*)local_this).get_user_data)();
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggUserData, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-EggUserData *EggObject::get_user_data(TypeHandle type) const
      TypeHandle arg_local;
      TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
      if (!(arg_this != nullptr)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "EggObject.get_user_data", "TypeHandle");
      }
      EggUserData *return_value = ((*(const EggObject*)local_this).get_user_data)(*arg_this);
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggUserData, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_user_data() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_user_data(EggObject self)\n"
      "get_user_data(EggObject self, TypeHandle type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggObject_get_user_data_10_comment =
  "C++ Interface:\n"
  "get_user_data(EggObject self)\n"
  "get_user_data(EggObject self, TypeHandle type)\n"
  "\n"
  "/**\n"
  " * Returns the user data pointer most recently stored on this object, or NULL\n"
  " * if nothing was previously stored.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the user data pointer of the indicated type, if it exists, or NULL\n"
  " * if it does not.\n"
  " */";
#else
static const char *Dtool_EggObject_get_user_data_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggObject::has_user_data(void) const
 * bool EggObject::has_user_data(TypeHandle type) const
 */
static PyObject *Dtool_EggObject_has_user_data_11(PyObject *self, PyObject *args) {
  EggObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggObject)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-bool EggObject::has_user_data(void) const
      bool return_value = ((*(const EggObject*)local_this).has_user_data)();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-bool EggObject::has_user_data(TypeHandle type) const
      TypeHandle arg_local;
      TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
      if (!(arg_this != nullptr)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "EggObject.has_user_data", "TypeHandle");
      }
      bool return_value = ((*(const EggObject*)local_this).has_user_data)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "has_user_data() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_user_data(EggObject self)\n"
      "has_user_data(EggObject self, TypeHandle type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggObject_has_user_data_11_comment =
  "C++ Interface:\n"
  "has_user_data(EggObject self)\n"
  "has_user_data(EggObject self, TypeHandle type)\n"
  "\n"
  "/**\n"
  " * Returns true if a generic user data pointer has recently been set and not\n"
  " * yet cleared, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if the user data pointer of the indicated type has been set,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_EggObject_has_user_data_11_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggObject::clear_user_data(void)
 * void EggObject::clear_user_data(TypeHandle type)
 */
static PyObject *Dtool_EggObject_clear_user_data_12(PyObject *self, PyObject *args) {
  EggObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggObject, (void **)&local_this, "EggObject.clear_user_data")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-void EggObject::clear_user_data(void)
      ((*local_this).clear_user_data)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-void EggObject::clear_user_data(TypeHandle type)
      TypeHandle arg_local;
      TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
      if (!(arg_this != nullptr)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "EggObject.clear_user_data", "TypeHandle");
      }
      ((*local_this).clear_user_data)(*arg_this);
      return Dtool_Return_None();
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "clear_user_data() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_user_data(const EggObject self)\n"
      "clear_user_data(const EggObject self, TypeHandle type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggObject_clear_user_data_12_comment =
  "C++ Interface:\n"
  "clear_user_data(const EggObject self)\n"
  "clear_user_data(const EggObject self, TypeHandle type)\n"
  "\n"
  "/**\n"
  " * Removes *all* user data pointers from the node.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Removes the user data pointer of the indicated type.\n"
  " */";
#else
static const char *Dtool_EggObject_clear_user_data_12_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggObject::get_class_type(void)
 */
static PyObject *Dtool_EggObject_get_class_type_13(PyObject *, PyObject *) {
  // 1-static TypeHandle EggObject::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggObject::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggObject_get_class_type_13_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggObject_get_class_type_13_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggObject::EggObject(void)
 * EggObject::EggObject(EggObject const &copy)
 */
static int Dtool_Init_EggObject(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-EggObject::EggObject(void)
      EggObject *return_value = new EggObject();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggObject, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-EggObject::EggObject(EggObject const &copy)
        EggObject const *arg_this = (EggObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggObject, 0, "EggObject.EggObject", true, true);
        if (arg_this != nullptr) {
          EggObject *return_value = new EggObject(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggObject, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggObject() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggObject()\n"
      "EggObject(const EggObject copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggObject(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggObject) {
    printf("EggObject ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggObject *local_this = (EggObject *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggObject) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggObject(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggObject*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggObject*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggObject*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggNamedObject
 */
/**
 * Python function wrapper for:
 * inline void EggNamedObject::operator =(EggNamedObject const &copy)
 */
static PyObject *Dtool_EggNamedObject_operator_21(PyObject *self, PyObject *arg) {
  EggNamedObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNamedObject, (void **)&local_this, "EggNamedObject.assign")) {
    return nullptr;
  }
  // 1-inline void EggNamedObject::operator =(EggNamedObject const &copy)
  EggNamedObject const *arg_this = (EggNamedObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggNamedObject, 1, "EggNamedObject.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggNamedObject *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggNamedObject, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggNamedObject self, const EggNamedObject copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNamedObject_operator_21_comment =
  "C++ Interface:\n"
  "assign(const EggNamedObject self, const EggNamedObject copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggNamedObject_operator_21_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggNamedObject::output(std::ostream &out) const
 */
static PyObject *Dtool_EggNamedObject_output_22(PyObject *self, PyObject *arg) {
  EggNamedObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNamedObject)) {
    return nullptr;
  }
  // 1-void EggNamedObject::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "EggNamedObject.output", false, true);
  if (arg_this != nullptr) {
    ((*(const EggNamedObject*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(EggNamedObject self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNamedObject_output_22_comment =
  "C++ Interface:\n"
  "output(EggNamedObject self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggNamedObject_output_22_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggNamedObject::get_class_type(void)
 */
static PyObject *Dtool_EggNamedObject_get_class_type_23(PyObject *, PyObject *) {
  // 1-static TypeHandle EggNamedObject::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggNamedObject::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggNamedObject_get_class_type_23_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggNamedObject_get_class_type_23_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggObject *EggNamedObject::upcast_to_EggObject(void)
 */
static PyObject *Dtool_EggNamedObject_upcast_to_EggObject_15(PyObject *self, PyObject *) {
  EggNamedObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNamedObject, (void **)&local_this, "EggNamedObject.upcast_to_EggObject")) {
    return nullptr;
  }
  // 1-EggObject *EggNamedObject::upcast_to_EggObject(void)
  EggObject *return_value = (EggObject *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggNamedObject_upcast_to_EggObject_15_comment =
  "C++ Interface:\n"
  "upcast_to_EggObject(const EggNamedObject self)\n"
  "\n"
  "upcast from EggNamedObject to EggObject";
#else
static const char *Dtool_EggNamedObject_upcast_to_EggObject_15_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Namable *EggNamedObject::upcast_to_Namable(void)
 */
static PyObject *Dtool_EggNamedObject_upcast_to_Namable_18(PyObject *self, PyObject *) {
  EggNamedObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNamedObject, (void **)&local_this, "EggNamedObject.upcast_to_Namable")) {
    return nullptr;
  }
  // 1-Namable *EggNamedObject::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggNamedObject_upcast_to_Namable_18_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const EggNamedObject self)\n"
  "\n"
  "upcast from EggNamedObject to Namable";
#else
static const char *Dtool_EggNamedObject_upcast_to_Namable_18_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggNamedObject::EggNamedObject(EggNamedObject const &copy)
 * inline explicit EggNamedObject::EggNamedObject(std::string const &name = "")
 */
static int Dtool_Init_EggNamedObject(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline explicit EggNamedObject::EggNamedObject(std::string const &name)
      EggNamedObject *return_value = new EggNamedObject();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggNamedObject, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline EggNamedObject::EggNamedObject(EggNamedObject const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          EggNamedObject const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_EggNamedObject);
          if (param0_this != nullptr) {
            EggNamedObject *return_value = new EggNamedObject(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggNamedObject, true, false);
          }
        }
      }

      {
        // -2 inline explicit EggNamedObject::EggNamedObject(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:EggNamedObject", (char **)keyword_list, &param0_str, &param0_len)) {
          EggNamedObject *return_value = new EggNamedObject(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggNamedObject, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline EggNamedObject::EggNamedObject(EggNamedObject const &copy)
      // No coercion possible: inline explicit EggNamedObject::EggNamedObject(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggNamedObject() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggNamedObject()\n"
      "EggNamedObject(const EggNamedObject copy)\n"
      "EggNamedObject(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggNamedObject(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggNamedObject) {
    printf("EggNamedObject ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggNamedObject *local_this = (EggNamedObject *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggNamedObject) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggNamedObject(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggNamedObject*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggNamedObject*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggNamedObject*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggNamedObject*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggNamedObject*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggNode
 */
/**
 * Python function wrapper for:
 * inline void EggNode::operator =(EggNode const &copy)
 */
static PyObject *Dtool_EggNode_operator_26(PyObject *self, PyObject *arg) {
  EggNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.assign")) {
    return nullptr;
  }
  // 1-inline void EggNode::operator =(EggNode const &copy)
  EggNode const *arg_this = (EggNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggNode, 1, "EggNode.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggNode *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggNode, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggNode self, const EggNode copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNode_operator_26_comment =
  "C++ Interface:\n"
  "assign(const EggNode self, const EggNode copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggNode_operator_26_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggGroupNode *EggNode::get_parent(void) const
 */
static PyObject *Dtool_EggNode_get_parent_27(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNode)) {
    return nullptr;
  }
  // 1-inline EggGroupNode *EggNode::get_parent(void) const
  EggGroupNode *return_value = ((*(const EggNode*)local_this).get_parent)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggGroupNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggNode_get_parent_27_comment =
  "C++ Interface:\n"
  "get_parent(EggNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggNode_get_parent_27_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggNode::get_depth(void) const
 */
static PyObject *Dtool_EggNode_get_depth_28(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNode)) {
    return nullptr;
  }
  // 1-inline int EggNode::get_depth(void) const
  int return_value = ((*(const EggNode*)local_this).get_depth)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_get_depth_28_comment =
  "C++ Interface:\n"
  "get_depth(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns the number of nodes above this node in the egg hierarchy.\n"
  " */";
#else
static const char *Dtool_EggNode_get_depth_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggNode::is_under_instance(void) const
 */
static PyObject *Dtool_EggNode_is_under_instance_29(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNode)) {
    return nullptr;
  }
  // 1-inline bool EggNode::is_under_instance(void) const
  bool return_value = ((*(const EggNode*)local_this).is_under_instance)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_is_under_instance_29_comment =
  "C++ Interface:\n"
  "is_under_instance(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if there is an <Instance> node somewhere in the egg tree at or\n"
  " * above this node, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggNode_is_under_instance_29_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggNode::is_under_transform(void) const
 */
static PyObject *Dtool_EggNode_is_under_transform_30(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNode)) {
    return nullptr;
  }
  // 1-inline bool EggNode::is_under_transform(void) const
  bool return_value = ((*(const EggNode*)local_this).is_under_transform)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_is_under_transform_30_comment =
  "C++ Interface:\n"
  "is_under_transform(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if there is a <Transform> entry somewhere in the egg tree at\n"
  " * or above this node, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggNode_is_under_transform_30_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggNode::is_local_coord(void) const
 */
static PyObject *Dtool_EggNode_is_local_coord_31(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNode)) {
    return nullptr;
  }
  // 1-inline bool EggNode::is_local_coord(void) const
  bool return_value = ((*(const EggNode*)local_this).is_local_coord)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_is_local_coord_31_comment =
  "C++ Interface:\n"
  "is_local_coord(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if this node's vertices are not in the global coordinate\n"
  " * space.  This will be the case if there was an <Instance> node under a\n"
  " * transform at or above this node.\n"
  " */";
#else
static const char *Dtool_EggNode_is_local_coord_31_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d const &EggNode::get_vertex_frame(void) const
 */
static PyObject *Dtool_EggNode_get_vertex_frame_80(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNode)) {
    return nullptr;
  }
  // 1-inline LMatrix4d const &EggNode::get_vertex_frame(void) const
  LMatrix4d const *return_value = &(((*(const EggNode*)local_this).get_vertex_frame)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_get_vertex_frame_80_comment =
  "C++ Interface:\n"
  "get_vertex_frame(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns the coordinate frame of the vertices referenced by primitives at or\n"
  " * under this node.  This is not the same as get_node_frame().\n"
  " *\n"
  " * Generally, vertices in an egg file are stored in the global coordinate\n"
  " * space, regardless of the transforms defined at each node.  Thus,\n"
  " * get_vertex_frame() will usually return the identity transform (global\n"
  " * coordinate space).  However, primitives under an <Instance> entry reference\n"
  " * their vertices in the coordinate system under effect at the time of the\n"
  " * <Instance>.  Thus, nodes under an <Instance> entry may return this non-\n"
  " * identity matrix.\n"
  " *\n"
  " * Specifically, this may return a non-identity matrix only if\n"
  " * is_local_coord() is true.\n"
  " */";
#else
static const char *Dtool_EggNode_get_vertex_frame_80_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d const &EggNode::get_node_frame(void) const
 */
static PyObject *Dtool_EggNode_get_node_frame_81(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNode)) {
    return nullptr;
  }
  // 1-inline LMatrix4d const &EggNode::get_node_frame(void) const
  LMatrix4d const *return_value = &(((*(const EggNode*)local_this).get_node_frame)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_get_node_frame_81_comment =
  "C++ Interface:\n"
  "get_node_frame(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns the coordinate frame of the node itself.  This is simply the net\n"
  " * product of all transformations up to the root.\n"
  " */";
#else
static const char *Dtool_EggNode_get_node_frame_81_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d const &EggNode::get_vertex_frame_inv(void) const
 */
static PyObject *Dtool_EggNode_get_vertex_frame_inv_82(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNode)) {
    return nullptr;
  }
  // 1-inline LMatrix4d const &EggNode::get_vertex_frame_inv(void) const
  LMatrix4d const *return_value = &(((*(const EggNode*)local_this).get_vertex_frame_inv)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_get_vertex_frame_inv_82_comment =
  "C++ Interface:\n"
  "get_vertex_frame_inv(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns the inverse of the matrix returned by get_vertex_frame().  See\n"
  " * get_vertex_frame().\n"
  " */";
#else
static const char *Dtool_EggNode_get_vertex_frame_inv_82_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d const &EggNode::get_node_frame_inv(void) const
 */
static PyObject *Dtool_EggNode_get_node_frame_inv_83(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNode)) {
    return nullptr;
  }
  // 1-inline LMatrix4d const &EggNode::get_node_frame_inv(void) const
  LMatrix4d const *return_value = &(((*(const EggNode*)local_this).get_node_frame_inv)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_get_node_frame_inv_83_comment =
  "C++ Interface:\n"
  "get_node_frame_inv(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns the inverse of the matrix returned by get_node_frame().  See\n"
  " * get_node_frame().\n"
  " */";
#else
static const char *Dtool_EggNode_get_node_frame_inv_83_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d const &EggNode::get_vertex_to_node(void) const
 */
static PyObject *Dtool_EggNode_get_vertex_to_node_84(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNode)) {
    return nullptr;
  }
  // 1-inline LMatrix4d const &EggNode::get_vertex_to_node(void) const
  LMatrix4d const *return_value = &(((*(const EggNode*)local_this).get_vertex_to_node)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_get_vertex_to_node_84_comment =
  "C++ Interface:\n"
  "get_vertex_to_node(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns the transformation matrix suitable for converting the vertices as\n"
  " * read from the egg file into the coordinate space of the node.  This is the\n"
  " * same thing as:\n"
  " *\n"
  " * get_vertex_frame() * get_node_frame_inv()\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggNode_get_vertex_to_node_84_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d const &EggNode::get_node_to_vertex(void) const
 */
static PyObject *Dtool_EggNode_get_node_to_vertex_85(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNode)) {
    return nullptr;
  }
  // 1-inline LMatrix4d const &EggNode::get_node_to_vertex(void) const
  LMatrix4d const *return_value = &(((*(const EggNode*)local_this).get_node_to_vertex)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_get_node_to_vertex_85_comment =
  "C++ Interface:\n"
  "get_node_to_vertex(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns the transformation matrix suitable for converting vertices in the\n"
  " * coordinate space of the node to the appropriate coordinate space for\n"
  " * storing in the egg file.  This is the same thing as:\n"
  " *\n"
  " * get_node_frame() * get_vertex_frame_inv()\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggNode_get_node_to_vertex_85_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d const *EggNode::get_vertex_frame_ptr(void) const
 */
static PyObject *Dtool_EggNode_get_vertex_frame_ptr_86(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNode)) {
    return nullptr;
  }
  // 1-inline LMatrix4d const *EggNode::get_vertex_frame_ptr(void) const
  LMatrix4d const *return_value = ((*(const EggNode*)local_this).get_vertex_frame_ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_get_vertex_frame_ptr_86_comment =
  "C++ Interface:\n"
  "get_vertex_frame_ptr(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns either a NULL pointer or a unique pointer shared by nodes with the\n"
  " * same get_vertex_frame() matrix.\n"
  " */";
#else
static const char *Dtool_EggNode_get_vertex_frame_ptr_86_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d const *EggNode::get_node_frame_ptr(void) const
 */
static PyObject *Dtool_EggNode_get_node_frame_ptr_87(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNode)) {
    return nullptr;
  }
  // 1-inline LMatrix4d const *EggNode::get_node_frame_ptr(void) const
  LMatrix4d const *return_value = ((*(const EggNode*)local_this).get_node_frame_ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_get_node_frame_ptr_87_comment =
  "C++ Interface:\n"
  "get_node_frame_ptr(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns either a NULL pointer or a unique pointer shared by nodes with the\n"
  " * same get_node_frame() matrix.\n"
  " */";
#else
static const char *Dtool_EggNode_get_node_frame_ptr_87_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d const *EggNode::get_vertex_frame_inv_ptr(void) const
 */
static PyObject *Dtool_EggNode_get_vertex_frame_inv_ptr_88(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNode)) {
    return nullptr;
  }
  // 1-inline LMatrix4d const *EggNode::get_vertex_frame_inv_ptr(void) const
  LMatrix4d const *return_value = ((*(const EggNode*)local_this).get_vertex_frame_inv_ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_get_vertex_frame_inv_ptr_88_comment =
  "C++ Interface:\n"
  "get_vertex_frame_inv_ptr(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns either a NULL pointer or a unique pointer shared by nodes with the\n"
  " * same get_vertex_frame_inv() matrix.\n"
  " */";
#else
static const char *Dtool_EggNode_get_vertex_frame_inv_ptr_88_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d const *EggNode::get_node_frame_inv_ptr(void) const
 */
static PyObject *Dtool_EggNode_get_node_frame_inv_ptr_89(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNode)) {
    return nullptr;
  }
  // 1-inline LMatrix4d const *EggNode::get_node_frame_inv_ptr(void) const
  LMatrix4d const *return_value = ((*(const EggNode*)local_this).get_node_frame_inv_ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_get_node_frame_inv_ptr_89_comment =
  "C++ Interface:\n"
  "get_node_frame_inv_ptr(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns either a NULL pointer or a unique pointer shared by nodes with the\n"
  " * same get_node_frame_inv() matrix.\n"
  " */";
#else
static const char *Dtool_EggNode_get_node_frame_inv_ptr_89_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d const *EggNode::get_vertex_to_node_ptr(void) const
 */
static PyObject *Dtool_EggNode_get_vertex_to_node_ptr_90(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNode)) {
    return nullptr;
  }
  // 1-inline LMatrix4d const *EggNode::get_vertex_to_node_ptr(void) const
  LMatrix4d const *return_value = ((*(const EggNode*)local_this).get_vertex_to_node_ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_get_vertex_to_node_ptr_90_comment =
  "C++ Interface:\n"
  "get_vertex_to_node_ptr(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns either a NULL pointer or a unique pointer shared by nodes with the\n"
  " * same get_vertex_to_node() matrix.\n"
  " */";
#else
static const char *Dtool_EggNode_get_vertex_to_node_ptr_90_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d const *EggNode::get_node_to_vertex_ptr(void) const
 */
static PyObject *Dtool_EggNode_get_node_to_vertex_ptr_91(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNode)) {
    return nullptr;
  }
  // 1-inline LMatrix4d const *EggNode::get_node_to_vertex_ptr(void) const
  LMatrix4d const *return_value = ((*(const EggNode*)local_this).get_node_to_vertex_ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_get_node_to_vertex_ptr_91_comment =
  "C++ Interface:\n"
  "get_node_to_vertex_ptr(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns either a NULL pointer or a unique pointer shared by nodes with the\n"
  " * same get_node_to_vertex() matrix.\n"
  " */";
#else
static const char *Dtool_EggNode_get_node_to_vertex_ptr_91_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggNode::transform(LMatrix4d const &mat)
 */
static PyObject *Dtool_EggNode_transform_92(PyObject *self, PyObject *arg) {
  EggNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.transform")) {
    return nullptr;
  }
  // 1-inline void EggNode::transform(LMatrix4d const &mat)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggNode.transform", "LMatrix4d");
  }
  ((*local_this).transform)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "transform(const EggNode self, const LMatrix4d mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNode_transform_92_comment =
  "C++ Interface:\n"
  "transform(const EggNode self, const LMatrix4d mat)\n"
  "\n"
  "/**\n"
  " * Applies the indicated transformation to the node and all of its\n"
  " * descendants.\n"
  " */";
#else
static const char *Dtool_EggNode_transform_92_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggNode::transform_vertices_only(LMatrix4d const &mat)
 */
static PyObject *Dtool_EggNode_transform_vertices_only_93(PyObject *self, PyObject *arg) {
  EggNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.transform_vertices_only")) {
    return nullptr;
  }
  // 1-inline void EggNode::transform_vertices_only(LMatrix4d const &mat)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggNode.transform_vertices_only", "LMatrix4d");
  }
  ((*local_this).transform_vertices_only)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "transform_vertices_only(const EggNode self, const LMatrix4d mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNode_transform_vertices_only_93_comment =
  "C++ Interface:\n"
  "transform_vertices_only(const EggNode self, const LMatrix4d mat)\n"
  "\n"
  "/**\n"
  " * Applies the indicated transformation only to vertices that appear in global\n"
  " * space within vertex pools at this node and below.  Joints and other\n"
  " * transforms are not affected, nor are local vertices.\n"
  " */";
#else
static const char *Dtool_EggNode_transform_vertices_only_93_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggNode::flatten_transforms(void)
 */
static PyObject *Dtool_EggNode_flatten_transforms_94(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.flatten_transforms")) {
    return nullptr;
  }
  // 1-inline void EggNode::flatten_transforms(void)
  ((*local_this).flatten_transforms)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggNode_flatten_transforms_94_comment =
  "C++ Interface:\n"
  "flatten_transforms(const EggNode self)\n"
  "\n"
  "/**\n"
  " * Removes any transform and instance records from this node in the scene\n"
  " * graph and below.  If an instance node is encountered, removes the instance\n"
  " * and applies the transform to its vertices, duplicating vertices if\n"
  " * necessary.\n"
  " *\n"
  " * Since this function may result in duplicated vertices, it may be a good\n"
  " * idea to call remove_unused_vertices() after calling this.\n"
  " */";
#else
static const char *Dtool_EggNode_flatten_transforms_94_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggNode::apply_texmats(void)
 */
static PyObject *Dtool_EggNode_apply_texmats_95(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.apply_texmats")) {
    return nullptr;
  }
  // 1-void EggNode::apply_texmats(void)
  ((*local_this).apply_texmats)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggNode_apply_texmats_95_comment =
  "C++ Interface:\n"
  "apply_texmats(const EggNode self)\n"
  "\n"
  "/**\n"
  " * Applies the texture matrices to the UV's of the vertices that reference\n"
  " * them, and then removes the texture matrices from the textures themselves.\n"
  " */";
#else
static const char *Dtool_EggNode_apply_texmats_95_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggNode::is_joint(void) const
 */
static PyObject *Dtool_EggNode_is_joint_97(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNode)) {
    return nullptr;
  }
  // 1-virtual bool EggNode::is_joint(void) const
  bool return_value = ((*(const EggNode*)local_this).is_joint)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_is_joint_97_comment =
  "C++ Interface:\n"
  "is_joint(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if this particular node represents a <Joint> entry or not.\n"
  " * This is a handy thing to know since Joints are sorted to the end of their\n"
  " * sibling list when writing an egg file.  See EggGroupNode::write().\n"
  " */";
#else
static const char *Dtool_EggNode_is_joint_97_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggNode::is_anim_matrix(void) const
 */
static PyObject *Dtool_EggNode_is_anim_matrix_98(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNode)) {
    return nullptr;
  }
  // 1-virtual bool EggNode::is_anim_matrix(void) const
  bool return_value = ((*(const EggNode*)local_this).is_anim_matrix)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_is_anim_matrix_98_comment =
  "C++ Interface:\n"
  "is_anim_matrix(EggNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if this node represents a table of animation transformation\n"
  " * data, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggNode_is_anim_matrix_98_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggNode::determine_alpha_mode(void)
 */
static PyObject *Dtool_EggNode_determine_alpha_mode_99(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.determine_alpha_mode")) {
    return nullptr;
  }
  // 1-virtual EggRenderMode *EggNode::determine_alpha_mode(void)
  EggRenderMode *return_value = ((*local_this).determine_alpha_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_determine_alpha_mode_99_comment =
  "C++ Interface:\n"
  "determine_alpha_mode(const EggNode self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this node that has an alpha_mode\n"
  " * other than AM_unspecified.  Returns a valid EggRenderMode pointer if one is\n"
  " * found, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_EggNode_determine_alpha_mode_99_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggNode::determine_depth_write_mode(void)
 */
static PyObject *Dtool_EggNode_determine_depth_write_mode_100(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.determine_depth_write_mode")) {
    return nullptr;
  }
  // 1-virtual EggRenderMode *EggNode::determine_depth_write_mode(void)
  EggRenderMode *return_value = ((*local_this).determine_depth_write_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_determine_depth_write_mode_100_comment =
  "C++ Interface:\n"
  "determine_depth_write_mode(const EggNode self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this node that has a\n"
  " * depth_write_mode other than DWM_unspecified.  Returns a valid EggRenderMode\n"
  " * pointer if one is found, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_EggNode_determine_depth_write_mode_100_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggNode::determine_depth_test_mode(void)
 */
static PyObject *Dtool_EggNode_determine_depth_test_mode_101(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.determine_depth_test_mode")) {
    return nullptr;
  }
  // 1-virtual EggRenderMode *EggNode::determine_depth_test_mode(void)
  EggRenderMode *return_value = ((*local_this).determine_depth_test_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_determine_depth_test_mode_101_comment =
  "C++ Interface:\n"
  "determine_depth_test_mode(const EggNode self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this node that has a\n"
  " * depth_test_mode other than DTM_unspecified.  Returns a valid EggRenderMode\n"
  " * pointer if one is found, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_EggNode_determine_depth_test_mode_101_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggNode::determine_visibility_mode(void)
 */
static PyObject *Dtool_EggNode_determine_visibility_mode_102(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.determine_visibility_mode")) {
    return nullptr;
  }
  // 1-virtual EggRenderMode *EggNode::determine_visibility_mode(void)
  EggRenderMode *return_value = ((*local_this).determine_visibility_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_determine_visibility_mode_102_comment =
  "C++ Interface:\n"
  "determine_visibility_mode(const EggNode self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this node that has a\n"
  " * visibility_mode other than VM_unspecified.  Returns a valid EggRenderMode\n"
  " * pointer if one is found, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_EggNode_determine_visibility_mode_102_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggNode::determine_depth_offset(void)
 */
static PyObject *Dtool_EggNode_determine_depth_offset_103(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.determine_depth_offset")) {
    return nullptr;
  }
  // 1-virtual EggRenderMode *EggNode::determine_depth_offset(void)
  EggRenderMode *return_value = ((*local_this).determine_depth_offset)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_determine_depth_offset_103_comment =
  "C++ Interface:\n"
  "determine_depth_offset(const EggNode self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this node that has a depth_offset\n"
  " * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_EggNode_determine_depth_offset_103_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggNode::determine_draw_order(void)
 */
static PyObject *Dtool_EggNode_determine_draw_order_104(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.determine_draw_order")) {
    return nullptr;
  }
  // 1-virtual EggRenderMode *EggNode::determine_draw_order(void)
  EggRenderMode *return_value = ((*local_this).determine_draw_order)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_determine_draw_order_104_comment =
  "C++ Interface:\n"
  "determine_draw_order(const EggNode self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this node that has a draw_order\n"
  " * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_EggNode_determine_draw_order_104_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggNode::determine_bin(void)
 */
static PyObject *Dtool_EggNode_determine_bin_105(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.determine_bin")) {
    return nullptr;
  }
  // 1-virtual EggRenderMode *EggNode::determine_bin(void)
  EggRenderMode *return_value = ((*local_this).determine_bin)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_determine_bin_105_comment =
  "C++ Interface:\n"
  "determine_bin(const EggNode self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this node that has a bin specified.\n"
  " * Returns a valid EggRenderMode pointer if one is found, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_EggNode_determine_bin_105_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggNode::determine_indexed(void)
 */
static PyObject *Dtool_EggNode_determine_indexed_106(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.determine_indexed")) {
    return nullptr;
  }
  // 1-virtual bool EggNode::determine_indexed(void)
  bool return_value = ((*local_this).determine_indexed)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_determine_indexed_106_comment =
  "C++ Interface:\n"
  "determine_indexed(const EggNode self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup at this level or above\n"
  " * that has the \"indexed\" scalar set.  Returns the value of the indexed scalar\n"
  " * if it is found, or false if it is not.\n"
  " *\n"
  " * In other words, returns true if the \"indexed\" flag is in effect for the\n"
  " * indicated node, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggNode_determine_indexed_106_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggNode::determine_decal(void)
 */
static PyObject *Dtool_EggNode_determine_decal_107(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.determine_decal")) {
    return nullptr;
  }
  // 1-virtual bool EggNode::determine_decal(void)
  bool return_value = ((*local_this).determine_decal)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_determine_decal_107_comment =
  "C++ Interface:\n"
  "determine_decal(const EggNode self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup at this level or above\n"
  " * that has the \"decal\" flag set.  Returns the value of the decal flag if it\n"
  " * is found, or false if it is not.\n"
  " *\n"
  " * In other words, returns true if the \"decal\" flag is in effect for the\n"
  " * indicated node, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggNode_determine_decal_107_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void EggNode::write(std::ostream &out, int indent_level) const = 0
 */
static PyObject *Dtool_EggNode_write_108(PyObject *self, PyObject *args, PyObject *kwds) {
  EggNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNode)) {
    return nullptr;
  }
  // 1-virtual void EggNode::write(std::ostream &out, int indent_level) const = 0
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "EggNode.write", false, true);
    if (param1_this != nullptr) {
      ((*(const EggNode*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(EggNode self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNode_write_108_comment =
  "C++ Interface:\n"
  "write(EggNode self, ostream out, int indent_level)\n";
#else
static const char *Dtool_EggNode_write_108_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggNode::parse_egg(std::string const &egg_syntax)
 */
static PyObject *Dtool_EggNode_parse_egg_109(PyObject *self, PyObject *arg) {
  EggNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNode, (void **)&local_this, "EggNode.parse_egg")) {
    return nullptr;
  }
  // 1-bool EggNode::parse_egg(std::string const &egg_syntax)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*local_this).parse_egg)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "parse_egg(const EggNode self, str egg_syntax)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNode_parse_egg_109_comment =
  "C++ Interface:\n"
  "parse_egg(const EggNode self, str egg_syntax)\n"
  "\n"
  "/**\n"
  " * Parses the egg syntax given in the indicate string as if it had been read\n"
  " * from the egg file within this object's definition.  Updates the object\n"
  " * accordingly.  Returns true if successful, false if there was some parse\n"
  " * error or if the object does not support this functionality.\n"
  " */";
#else
static const char *Dtool_EggNode_parse_egg_109_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggNode::test_under_integrity(void) const
 */
static PyObject *Dtool_EggNode_test_under_integrity_110(PyObject *self, PyObject *) {
  EggNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNode)) {
    return nullptr;
  }
  // 1-void EggNode::test_under_integrity(void) const
  ((*(const EggNode*)local_this).test_under_integrity)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggNode_test_under_integrity_110_comment =
  "C++ Interface:\n"
  "test_under_integrity(EggNode self)\n";
#else
static const char *Dtool_EggNode_test_under_integrity_110_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggNode::get_class_type(void)
 */
static PyObject *Dtool_EggNode_get_class_type_111(PyObject *, PyObject *) {
  // 1-static TypeHandle EggNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggNode_get_class_type_111_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggNode_get_class_type_111_comment = nullptr;
#endif

static PyObject *Dtool_EggNode_parent_Getter(PyObject *self, void *) {
  const EggNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline EggGroupNode *EggNode::get_parent(void) const
  EggGroupNode *return_value = ((*(const EggNode*)local_this).get_parent)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggGroupNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_EggNode_depth_Getter(PyObject *self, void *) {
  const EggNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int EggNode::get_depth(void) const
  int return_value = ((*(const EggNode*)local_this).get_depth)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_EggNode(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_EggNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggNode) {
    printf("EggNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggNode *local_this = (EggNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggNode*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggNode*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggGroupNode
 */
/**
 * Python function wrapper for:
 * void EggGroupNode::operator =(EggGroupNode const &copy)
 */
static PyObject *Dtool_EggGroupNode_operator_36(PyObject *self, PyObject *arg) {
  EggGroupNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.assign")) {
    return nullptr;
  }
  // 1-void EggGroupNode::operator =(EggGroupNode const &copy)
  EggGroupNode const *arg_this = (EggGroupNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggGroupNode, 1, "EggGroupNode.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggGroupNode *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggGroupNode, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggGroupNode self, const EggGroupNode copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_operator_36_comment =
  "C++ Interface:\n"
  "assign(const EggGroupNode self, const EggGroupNode copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroupNode_operator_36_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggGroupNode::empty(void) const
 */
static PyObject *Dtool_EggGroupNode_empty_37(PyObject *self, PyObject *) {
  EggGroupNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroupNode)) {
    return nullptr;
  }
  // 1-bool EggGroupNode::empty(void) const
  bool return_value = ((*(const EggGroupNode*)local_this).empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_empty_37_comment =
  "C++ Interface:\n"
  "empty(EggGroupNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroupNode_empty_37_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggGroupNode::size_type EggGroupNode::size(void) const
 */
static PyObject *Dtool_EggGroupNode_size_38(PyObject *self, PyObject *) {
  EggGroupNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroupNode)) {
    return nullptr;
  }
  // 1-EggGroupNode::size_type EggGroupNode::size(void) const
  EggGroupNode::size_type return_value = ((*(const EggGroupNode*)local_this).size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_size_38_comment =
  "C++ Interface:\n"
  "size(EggGroupNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroupNode_size_38_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::clear(void)
 */
static PyObject *Dtool_EggGroupNode_clear_39(PyObject *self, PyObject *) {
  EggGroupNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.clear")) {
    return nullptr;
  }
  // 1-void EggGroupNode::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_clear_39_comment =
  "C++ Interface:\n"
  "clear(const EggGroupNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroupNode_clear_39_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggNode *EggGroupNode::get_first_child(void)
 */
static PyObject *Dtool_EggGroupNode_get_first_child_40(PyObject *self, PyObject *) {
  EggGroupNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.get_first_child")) {
    return nullptr;
  }
  // 1-EggNode *EggGroupNode::get_first_child(void)
  EggNode *return_value = ((*local_this).get_first_child)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_get_first_child_40_comment =
  "C++ Interface:\n"
  "get_first_child(const EggGroupNode self)\n"
  "\n"
  "// This is an alternate way to traverse the list of children.  It is mainly\n"
  "// provided for scripting code, which can't use the iterators defined above\n"
  "// (they don't export through interrogate very well). These are, of course,\n"
  "// non-thread-safe.\n"
  "\n"
  "/**\n"
  " * Returns the first child in the group's list of children, or NULL if the\n"
  " * list of children is empty.  Can be used with get_next_child() to return the\n"
  " * complete list of children without using the iterator class; however, this\n"
  " * is non-thread-safe, and so is not recommended except for languages other\n"
  " * than C++ which cannot use the iterators.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_get_first_child_40_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggNode *EggGroupNode::get_next_child(void)
 */
static PyObject *Dtool_EggGroupNode_get_next_child_41(PyObject *self, PyObject *) {
  EggGroupNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.get_next_child")) {
    return nullptr;
  }
  // 1-EggNode *EggGroupNode::get_next_child(void)
  EggNode *return_value = ((*local_this).get_next_child)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_get_next_child_41_comment =
  "C++ Interface:\n"
  "get_next_child(const EggGroupNode self)\n"
  "\n"
  "/**\n"
  " * Returns the next child in the group's list of children since the last call\n"
  " * to get_first_child() or get_next_child(), or NULL if the last child has\n"
  " * been returned.  Can be used with get_first_child() to return the complete\n"
  " * list of children without using the iterator class; however, this is non-\n"
  " * thread-safe, and so is not recommended except for languages other than C++\n"
  " * which cannot use the iterators.\n"
  " *\n"
  " * It is an error to call this without previously calling get_first_child().\n"
  " */";
#else
static const char *Dtool_EggGroupNode_get_next_child_41_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *EggGroupNode::get_children(void) const
 */
static PyObject *Dtool_EggGroupNode_get_children_42(PyObject *self, PyObject *) {
  EggGroupNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroupNode)) {
    return nullptr;
  }
  // 1-PyObject *EggGroupNode::get_children(void) const
  PyObject *return_value = invoke_extension((const EggGroupNode*)local_this).get_children();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_get_children_42_comment =
  "C++ Interface:\n"
  "get_children(EggGroupNode self)\n";
#else
static const char *Dtool_EggGroupNode_get_children_42_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggNode *EggGroupNode::add_child(EggNode *node)
 */
static PyObject *Dtool_EggGroupNode_add_child_47(PyObject *self, PyObject *arg) {
  EggGroupNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.add_child")) {
    return nullptr;
  }
  // 1-EggNode *EggGroupNode::add_child(EggNode *node)
  EggNode *arg_this = (EggNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggNode, 1, "EggGroupNode.add_child", false, true);
  if (arg_this != nullptr) {
    EggNode *return_value = ((*local_this).add_child)(arg_this);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggNode, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_child(const EggGroupNode self, EggNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_add_child_47_comment =
  "C++ Interface:\n"
  "add_child(const EggGroupNode self, EggNode node)\n"
  "\n"
  "/**\n"
  " * Adds the indicated child to the group and returns it.  If the child node is\n"
  " * already a child of some other node, removes it first.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_add_child_47_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< EggNode > EggGroupNode::remove_child(EggNode *node)
 */
static PyObject *Dtool_EggGroupNode_remove_child_48(PyObject *self, PyObject *arg) {
  EggGroupNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.remove_child")) {
    return nullptr;
  }
  // 1-PointerTo< EggNode > EggGroupNode::remove_child(EggNode *node)
  EggNode *arg_this = (EggNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggNode, 1, "EggGroupNode.remove_child", false, true);
  if (arg_this != nullptr) {
    PointerTo< EggNode > return_value = ((*local_this).remove_child)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    EggNode *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_EggNode, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_child(const EggGroupNode self, EggNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_remove_child_48_comment =
  "C++ Interface:\n"
  "remove_child(const EggGroupNode self, EggNode node)\n"
  "\n"
  "/**\n"
  " * Removes the indicated child node from the group and returns it.  If the\n"
  " * child was not already in the group, does nothing and returns NULL.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_remove_child_48_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::steal_children(EggGroupNode &other)
 */
static PyObject *Dtool_EggGroupNode_steal_children_49(PyObject *self, PyObject *arg) {
  EggGroupNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.steal_children")) {
    return nullptr;
  }
  // 1-void EggGroupNode::steal_children(EggGroupNode &other)
  EggGroupNode *arg_this = (EggGroupNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggGroupNode, 1, "EggGroupNode.steal_children", false, true);
  if (arg_this != nullptr) {
    ((*local_this).steal_children)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "steal_children(const EggGroupNode self, EggGroupNode other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_steal_children_49_comment =
  "C++ Interface:\n"
  "steal_children(const EggGroupNode self, EggGroupNode other)\n"
  "\n"
  "/**\n"
  " * Moves all the children from the other node to this one.  This is especially\n"
  " * useful because the group node copy assignment operator does not copy\n"
  " * children.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_steal_children_49_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggNode *EggGroupNode::find_child(std::string const &name) const
 */
static PyObject *Dtool_EggGroupNode_find_child_50(PyObject *self, PyObject *arg) {
  EggGroupNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroupNode)) {
    return nullptr;
  }
  // 1-EggNode *EggGroupNode::find_child(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    EggNode *return_value = ((*(const EggGroupNode*)local_this).find_child)(std::string(param1_str, param1_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggNode, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_child(EggGroupNode self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_find_child_50_comment =
  "C++ Interface:\n"
  "find_child(EggGroupNode self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the child of this node whose name is the indicated string, or NULL\n"
  " * if there is no child of this node by that name.  Does not search\n"
  " * recursively.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_find_child_50_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggGroupNode::has_absolute_pathnames(void) const
 */
static PyObject *Dtool_EggGroupNode_has_absolute_pathnames_51(PyObject *self, PyObject *) {
  EggGroupNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroupNode)) {
    return nullptr;
  }
  // 1-bool EggGroupNode::has_absolute_pathnames(void) const
  bool return_value = ((*(const EggGroupNode*)local_this).has_absolute_pathnames)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_has_absolute_pathnames_51_comment =
  "C++ Interface:\n"
  "has_absolute_pathnames(EggGroupNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if any nodes at this level and below include a reference to a\n"
  " * file via an absolute pathname, or false if all references are relative.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_has_absolute_pathnames_51_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::resolve_filenames(DSearchPath const &searchpath)
 */
static PyObject *Dtool_EggGroupNode_resolve_filenames_52(PyObject *self, PyObject *arg) {
  EggGroupNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.resolve_filenames")) {
    return nullptr;
  }
  // 1-void EggGroupNode::resolve_filenames(DSearchPath const &searchpath)
  DSearchPath arg_local;
  DSearchPath const *arg_this = Dtool_Coerce_DSearchPath(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggGroupNode.resolve_filenames", "DSearchPath");
  }
  ((*local_this).resolve_filenames)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "resolve_filenames(const EggGroupNode self, const DSearchPath searchpath)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_resolve_filenames_52_comment =
  "C++ Interface:\n"
  "resolve_filenames(const EggGroupNode self, const DSearchPath searchpath)\n"
  "\n"
  "/**\n"
  " * Walks the tree and attempts to resolve any filenames encountered.  This\n"
  " * looks up filenames along the specified search path; it does not\n"
  " * automatically search the model_path for missing files.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_resolve_filenames_52_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::force_filenames(Filename const &directory)
 */
static PyObject *Dtool_EggGroupNode_force_filenames_53(PyObject *self, PyObject *arg) {
  EggGroupNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.force_filenames")) {
    return nullptr;
  }
  // 1-void EggGroupNode::force_filenames(Filename const &directory)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggGroupNode.force_filenames", "Filename");
  }
  ((*local_this).force_filenames)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "force_filenames(const EggGroupNode self, const Filename directory)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_force_filenames_53_comment =
  "C++ Interface:\n"
  "force_filenames(const EggGroupNode self, const Filename directory)\n"
  "\n"
  "/**\n"
  " * Similar to resolve_filenames, but each non-absolute filename encountered is\n"
  " * arbitrarily taken to be in the indicated directory, whether or not the so-\n"
  " * named filename exists.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_force_filenames_53_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::reverse_vertex_ordering(void)
 */
static PyObject *Dtool_EggGroupNode_reverse_vertex_ordering_54(PyObject *self, PyObject *) {
  EggGroupNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.reverse_vertex_ordering")) {
    return nullptr;
  }
  // 1-void EggGroupNode::reverse_vertex_ordering(void)
  ((*local_this).reverse_vertex_ordering)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_reverse_vertex_ordering_54_comment =
  "C++ Interface:\n"
  "reverse_vertex_ordering(const EggGroupNode self)\n"
  "\n"
  "/**\n"
  " * Reverses the vertex ordering of all polygons defined at this node and\n"
  " * below.  Does not change the surface normals, if any.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_reverse_vertex_ordering_54_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::recompute_vertex_normals(double threshold, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_EggGroupNode_recompute_vertex_normals_55(PyObject *self, PyObject *args, PyObject *kwds) {
  EggGroupNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.recompute_vertex_normals")) {
    return nullptr;
  }
  // 1-void EggGroupNode::recompute_vertex_normals(double threshold, CoordinateSystem cs = ::CS_default)
  double param1;
  int param2 = ::CS_default;
  static const char *keyword_list[] = {"threshold", "cs", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "d|i:recompute_vertex_normals", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).recompute_vertex_normals)((double)param1, (CoordinateSystem)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "recompute_vertex_normals(const EggGroupNode self, double threshold, int cs)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_recompute_vertex_normals_55_comment =
  "C++ Interface:\n"
  "recompute_vertex_normals(const EggGroupNode self, double threshold, int cs)\n"
  "\n"
  "/**\n"
  " * Recomputes all the vertex normals for polygon geometry at this group node\n"
  " * and below so that they accurately reflect the vertex positions.  A shared\n"
  " * edge between two polygons (even in different groups) is considered smooth\n"
  " * if the angle between the two edges is less than threshold degrees.\n"
  " *\n"
  " * This function also removes degenerate polygons that do not have enough\n"
  " * vertices to define a normal.  It does not affect normals for other kinds of\n"
  " * primitives like Nurbs or Points.\n"
  " *\n"
  " * This function does not remove or adjust vertices in the vertex pool; it\n"
  " * only adds new vertices with the correct normals.  Thus, it is a good idea\n"
  " * to call remove_unused_vertices() after calling this.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_recompute_vertex_normals_55_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::recompute_polygon_normals(CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_EggGroupNode_recompute_polygon_normals_56(PyObject *self, PyObject *args, PyObject *kwds) {
  EggGroupNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.recompute_polygon_normals")) {
    return nullptr;
  }
  // 1-void EggGroupNode::recompute_polygon_normals(CoordinateSystem cs = ::CS_default)
  int param1 = ::CS_default;
  static const char *keyword_list[] = {"cs", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:recompute_polygon_normals", (char **)keyword_list, &param1)) {
    ((*local_this).recompute_polygon_normals)((CoordinateSystem)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "recompute_polygon_normals(const EggGroupNode self, int cs)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_recompute_polygon_normals_56_comment =
  "C++ Interface:\n"
  "recompute_polygon_normals(const EggGroupNode self, int cs)\n"
  "\n"
  "/**\n"
  " * Recomputes all the polygon normals for polygon geometry at this group node\n"
  " * and below so that they accurately reflect the vertex positions.  Normals\n"
  " * are removed from the vertices and defined only on polygons, giving the\n"
  " * geometry a faceted appearance.\n"
  " *\n"
  " * This function also removes degenerate polygons that do not have enough\n"
  " * vertices to define a normal.  It does not affect normals for other kinds of\n"
  " * primitives like Nurbs or Points.\n"
  " *\n"
  " * This function does not remove or adjust vertices in the vertex pool; it\n"
  " * only adds new vertices with the normals removed.  Thus, it is a good idea\n"
  " * to call remove_unused_vertices() after calling this.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_recompute_polygon_normals_56_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::strip_normals(void)
 */
static PyObject *Dtool_EggGroupNode_strip_normals_57(PyObject *self, PyObject *) {
  EggGroupNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.strip_normals")) {
    return nullptr;
  }
  // 1-void EggGroupNode::strip_normals(void)
  ((*local_this).strip_normals)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_strip_normals_57_comment =
  "C++ Interface:\n"
  "strip_normals(const EggGroupNode self)\n"
  "\n"
  "/**\n"
  " * Removes all normals from primitives, and the vertices they reference, at\n"
  " * this node and below.\n"
  " *\n"
  " * This function does not remove or adjust vertices in the vertex pool; it\n"
  " * only adds new vertices with the normal removed.  Thus, it is a good idea to\n"
  " * call remove_unused_vertices() after calling this.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_strip_normals_57_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggGroupNode::recompute_tangent_binormal(GlobPattern const &uv_name)
 * Rejected Remap [bool EggGroupNode::recompute_tangent_binormal(vector_string const &names)]
 */
static PyObject *Dtool_EggGroupNode_recompute_tangent_binormal_58(PyObject *self, PyObject *arg) {
  EggGroupNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.recompute_tangent_binormal")) {
    return nullptr;
  }
  // 1-bool EggGroupNode::recompute_tangent_binormal(GlobPattern const &uv_name)
  GlobPattern arg_local;
  GlobPattern const *arg_this = Dtool_Coerce_GlobPattern(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggGroupNode.recompute_tangent_binormal", "GlobPattern");
  }
  bool return_value = ((*local_this).recompute_tangent_binormal)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "recompute_tangent_binormal(const EggGroupNode self, const GlobPattern uv_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_recompute_tangent_binormal_58_comment =
  "C++ Interface:\n"
  "recompute_tangent_binormal(const EggGroupNode self, const GlobPattern uv_name)\n"
  "\n"
  "/**\n"
  " * This function recomputes the tangent and binormal for the named texture\n"
  " * coordinate set for all vertices at this level and below.  Use the empty\n"
  " * string for the default texture coordinate set.\n"
  " *\n"
  " * It is necessary for each vertex to already have a normal (or at least a\n"
  " * polygon normal), as well as a texture coordinate in the named texture\n"
  " * coordinate set, before calling this function.  You might precede this with\n"
  " * recompute_vertex_normals() to ensure that the normals exist.\n"
  " *\n"
  " * Like recompute_vertex_normals(), this function does not remove or adjust\n"
  " * vertices in the vertex pool; it only adds new vertices with the new\n"
  " * tangents and binormals computed.  Thus, it is a good idea to call\n"
  " * remove_unused_vertices() after calling this.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This function recomputes the tangent and binormal for the named texture\n"
  " * coordinate sets.  Returns true if anything was done.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_recompute_tangent_binormal_58_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggGroupNode::recompute_tangent_binormal_auto(void)
 */
static PyObject *Dtool_EggGroupNode_recompute_tangent_binormal_auto_59(PyObject *self, PyObject *) {
  EggGroupNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.recompute_tangent_binormal_auto")) {
    return nullptr;
  }
  // 1-bool EggGroupNode::recompute_tangent_binormal_auto(void)
  bool return_value = ((*local_this).recompute_tangent_binormal_auto)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_recompute_tangent_binormal_auto_59_comment =
  "C++ Interface:\n"
  "recompute_tangent_binormal_auto(const EggGroupNode self)\n"
  "\n"
  "/**\n"
  " * This function recomputes the tangent and binormal for any texture\n"
  " * coordinate set that affects a normal map.  Returns true if anything was\n"
  " * done.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_recompute_tangent_binormal_auto_59_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int EggGroupNode::triangulate_polygons(int flags)
 */
static PyObject *Dtool_EggGroupNode_triangulate_polygons_61(PyObject *self, PyObject *arg) {
  EggGroupNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.triangulate_polygons")) {
    return nullptr;
  }
  // 1-int EggGroupNode::triangulate_polygons(int flags)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*local_this).triangulate_polygons)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "triangulate_polygons(const EggGroupNode self, int flags)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_triangulate_polygons_61_comment =
  "C++ Interface:\n"
  "triangulate_polygons(const EggGroupNode self, int flags)\n"
  "\n"
  "/**\n"
  " * Replace all higher-order polygons at this point in the scene graph and\n"
  " * below with triangles.  Returns the total number of new triangles produced,\n"
  " * less degenerate polygons removed.\n"
  " *\n"
  " * If flags contains T_polygon and T_convex, both concave and convex polygons\n"
  " * will be subdivided into triangles; with only T_polygon, only concave\n"
  " * polygons will be subdivided, and convex polygons will be largely unchanged.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_triangulate_polygons_61_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::mesh_triangles(int flags)
 */
static PyObject *Dtool_EggGroupNode_mesh_triangles_62(PyObject *self, PyObject *arg) {
  EggGroupNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.mesh_triangles")) {
    return nullptr;
  }
  // 1-void EggGroupNode::mesh_triangles(int flags)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).mesh_triangles)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "mesh_triangles(const EggGroupNode self, int flags)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_mesh_triangles_62_comment =
  "C++ Interface:\n"
  "mesh_triangles(const EggGroupNode self, int flags)\n"
  "\n"
  "/**\n"
  " * Combine triangles together into triangle strips, at this group and below.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_mesh_triangles_62_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::make_point_primitives(void)
 */
static PyObject *Dtool_EggGroupNode_make_point_primitives_63(PyObject *self, PyObject *) {
  EggGroupNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.make_point_primitives")) {
    return nullptr;
  }
  // 1-void EggGroupNode::make_point_primitives(void)
  ((*local_this).make_point_primitives)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_make_point_primitives_63_comment =
  "C++ Interface:\n"
  "make_point_primitives(const EggGroupNode self)\n"
  "\n"
  "/**\n"
  " * Creates PointLight primitives to reference any otherwise unreferences\n"
  " * vertices discovered in this group or below.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_make_point_primitives_63_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int EggGroupNode::remove_unused_vertices(bool recurse)
 */
static PyObject *Dtool_EggGroupNode_remove_unused_vertices_65(PyObject *self, PyObject *arg) {
  EggGroupNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.remove_unused_vertices")) {
    return nullptr;
  }
  // 1-int EggGroupNode::remove_unused_vertices(bool recurse)
  int return_value = ((*local_this).remove_unused_vertices)((PyObject_IsTrue(arg) != 0));
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_unused_vertices(const EggGroupNode self, bool recurse)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_remove_unused_vertices_65_comment =
  "C++ Interface:\n"
  "remove_unused_vertices(const EggGroupNode self, bool recurse)\n"
  "\n"
  "/**\n"
  " * Removes all vertices from VertexPools within this group or below that are\n"
  " * not referenced by at least one primitive.  Also collapses together\n"
  " * equivalent vertices, and renumbers all vertices after the operation so\n"
  " * their indices are consecutive, beginning at zero.  Returns the total number\n"
  " * of vertices removed.\n"
  " *\n"
  " * Note that this operates on the VertexPools within this group level, without\n"
  " * respect to primitives that reference these vertices (unlike other functions\n"
  " * like strip_normals()).  It is therefore most useful to call this on the\n"
  " * EggData root, rather than on a subgroup within the hierarchy, since a\n"
  " * VertexPool may appear anywhere in the hierarchy.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_remove_unused_vertices_65_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int EggGroupNode::remove_invalid_primitives(bool recurse)
 */
static PyObject *Dtool_EggGroupNode_remove_invalid_primitives_66(PyObject *self, PyObject *arg) {
  EggGroupNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.remove_invalid_primitives")) {
    return nullptr;
  }
  // 1-int EggGroupNode::remove_invalid_primitives(bool recurse)
  int return_value = ((*local_this).remove_invalid_primitives)((PyObject_IsTrue(arg) != 0));
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_invalid_primitives(const EggGroupNode self, bool recurse)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_remove_invalid_primitives_66_comment =
  "C++ Interface:\n"
  "remove_invalid_primitives(const EggGroupNode self, bool recurse)\n"
  "\n"
  "/**\n"
  " * Removes primitives at this level and below which appear to be degenerate;\n"
  " * e.g.  polygons with fewer than 3 vertices, etc.  Returns the number of\n"
  " * primitives removed.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_remove_invalid_primitives_66_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::clear_connected_shading(void)
 */
static PyObject *Dtool_EggGroupNode_clear_connected_shading_67(PyObject *self, PyObject *) {
  EggGroupNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.clear_connected_shading")) {
    return nullptr;
  }
  // 1-void EggGroupNode::clear_connected_shading(void)
  ((*local_this).clear_connected_shading)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_clear_connected_shading_67_comment =
  "C++ Interface:\n"
  "clear_connected_shading(const EggGroupNode self)\n"
  "\n"
  "/**\n"
  " * Resets the connected_shading information on all primitives at this node and\n"
  " * below, so that it may be accurately rederived by the next call to\n"
  " * get_connected_shading().\n"
  " *\n"
  " * It may be a good idea to call remove_unused_vertices() as well, to\n"
  " * establish the correct connectivity between common vertices.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_clear_connected_shading_67_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::get_connected_shading(void)
 */
static PyObject *Dtool_EggGroupNode_get_connected_shading_68(PyObject *self, PyObject *) {
  EggGroupNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.get_connected_shading")) {
    return nullptr;
  }
  // 1-void EggGroupNode::get_connected_shading(void)
  ((*local_this).get_connected_shading)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_get_connected_shading_68_comment =
  "C++ Interface:\n"
  "get_connected_shading(const EggGroupNode self)\n"
  "\n"
  "/**\n"
  " * Queries the connected_shading information on all primitives at this node\n"
  " * and below, to ensure that it has been completely filled in before we start\n"
  " * mucking around with vertices.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_get_connected_shading_68_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::unify_attributes(bool use_connected_shading, bool allow_per_primitive, bool recurse)
 */
static PyObject *Dtool_EggGroupNode_unify_attributes_69(PyObject *self, PyObject *args, PyObject *kwds) {
  EggGroupNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.unify_attributes")) {
    return nullptr;
  }
  // 1-void EggGroupNode::unify_attributes(bool use_connected_shading, bool allow_per_primitive, bool recurse)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"use_connected_shading", "allow_per_primitive", "recurse", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:unify_attributes", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).unify_attributes)((PyObject_IsTrue(param1) != 0), (PyObject_IsTrue(param2) != 0), (PyObject_IsTrue(param3) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unify_attributes(const EggGroupNode self, bool use_connected_shading, bool allow_per_primitive, bool recurse)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_unify_attributes_69_comment =
  "C++ Interface:\n"
  "unify_attributes(const EggGroupNode self, bool use_connected_shading, bool allow_per_primitive, bool recurse)\n"
  "\n"
  "/**\n"
  " * Applies per-vertex normal and color to all vertices, if they are in fact\n"
  " * per-vertex (and different for each vertex), or moves them to the primitive\n"
  " * if they are all the same.\n"
  " *\n"
  " * After this call, either the primitive will have normals or its vertices\n"
  " * will, but not both.  Ditto for colors.\n"
  " *\n"
  " * If use_connected_shading is true, each polygon is considered in conjunction\n"
  " * with all connected polygons; otherwise, each polygon is considered\n"
  " * individually.\n"
  " *\n"
  " * If allow_per_primitive is false, S_per_face or S_overall will treated like\n"
  " * S_per_vertex: normals and colors will always be assigned to the vertices.\n"
  " * In this case, there will never be per-primitive colors or normals after\n"
  " * this call returns.  On the other hand, if allow_per_primitive is true, then\n"
  " * S_per_face means that normals and colors should be assigned to the\n"
  " * primitives, and removed from the vertices, as described above.\n"
  " *\n"
  " * This may create redundant vertices in the vertex pool, so it may be a good\n"
  " * idea to follow this up with remove_unused_vertices().\n"
  " */";
#else
static const char *Dtool_EggGroupNode_unify_attributes_69_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::apply_last_attribute(bool recurse)
 */
static PyObject *Dtool_EggGroupNode_apply_last_attribute_70(PyObject *self, PyObject *arg) {
  EggGroupNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.apply_last_attribute")) {
    return nullptr;
  }
  // 1-void EggGroupNode::apply_last_attribute(bool recurse)
  ((*local_this).apply_last_attribute)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_last_attribute(const EggGroupNode self, bool recurse)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_apply_last_attribute_70_comment =
  "C++ Interface:\n"
  "apply_last_attribute(const EggGroupNode self, bool recurse)\n"
  "\n"
  "/**\n"
  " * Sets the last vertex of the triangle (or each component) to the primitive\n"
  " * normal and/or color, if the primitive is flat-shaded.  This reflects the\n"
  " * OpenGL convention of storing flat-shaded properties on the last vertex,\n"
  " * although it is not usually a convention in Egg.\n"
  " *\n"
  " * This may create redundant vertices in the vertex pool, so it may be a good\n"
  " * idea to follow this up with remove_unused_vertices().\n"
  " */";
#else
static const char *Dtool_EggGroupNode_apply_last_attribute_70_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::apply_first_attribute(bool recurse)
 */
static PyObject *Dtool_EggGroupNode_apply_first_attribute_71(PyObject *self, PyObject *arg) {
  EggGroupNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.apply_first_attribute")) {
    return nullptr;
  }
  // 1-void EggGroupNode::apply_first_attribute(bool recurse)
  ((*local_this).apply_first_attribute)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_first_attribute(const EggGroupNode self, bool recurse)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_apply_first_attribute_71_comment =
  "C++ Interface:\n"
  "apply_first_attribute(const EggGroupNode self, bool recurse)\n"
  "\n"
  "/**\n"
  " * Sets the first vertex of the triangle (or each component) to the primitive\n"
  " * normal and/or color, if the primitive is flat-shaded.  This reflects the\n"
  " * DirectX convention of storing flat-shaded properties on the first vertex,\n"
  " * although it is not usually a convention in Egg.\n"
  " *\n"
  " * This may create redundant vertices in the vertex pool, so it may be a good\n"
  " * idea to follow this up with remove_unused_vertices().\n"
  " */";
#else
static const char *Dtool_EggGroupNode_apply_first_attribute_71_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroupNode::post_apply_flat_attribute(bool recurse)
 */
static PyObject *Dtool_EggGroupNode_post_apply_flat_attribute_72(PyObject *self, PyObject *arg) {
  EggGroupNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroupNode, (void **)&local_this, "EggGroupNode.post_apply_flat_attribute")) {
    return nullptr;
  }
  // 1-void EggGroupNode::post_apply_flat_attribute(bool recurse)
  ((*local_this).post_apply_flat_attribute)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "post_apply_flat_attribute(const EggGroupNode self, bool recurse)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_post_apply_flat_attribute_72_comment =
  "C++ Interface:\n"
  "post_apply_flat_attribute(const EggGroupNode self, bool recurse)\n"
  "\n"
  "/**\n"
  " * Intended as a followup to apply_last_attribute(), this also sets an\n"
  " * attribute on the first vertices of the primitive, if they don't already\n"
  " * have an attribute set, just so they end up with *something*.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_post_apply_flat_attribute_72_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggGroupNode::has_primitives(void) const
 */
static PyObject *Dtool_EggGroupNode_has_primitives_73(PyObject *self, PyObject *) {
  EggGroupNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroupNode)) {
    return nullptr;
  }
  // 1-virtual bool EggGroupNode::has_primitives(void) const
  bool return_value = ((*(const EggGroupNode*)local_this).has_primitives)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_has_primitives_73_comment =
  "C++ Interface:\n"
  "has_primitives(EggGroupNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if there are any primitives (e.g.  polygons) defined within\n"
  " * this group or below, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_has_primitives_73_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggGroupNode::joint_has_primitives(void) const
 */
static PyObject *Dtool_EggGroupNode_joint_has_primitives_74(PyObject *self, PyObject *) {
  EggGroupNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroupNode)) {
    return nullptr;
  }
  // 1-virtual bool EggGroupNode::joint_has_primitives(void) const
  bool return_value = ((*(const EggGroupNode*)local_this).joint_has_primitives)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_joint_has_primitives_74_comment =
  "C++ Interface:\n"
  "joint_has_primitives(EggGroupNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if there are any primitives (e.g.  polygons) defined within\n"
  " * this group or below, but the search does not include nested joints.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_joint_has_primitives_74_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggGroupNode::has_normals(void) const
 */
static PyObject *Dtool_EggGroupNode_has_normals_75(PyObject *self, PyObject *) {
  EggGroupNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroupNode)) {
    return nullptr;
  }
  // 1-virtual bool EggGroupNode::has_normals(void) const
  bool return_value = ((*(const EggGroupNode*)local_this).has_normals)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_has_normals_75_comment =
  "C++ Interface:\n"
  "has_normals(EggGroupNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if any of the primitives (e.g.  polygons) defined within this\n"
  " * group or below have either face or vertex normals defined, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_has_normals_75_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline bool EggGroupNode::is_right(LVector2d const &v1, LVector2d const &v2)
 */
static PyObject *Dtool_EggGroupNode_is_right_76(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline bool EggGroupNode::is_right(LVector2d const &v1, LVector2d const &v2)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"v1", "v2", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:is_right", (char **)keyword_list, &param0, &param1)) {
    LVector2d param0_local;
    LVector2d const *param0_this = Dtool_Coerce_LVector2d(param0, param0_local);
    if (!(param0_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "EggGroupNode.is_right", "LVector2d");
    }
    LVector2d param1_local;
    LVector2d const *param1_this = Dtool_Coerce_LVector2d(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "EggGroupNode.is_right", "LVector2d");
    }
    bool return_value = (EggGroupNode::is_right)(*param0_this, *param1_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_right(const LVector2d v1, const LVector2d v2)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_is_right_76_comment =
  "C++ Interface:\n"
  "is_right(const LVector2d v1, const LVector2d v2)\n"
  "\n"
  "/**\n"
  " * Returns true if the 2-d v1 is to the right of v2.\n"
  " */";
#else
static const char *Dtool_EggGroupNode_is_right_76_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggGroupNode::get_class_type(void)
 */
static PyObject *Dtool_EggGroupNode_get_class_type_77(PyObject *, PyObject *) {
  // 1-static TypeHandle EggGroupNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggGroupNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroupNode_get_class_type_77_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggGroupNode_get_class_type_77_comment = nullptr;
#endif

static PyObject *Dtool_EggGroupNode_children_Getter(PyObject *self, void *) {
  const EggGroupNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroupNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-PyObject *EggGroupNode::get_children(void) const
  PyObject *return_value = invoke_extension((const EggGroupNode*)local_this).get_children();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * EggGroupNode::EggGroupNode(EggGroupNode const &copy)
 * explicit EggGroupNode::EggGroupNode(std::string const &name = "")
 */
static int Dtool_Init_EggGroupNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-explicit EggGroupNode::EggGroupNode(std::string const &name)
      EggGroupNode *return_value = new EggGroupNode();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggGroupNode, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 EggGroupNode::EggGroupNode(EggGroupNode const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          EggGroupNode const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_EggGroupNode);
          if (param0_this != nullptr) {
            EggGroupNode *return_value = new EggGroupNode(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggGroupNode, true, false);
          }
        }
      }

      {
        // -2 explicit EggGroupNode::EggGroupNode(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:EggGroupNode", (char **)keyword_list, &param0_str, &param0_len)) {
          EggGroupNode *return_value = new EggGroupNode(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggGroupNode, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: EggGroupNode::EggGroupNode(EggGroupNode const &copy)
      // No coercion possible: explicit EggGroupNode::EggGroupNode(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggGroupNode() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggGroupNode()\n"
      "EggGroupNode(const EggGroupNode copy)\n"
      "EggGroupNode(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggGroupNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggGroupNode) {
    printf("EggGroupNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggGroupNode *local_this = (EggGroupNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggGroupNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggGroupNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggGroupNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggGroupNode*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggGroupNode*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggGroupNode*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggGroupNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggGroupNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggGroupNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggGroupNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggAnimData
 */
/**
 * Python function wrapper for:
 * inline void EggAnimData::operator =(EggAnimData const &copy)
 */
static PyObject *Dtool_EggAnimData_operator_114(PyObject *self, PyObject *arg) {
  EggAnimData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAnimData, (void **)&local_this, "EggAnimData.assign")) {
    return nullptr;
  }
  // 1-inline void EggAnimData::operator =(EggAnimData const &copy)
  EggAnimData const *arg_this = (EggAnimData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggAnimData, 1, "EggAnimData.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggAnimData *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggAnimData, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggAnimData self, const EggAnimData copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggAnimData_operator_114_comment =
  "C++ Interface:\n"
  "assign(const EggAnimData self, const EggAnimData copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAnimData_operator_114_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggAnimData::set_fps(double type)
 */
static PyObject *Dtool_EggAnimData_set_fps_115(PyObject *self, PyObject *arg) {
  EggAnimData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAnimData, (void **)&local_this, "EggAnimData.set_fps")) {
    return nullptr;
  }
  // 1-inline void EggAnimData::set_fps(double type)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_fps)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fps(const EggAnimData self, double type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggAnimData_set_fps_115_comment =
  "C++ Interface:\n"
  "set_fps(const EggAnimData self, double type)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAnimData_set_fps_115_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggAnimData::clear_fps(void)
 */
static PyObject *Dtool_EggAnimData_clear_fps_116(PyObject *self, PyObject *) {
  EggAnimData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAnimData, (void **)&local_this, "EggAnimData.clear_fps")) {
    return nullptr;
  }
  // 1-inline void EggAnimData::clear_fps(void)
  ((*local_this).clear_fps)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggAnimData_clear_fps_116_comment =
  "C++ Interface:\n"
  "clear_fps(const EggAnimData self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAnimData_clear_fps_116_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggAnimData::has_fps(void) const
 */
static PyObject *Dtool_EggAnimData_has_fps_117(PyObject *self, PyObject *) {
  EggAnimData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggAnimData)) {
    return nullptr;
  }
  // 1-inline bool EggAnimData::has_fps(void) const
  bool return_value = ((*(const EggAnimData*)local_this).has_fps)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggAnimData_has_fps_117_comment =
  "C++ Interface:\n"
  "has_fps(EggAnimData self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAnimData_has_fps_117_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double EggAnimData::get_fps(void) const
 */
static PyObject *Dtool_EggAnimData_get_fps_118(PyObject *self, PyObject *) {
  EggAnimData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggAnimData)) {
    return nullptr;
  }
  // 1-inline double EggAnimData::get_fps(void) const
  double return_value = ((*(const EggAnimData*)local_this).get_fps)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggAnimData_get_fps_118_comment =
  "C++ Interface:\n"
  "get_fps(EggAnimData self)\n"
  "\n"
  "/**\n"
  " * This is only valid if has_fps() returns true.\n"
  " */";
#else
static const char *Dtool_EggAnimData_get_fps_118_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggAnimData::clear_data(void)
 */
static PyObject *Dtool_EggAnimData_clear_data_119(PyObject *self, PyObject *) {
  EggAnimData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAnimData, (void **)&local_this, "EggAnimData.clear_data")) {
    return nullptr;
  }
  // 1-inline void EggAnimData::clear_data(void)
  ((*local_this).clear_data)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggAnimData_clear_data_119_comment =
  "C++ Interface:\n"
  "clear_data(const EggAnimData self)\n"
  "\n"
  "/**\n"
  " * Removes all data and empties the table.\n"
  " */";
#else
static const char *Dtool_EggAnimData_clear_data_119_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggAnimData::add_data(double value)
 */
static PyObject *Dtool_EggAnimData_add_data_120(PyObject *self, PyObject *arg) {
  EggAnimData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAnimData, (void **)&local_this, "EggAnimData.add_data")) {
    return nullptr;
  }
  // 1-inline void EggAnimData::add_data(double value)
  if (PyNumber_Check(arg)) {
    ((*local_this).add_data)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_data(const EggAnimData self, double value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggAnimData_add_data_120_comment =
  "C++ Interface:\n"
  "add_data(const EggAnimData self, double value)\n"
  "\n"
  "/**\n"
  " * Adds a single element to the table.\n"
  " */";
#else
static const char *Dtool_EggAnimData_add_data_120_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggAnimData::get_size(void) const
 */
static PyObject *Dtool_EggAnimData_get_size_121(PyObject *self, PyObject *) {
  EggAnimData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggAnimData)) {
    return nullptr;
  }
  // 1-inline int EggAnimData::get_size(void) const
  int return_value = ((*(const EggAnimData*)local_this).get_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggAnimData_get_size_121_comment =
  "C++ Interface:\n"
  "get_size(EggAnimData self)\n"
  "\n"
  "/**\n"
  " * Returns the number of elements in the table.\n"
  " */";
#else
static const char *Dtool_EggAnimData_get_size_121_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggAnimData::quantize(double quantum)
 */
static PyObject *Dtool_EggAnimData_quantize_122(PyObject *self, PyObject *arg) {
  EggAnimData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAnimData, (void **)&local_this, "EggAnimData.quantize")) {
    return nullptr;
  }
  // 1-void EggAnimData::quantize(double quantum)
  if (PyNumber_Check(arg)) {
    ((*local_this).quantize)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "quantize(const EggAnimData self, double quantum)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggAnimData_quantize_122_comment =
  "C++ Interface:\n"
  "quantize(const EggAnimData self, double quantum)\n"
  "\n"
  "/**\n"
  " * Rounds each element of the table to the nearest multiple of quantum.\n"
  " */";
#else
static const char *Dtool_EggAnimData_quantize_122_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggAnimData::get_class_type(void)
 */
static PyObject *Dtool_EggAnimData_get_class_type_123(PyObject *, PyObject *) {
  // 1-static TypeHandle EggAnimData::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggAnimData::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggAnimData_get_class_type_123_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggAnimData_get_class_type_123_comment = nullptr;
#endif

static int Dtool_Init_EggAnimData(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_EggAnimData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggAnimData) {
    printf("EggAnimData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggAnimData *local_this = (EggAnimData *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggAnimData) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggAnimData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggAnimData) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggAnimData*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggAnimPreload
 */
/**
 * Python function wrapper for:
 * inline void EggAnimPreload::operator =(EggAnimPreload const &copy)
 */
static PyObject *Dtool_EggAnimPreload_operator_127(PyObject *self, PyObject *arg) {
  EggAnimPreload *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAnimPreload, (void **)&local_this, "EggAnimPreload.assign")) {
    return nullptr;
  }
  // 1-inline void EggAnimPreload::operator =(EggAnimPreload const &copy)
  EggAnimPreload const *arg_this = (EggAnimPreload *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggAnimPreload, 1, "EggAnimPreload.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggAnimPreload *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggAnimPreload, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggAnimPreload self, const EggAnimPreload copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggAnimPreload_operator_127_comment =
  "C++ Interface:\n"
  "assign(const EggAnimPreload self, const EggAnimPreload copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAnimPreload_operator_127_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggAnimPreload::set_fps(double fps)
 */
static PyObject *Dtool_EggAnimPreload_set_fps_128(PyObject *self, PyObject *arg) {
  EggAnimPreload *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAnimPreload, (void **)&local_this, "EggAnimPreload.set_fps")) {
    return nullptr;
  }
  // 1-inline void EggAnimPreload::set_fps(double fps)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_fps)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fps(const EggAnimPreload self, double fps)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggAnimPreload_set_fps_128_comment =
  "C++ Interface:\n"
  "set_fps(const EggAnimPreload self, double fps)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAnimPreload_set_fps_128_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggAnimPreload::clear_fps(void)
 */
static PyObject *Dtool_EggAnimPreload_clear_fps_129(PyObject *self, PyObject *) {
  EggAnimPreload *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAnimPreload, (void **)&local_this, "EggAnimPreload.clear_fps")) {
    return nullptr;
  }
  // 1-inline void EggAnimPreload::clear_fps(void)
  ((*local_this).clear_fps)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggAnimPreload_clear_fps_129_comment =
  "C++ Interface:\n"
  "clear_fps(const EggAnimPreload self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAnimPreload_clear_fps_129_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggAnimPreload::has_fps(void) const
 */
static PyObject *Dtool_EggAnimPreload_has_fps_130(PyObject *self, PyObject *) {
  EggAnimPreload *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggAnimPreload)) {
    return nullptr;
  }
  // 1-inline bool EggAnimPreload::has_fps(void) const
  bool return_value = ((*(const EggAnimPreload*)local_this).has_fps)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggAnimPreload_has_fps_130_comment =
  "C++ Interface:\n"
  "has_fps(EggAnimPreload self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAnimPreload_has_fps_130_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double EggAnimPreload::get_fps(void) const
 */
static PyObject *Dtool_EggAnimPreload_get_fps_131(PyObject *self, PyObject *) {
  EggAnimPreload *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggAnimPreload)) {
    return nullptr;
  }
  // 1-inline double EggAnimPreload::get_fps(void) const
  double return_value = ((*(const EggAnimPreload*)local_this).get_fps)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggAnimPreload_get_fps_131_comment =
  "C++ Interface:\n"
  "get_fps(EggAnimPreload self)\n"
  "\n"
  "/**\n"
  " * This is only valid if has_fps() returns true.\n"
  " */";
#else
static const char *Dtool_EggAnimPreload_get_fps_131_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggAnimPreload::set_num_frames(int num_frames)
 */
static PyObject *Dtool_EggAnimPreload_set_num_frames_132(PyObject *self, PyObject *arg) {
  EggAnimPreload *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAnimPreload, (void **)&local_this, "EggAnimPreload.set_num_frames")) {
    return nullptr;
  }
  // 1-inline void EggAnimPreload::set_num_frames(int num_frames)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_num_frames)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_frames(const EggAnimPreload self, int num_frames)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggAnimPreload_set_num_frames_132_comment =
  "C++ Interface:\n"
  "set_num_frames(const EggAnimPreload self, int num_frames)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAnimPreload_set_num_frames_132_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggAnimPreload::clear_num_frames(void)
 */
static PyObject *Dtool_EggAnimPreload_clear_num_frames_133(PyObject *self, PyObject *) {
  EggAnimPreload *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAnimPreload, (void **)&local_this, "EggAnimPreload.clear_num_frames")) {
    return nullptr;
  }
  // 1-inline void EggAnimPreload::clear_num_frames(void)
  ((*local_this).clear_num_frames)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggAnimPreload_clear_num_frames_133_comment =
  "C++ Interface:\n"
  "clear_num_frames(const EggAnimPreload self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAnimPreload_clear_num_frames_133_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggAnimPreload::has_num_frames(void) const
 */
static PyObject *Dtool_EggAnimPreload_has_num_frames_134(PyObject *self, PyObject *) {
  EggAnimPreload *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggAnimPreload)) {
    return nullptr;
  }
  // 1-inline bool EggAnimPreload::has_num_frames(void) const
  bool return_value = ((*(const EggAnimPreload*)local_this).has_num_frames)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggAnimPreload_has_num_frames_134_comment =
  "C++ Interface:\n"
  "has_num_frames(EggAnimPreload self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAnimPreload_has_num_frames_134_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggAnimPreload::get_num_frames(void) const
 */
static PyObject *Dtool_EggAnimPreload_get_num_frames_135(PyObject *self, PyObject *) {
  EggAnimPreload *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggAnimPreload)) {
    return nullptr;
  }
  // 1-inline int EggAnimPreload::get_num_frames(void) const
  int return_value = ((*(const EggAnimPreload*)local_this).get_num_frames)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggAnimPreload_get_num_frames_135_comment =
  "C++ Interface:\n"
  "get_num_frames(EggAnimPreload self)\n"
  "\n"
  "/**\n"
  " * This is only valid if has_num_frames() returns true.\n"
  " */";
#else
static const char *Dtool_EggAnimPreload_get_num_frames_135_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggAnimPreload::get_class_type(void)
 */
static PyObject *Dtool_EggAnimPreload_get_class_type_136(PyObject *, PyObject *) {
  // 1-static TypeHandle EggAnimPreload::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggAnimPreload::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggAnimPreload_get_class_type_136_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggAnimPreload_get_class_type_136_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggAnimPreload::EggAnimPreload(EggAnimPreload const &copy)
 * inline explicit EggAnimPreload::EggAnimPreload(std::string const &name = "")
 */
static int Dtool_Init_EggAnimPreload(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline explicit EggAnimPreload::EggAnimPreload(std::string const &name)
      EggAnimPreload *return_value = new EggAnimPreload();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggAnimPreload, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline EggAnimPreload::EggAnimPreload(EggAnimPreload const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          EggAnimPreload const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_EggAnimPreload);
          if (param0_this != nullptr) {
            EggAnimPreload *return_value = new EggAnimPreload(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggAnimPreload, true, false);
          }
        }
      }

      {
        // -2 inline explicit EggAnimPreload::EggAnimPreload(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:EggAnimPreload", (char **)keyword_list, &param0_str, &param0_len)) {
          EggAnimPreload *return_value = new EggAnimPreload(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggAnimPreload, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline EggAnimPreload::EggAnimPreload(EggAnimPreload const &copy)
      // No coercion possible: inline explicit EggAnimPreload::EggAnimPreload(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggAnimPreload() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggAnimPreload()\n"
      "EggAnimPreload(const EggAnimPreload copy)\n"
      "EggAnimPreload(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggAnimPreload(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggAnimPreload) {
    printf("EggAnimPreload ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggAnimPreload *local_this = (EggAnimPreload *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggAnimPreload) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggAnimPreload(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggAnimPreload) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggAnimPreload*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggAnimPreload*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggAnimPreload*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggAnimPreload*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggAnimPreload*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggAnimPreload*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggAnimPreload*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggAttributes
 */
/**
 * Python function wrapper for:
 * void EggAttributes::operator =(EggAttributes const &copy)
 */
static PyObject *Dtool_EggAttributes_operator_143(PyObject *self, PyObject *arg) {
  EggAttributes *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAttributes, (void **)&local_this, "EggAttributes.assign")) {
    return nullptr;
  }
  // 1-void EggAttributes::operator =(EggAttributes const &copy)
  EggAttributes const *arg_this = (EggAttributes *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggAttributes, 1, "EggAttributes.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggAttributes *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggAttributes, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggAttributes self, const EggAttributes copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_operator_143_comment =
  "C++ Interface:\n"
  "assign(const EggAttributes self, const EggAttributes copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAttributes_operator_143_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggAttributes::has_normal(void) const
 */
static PyObject *Dtool_EggAttributes_has_normal_145(PyObject *self, PyObject *) {
  EggAttributes *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggAttributes)) {
    return nullptr;
  }
  // 1-inline bool EggAttributes::has_normal(void) const
  bool return_value = ((*(const EggAttributes*)local_this).has_normal)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_has_normal_145_comment =
  "C++ Interface:\n"
  "has_normal(EggAttributes self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAttributes_has_normal_145_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LNormald const &EggAttributes::get_normal(void) const
 */
static PyObject *Dtool_EggAttributes_get_normal_146(PyObject *self, PyObject *) {
  EggAttributes *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggAttributes)) {
    return nullptr;
  }
  // 1-inline LNormald const &EggAttributes::get_normal(void) const
  LNormald const *return_value = &(((*(const EggAttributes*)local_this).get_normal)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_get_normal_146_comment =
  "C++ Interface:\n"
  "get_normal(EggAttributes self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAttributes_get_normal_146_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggAttributes::set_normal(LNormald const &normal)
 */
static PyObject *Dtool_EggAttributes_set_normal_147(PyObject *self, PyObject *arg) {
  EggAttributes *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAttributes, (void **)&local_this, "EggAttributes.set_normal")) {
    return nullptr;
  }
  // 1-inline void EggAttributes::set_normal(LNormald const &normal)
  LVector3d arg_local;
  LNormald const *arg_this = Dtool_Coerce_LVector3d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggAttributes.set_normal", "LVector3d");
  }
  ((*local_this).set_normal)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_normal(const EggAttributes self, const LVector3d normal)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_set_normal_147_comment =
  "C++ Interface:\n"
  "set_normal(const EggAttributes self, const LVector3d normal)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAttributes_set_normal_147_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggAttributes::clear_normal(void)
 */
static PyObject *Dtool_EggAttributes_clear_normal_148(PyObject *self, PyObject *) {
  EggAttributes *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAttributes, (void **)&local_this, "EggAttributes.clear_normal")) {
    return nullptr;
  }
  // 1-inline void EggAttributes::clear_normal(void)
  ((*local_this).clear_normal)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_clear_normal_148_comment =
  "C++ Interface:\n"
  "clear_normal(const EggAttributes self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAttributes_clear_normal_148_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggAttributes::matches_normal(EggAttributes const &other) const
 */
static PyObject *Dtool_EggAttributes_matches_normal_149(PyObject *self, PyObject *arg) {
  EggAttributes *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggAttributes)) {
    return nullptr;
  }
  // 1-inline bool EggAttributes::matches_normal(EggAttributes const &other) const
  EggAttributes const *arg_this = (EggAttributes *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggAttributes, 1, "EggAttributes.matches_normal", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const EggAttributes*)local_this).matches_normal)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "matches_normal(EggAttributes self, const EggAttributes other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_matches_normal_149_comment =
  "C++ Interface:\n"
  "matches_normal(EggAttributes self, const EggAttributes other)\n"
  "\n"
  "/**\n"
  " * Returns true if this normal matches that of the other EggAttributes object,\n"
  " * include the morph list.\n"
  " */";
#else
static const char *Dtool_EggAttributes_matches_normal_149_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggAttributes::copy_normal(EggAttributes const &other)
 */
static PyObject *Dtool_EggAttributes_copy_normal_150(PyObject *self, PyObject *arg) {
  EggAttributes *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAttributes, (void **)&local_this, "EggAttributes.copy_normal")) {
    return nullptr;
  }
  // 1-inline void EggAttributes::copy_normal(EggAttributes const &other)
  EggAttributes const *arg_this = (EggAttributes *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggAttributes, 1, "EggAttributes.copy_normal", true, true);
  if (arg_this != nullptr) {
    ((*local_this).copy_normal)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_normal(const EggAttributes self, const EggAttributes other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_copy_normal_150_comment =
  "C++ Interface:\n"
  "copy_normal(const EggAttributes self, const EggAttributes other)\n"
  "\n"
  "/**\n"
  " * Sets this normal to be the same as the other's, include morphs.  If the\n"
  " * other has no normal, this clears the normal.\n"
  " */";
#else
static const char *Dtool_EggAttributes_copy_normal_150_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggAttributes::has_color(void) const
 */
static PyObject *Dtool_EggAttributes_has_color_151(PyObject *self, PyObject *) {
  EggAttributes *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggAttributes)) {
    return nullptr;
  }
  // 1-inline bool EggAttributes::has_color(void) const
  bool return_value = ((*(const EggAttributes*)local_this).has_color)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_has_color_151_comment =
  "C++ Interface:\n"
  "has_color(EggAttributes self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAttributes_has_color_151_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor EggAttributes::get_color(void) const
 */
static PyObject *Dtool_EggAttributes_get_color_152(PyObject *self, PyObject *) {
  EggAttributes *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggAttributes)) {
    return nullptr;
  }
  // 1-inline LColor EggAttributes::get_color(void) const
  LColor *return_value = new LColor(((*(const EggAttributes*)local_this).get_color)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_get_color_152_comment =
  "C++ Interface:\n"
  "get_color(EggAttributes self)\n"
  "\n"
  "/**\n"
  " * Returns the color set on this particular attribute.  If there is no color\n"
  " * set, returns white.\n"
  " */";
#else
static const char *Dtool_EggAttributes_get_color_152_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggAttributes::set_color(LColor const &Color)
 */
static PyObject *Dtool_EggAttributes_set_color_153(PyObject *self, PyObject *arg) {
  EggAttributes *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAttributes, (void **)&local_this, "EggAttributes.set_color")) {
    return nullptr;
  }
  // 1-inline void EggAttributes::set_color(LColor const &Color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggAttributes.set_color", "LVecBase4f");
  }
  ((*local_this).set_color)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color(const EggAttributes self, const LVecBase4f Color)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_set_color_153_comment =
  "C++ Interface:\n"
  "set_color(const EggAttributes self, const LVecBase4f Color)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAttributes_set_color_153_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggAttributes::clear_color(void)
 */
static PyObject *Dtool_EggAttributes_clear_color_154(PyObject *self, PyObject *) {
  EggAttributes *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAttributes, (void **)&local_this, "EggAttributes.clear_color")) {
    return nullptr;
  }
  // 1-inline void EggAttributes::clear_color(void)
  ((*local_this).clear_color)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_clear_color_154_comment =
  "C++ Interface:\n"
  "clear_color(const EggAttributes self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggAttributes_clear_color_154_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggAttributes::matches_color(EggAttributes const &other) const
 */
static PyObject *Dtool_EggAttributes_matches_color_155(PyObject *self, PyObject *arg) {
  EggAttributes *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggAttributes)) {
    return nullptr;
  }
  // 1-inline bool EggAttributes::matches_color(EggAttributes const &other) const
  EggAttributes const *arg_this = (EggAttributes *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggAttributes, 1, "EggAttributes.matches_color", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const EggAttributes*)local_this).matches_color)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "matches_color(EggAttributes self, const EggAttributes other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_matches_color_155_comment =
  "C++ Interface:\n"
  "matches_color(EggAttributes self, const EggAttributes other)\n"
  "\n"
  "/**\n"
  " * Returns true if this color matches that of the other EggAttributes object,\n"
  " * include the morph list.\n"
  " */";
#else
static const char *Dtool_EggAttributes_matches_color_155_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggAttributes::copy_color(EggAttributes const &other)
 */
static PyObject *Dtool_EggAttributes_copy_color_156(PyObject *self, PyObject *arg) {
  EggAttributes *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAttributes, (void **)&local_this, "EggAttributes.copy_color")) {
    return nullptr;
  }
  // 1-inline void EggAttributes::copy_color(EggAttributes const &other)
  EggAttributes const *arg_this = (EggAttributes *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggAttributes, 1, "EggAttributes.copy_color", true, true);
  if (arg_this != nullptr) {
    ((*local_this).copy_color)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_color(const EggAttributes self, const EggAttributes other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_copy_color_156_comment =
  "C++ Interface:\n"
  "copy_color(const EggAttributes self, const EggAttributes other)\n"
  "\n"
  "/**\n"
  " * Sets this color to be the same as the other's, include morphs.  If the\n"
  " * other has no color, this clears the color.\n"
  " */";
#else
static const char *Dtool_EggAttributes_copy_color_156_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggAttributes::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_EggAttributes_write_157(PyObject *self, PyObject *args, PyObject *kwds) {
  EggAttributes *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggAttributes)) {
    return nullptr;
  }
  // 1-void EggAttributes::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "EggAttributes.write", false, true);
    if (param1_this != nullptr) {
      ((*(const EggAttributes*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(EggAttributes self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_write_157_comment =
  "C++ Interface:\n"
  "write(EggAttributes self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes the attributes to the indicated output stream in Egg format.\n"
  " */";
#else
static const char *Dtool_EggAttributes_write_157_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggAttributes::sorts_less_than(EggAttributes const &other) const
 */
static PyObject *Dtool_EggAttributes_sorts_less_than_158(PyObject *self, PyObject *arg) {
  EggAttributes *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggAttributes)) {
    return nullptr;
  }
  // 1-inline bool EggAttributes::sorts_less_than(EggAttributes const &other) const
  EggAttributes const *arg_this = (EggAttributes *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggAttributes, 1, "EggAttributes.sorts_less_than", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const EggAttributes*)local_this).sorts_less_than)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "sorts_less_than(EggAttributes self, const EggAttributes other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_sorts_less_than_158_comment =
  "C++ Interface:\n"
  "sorts_less_than(EggAttributes self, const EggAttributes other)\n"
  "\n"
  "/**\n"
  " * An ordering operator to compare two vertices for sorting order.  This\n"
  " * imposes an arbitrary ordering useful to identify unique vertices.\n"
  " */";
#else
static const char *Dtool_EggAttributes_sorts_less_than_158_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int EggAttributes::compare_to(EggAttributes const &other) const
 */
static PyObject *Dtool_EggAttributes_compare_to_159(PyObject *self, PyObject *arg) {
  EggAttributes *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggAttributes)) {
    return nullptr;
  }
  // 1-int EggAttributes::compare_to(EggAttributes const &other) const
  EggAttributes const *arg_this = (EggAttributes *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggAttributes, 1, "EggAttributes.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const EggAttributes*)local_this).compare_to)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(EggAttributes self, const EggAttributes other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_compare_to_159_comment =
  "C++ Interface:\n"
  "compare_to(EggAttributes self, const EggAttributes other)\n"
  "\n"
  "/**\n"
  " * An ordering operator to compare two vertices for sorting order.  This\n"
  " * imposes an arbitrary ordering useful to identify unique vertices.\n"
  " */";
#else
static const char *Dtool_EggAttributes_compare_to_159_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggAttributes::transform(LMatrix4d const &mat)
 */
static PyObject *Dtool_EggAttributes_transform_160(PyObject *self, PyObject *arg) {
  EggAttributes *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggAttributes, (void **)&local_this, "EggAttributes.transform")) {
    return nullptr;
  }
  // 1-void EggAttributes::transform(LMatrix4d const &mat)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggAttributes.transform", "LMatrix4d");
  }
  ((*local_this).transform)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "transform(const EggAttributes self, const LMatrix4d mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_transform_160_comment =
  "C++ Interface:\n"
  "transform(const EggAttributes self, const LMatrix4d mat)\n"
  "\n"
  "/**\n"
  " * Applies the indicated transformation matrix to the attributes.\n"
  " */";
#else
static const char *Dtool_EggAttributes_transform_160_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggAttributes::get_class_type(void)
 */
static PyObject *Dtool_EggAttributes_get_class_type_169(PyObject *, PyObject *) {
  // 1-static TypeHandle EggAttributes::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggAttributes::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggAttributes_get_class_type_169_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggAttributes_get_class_type_169_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggAttributes::EggAttributes(void)
 * EggAttributes::EggAttributes(EggAttributes const &copy)
 */
static int Dtool_Init_EggAttributes(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-EggAttributes::EggAttributes(void)
      EggAttributes *return_value = new EggAttributes();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggAttributes, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-EggAttributes::EggAttributes(EggAttributes const &copy)
        EggAttributes const *arg_this = (EggAttributes *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggAttributes, 0, "EggAttributes.EggAttributes", true, true);
        if (arg_this != nullptr) {
          EggAttributes *return_value = new EggAttributes(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggAttributes, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggAttributes() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggAttributes()\n"
      "EggAttributes(const EggAttributes copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggAttributes(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggAttributes) {
    printf("EggAttributes ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggAttributes *local_this = (EggAttributes *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggAttributes) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggAttributes(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggAttributes) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggVertexUV
 */
/**
 * Python function wrapper for:
 * void EggVertexUV::operator =(EggVertexUV const &copy)
 */
static PyObject *Dtool_EggVertexUV_operator_172(PyObject *self, PyObject *arg) {
  EggVertexUV *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexUV, (void **)&local_this, "EggVertexUV.assign")) {
    return nullptr;
  }
  // 1-void EggVertexUV::operator =(EggVertexUV const &copy)
  EggVertexUV const *arg_this = (EggVertexUV *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertexUV, 1, "EggVertexUV.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggVertexUV *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertexUV, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggVertexUV self, const EggVertexUV copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_operator_172_comment =
  "C++ Interface:\n"
  "assign(const EggVertexUV self, const EggVertexUV copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertexUV_operator_172_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline std::string EggVertexUV::filter_name(std::string const &name)
 */
static PyObject *Dtool_EggVertexUV_filter_name_173(PyObject *, PyObject *arg) {
  // 1-static inline std::string EggVertexUV::filter_name(std::string const &name)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    std::string return_value = (EggVertexUV::filter_name)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "filter_name(str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_filter_name_173_comment =
  "C++ Interface:\n"
  "filter_name(str name)\n"
  "\n"
  "/**\n"
  " * Returns the actual name that should be set for a given name string.\n"
  " * Usually this is the same string that is input, but for historical reasons\n"
  " * the texture coordinate name \"default\" is mapped to the empty string.\n"
  " */";
#else
static const char *Dtool_EggVertexUV_filter_name_173_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertexUV::set_name(std::string const &name)
 */
static PyObject *Dtool_EggVertexUV_set_name_174(PyObject *self, PyObject *arg) {
  EggVertexUV *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexUV, (void **)&local_this, "EggVertexUV.set_name")) {
    return nullptr;
  }
  // 1-inline void EggVertexUV::set_name(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_name)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_name(const EggVertexUV self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_set_name_174_comment =
  "C++ Interface:\n"
  "set_name(const EggVertexUV self, str name)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertexUV_set_name_174_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggVertexUV::get_num_dimensions(void) const
 */
static PyObject *Dtool_EggVertexUV_get_num_dimensions_175(PyObject *self, PyObject *) {
  EggVertexUV *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertexUV)) {
    return nullptr;
  }
  // 1-inline int EggVertexUV::get_num_dimensions(void) const
  int return_value = ((*(const EggVertexUV*)local_this).get_num_dimensions)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_get_num_dimensions_175_comment =
  "C++ Interface:\n"
  "get_num_dimensions(EggVertexUV self)\n"
  "\n"
  "/**\n"
  " * Returns the number of components of the texture coordinate set.  This is\n"
  " * either 2 (the normal case) or 3 (for a 3-d texture coordinate).\n"
  " */";
#else
static const char *Dtool_EggVertexUV_get_num_dimensions_175_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggVertexUV::has_w(void) const
 */
static PyObject *Dtool_EggVertexUV_has_w_176(PyObject *self, PyObject *) {
  EggVertexUV *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertexUV)) {
    return nullptr;
  }
  // 1-inline bool EggVertexUV::has_w(void) const
  bool return_value = ((*(const EggVertexUV*)local_this).has_w)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_has_w_176_comment =
  "C++ Interface:\n"
  "has_w(EggVertexUV self)\n"
  "\n"
  "/**\n"
  " * Returns true if the texture coordinate has a third, w component, false if\n"
  " * it is just a normal 2-d texture coordinate.\n"
  " */";
#else
static const char *Dtool_EggVertexUV_has_w_176_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LTexCoordd EggVertexUV::get_uv(void) const
 */
static PyObject *Dtool_EggVertexUV_get_uv_177(PyObject *self, PyObject *) {
  EggVertexUV *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertexUV)) {
    return nullptr;
  }
  // 1-inline LTexCoordd EggVertexUV::get_uv(void) const
  LTexCoordd *return_value = new LTexCoordd(((*(const EggVertexUV*)local_this).get_uv)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_get_uv_177_comment =
  "C++ Interface:\n"
  "get_uv(EggVertexUV self)\n"
  "\n"
  "/**\n"
  " * Returns the texture coordinate pair, if get_num_dimensions() is 2.\n"
  " */";
#else
static const char *Dtool_EggVertexUV_get_uv_177_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LTexCoord3d const &EggVertexUV::get_uvw(void) const
 */
static PyObject *Dtool_EggVertexUV_get_uvw_178(PyObject *self, PyObject *) {
  EggVertexUV *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertexUV)) {
    return nullptr;
  }
  // 1-inline LTexCoord3d const &EggVertexUV::get_uvw(void) const
  LTexCoord3d const *return_value = &(((*(const EggVertexUV*)local_this).get_uvw)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_get_uvw_178_comment =
  "C++ Interface:\n"
  "get_uvw(EggVertexUV self)\n"
  "\n"
  "/**\n"
  " * Returns the texture coordinate triple, if get_num_dimensions() is 3.  This\n"
  " * is also legal to call if get_num_dimensions() is 2 (but the last dimension\n"
  " * will be zero).\n"
  " */";
#else
static const char *Dtool_EggVertexUV_get_uvw_178_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertexUV::set_uv(LTexCoordd const &texCoord)
 */
static PyObject *Dtool_EggVertexUV_set_uv_179(PyObject *self, PyObject *arg) {
  EggVertexUV *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexUV, (void **)&local_this, "EggVertexUV.set_uv")) {
    return nullptr;
  }
  // 1-inline void EggVertexUV::set_uv(LTexCoordd const &texCoord)
  LPoint2d arg_local;
  LTexCoordd const *arg_this = Dtool_Coerce_LPoint2d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggVertexUV.set_uv", "LPoint2d");
  }
  ((*local_this).set_uv)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_uv(const EggVertexUV self, const LPoint2d texCoord)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_set_uv_179_comment =
  "C++ Interface:\n"
  "set_uv(const EggVertexUV self, const LPoint2d texCoord)\n"
  "\n"
  "/**\n"
  " * Sets the texture coordinate pair.  This makes the texture coordinate a 2-d\n"
  " * texture coordinate, which is the usual case.\n"
  " */";
#else
static const char *Dtool_EggVertexUV_set_uv_179_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertexUV::set_uvw(LTexCoord3d const &texCoord)
 */
static PyObject *Dtool_EggVertexUV_set_uvw_180(PyObject *self, PyObject *arg) {
  EggVertexUV *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexUV, (void **)&local_this, "EggVertexUV.set_uvw")) {
    return nullptr;
  }
  // 1-inline void EggVertexUV::set_uvw(LTexCoord3d const &texCoord)
  LPoint3d arg_local;
  LTexCoord3d const *arg_this = Dtool_Coerce_LPoint3d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggVertexUV.set_uvw", "LPoint3d");
  }
  ((*local_this).set_uvw)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_uvw(const EggVertexUV self, const LPoint3d texCoord)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_set_uvw_180_comment =
  "C++ Interface:\n"
  "set_uvw(const EggVertexUV self, const LPoint3d texCoord)\n"
  "\n"
  "/**\n"
  " * Sets the texture coordinate triple.  This makes the texture coordinate a\n"
  " * 3-d texture coordinate.\n"
  " */";
#else
static const char *Dtool_EggVertexUV_set_uvw_180_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggVertexUV::has_tangent(void) const
 */
static PyObject *Dtool_EggVertexUV_has_tangent_181(PyObject *self, PyObject *) {
  EggVertexUV *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertexUV)) {
    return nullptr;
  }
  // 1-inline bool EggVertexUV::has_tangent(void) const
  bool return_value = ((*(const EggVertexUV*)local_this).has_tangent)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_has_tangent_181_comment =
  "C++ Interface:\n"
  "has_tangent(EggVertexUV self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertexUV_has_tangent_181_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggVertexUV::has_tangent4(void) const
 */
static PyObject *Dtool_EggVertexUV_has_tangent4_182(PyObject *self, PyObject *) {
  EggVertexUV *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertexUV)) {
    return nullptr;
  }
  // 1-inline bool EggVertexUV::has_tangent4(void) const
  bool return_value = ((*(const EggVertexUV*)local_this).has_tangent4)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_has_tangent4_182_comment =
  "C++ Interface:\n"
  "has_tangent4(EggVertexUV self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertexUV_has_tangent4_182_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LNormald const &EggVertexUV::get_tangent(void) const
 */
static PyObject *Dtool_EggVertexUV_get_tangent_183(PyObject *self, PyObject *) {
  EggVertexUV *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertexUV)) {
    return nullptr;
  }
  // 1-inline LNormald const &EggVertexUV::get_tangent(void) const
  LNormald const *return_value = &(((*(const EggVertexUV*)local_this).get_tangent)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_get_tangent_183_comment =
  "C++ Interface:\n"
  "get_tangent(EggVertexUV self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertexUV_get_tangent_183_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4d EggVertexUV::get_tangent4(void) const
 */
static PyObject *Dtool_EggVertexUV_get_tangent4_184(PyObject *self, PyObject *) {
  EggVertexUV *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertexUV)) {
    return nullptr;
  }
  // 1-inline LVecBase4d EggVertexUV::get_tangent4(void) const
  LVecBase4d *return_value = new LVecBase4d(((*(const EggVertexUV*)local_this).get_tangent4)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_get_tangent4_184_comment =
  "C++ Interface:\n"
  "get_tangent4(EggVertexUV self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertexUV_get_tangent4_184_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertexUV::set_tangent(LNormald const &tangent)
 */
static PyObject *Dtool_EggVertexUV_set_tangent_185(PyObject *self, PyObject *arg) {
  EggVertexUV *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexUV, (void **)&local_this, "EggVertexUV.set_tangent")) {
    return nullptr;
  }
  // 1-inline void EggVertexUV::set_tangent(LNormald const &tangent)
  LVector3d arg_local;
  LNormald const *arg_this = Dtool_Coerce_LVector3d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggVertexUV.set_tangent", "LVector3d");
  }
  ((*local_this).set_tangent)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tangent(const EggVertexUV self, const LVector3d tangent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_set_tangent_185_comment =
  "C++ Interface:\n"
  "set_tangent(const EggVertexUV self, const LVector3d tangent)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertexUV_set_tangent_185_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertexUV::set_tangent4(LVecBase4d const &tangent)
 */
static PyObject *Dtool_EggVertexUV_set_tangent4_186(PyObject *self, PyObject *arg) {
  EggVertexUV *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexUV, (void **)&local_this, "EggVertexUV.set_tangent4")) {
    return nullptr;
  }
  // 1-inline void EggVertexUV::set_tangent4(LVecBase4d const &tangent)
  LVecBase4d arg_local;
  LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggVertexUV.set_tangent4", "LVecBase4d");
  }
  ((*local_this).set_tangent4)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tangent4(const EggVertexUV self, const LVecBase4d tangent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_set_tangent4_186_comment =
  "C++ Interface:\n"
  "set_tangent4(const EggVertexUV self, const LVecBase4d tangent)\n"
  "\n"
  "/**\n"
  " * Sets the tangent vector, along with a fourth parameter that is multiplied\n"
  " * with the result of cross(normal, tangent) when computing the binormal.\n"
  " */";
#else
static const char *Dtool_EggVertexUV_set_tangent4_186_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertexUV::clear_tangent(void)
 */
static PyObject *Dtool_EggVertexUV_clear_tangent_187(PyObject *self, PyObject *) {
  EggVertexUV *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexUV, (void **)&local_this, "EggVertexUV.clear_tangent")) {
    return nullptr;
  }
  // 1-inline void EggVertexUV::clear_tangent(void)
  ((*local_this).clear_tangent)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_clear_tangent_187_comment =
  "C++ Interface:\n"
  "clear_tangent(const EggVertexUV self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertexUV_clear_tangent_187_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggVertexUV::has_binormal(void) const
 */
static PyObject *Dtool_EggVertexUV_has_binormal_188(PyObject *self, PyObject *) {
  EggVertexUV *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertexUV)) {
    return nullptr;
  }
  // 1-inline bool EggVertexUV::has_binormal(void) const
  bool return_value = ((*(const EggVertexUV*)local_this).has_binormal)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_has_binormal_188_comment =
  "C++ Interface:\n"
  "has_binormal(EggVertexUV self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertexUV_has_binormal_188_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LNormald const &EggVertexUV::get_binormal(void) const
 */
static PyObject *Dtool_EggVertexUV_get_binormal_189(PyObject *self, PyObject *) {
  EggVertexUV *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertexUV)) {
    return nullptr;
  }
  // 1-inline LNormald const &EggVertexUV::get_binormal(void) const
  LNormald const *return_value = &(((*(const EggVertexUV*)local_this).get_binormal)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_get_binormal_189_comment =
  "C++ Interface:\n"
  "get_binormal(EggVertexUV self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertexUV_get_binormal_189_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertexUV::set_binormal(LNormald const &binormal)
 */
static PyObject *Dtool_EggVertexUV_set_binormal_190(PyObject *self, PyObject *arg) {
  EggVertexUV *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexUV, (void **)&local_this, "EggVertexUV.set_binormal")) {
    return nullptr;
  }
  // 1-inline void EggVertexUV::set_binormal(LNormald const &binormal)
  LVector3d arg_local;
  LNormald const *arg_this = Dtool_Coerce_LVector3d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggVertexUV.set_binormal", "LVector3d");
  }
  ((*local_this).set_binormal)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_binormal(const EggVertexUV self, const LVector3d binormal)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_set_binormal_190_comment =
  "C++ Interface:\n"
  "set_binormal(const EggVertexUV self, const LVector3d binormal)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertexUV_set_binormal_190_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertexUV::clear_binormal(void)
 */
static PyObject *Dtool_EggVertexUV_clear_binormal_191(PyObject *self, PyObject *) {
  EggVertexUV *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexUV, (void **)&local_this, "EggVertexUV.clear_binormal")) {
    return nullptr;
  }
  // 1-inline void EggVertexUV::clear_binormal(void)
  ((*local_this).clear_binormal)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_clear_binormal_191_comment =
  "C++ Interface:\n"
  "clear_binormal(const EggVertexUV self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertexUV_clear_binormal_191_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< EggVertexUV > EggVertexUV::make_average(EggVertexUV const *first, EggVertexUV const *second)
 */
static PyObject *Dtool_EggVertexUV_make_average_192(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static PointerTo< EggVertexUV > EggVertexUV::make_average(EggVertexUV const *first, EggVertexUV const *second)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"first", "second", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:make_average", (char **)keyword_list, &param0, &param1)) {
    EggVertexUV const *param0_this = (EggVertexUV *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_EggVertexUV, 0, "EggVertexUV.make_average", true, true);
    EggVertexUV const *param1_this = (EggVertexUV *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_EggVertexUV, 1, "EggVertexUV.make_average", true, true);
    if (param0_this != nullptr && param1_this != nullptr) {
      PointerTo< EggVertexUV > return_value = (EggVertexUV::make_average)(param0_this, param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      EggVertexUV *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_EggVertexUV, true, false, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_average(const EggVertexUV first, const EggVertexUV second)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_make_average_192_comment =
  "C++ Interface:\n"
  "make_average(const EggVertexUV first, const EggVertexUV second)\n"
  "\n"
  "/**\n"
  " * Creates a new EggVertexUV that contains the averaged values of the two\n"
  " * given objects.  It is an error if they don't have the same name.\n"
  " */";
#else
static const char *Dtool_EggVertexUV_make_average_192_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggVertexUV::transform(LMatrix4d const &mat)
 */
static PyObject *Dtool_EggVertexUV_transform_193(PyObject *self, PyObject *arg) {
  EggVertexUV *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexUV, (void **)&local_this, "EggVertexUV.transform")) {
    return nullptr;
  }
  // 1-void EggVertexUV::transform(LMatrix4d const &mat)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggVertexUV.transform", "LMatrix4d");
  }
  ((*local_this).transform)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "transform(const EggVertexUV self, const LMatrix4d mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_transform_193_comment =
  "C++ Interface:\n"
  "transform(const EggVertexUV self, const LMatrix4d mat)\n"
  "\n"
  "/**\n"
  " * Applies the indicated transformation matrix to the UV's tangent and/or\n"
  " * binormal.  This does nothing if there is no tangent or binormal.\n"
  " */";
#else
static const char *Dtool_EggVertexUV_transform_193_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggVertexUV::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_EggVertexUV_write_194(PyObject *self, PyObject *args, PyObject *kwds) {
  EggVertexUV *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertexUV)) {
    return nullptr;
  }
  // 1-void EggVertexUV::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "EggVertexUV.write", false, true);
    if (param1_this != nullptr) {
      ((*(const EggVertexUV*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(EggVertexUV self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_write_194_comment =
  "C++ Interface:\n"
  "write(EggVertexUV self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertexUV_write_194_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int EggVertexUV::compare_to(EggVertexUV const &other) const
 */
static PyObject *Dtool_EggVertexUV_compare_to_195(PyObject *self, PyObject *arg) {
  EggVertexUV *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertexUV)) {
    return nullptr;
  }
  // 1-int EggVertexUV::compare_to(EggVertexUV const &other) const
  EggVertexUV const *arg_this = (EggVertexUV *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertexUV, 1, "EggVertexUV.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const EggVertexUV*)local_this).compare_to)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(EggVertexUV self, const EggVertexUV other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_compare_to_195_comment =
  "C++ Interface:\n"
  "compare_to(EggVertexUV self, const EggVertexUV other)\n"
  "\n"
  "/**\n"
  " * An ordering operator to compare two vertices for sorting order.  This\n"
  " * imposes an arbitrary ordering useful to identify unique vertices.\n"
  " */";
#else
static const char *Dtool_EggVertexUV_compare_to_195_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggVertexUV::get_class_type(void)
 */
static PyObject *Dtool_EggVertexUV_get_class_type_200(PyObject *, PyObject *) {
  // 1-static TypeHandle EggVertexUV::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggVertexUV::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexUV_get_class_type_200_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggVertexUV_get_class_type_200_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggVertexUV::EggVertexUV(EggVertexUV const &copy)
 * explicit EggVertexUV::EggVertexUV(std::string const &name, LTexCoord3d const &uvw)
 * explicit EggVertexUV::EggVertexUV(std::string const &name, LTexCoordd const &uv)
 */
static int Dtool_Init_EggVertexUV(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-EggVertexUV::EggVertexUV(EggVertexUV const &copy)
        EggVertexUV const *arg_this = (EggVertexUV *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertexUV, 0, "EggVertexUV.EggVertexUV", true, true);
        if (arg_this != nullptr) {
          EggVertexUV *return_value = new EggVertexUV(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggVertexUV, true, false);
        }
      }
    }
    break;
  case 2:
    {
      {
        // -2 explicit EggVertexUV::EggVertexUV(std::string const &name, LTexCoord3d const &uvw)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        PyObject *param1;
        static const char *keyword_list[] = {"name", "uvw", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:EggVertexUV", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
          LTexCoord3d const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LPoint3d);
          if (param1_this != nullptr) {
            EggVertexUV *return_value = new EggVertexUV(std::string(param0_str, param0_len), *param1_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggVertexUV, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 explicit EggVertexUV::EggVertexUV(std::string const &name, LTexCoordd const &uv)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        PyObject *param1;
        static const char *keyword_list[] = {"name", "uv", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:EggVertexUV", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
          LTexCoordd const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LPoint2d);
          if (param1_this != nullptr) {
            EggVertexUV *return_value = new EggVertexUV(std::string(param0_str, param0_len), *param1_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggVertexUV, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 explicit EggVertexUV::EggVertexUV(std::string const &name, LTexCoord3d const &uvw)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        PyObject *param1;
        static const char *keyword_list[] = {"name", "uvw", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:EggVertexUV", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
          LPoint3d param1_local;
          LTexCoord3d const *param1_this = Dtool_Coerce_LPoint3d(param1, param1_local);
          if ((param1_this != nullptr)) {
            EggVertexUV *return_value = new EggVertexUV(std::string(param0_str, param0_len), *param1_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggVertexUV, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 explicit EggVertexUV::EggVertexUV(std::string const &name, LTexCoordd const &uv)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        PyObject *param1;
        static const char *keyword_list[] = {"name", "uv", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:EggVertexUV", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
          LPoint2d param1_local;
          LTexCoordd const *param1_this = Dtool_Coerce_LPoint2d(param1, param1_local);
          if ((param1_this != nullptr)) {
            EggVertexUV *return_value = new EggVertexUV(std::string(param0_str, param0_len), *param1_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggVertexUV, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggVertexUV() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggVertexUV(const EggVertexUV copy)\n"
      "EggVertexUV(str name, const LPoint3d uvw)\n"
      "EggVertexUV(str name, const LPoint2d uv)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggVertexUV(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggVertexUV) {
    printf("EggVertexUV ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggVertexUV *local_this = (EggVertexUV *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggVertexUV) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggVertexUV(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggVertexUV) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggVertexUV*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggVertexUV*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggVertexUV*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggVertexUV*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggVertexUV*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggVertexUV*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggVertexAux
 */
/**
 * Python function wrapper for:
 * void EggVertexAux::operator =(EggVertexAux const &copy)
 */
static PyObject *Dtool_EggVertexAux_operator_203(PyObject *self, PyObject *arg) {
  EggVertexAux *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexAux, (void **)&local_this, "EggVertexAux.assign")) {
    return nullptr;
  }
  // 1-void EggVertexAux::operator =(EggVertexAux const &copy)
  EggVertexAux const *arg_this = (EggVertexAux *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertexAux, 1, "EggVertexAux.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggVertexAux *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertexAux, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggVertexAux self, const EggVertexAux copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexAux_operator_203_comment =
  "C++ Interface:\n"
  "assign(const EggVertexAux self, const EggVertexAux copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertexAux_operator_203_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertexAux::set_name(std::string const &name)
 */
static PyObject *Dtool_EggVertexAux_set_name_204(PyObject *self, PyObject *arg) {
  EggVertexAux *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexAux, (void **)&local_this, "EggVertexAux.set_name")) {
    return nullptr;
  }
  // 1-inline void EggVertexAux::set_name(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_name)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_name(const EggVertexAux self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexAux_set_name_204_comment =
  "C++ Interface:\n"
  "set_name(const EggVertexAux self, str name)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertexAux_set_name_204_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4d const &EggVertexAux::get_aux(void) const
 */
static PyObject *Dtool_EggVertexAux_get_aux_205(PyObject *self, PyObject *) {
  EggVertexAux *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertexAux)) {
    return nullptr;
  }
  // 1-inline LVecBase4d const &EggVertexAux::get_aux(void) const
  LVecBase4d const *return_value = &(((*(const EggVertexAux*)local_this).get_aux)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexAux_get_aux_205_comment =
  "C++ Interface:\n"
  "get_aux(EggVertexAux self)\n"
  "\n"
  "/**\n"
  " * Returns the auxiliary data quadruple.\n"
  " */";
#else
static const char *Dtool_EggVertexAux_get_aux_205_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertexAux::set_aux(LVecBase4d const &aux)
 */
static PyObject *Dtool_EggVertexAux_set_aux_206(PyObject *self, PyObject *arg) {
  EggVertexAux *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexAux, (void **)&local_this, "EggVertexAux.set_aux")) {
    return nullptr;
  }
  // 1-inline void EggVertexAux::set_aux(LVecBase4d const &aux)
  LVecBase4d arg_local;
  LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggVertexAux.set_aux", "LVecBase4d");
  }
  ((*local_this).set_aux)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_aux(const EggVertexAux self, const LVecBase4d aux)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexAux_set_aux_206_comment =
  "C++ Interface:\n"
  "set_aux(const EggVertexAux self, const LVecBase4d aux)\n"
  "\n"
  "/**\n"
  " * Sets the auxiliary data quadruple.\n"
  " */";
#else
static const char *Dtool_EggVertexAux_set_aux_206_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< EggVertexAux > EggVertexAux::make_average(EggVertexAux const *first, EggVertexAux const *second)
 */
static PyObject *Dtool_EggVertexAux_make_average_207(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static PointerTo< EggVertexAux > EggVertexAux::make_average(EggVertexAux const *first, EggVertexAux const *second)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"first", "second", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:make_average", (char **)keyword_list, &param0, &param1)) {
    EggVertexAux const *param0_this = (EggVertexAux *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_EggVertexAux, 0, "EggVertexAux.make_average", true, true);
    EggVertexAux const *param1_this = (EggVertexAux *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_EggVertexAux, 1, "EggVertexAux.make_average", true, true);
    if (param0_this != nullptr && param1_this != nullptr) {
      PointerTo< EggVertexAux > return_value = (EggVertexAux::make_average)(param0_this, param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      EggVertexAux *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_EggVertexAux, true, false, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_average(const EggVertexAux first, const EggVertexAux second)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexAux_make_average_207_comment =
  "C++ Interface:\n"
  "make_average(const EggVertexAux first, const EggVertexAux second)\n"
  "\n"
  "/**\n"
  " * Creates a new EggVertexAux that contains the averaged values of the two\n"
  " * given objects.  It is an error if they don't have the same name.\n"
  " */";
#else
static const char *Dtool_EggVertexAux_make_average_207_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggVertexAux::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_EggVertexAux_write_208(PyObject *self, PyObject *args, PyObject *kwds) {
  EggVertexAux *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertexAux)) {
    return nullptr;
  }
  // 1-void EggVertexAux::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "EggVertexAux.write", false, true);
    if (param1_this != nullptr) {
      ((*(const EggVertexAux*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(EggVertexAux self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexAux_write_208_comment =
  "C++ Interface:\n"
  "write(EggVertexAux self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertexAux_write_208_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int EggVertexAux::compare_to(EggVertexAux const &other) const
 */
static PyObject *Dtool_EggVertexAux_compare_to_209(PyObject *self, PyObject *arg) {
  EggVertexAux *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertexAux)) {
    return nullptr;
  }
  // 1-int EggVertexAux::compare_to(EggVertexAux const &other) const
  EggVertexAux const *arg_this = (EggVertexAux *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertexAux, 1, "EggVertexAux.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const EggVertexAux*)local_this).compare_to)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(EggVertexAux self, const EggVertexAux other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexAux_compare_to_209_comment =
  "C++ Interface:\n"
  "compare_to(EggVertexAux self, const EggVertexAux other)\n"
  "\n"
  "/**\n"
  " * An ordering operator to compare two vertices for sorting order.  This\n"
  " * imposes an arbitrary ordering useful to identify unique vertices.\n"
  " */";
#else
static const char *Dtool_EggVertexAux_compare_to_209_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggVertexAux::get_class_type(void)
 */
static PyObject *Dtool_EggVertexAux_get_class_type_210(PyObject *, PyObject *) {
  // 1-static TypeHandle EggVertexAux::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggVertexAux::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexAux_get_class_type_210_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggVertexAux_get_class_type_210_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggVertexAux::EggVertexAux(EggVertexAux const &copy)
 * explicit EggVertexAux::EggVertexAux(std::string const &name, LVecBase4d const &aux)
 */
static int Dtool_Init_EggVertexAux(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-EggVertexAux::EggVertexAux(EggVertexAux const &copy)
        EggVertexAux const *arg_this = (EggVertexAux *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertexAux, 0, "EggVertexAux.EggVertexAux", true, true);
        if (arg_this != nullptr) {
          EggVertexAux *return_value = new EggVertexAux(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggVertexAux, true, false);
        }
      }
    }
    break;
  case 2:
    {
      // 1-explicit EggVertexAux::EggVertexAux(std::string const &name, LVecBase4d const &aux)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      PyObject *param1;
      static const char *keyword_list[] = {"name", "aux", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:EggVertexAux", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
        LVecBase4d param1_local;
        LVecBase4d const *param1_this = Dtool_Coerce_LVecBase4d(param1, param1_local);
        if (!(param1_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param1, 1, "EggVertexAux.EggVertexAux", "LVecBase4d");
          return -1;
        }
        EggVertexAux *return_value = new EggVertexAux(std::string(param0_str, param0_len), *param1_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggVertexAux, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggVertexAux() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggVertexAux(const EggVertexAux copy)\n"
      "EggVertexAux(str name, const LVecBase4d aux)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggVertexAux(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggVertexAux) {
    printf("EggVertexAux ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggVertexAux *local_this = (EggVertexAux *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggVertexAux) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggVertexAux(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggVertexAux) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggVertexAux*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggVertexAux*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggVertexAux*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggVertexAux*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggVertexAux*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggVertexAux*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggVertex
 */
/**
 * Python function wrapper for:
 * void EggVertex::operator =(EggVertex const &copy)
 */
static PyObject *Dtool_EggVertex_operator_217(PyObject *self, PyObject *arg) {
  EggVertex *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.assign")) {
    return nullptr;
  }
  // 1-void EggVertex::operator =(EggVertex const &copy)
  EggVertex const *arg_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertex, 1, "EggVertex.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggVertex *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggVertex self, const EggVertex copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_operator_217_comment =
  "C++ Interface:\n"
  "assign(const EggVertex self, const EggVertex copy)\n"
  "\n"
  "/**\n"
  " * Copies all properties of the vertex except its vertex pool, index number,\n"
  " * and group membership.\n"
  " */";
#else
static const char *Dtool_EggVertex_operator_217_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggVertexPool *EggVertex::get_pool(void) const
 */
static PyObject *Dtool_EggVertex_get_pool_219(PyObject *self, PyObject *) {
  EggVertex *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertex)) {
    return nullptr;
  }
  // 1-inline EggVertexPool *EggVertex::get_pool(void) const
  EggVertexPool *return_value = ((*(const EggVertex*)local_this).get_pool)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertexPool, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_pool_219_comment =
  "C++ Interface:\n"
  "get_pool(EggVertex self)\n"
  "\n"
  "/**\n"
  " * Returns the vertex pool this vertex belongs in.  This may be NULL if the\n"
  " * vertex has not been added to a pool.\n"
  " */";
#else
static const char *Dtool_EggVertex_get_pool_219_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggVertex::is_forward_reference(void) const
 */
static PyObject *Dtool_EggVertex_is_forward_reference_220(PyObject *self, PyObject *) {
  EggVertex *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertex)) {
    return nullptr;
  }
  // 1-inline bool EggVertex::is_forward_reference(void) const
  bool return_value = ((*(const EggVertex*)local_this).is_forward_reference)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_is_forward_reference_220_comment =
  "C++ Interface:\n"
  "is_forward_reference(EggVertex self)\n"
  "\n"
  "/**\n"
  " * Returns true if the vertex is a forward reference to some vertex that\n"
  " * hasn't been defined yet.  In this case, the vertex may not have any\n"
  " * properties filled in yet.\n"
  " *\n"
  " * This can only happen if you implicitly create a vertex via\n"
  " * EggVertexPool::get_forward_vertex(). Presumably, when the vertex pool is\n"
  " * later filled in, this vertex will be replaced with real data.\n"
  " */";
#else
static const char *Dtool_EggVertex_is_forward_reference_220_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertex::set_pos(LPoint2d const &pos)
 * inline void EggVertex::set_pos(LPoint3d const &pos)
 * inline void EggVertex::set_pos(LPoint4d const &pos)
 * inline void EggVertex::set_pos(double pos)
 */
static PyObject *Dtool_EggVertex_set_pos_221(PyObject *self, PyObject *arg) {
  EggVertex *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.set_pos")) {
    return nullptr;
  }
  {
    // -2 inline void EggVertex::set_pos(LPoint2d const &pos)
    LPoint2d const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LPoint2d);
    if (arg_this != nullptr) {
      ((*local_this).set_pos)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void EggVertex::set_pos(LPoint3d const &pos)
    LPoint3d const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LPoint3d);
    if (arg_this != nullptr) {
      ((*local_this).set_pos)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void EggVertex::set_pos(LPoint4d const &pos)
    LPoint4d const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LPoint4d);
    if (arg_this != nullptr) {
      ((*local_this).set_pos)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void EggVertex::set_pos(double pos)
    if (PyNumber_Check(arg)) {
      ((*local_this).set_pos)(PyFloat_AsDouble(arg));
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void EggVertex::set_pos(LPoint2d const &pos)
    LPoint2d arg_local;
    LPoint2d const *arg_this = Dtool_Coerce_LPoint2d(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).set_pos)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void EggVertex::set_pos(LPoint3d const &pos)
    LPoint3d arg_local;
    LPoint3d const *arg_this = Dtool_Coerce_LPoint3d(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).set_pos)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void EggVertex::set_pos(LPoint4d const &pos)
    LPoint4d arg_local;
    LPoint4d const *arg_this = Dtool_Coerce_LPoint4d(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).set_pos)(*arg_this);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: inline void EggVertex::set_pos(double pos)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pos(const EggVertex self, const LPoint2d pos)\n"
      "set_pos(const EggVertex self, const LPoint3d pos)\n"
      "set_pos(const EggVertex self, const LPoint4d pos)\n"
      "set_pos(const EggVertex self, double pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_set_pos_221_comment =
  "C++ Interface:\n"
  "set_pos(const EggVertex self, const LPoint2d pos)\n"
  "set_pos(const EggVertex self, const LPoint3d pos)\n"
  "set_pos(const EggVertex self, const LPoint4d pos)\n"
  "set_pos(const EggVertex self, double pos)\n"
  "\n"
  "// The pos might have 1, 2, 3, or 4 dimensions.  That complicates things a\n"
  "// bit.\n"
  "\n"
  "/**\n"
  " * Sets the vertex position.  This variant sets the vertex to a one-\n"
  " * dimensional value.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the vertex position.  This variant sets the vertex to a two-\n"
  " * dimensional value.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the vertex position.  This variant sets the vertex to a three-\n"
  " * dimensional value.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the vertex position.  This variant sets the vertex to a four-\n"
  " * dimensional value.\n"
  " */";
#else
static const char *Dtool_EggVertex_set_pos_221_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertex::set_pos4(LPoint4d const &pos)
 */
static PyObject *Dtool_EggVertex_set_pos4_222(PyObject *self, PyObject *arg) {
  EggVertex *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.set_pos4")) {
    return nullptr;
  }
  // 1-inline void EggVertex::set_pos4(LPoint4d const &pos)
  LPoint4d arg_local;
  LPoint4d const *arg_this = Dtool_Coerce_LPoint4d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggVertex.set_pos4", "LPoint4d");
  }
  ((*local_this).set_pos4)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pos4(const EggVertex self, const LPoint4d pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_set_pos4_222_comment =
  "C++ Interface:\n"
  "set_pos4(const EggVertex self, const LPoint4d pos)\n"
  "\n"
  "/**\n"
  " * This special flavor of set_pos() sets the vertex as a four-component value,\n"
  " * but does not change the set number of dimensions.  It's handy for\n"
  " * retrieving the vertex position via get_pos4, manipulating it, then storing\n"
  " * it back again, without worrying about the number of dimensions it actually\n"
  " * had.\n"
  " */";
#else
static const char *Dtool_EggVertex_set_pos4_222_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggVertex::get_num_dimensions(void) const
 */
static PyObject *Dtool_EggVertex_get_num_dimensions_223(PyObject *self, PyObject *) {
  EggVertex *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertex)) {
    return nullptr;
  }
  // 1-inline int EggVertex::get_num_dimensions(void) const
  int return_value = ((*(const EggVertex*)local_this).get_num_dimensions)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_num_dimensions_223_comment =
  "C++ Interface:\n"
  "get_num_dimensions(EggVertex self)\n"
  "\n"
  "// get_pos[123] return the pos as the corresponding type.  It is an error to\n"
  "// call any of these without first verifying that get_num_dimensions()\n"
  "// matches the desired type.  However, get_pos4() may always be called; it\n"
  "// returns the pos as a four-component point in homogeneous space (with a\n"
  "// 1.0 in the last position if the pos has fewer than four components).\n"
  "\n"
  "/**\n"
  " * Returns the number of dimensions the vertex uses.  Usually this will be 3,\n"
  " * but it may be 1, 2, 3, or 4.\n"
  " */";
#else
static const char *Dtool_EggVertex_get_num_dimensions_223_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double EggVertex::get_pos1(void) const
 */
static PyObject *Dtool_EggVertex_get_pos1_224(PyObject *self, PyObject *) {
  EggVertex *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertex)) {
    return nullptr;
  }
  // 1-inline double EggVertex::get_pos1(void) const
  double return_value = ((*(const EggVertex*)local_this).get_pos1)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_pos1_224_comment =
  "C++ Interface:\n"
  "get_pos1(EggVertex self)\n"
  "\n"
  "/**\n"
  " * Only valid if get_num_dimensions() returns 1. Returns the position as a\n"
  " * one-dimensional value.\n"
  " */";
#else
static const char *Dtool_EggVertex_get_pos1_224_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2d EggVertex::get_pos2(void) const
 */
static PyObject *Dtool_EggVertex_get_pos2_225(PyObject *self, PyObject *) {
  EggVertex *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertex)) {
    return nullptr;
  }
  // 1-inline LPoint2d EggVertex::get_pos2(void) const
  LPoint2d *return_value = new LPoint2d(((*(const EggVertex*)local_this).get_pos2)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_pos2_225_comment =
  "C++ Interface:\n"
  "get_pos2(EggVertex self)\n"
  "\n"
  "/**\n"
  " * Only valid if get_num_dimensions() returns 2. Returns the position as a\n"
  " * two-dimensional value.\n"
  " */";
#else
static const char *Dtool_EggVertex_get_pos2_225_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVertexd EggVertex::get_pos3(void) const
 */
static PyObject *Dtool_EggVertex_get_pos3_226(PyObject *self, PyObject *) {
  EggVertex *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertex)) {
    return nullptr;
  }
  // 1-inline LVertexd EggVertex::get_pos3(void) const
  LVertexd *return_value = new LVertexd(((*(const EggVertex*)local_this).get_pos3)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_pos3_226_comment =
  "C++ Interface:\n"
  "get_pos3(EggVertex self)\n"
  "\n"
  "/**\n"
  " * Valid if get_num_dimensions() returns 3 or 4. Returns the position as a\n"
  " * three-dimensional value.\n"
  " */";
#else
static const char *Dtool_EggVertex_get_pos3_226_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint4d EggVertex::get_pos4(void) const
 */
static PyObject *Dtool_EggVertex_get_pos4_227(PyObject *self, PyObject *) {
  EggVertex *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertex)) {
    return nullptr;
  }
  // 1-inline LPoint4d EggVertex::get_pos4(void) const
  LPoint4d *return_value = new LPoint4d(((*(const EggVertex*)local_this).get_pos4)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_pos4_227_comment =
  "C++ Interface:\n"
  "get_pos4(EggVertex self)\n"
  "\n"
  "/**\n"
  " * This is always valid, regardless of the value of get_num_dimensions.  It\n"
  " * returns the position as a four-dimensional value.  If the pos has fewer\n"
  " * than four dimensions, this value represents the pos extended into four-\n"
  " * dimensional homogenous space, e.g.  by adding 1 as the fourth component.\n"
  " */";
#else
static const char *Dtool_EggVertex_get_pos4_227_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggVertex::has_uv(void) const
 * bool EggVertex::has_uv(std::string const &name) const
 */
static PyObject *Dtool_EggVertex_has_uv_228(PyObject *self, PyObject *args) {
  EggVertex *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertex)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline bool EggVertex::has_uv(void) const
      bool return_value = ((*(const EggVertex*)local_this).has_uv)();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-bool EggVertex::has_uv(std::string const &name) const
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
        param1_str = nullptr;
      }
#endif
      if (param1_str != nullptr) {
        bool return_value = ((*(const EggVertex*)local_this).has_uv)(std::string(param1_str, param1_len));
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "has_uv() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_uv(EggVertex self)\n"
      "has_uv(EggVertex self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_has_uv_228_comment =
  "C++ Interface:\n"
  "has_uv(EggVertex self)\n"
  "has_uv(EggVertex self, str name)\n"
  "\n"
  "/**\n"
  " * Returns true if the vertex has an unnamed UV coordinate pair, false\n"
  " * otherwise.\n"
  " *\n"
  " * This is the more restrictive interface, and is generally useful only in the\n"
  " * absence of multitexturing; see has_uv(name) for the interface that supports\n"
  " * multitexturing.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if the vertex has the named UV coordinate pair, and the named\n"
  " * UV coordinate pair is 2-d, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggVertex_has_uv_228_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LTexCoordd EggVertex::get_uv(void) const
 * LTexCoordd EggVertex::get_uv(std::string const &name) const
 */
static PyObject *Dtool_EggVertex_get_uv_229(PyObject *self, PyObject *args) {
  EggVertex *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertex)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LTexCoordd EggVertex::get_uv(void) const
      LTexCoordd *return_value = new LTexCoordd(((*(const EggVertex*)local_this).get_uv)());
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-LTexCoordd EggVertex::get_uv(std::string const &name) const
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
        param1_str = nullptr;
      }
#endif
      if (param1_str != nullptr) {
        LTexCoordd *return_value = new LTexCoordd(((*(const EggVertex*)local_this).get_uv)(std::string(param1_str, param1_len)));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_uv() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_uv(EggVertex self)\n"
      "get_uv(EggVertex self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_uv_229_comment =
  "C++ Interface:\n"
  "get_uv(EggVertex self)\n"
  "get_uv(EggVertex self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the unnamed UV coordinate pair on the vertex.  It is an error to\n"
  " * call this if has_uv() has returned false.\n"
  " *\n"
  " * This is the more restrictive interface, and is generally useful only in the\n"
  " * absence of multitexturing; see get_uv(name) for the interface that supports\n"
  " * multitexturing.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the named UV coordinate pair on the vertex.  It is an error to call\n"
  " * this if has_uv(name) returned false.\n"
  " */";
#else
static const char *Dtool_EggVertex_get_uv_229_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertex::set_uv(LTexCoordd const &texCoord)
 * void EggVertex::set_uv(std::string const &name, LTexCoordd const &texCoord)
 */
static PyObject *Dtool_EggVertex_set_uv_230(PyObject *self, PyObject *args, PyObject *kwds) {
  EggVertex *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.set_uv")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "texCoord")) {
        // 1-inline void EggVertex::set_uv(LTexCoordd const &texCoord)
        LPoint2d arg_local;
        LTexCoordd const *arg_this = Dtool_Coerce_LPoint2d(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "EggVertex.set_uv", "LPoint2d");
        }
        ((*local_this).set_uv)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-void EggVertex::set_uv(std::string const &name, LTexCoordd const &texCoord)
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      PyObject *param2;
      static const char *keyword_list[] = {"name", "texCoord", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:set_uv", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
        LPoint2d param2_local;
        LTexCoordd const *param2_this = Dtool_Coerce_LPoint2d(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "EggVertex.set_uv", "LPoint2d");
        }
        ((*local_this).set_uv)(std::string(param1_str, param1_len), *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_uv() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_uv(const EggVertex self, const LPoint2d texCoord)\n"
      "set_uv(const EggVertex self, str name, const LPoint2d texCoord)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_set_uv_230_comment =
  "C++ Interface:\n"
  "set_uv(const EggVertex self, const LPoint2d texCoord)\n"
  "set_uv(const EggVertex self, str name, const LPoint2d texCoord)\n"
  "\n"
  "/**\n"
  " * Replaces the unnamed UV coordinate pair on the vertex with the indicated\n"
  " * value.\n"
  " *\n"
  " * This is the more restrictive interface, and is generally useful only in the\n"
  " * absence of multitexturing; see set_uv(name, uv) for the interface that\n"
  " * supports multitexturing.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the indicated UV coordinate pair on the vertex.  This replaces any UV\n"
  " * coordinate pair with the same name already on the vertex, but preserves UV\n"
  " * morphs.\n"
  " */";
#else
static const char *Dtool_EggVertex_set_uv_230_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertex::clear_uv(void)
 * void EggVertex::clear_uv(std::string const &name)
 */
static PyObject *Dtool_EggVertex_clear_uv_231(PyObject *self, PyObject *args) {
  EggVertex *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.clear_uv")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void EggVertex::clear_uv(void)
      ((*local_this).clear_uv)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-void EggVertex::clear_uv(std::string const &name)
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
        param1_str = nullptr;
      }
#endif
      if (param1_str != nullptr) {
        ((*local_this).clear_uv)(std::string(param1_str, param1_len));
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "clear_uv() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_uv(const EggVertex self)\n"
      "clear_uv(const EggVertex self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_clear_uv_231_comment =
  "C++ Interface:\n"
  "clear_uv(const EggVertex self)\n"
  "clear_uv(const EggVertex self, str name)\n"
  "\n"
  "/**\n"
  " * Removes all UV coordinate pairs from the vertex.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Removes the named UV coordinate pair from the vertex, along with any UV\n"
  " * morphs.\n"
  " */";
#else
static const char *Dtool_EggVertex_clear_uv_231_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggVertex::has_uvw(std::string const &name) const
 */
static PyObject *Dtool_EggVertex_has_uvw_232(PyObject *self, PyObject *arg) {
  EggVertex *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertex)) {
    return nullptr;
  }
  // 1-bool EggVertex::has_uvw(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*(const EggVertex*)local_this).has_uvw)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_uvw(EggVertex self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_has_uvw_232_comment =
  "C++ Interface:\n"
  "has_uvw(EggVertex self, str name)\n"
  "\n"
  "/**\n"
  " * Returns true if the vertex has the named UV coordinate triple, and the\n"
  " * named UV coordinate triple is 3-d, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggVertex_has_uvw_232_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LTexCoord3d const &EggVertex::get_uvw(std::string const &name) const
 */
static PyObject *Dtool_EggVertex_get_uvw_233(PyObject *self, PyObject *arg) {
  EggVertex *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertex)) {
    return nullptr;
  }
  // 1-LTexCoord3d const &EggVertex::get_uvw(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    LTexCoord3d const *return_value = &(((*(const EggVertex*)local_this).get_uvw)(std::string(param1_str, param1_len)));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_uvw(EggVertex self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_uvw_233_comment =
  "C++ Interface:\n"
  "get_uvw(EggVertex self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the named UV coordinate triple on the vertex.  It is an error to\n"
  " * call this if has_uvw(name) returned false.\n"
  " */";
#else
static const char *Dtool_EggVertex_get_uvw_233_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggVertex::set_uvw(std::string const &name, LTexCoord3d const &texCoord)
 */
static PyObject *Dtool_EggVertex_set_uvw_234(PyObject *self, PyObject *args, PyObject *kwds) {
  EggVertex *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.set_uvw")) {
    return nullptr;
  }
  // 1-void EggVertex::set_uvw(std::string const &name, LTexCoord3d const &texCoord)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"name", "texCoord", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:set_uvw", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    LPoint3d param2_local;
    LTexCoord3d const *param2_this = Dtool_Coerce_LPoint3d(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "EggVertex.set_uvw", "LPoint3d");
    }
    ((*local_this).set_uvw)(std::string(param1_str, param1_len), *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_uvw(const EggVertex self, str name, const LPoint3d texCoord)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_set_uvw_234_comment =
  "C++ Interface:\n"
  "set_uvw(const EggVertex self, str name, const LPoint3d texCoord)\n"
  "\n"
  "/**\n"
  " * Sets the indicated UV coordinate triple on the vertex.  This replaces any\n"
  " * UV coordinate pair or triple with the same name already on the vertex, but\n"
  " * preserves UV morphs.\n"
  " */";
#else
static const char *Dtool_EggVertex_set_uvw_234_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggVertexUV const *EggVertex::get_uv_obj(std::string const &name) const
 */
static PyObject *Dtool_EggVertex_get_uv_obj_235(PyObject *self, PyObject *arg) {
  EggVertex *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertex)) {
    return nullptr;
  }
  // 1-EggVertexUV const *EggVertex::get_uv_obj(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    EggVertexUV const *return_value = ((*(const EggVertex*)local_this).get_uv_obj)(std::string(param1_str, param1_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertexUV, true, true, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_uv_obj(EggVertex self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_uv_obj_235_comment =
  "C++ Interface:\n"
  "get_uv_obj(EggVertex self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the named EggVertexUV object, which defines both the UV coordinate\n"
  " * pair for this name and the UV morphs.  This object might be shared between\n"
  " * multiple vertices.  You should not attempt to modify this object; instead,\n"
  " * call modify_uv_object to return a modifiable pointer.\n"
  " */";
#else
static const char *Dtool_EggVertex_get_uv_obj_235_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggVertexUV *EggVertex::modify_uv_obj(std::string const &name)
 */
static PyObject *Dtool_EggVertex_modify_uv_obj_236(PyObject *self, PyObject *arg) {
  EggVertex *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.modify_uv_obj")) {
    return nullptr;
  }
  // 1-EggVertexUV *EggVertex::modify_uv_obj(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    EggVertexUV *return_value = ((*local_this).modify_uv_obj)(std::string(param1_str, param1_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertexUV, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "modify_uv_obj(const EggVertex self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_modify_uv_obj_236_comment =
  "C++ Interface:\n"
  "modify_uv_obj(const EggVertex self, str name)\n"
  "\n"
  "/**\n"
  " * Returns a modifiable pointer to the named EggVertexUV object, which defines\n"
  " * both the UV coordinate pair for this name and the UV morphs.  Returns NULL\n"
  " * if there is no such named UV object.\n"
  " */";
#else
static const char *Dtool_EggVertex_modify_uv_obj_236_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggVertex::set_uv_obj(EggVertexUV *vertex_uv)
 */
static PyObject *Dtool_EggVertex_set_uv_obj_237(PyObject *self, PyObject *arg) {
  EggVertex *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.set_uv_obj")) {
    return nullptr;
  }
  // 1-void EggVertex::set_uv_obj(EggVertexUV *vertex_uv)
  EggVertexUV *arg_this = (EggVertexUV *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertexUV, 1, "EggVertex.set_uv_obj", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_uv_obj)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_uv_obj(const EggVertex self, EggVertexUV vertex_uv)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_set_uv_obj_237_comment =
  "C++ Interface:\n"
  "set_uv_obj(const EggVertex self, EggVertexUV vertex_uv)\n"
  "\n"
  "/**\n"
  " * Sets the indicated EggVertexUV on the vertex.  This replaces any UV\n"
  " * coordinate pair with the same name already on the vertex, including UV\n"
  " * morphs.\n"
  " */";
#else
static const char *Dtool_EggVertex_set_uv_obj_237_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggVertex::has_aux(void) const
 * bool EggVertex::has_aux(std::string const &name) const
 */
static PyObject *Dtool_EggVertex_has_aux_238(PyObject *self, PyObject *args) {
  EggVertex *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertex)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline bool EggVertex::has_aux(void) const
      bool return_value = ((*(const EggVertex*)local_this).has_aux)();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-bool EggVertex::has_aux(std::string const &name) const
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
        param1_str = nullptr;
      }
#endif
      if (param1_str != nullptr) {
        bool return_value = ((*(const EggVertex*)local_this).has_aux)(std::string(param1_str, param1_len));
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "has_aux() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_aux(EggVertex self)\n"
      "has_aux(EggVertex self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_has_aux_238_comment =
  "C++ Interface:\n"
  "has_aux(EggVertex self)\n"
  "has_aux(EggVertex self, str name)\n"
  "\n"
  "/**\n"
  " * Returns true if the vertex has any auxiliary data, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if the vertex has the named auxiliary data quadruple.\n"
  " */";
#else
static const char *Dtool_EggVertex_has_aux_238_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertex::clear_aux(void)
 * void EggVertex::clear_aux(std::string const &name)
 */
static PyObject *Dtool_EggVertex_clear_aux_239(PyObject *self, PyObject *args) {
  EggVertex *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.clear_aux")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void EggVertex::clear_aux(void)
      ((*local_this).clear_aux)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-void EggVertex::clear_aux(std::string const &name)
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
        param1_str = nullptr;
      }
#endif
      if (param1_str != nullptr) {
        ((*local_this).clear_aux)(std::string(param1_str, param1_len));
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "clear_aux() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_aux(const EggVertex self)\n"
      "clear_aux(const EggVertex self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_clear_aux_239_comment =
  "C++ Interface:\n"
  "clear_aux(const EggVertex self)\n"
  "clear_aux(const EggVertex self, str name)\n"
  "\n"
  "/**\n"
  " * Removes all auxiliary data from the vertex.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Removes the named auxiliary data from the vertex.\n"
  " */";
#else
static const char *Dtool_EggVertex_clear_aux_239_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVecBase4d const &EggVertex::get_aux(std::string const &name) const
 */
static PyObject *Dtool_EggVertex_get_aux_240(PyObject *self, PyObject *arg) {
  EggVertex *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertex)) {
    return nullptr;
  }
  // 1-LVecBase4d const &EggVertex::get_aux(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    LVecBase4d const *return_value = &(((*(const EggVertex*)local_this).get_aux)(std::string(param1_str, param1_len)));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_aux(EggVertex self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_aux_240_comment =
  "C++ Interface:\n"
  "get_aux(EggVertex self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the named auxiliary data quadruple on the vertex.  It is an error\n"
  " * to call this if has_aux(name) returned false.\n"
  " */";
#else
static const char *Dtool_EggVertex_get_aux_240_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggVertex::set_aux(std::string const &name, LVecBase4d const &aux)
 */
static PyObject *Dtool_EggVertex_set_aux_241(PyObject *self, PyObject *args, PyObject *kwds) {
  EggVertex *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.set_aux")) {
    return nullptr;
  }
  // 1-void EggVertex::set_aux(std::string const &name, LVecBase4d const &aux)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"name", "aux", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:set_aux", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    LVecBase4d param2_local;
    LVecBase4d const *param2_this = Dtool_Coerce_LVecBase4d(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "EggVertex.set_aux", "LVecBase4d");
    }
    ((*local_this).set_aux)(std::string(param1_str, param1_len), *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_aux(const EggVertex self, str name, const LVecBase4d aux)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_set_aux_241_comment =
  "C++ Interface:\n"
  "set_aux(const EggVertex self, str name, const LVecBase4d aux)\n"
  "\n"
  "/**\n"
  " * Sets the indicated auxiliary data quadruple on the vertex.  This replaces\n"
  " * any auxiliary data with the same name already on the vertex.\n"
  " */";
#else
static const char *Dtool_EggVertex_set_aux_241_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggVertexAux const *EggVertex::get_aux_obj(std::string const &name) const
 */
static PyObject *Dtool_EggVertex_get_aux_obj_242(PyObject *self, PyObject *arg) {
  EggVertex *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertex)) {
    return nullptr;
  }
  // 1-EggVertexAux const *EggVertex::get_aux_obj(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    EggVertexAux const *return_value = ((*(const EggVertex*)local_this).get_aux_obj)(std::string(param1_str, param1_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertexAux, true, true, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_aux_obj(EggVertex self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_aux_obj_242_comment =
  "C++ Interface:\n"
  "get_aux_obj(EggVertex self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the named EggVertexAux object, which defines the auxiliary data for\n"
  " * this name.  This object might be shared between multiple vertices.  You\n"
  " * should not attempt to modify this object; instead, call modify_aux_object\n"
  " * to return a modifiable pointer.\n"
  " */";
#else
static const char *Dtool_EggVertex_get_aux_obj_242_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggVertexAux *EggVertex::modify_aux_obj(std::string const &name)
 */
static PyObject *Dtool_EggVertex_modify_aux_obj_243(PyObject *self, PyObject *arg) {
  EggVertex *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.modify_aux_obj")) {
    return nullptr;
  }
  // 1-EggVertexAux *EggVertex::modify_aux_obj(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    EggVertexAux *return_value = ((*local_this).modify_aux_obj)(std::string(param1_str, param1_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertexAux, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "modify_aux_obj(const EggVertex self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_modify_aux_obj_243_comment =
  "C++ Interface:\n"
  "modify_aux_obj(const EggVertex self, str name)\n"
  "\n"
  "/**\n"
  " * Returns a modifiable pointer to the named EggVertexAux object, which\n"
  " * defines the auxiliary data for this name.  Returns NULL if there is no such\n"
  " * named UV object.\n"
  " */";
#else
static const char *Dtool_EggVertex_modify_aux_obj_243_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggVertex::set_aux_obj(EggVertexAux *vertex_aux)
 */
static PyObject *Dtool_EggVertex_set_aux_obj_244(PyObject *self, PyObject *arg) {
  EggVertex *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.set_aux_obj")) {
    return nullptr;
  }
  // 1-void EggVertex::set_aux_obj(EggVertexAux *vertex_aux)
  EggVertexAux *arg_this = (EggVertexAux *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertexAux, 1, "EggVertex.set_aux_obj", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_aux_obj)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_aux_obj(const EggVertex self, EggVertexAux vertex_aux)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_set_aux_obj_244_comment =
  "C++ Interface:\n"
  "set_aux_obj(const EggVertex self, EggVertexAux vertex_aux)\n"
  "\n"
  "/**\n"
  " * Sets the indicated EggVertexAux on the vertex.  This replaces any auxiliary\n"
  " * data with the same name already on the vertex.\n"
  " */";
#else
static const char *Dtool_EggVertex_set_aux_obj_244_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< EggVertex > EggVertex::make_average(EggVertex const *first, EggVertex const *second)
 */
static PyObject *Dtool_EggVertex_make_average_245(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static PointerTo< EggVertex > EggVertex::make_average(EggVertex const *first, EggVertex const *second)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"first", "second", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:make_average", (char **)keyword_list, &param0, &param1)) {
    EggVertex const *param0_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_EggVertex, 0, "EggVertex.make_average", true, true);
    EggVertex const *param1_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_EggVertex, 1, "EggVertex.make_average", true, true);
    if (param0_this != nullptr && param1_this != nullptr) {
      PointerTo< EggVertex > return_value = (EggVertex::make_average)(param0_this, param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      EggVertex *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_EggVertex, true, false, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_average(const EggVertex first, const EggVertex second)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_make_average_245_comment =
  "C++ Interface:\n"
  "make_average(const EggVertex first, const EggVertex second)\n"
  "\n"
  "/**\n"
  " * Creates a new vertex that lies in between the two given vertices.  The\n"
  " * attributes for the UV sets they have in common are averaged.\n"
  " *\n"
  " * Both vertices need to be either in no pool, or in the same pool.  In the\n"
  " * latter case, the new vertex will be placed in that pool.\n"
  " */";
#else
static const char *Dtool_EggVertex_make_average_245_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggVertex::get_index(void) const
 */
static PyObject *Dtool_EggVertex_get_index_246(PyObject *self, PyObject *) {
  EggVertex *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertex)) {
    return nullptr;
  }
  // 1-inline int EggVertex::get_index(void) const
  int return_value = ((*(const EggVertex*)local_this).get_index)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_index_246_comment =
  "C++ Interface:\n"
  "get_index(EggVertex self)\n"
  "\n"
  "/**\n"
  " * Returns the index number of the vertex within its pool.\n"
  " */";
#else
static const char *Dtool_EggVertex_get_index_246_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertex::set_external_index(int external_index)
 */
static PyObject *Dtool_EggVertex_set_external_index_247(PyObject *self, PyObject *arg) {
  EggVertex *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.set_external_index")) {
    return nullptr;
  }
  // 1-inline void EggVertex::set_external_index(int external_index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_external_index)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_external_index(const EggVertex self, int external_index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_set_external_index_247_comment =
  "C++ Interface:\n"
  "set_external_index(const EggVertex self, int external_index)\n"
  "\n"
  "/**\n"
  " * Sets a special index number that is associated with the EggVertex (but is\n"
  " * not written to the egg file). This number is not interpreted by any egg\n"
  " * code; it is simply maintained along with the vertex.  It *is* used to\n"
  " * differentiate otherwise identical vertices in\n"
  " * EggVertexPool::create_unique_vertex(), however.\n"
  " *\n"
  " * The intention of this number is as an aid for file converters, to associate\n"
  " * an EggVertex back to the index number of the original source vertex.\n"
  " */";
#else
static const char *Dtool_EggVertex_set_external_index_247_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggVertex::get_external_index(void) const
 */
static PyObject *Dtool_EggVertex_get_external_index_248(PyObject *self, PyObject *) {
  EggVertex *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertex)) {
    return nullptr;
  }
  // 1-inline int EggVertex::get_external_index(void) const
  int return_value = ((*(const EggVertex*)local_this).get_external_index)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_external_index_248_comment =
  "C++ Interface:\n"
  "get_external_index(EggVertex self)\n"
  "\n"
  "/**\n"
  " * Returns the number set by set_external_index().  See set_external_index().\n"
  " */";
#else
static const char *Dtool_EggVertex_get_external_index_248_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggVertex::set_external_index2(int external_index2)
 */
static PyObject *Dtool_EggVertex_set_external_index2_249(PyObject *self, PyObject *arg) {
  EggVertex *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.set_external_index2")) {
    return nullptr;
  }
  // 1-inline void EggVertex::set_external_index2(int external_index2)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_external_index2)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_external_index2(const EggVertex self, int external_index2)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_set_external_index2_249_comment =
  "C++ Interface:\n"
  "set_external_index2(const EggVertex self, int external_index2)\n"
  "\n"
  "/**\n"
  " * Similar to set_external_index(), but this is a different number which may\n"
  " * be used for a different purpose by the calling code.  The egg library does\n"
  " * not assign any meaning to this number or use it in any way.\n"
  " */";
#else
static const char *Dtool_EggVertex_set_external_index2_249_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggVertex::get_external_index2(void) const
 */
static PyObject *Dtool_EggVertex_get_external_index2_250(PyObject *self, PyObject *) {
  EggVertex *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertex)) {
    return nullptr;
  }
  // 1-inline int EggVertex::get_external_index2(void) const
  int return_value = ((*(const EggVertex*)local_this).get_external_index2)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_external_index2_250_comment =
  "C++ Interface:\n"
  "get_external_index2(EggVertex self)\n"
  "\n"
  "/**\n"
  " * Returns the number set by set_external_index2().  See\n"
  " * set_external_index2().\n"
  " */";
#else
static const char *Dtool_EggVertex_get_external_index2_250_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggVertex::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_EggVertex_write_251(PyObject *self, PyObject *args, PyObject *kwds) {
  EggVertex *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertex)) {
    return nullptr;
  }
  // 1-void EggVertex::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "EggVertex.write", false, true);
    if (param1_this != nullptr) {
      ((*(const EggVertex*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(EggVertex self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_write_251_comment =
  "C++ Interface:\n"
  "write(EggVertex self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes the vertex to the indicated output stream in Egg format.\n"
  " */";
#else
static const char *Dtool_EggVertex_write_251_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggVertex::sorts_less_than(EggVertex const &other) const
 */
static PyObject *Dtool_EggVertex_sorts_less_than_252(PyObject *self, PyObject *arg) {
  EggVertex *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertex)) {
    return nullptr;
  }
  // 1-inline bool EggVertex::sorts_less_than(EggVertex const &other) const
  EggVertex const *arg_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertex, 1, "EggVertex.sorts_less_than", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const EggVertex*)local_this).sorts_less_than)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "sorts_less_than(EggVertex self, const EggVertex other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_sorts_less_than_252_comment =
  "C++ Interface:\n"
  "sorts_less_than(EggVertex self, const EggVertex other)\n"
  "\n"
  "/**\n"
  " * An ordering operator to compare two vertices for sorting order.  This\n"
  " * imposes an arbitrary ordering useful to identify unique vertices.\n"
  " */";
#else
static const char *Dtool_EggVertex_sorts_less_than_252_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int EggVertex::compare_to(EggVertex const &other) const
 */
static PyObject *Dtool_EggVertex_compare_to_253(PyObject *self, PyObject *arg) {
  EggVertex *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertex)) {
    return nullptr;
  }
  // 1-int EggVertex::compare_to(EggVertex const &other) const
  EggVertex const *arg_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertex, 1, "EggVertex.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const EggVertex*)local_this).compare_to)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(EggVertex self, const EggVertex other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_compare_to_253_comment =
  "C++ Interface:\n"
  "compare_to(EggVertex self, const EggVertex other)\n"
  "\n"
  "/**\n"
  " * An ordering operator to compare two vertices for sorting order.  This\n"
  " * imposes an arbitrary ordering useful to identify unique vertices.\n"
  " *\n"
  " * Group membership is not considered in this comparison.  This is somewhat\n"
  " * problematic, but cannot easily be helped, because considering group\n"
  " * membership would make it difficult to add and remove groups from vertices.\n"
  " * It also makes it impossible to meaningfully compare with a concrete\n"
  " * EggVertex object (which cannot have group memberships).\n"
  " *\n"
  " * However, this is not altogether bad, because two vertices that are\n"
  " * identical in all other properties should generally also be identical in\n"
  " * group memberships, else the vertices will tend to fly apart when the joints\n"
  " * animate.\n"
  " */";
#else
static const char *Dtool_EggVertex_compare_to_253_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int EggVertex::get_num_local_coord(void) const
 */
static PyObject *Dtool_EggVertex_get_num_local_coord_254(PyObject *self, PyObject *) {
  EggVertex *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertex)) {
    return nullptr;
  }
  // 1-int EggVertex::get_num_local_coord(void) const
  int return_value = ((*(const EggVertex*)local_this).get_num_local_coord)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_num_local_coord_254_comment =
  "C++ Interface:\n"
  "get_num_local_coord(EggVertex self)\n"
  "\n"
  "/**\n"
  " * Returns the number of primitives that own this vertex whose vertices are\n"
  " * interpreted to be in a local coordinate system.\n"
  " */";
#else
static const char *Dtool_EggVertex_get_num_local_coord_254_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int EggVertex::get_num_global_coord(void) const
 */
static PyObject *Dtool_EggVertex_get_num_global_coord_255(PyObject *self, PyObject *) {
  EggVertex *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertex)) {
    return nullptr;
  }
  // 1-int EggVertex::get_num_global_coord(void) const
  int return_value = ((*(const EggVertex*)local_this).get_num_global_coord)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_num_global_coord_255_comment =
  "C++ Interface:\n"
  "get_num_global_coord(EggVertex self)\n"
  "\n"
  "/**\n"
  " * Returns the number of primitives that own this vertex whose vertices are\n"
  " * interpreted in the global coordinate system.\n"
  " */";
#else
static const char *Dtool_EggVertex_get_num_global_coord_255_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggVertex::transform(LMatrix4d const &mat)
 */
static PyObject *Dtool_EggVertex_transform_256(PyObject *self, PyObject *arg) {
  EggVertex *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.transform")) {
    return nullptr;
  }
  // 1-void EggVertex::transform(LMatrix4d const &mat)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggVertex.transform", "LMatrix4d");
  }
  ((*local_this).transform)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "transform(const EggVertex self, const LMatrix4d mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_transform_256_comment =
  "C++ Interface:\n"
  "transform(const EggVertex self, const LMatrix4d mat)\n"
  "\n"
  "/**\n"
  " * Applies the indicated transformation matrix to the vertex.\n"
  " */";
#else
static const char *Dtool_EggVertex_transform_256_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggVertex::has_gref(EggGroup const *group) const
 */
static PyObject *Dtool_EggVertex_has_gref_257(PyObject *self, PyObject *arg) {
  EggVertex *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertex)) {
    return nullptr;
  }
  // 1-bool EggVertex::has_gref(EggGroup const *group) const
  EggGroup const *arg_this = (EggGroup *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggGroup, 1, "EggVertex.has_gref", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const EggVertex*)local_this).has_gref)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_gref(EggVertex self, const EggGroup group)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_has_gref_257_comment =
  "C++ Interface:\n"
  "has_gref(EggVertex self, const EggGroup group)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated group references this vertex, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_EggVertex_has_gref_257_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggVertex::copy_grefs_from(EggVertex const &other)
 */
static PyObject *Dtool_EggVertex_copy_grefs_from_258(PyObject *self, PyObject *arg) {
  EggVertex *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.copy_grefs_from")) {
    return nullptr;
  }
  // 1-void EggVertex::copy_grefs_from(EggVertex const &other)
  EggVertex const *arg_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertex, 1, "EggVertex.copy_grefs_from", true, true);
  if (arg_this != nullptr) {
    ((*local_this).copy_grefs_from)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_grefs_from(const EggVertex self, const EggVertex other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_copy_grefs_from_258_comment =
  "C++ Interface:\n"
  "copy_grefs_from(const EggVertex self, const EggVertex other)\n"
  "\n"
  "/**\n"
  " * Copies all the group references from the other vertex onto this one.  This\n"
  " * assigns the current vertex to exactly the same groups, with exactly the\n"
  " * same memberships, as the given one.\n"
  " *\n"
  " * Warning: only an EggVertex allocated from the free store may have groups\n"
  " * assigned to it.  Do not attempt to call this on a temporary concrete\n"
  " * EggVertex object; a core dump will certainly result.\n"
  " */";
#else
static const char *Dtool_EggVertex_copy_grefs_from_258_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggVertex::clear_grefs(void)
 */
static PyObject *Dtool_EggVertex_clear_grefs_259(PyObject *self, PyObject *) {
  EggVertex *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.clear_grefs")) {
    return nullptr;
  }
  // 1-void EggVertex::clear_grefs(void)
  ((*local_this).clear_grefs)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_clear_grefs_259_comment =
  "C++ Interface:\n"
  "clear_grefs(const EggVertex self)\n"
  "\n"
  "/**\n"
  " * Removes all group references from the vertex, so that it is not assigned to\n"
  " * any group.\n"
  " */";
#else
static const char *Dtool_EggVertex_clear_grefs_259_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int EggVertex::has_pref(EggPrimitive const *prim) const
 */
static PyObject *Dtool_EggVertex_has_pref_260(PyObject *self, PyObject *arg) {
  EggVertex *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertex)) {
    return nullptr;
  }
  // 1-int EggVertex::has_pref(EggPrimitive const *prim) const
  EggPrimitive const *arg_this = (EggPrimitive *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggPrimitive, 1, "EggVertex.has_pref", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const EggVertex*)local_this).has_pref)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_pref(EggVertex self, const EggPrimitive prim)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_has_pref_260_comment =
  "C++ Interface:\n"
  "has_pref(EggVertex self, const EggPrimitive prim)\n"
  "\n"
  "/**\n"
  " * Returns the number of times the vertex appears in the indicated primitive,\n"
  " * or 0 if it does not appear.\n"
  " */";
#else
static const char *Dtool_EggVertex_has_pref_260_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggVertex::test_gref_integrity(void) const
 */
static PyObject *Dtool_EggVertex_test_gref_integrity_261(PyObject *self, PyObject *) {
  EggVertex *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertex)) {
    return nullptr;
  }
  // 1-void EggVertex::test_gref_integrity(void) const
  ((*(const EggVertex*)local_this).test_gref_integrity)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_test_gref_integrity_261_comment =
  "C++ Interface:\n"
  "test_gref_integrity(EggVertex self)\n";
#else
static const char *Dtool_EggVertex_test_gref_integrity_261_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggVertex::test_pref_integrity(void) const
 */
static PyObject *Dtool_EggVertex_test_pref_integrity_262(PyObject *self, PyObject *) {
  EggVertex *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertex)) {
    return nullptr;
  }
  // 1-void EggVertex::test_pref_integrity(void) const
  ((*(const EggVertex*)local_this).test_pref_integrity)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_test_pref_integrity_262_comment =
  "C++ Interface:\n"
  "test_pref_integrity(EggVertex self)\n";
#else
static const char *Dtool_EggVertex_test_pref_integrity_262_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggVertex::output(std::ostream &out) const
 */
static PyObject *Dtool_EggVertex_output_263(PyObject *self, PyObject *arg) {
  EggVertex *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertex)) {
    return nullptr;
  }
  // 1-void EggVertex::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "EggVertex.output", false, true);
  if (arg_this != nullptr) {
    ((*(const EggVertex*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(EggVertex self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_output_263_comment =
  "C++ Interface:\n"
  "output(EggVertex self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggVertex_output_263_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggVertex::get_class_type(void)
 */
static PyObject *Dtool_EggVertex_get_class_type_268(PyObject *, PyObject *) {
  // 1-static TypeHandle EggVertex::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggVertex::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_get_class_type_268_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggVertex_get_class_type_268_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggObject *EggVertex::upcast_to_EggObject(void)
 */
static PyObject *Dtool_EggVertex_upcast_to_EggObject_212(PyObject *self, PyObject *) {
  EggVertex *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.upcast_to_EggObject")) {
    return nullptr;
  }
  // 1-EggObject *EggVertex::upcast_to_EggObject(void)
  EggObject *return_value = (EggObject *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_upcast_to_EggObject_212_comment =
  "C++ Interface:\n"
  "upcast_to_EggObject(const EggVertex self)\n"
  "\n"
  "upcast from EggVertex to EggObject";
#else
static const char *Dtool_EggVertex_upcast_to_EggObject_212_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggAttributes *EggVertex::upcast_to_EggAttributes(void)
 */
static PyObject *Dtool_EggVertex_upcast_to_EggAttributes_214(PyObject *self, PyObject *) {
  EggVertex *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertex, (void **)&local_this, "EggVertex.upcast_to_EggAttributes")) {
    return nullptr;
  }
  // 1-EggAttributes *EggVertex::upcast_to_EggAttributes(void)
  EggAttributes *return_value = (EggAttributes *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggAttributes, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggVertex_upcast_to_EggAttributes_214_comment =
  "C++ Interface:\n"
  "upcast_to_EggAttributes(const EggVertex self)\n"
  "\n"
  "upcast from EggVertex to EggAttributes";
#else
static const char *Dtool_EggVertex_upcast_to_EggAttributes_214_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggVertex::EggVertex(void)
 * EggVertex::EggVertex(EggVertex const &copy)
 */
static int Dtool_Init_EggVertex(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-EggVertex::EggVertex(void)
      EggVertex *return_value = new EggVertex();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggVertex, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-EggVertex::EggVertex(EggVertex const &copy)
        EggVertex const *arg_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertex, 0, "EggVertex.EggVertex", true, true);
        if (arg_this != nullptr) {
          EggVertex *return_value = new EggVertex(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggVertex, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggVertex() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggVertex()\n"
      "EggVertex(const EggVertex copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggVertex(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggVertex) {
    printf("EggVertex ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggVertex *local_this = (EggVertex *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggVertex) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggAttributes) {
    return (EggAttributes *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggVertex(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggVertex) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggAttributes) {
    EggAttributes* other_this = (EggAttributes*)from_this;
    return (EggVertex*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggVertex*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggVertex*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggVertex*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggVertex*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggVertexPool
 */
/**
 * Python function wrapper for:
 * inline bool EggVertexPool::has_vertex(int index) const
 */
static PyObject *Dtool_EggVertexPool_has_vertex_271(PyObject *self, PyObject *arg) {
  EggVertexPool *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertexPool)) {
    return nullptr;
  }
  // 1-inline bool EggVertexPool::has_vertex(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*(const EggVertexPool*)local_this).has_vertex)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_vertex(EggVertexPool self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_has_vertex_271_comment =
  "C++ Interface:\n"
  "has_vertex(EggVertexPool self, int index)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated vertex has been defined in the vertex pool,\n"
  " * false otherwise.  This does not include forward references.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_has_vertex_271_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggVertexPool::has_forward_vertices(void) const
 */
static PyObject *Dtool_EggVertexPool_has_forward_vertices_272(PyObject *self, PyObject *) {
  EggVertexPool *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertexPool)) {
    return nullptr;
  }
  // 1-bool EggVertexPool::has_forward_vertices(void) const
  bool return_value = ((*(const EggVertexPool*)local_this).has_forward_vertices)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_has_forward_vertices_272_comment =
  "C++ Interface:\n"
  "has_forward_vertices(EggVertexPool self)\n"
  "\n"
  "/**\n"
  " * Returns true if any vertices in the pool are undefined forward-reference\n"
  " * vertices, false if all vertices are defined.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_has_forward_vertices_272_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggVertexPool::has_defined_vertices(void) const
 */
static PyObject *Dtool_EggVertexPool_has_defined_vertices_273(PyObject *self, PyObject *) {
  EggVertexPool *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertexPool)) {
    return nullptr;
  }
  // 1-bool EggVertexPool::has_defined_vertices(void) const
  bool return_value = ((*(const EggVertexPool*)local_this).has_defined_vertices)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_has_defined_vertices_273_comment =
  "C++ Interface:\n"
  "has_defined_vertices(EggVertexPool self)\n"
  "\n"
  "/**\n"
  " * Returns true if any vertices in the pool are fully defined vertices, false\n"
  " * if all vertices are forward references.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_has_defined_vertices_273_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggVertex *EggVertexPool::get_vertex(int index) const
 */
static PyObject *Dtool_EggVertexPool_get_vertex_274(PyObject *self, PyObject *arg) {
  EggVertexPool *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertexPool)) {
    return nullptr;
  }
  // 1-EggVertex *EggVertexPool::get_vertex(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    EggVertex *return_value = ((*(const EggVertexPool*)local_this).get_vertex)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex(EggVertexPool self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_get_vertex_274_comment =
  "C++ Interface:\n"
  "get_vertex(EggVertexPool self, int index)\n"
  "\n"
  "// Returns NULL if there is no such vertex.\n"
  "\n"
  "/**\n"
  " * Returns the vertex in the pool with the indicated index number, or NULL if\n"
  " * no vertices have that index number.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_get_vertex_274_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggVertex *EggVertexPool::get_forward_vertex(int index)
 */
static PyObject *Dtool_EggVertexPool_get_forward_vertex_276(PyObject *self, PyObject *arg) {
  EggVertexPool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexPool, (void **)&local_this, "EggVertexPool.get_forward_vertex")) {
    return nullptr;
  }
  // 1-EggVertex *EggVertexPool::get_forward_vertex(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    EggVertex *return_value = ((*local_this).get_forward_vertex)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_forward_vertex(const EggVertexPool self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_get_forward_vertex_276_comment =
  "C++ Interface:\n"
  "get_forward_vertex(const EggVertexPool self, int index)\n"
  "\n"
  "// Returns a forward reference if there is no such vertex.\n"
  "\n"
  "/**\n"
  " * Returns the vertex in the pool with the indicated index number.  If there\n"
  " * is not a vertex in the pool with the indicated index number, creates a\n"
  " * special forward-reference EggVertex that has no data, on the assumption\n"
  " * that the vertex pool has not yet been fully read and more data will be\n"
  " * available later.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_get_forward_vertex_276_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int EggVertexPool::get_highest_index(void) const
 */
static PyObject *Dtool_EggVertexPool_get_highest_index_277(PyObject *self, PyObject *) {
  EggVertexPool *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertexPool)) {
    return nullptr;
  }
  // 1-int EggVertexPool::get_highest_index(void) const
  int return_value = ((*(const EggVertexPool*)local_this).get_highest_index)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_get_highest_index_277_comment =
  "C++ Interface:\n"
  "get_highest_index(EggVertexPool self)\n"
  "\n"
  "// Returns 0 if the pool is empty.\n"
  "\n"
  "/**\n"
  " * Returns the highest index number used by any vertex in the pool (except\n"
  " * forward references).  Returns -1 if the pool is empty.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_get_highest_index_277_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggVertexPool::set_highest_index(int highest_index)
 */
static PyObject *Dtool_EggVertexPool_set_highest_index_278(PyObject *self, PyObject *arg) {
  EggVertexPool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexPool, (void **)&local_this, "EggVertexPool.set_highest_index")) {
    return nullptr;
  }
  // 1-void EggVertexPool::set_highest_index(int highest_index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_highest_index)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_highest_index(const EggVertexPool self, int highest_index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_set_highest_index_278_comment =
  "C++ Interface:\n"
  "set_highest_index(const EggVertexPool self, int highest_index)\n"
  "\n"
  "/**\n"
  " * Artificially changes the \"highest index number\", so that a newly created\n"
  " * vertex will begin at this number plus 1.  This can be used to default a\n"
  " * vertex pool to start counting at 1 (or any other index number), instead of\n"
  " * the default of 0.  Use with caution.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_set_highest_index_278_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int EggVertexPool::get_num_dimensions(void) const
 */
static PyObject *Dtool_EggVertexPool_get_num_dimensions_279(PyObject *self, PyObject *) {
  EggVertexPool *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertexPool)) {
    return nullptr;
  }
  // 1-int EggVertexPool::get_num_dimensions(void) const
  int return_value = ((*(const EggVertexPool*)local_this).get_num_dimensions)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_get_num_dimensions_279_comment =
  "C++ Interface:\n"
  "get_num_dimensions(EggVertexPool self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum number of dimensions used by any vertex in the pool.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_get_num_dimensions_279_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggVertexPool::has_normals(void) const
 */
static PyObject *Dtool_EggVertexPool_has_normals_280(PyObject *self, PyObject *) {
  EggVertexPool *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertexPool)) {
    return nullptr;
  }
  // 1-virtual bool EggVertexPool::has_normals(void) const
  bool return_value = ((*(const EggVertexPool*)local_this).has_normals)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_has_normals_280_comment =
  "C++ Interface:\n"
  "has_normals(EggVertexPool self)\n"
  "\n"
  "/**\n"
  " * Returns true if any vertex in the pool has a normal defined, false if none\n"
  " * of them do.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_has_normals_280_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggVertexPool::has_colors(void) const
 */
static PyObject *Dtool_EggVertexPool_has_colors_281(PyObject *self, PyObject *) {
  EggVertexPool *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertexPool)) {
    return nullptr;
  }
  // 1-bool EggVertexPool::has_colors(void) const
  bool return_value = ((*(const EggVertexPool*)local_this).has_colors)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_has_colors_281_comment =
  "C++ Interface:\n"
  "has_colors(EggVertexPool self)\n"
  "\n"
  "/**\n"
  " * Returns true if any vertex in the pool has a color defined, false if none\n"
  " * of them do.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_has_colors_281_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggVertexPool::has_nonwhite_colors(void) const
 */
static PyObject *Dtool_EggVertexPool_has_nonwhite_colors_282(PyObject *self, PyObject *) {
  EggVertexPool *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertexPool)) {
    return nullptr;
  }
  // 1-bool EggVertexPool::has_nonwhite_colors(void) const
  bool return_value = ((*(const EggVertexPool*)local_this).has_nonwhite_colors)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_has_nonwhite_colors_282_comment =
  "C++ Interface:\n"
  "has_nonwhite_colors(EggVertexPool self)\n"
  "\n"
  "/**\n"
  " * Returns true if any vertex in the pool has a color defined other than\n"
  " * white, false if no vertices have colors, or if all colors are white.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_has_nonwhite_colors_282_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggVertexPool::has_uvs(void) const
 */
static PyObject *Dtool_EggVertexPool_has_uvs_284(PyObject *self, PyObject *) {
  EggVertexPool *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertexPool)) {
    return nullptr;
  }
  // 1-bool EggVertexPool::has_uvs(void) const
  bool return_value = ((*(const EggVertexPool*)local_this).has_uvs)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_has_uvs_284_comment =
  "C++ Interface:\n"
  "has_uvs(EggVertexPool self)\n"
  "\n"
  "/**\n"
  " * Returns true if any vertex in the pool has a uv defined, false if none of\n"
  " * them do.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_has_uvs_284_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggVertexPool::has_aux(void) const
 */
static PyObject *Dtool_EggVertexPool_has_aux_285(PyObject *self, PyObject *) {
  EggVertexPool *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggVertexPool)) {
    return nullptr;
  }
  // 1-bool EggVertexPool::has_aux(void) const
  bool return_value = ((*(const EggVertexPool*)local_this).has_aux)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_has_aux_285_comment =
  "C++ Interface:\n"
  "has_aux(EggVertexPool self)\n"
  "\n"
  "/**\n"
  " * Returns true if any vertex in the pool has auxiliary data defined, false if\n"
  " * none of them do.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_has_aux_285_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggVertex *EggVertexPool::add_vertex(EggVertex *vertex, int index = -1)
 */
static PyObject *Dtool_EggVertexPool_add_vertex_289(PyObject *self, PyObject *args, PyObject *kwds) {
  EggVertexPool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexPool, (void **)&local_this, "EggVertexPool.add_vertex")) {
    return nullptr;
  }
  // 1-EggVertex *EggVertexPool::add_vertex(EggVertex *vertex, int index = -1)
  PyObject *param1;
  int param2 = -1;
  static const char *keyword_list[] = {"vertex", "index", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:add_vertex", (char **)keyword_list, &param1, &param2)) {
    EggVertex *param1_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_EggVertex, 1, "EggVertexPool.add_vertex", false, true);
    if (param1_this != nullptr) {
      EggVertex *return_value = ((*local_this).add_vertex)(param1_this, (int)param2);
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_vertex(const EggVertexPool self, EggVertex vertex, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_add_vertex_289_comment =
  "C++ Interface:\n"
  "add_vertex(const EggVertexPool self, EggVertex vertex, int index)\n"
  "\n"
  "// add_vertex() adds a freshly-allocated vertex.  It is up to the user to\n"
  "// allocate the vertex.\n"
  "\n"
  "/**\n"
  " * Adds the indicated vertex to the pool.  It is an error if the vertex is\n"
  " * already a member of this or any other pool.  The vertex must have been\n"
  " * allocated from the free store; its pointer will now be owned by the vertex\n"
  " * pool.  If the index number is supplied, tries to assign that index number;\n"
  " * it is an error if the index number is already in use.\n"
  " *\n"
  " * It is possible that a forward reference to this vertex was requested in the\n"
  " * past; if so, the data from the supplied vertex is copied onto the forward\n"
  " * reference, which becomes the actual vertex.  In this case, a different\n"
  " * pointer is saved (and returned) than the one actually passed in.  In the\n"
  " * usual case, however, the vertex pointer passed in is the one that is saved\n"
  " * in the vertex pool and returned from this method.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_add_vertex_289_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggVertex *EggVertexPool::make_new_vertex(void)
 * inline EggVertex *EggVertexPool::make_new_vertex(LPoint2d const &pos)
 * inline EggVertex *EggVertexPool::make_new_vertex(LPoint3d const &pos)
 * inline EggVertex *EggVertexPool::make_new_vertex(LPoint4d const &pos)
 * inline EggVertex *EggVertexPool::make_new_vertex(double pos)
 */
static PyObject *Dtool_EggVertexPool_make_new_vertex_290(PyObject *self, PyObject *args) {
  EggVertexPool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexPool, (void **)&local_this, "EggVertexPool.make_new_vertex")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline EggVertex *EggVertexPool::make_new_vertex(void)
      EggVertex *return_value = ((*local_this).make_new_vertex)();
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      {
        // -2 inline EggVertex *EggVertexPool::make_new_vertex(LPoint2d const &pos)
        LPoint2d const *arg_this = nullptr;
        DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LPoint2d);
        if (arg_this != nullptr) {
          EggVertex *return_value = ((*local_this).make_new_vertex)(*arg_this);
          if (return_value != nullptr) {
            return_value->ref();
          }
          if (Dtool_CheckErrorOccurred()) {
            if (return_value != nullptr) {
              unref_delete(return_value);
            }
            return nullptr;
          }
          if (return_value == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
          }
        }
      }

      {
        // -2 inline EggVertex *EggVertexPool::make_new_vertex(LPoint3d const &pos)
        LPoint3d const *arg_this = nullptr;
        DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LPoint3d);
        if (arg_this != nullptr) {
          EggVertex *return_value = ((*local_this).make_new_vertex)(*arg_this);
          if (return_value != nullptr) {
            return_value->ref();
          }
          if (Dtool_CheckErrorOccurred()) {
            if (return_value != nullptr) {
              unref_delete(return_value);
            }
            return nullptr;
          }
          if (return_value == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
          }
        }
      }

      {
        // -2 inline EggVertex *EggVertexPool::make_new_vertex(LPoint4d const &pos)
        LPoint4d const *arg_this = nullptr;
        DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LPoint4d);
        if (arg_this != nullptr) {
          EggVertex *return_value = ((*local_this).make_new_vertex)(*arg_this);
          if (return_value != nullptr) {
            return_value->ref();
          }
          if (Dtool_CheckErrorOccurred()) {
            if (return_value != nullptr) {
              unref_delete(return_value);
            }
            return nullptr;
          }
          if (return_value == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
          }
        }
      }

      {
        // -2 inline EggVertex *EggVertexPool::make_new_vertex(double pos)
        if (PyNumber_Check(arg)) {
          EggVertex *return_value = ((*local_this).make_new_vertex)(PyFloat_AsDouble(arg));
          if (return_value != nullptr) {
            return_value->ref();
          }
          if (Dtool_CheckErrorOccurred()) {
            if (return_value != nullptr) {
              unref_delete(return_value);
            }
            return nullptr;
          }
          if (return_value == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
          }
        }
      }

      {
        // -2 inline EggVertex *EggVertexPool::make_new_vertex(LPoint2d const &pos)
        LPoint2d arg_local;
        LPoint2d const *arg_this = Dtool_Coerce_LPoint2d(arg, arg_local);
        if ((arg_this != nullptr)) {
          EggVertex *return_value = ((*local_this).make_new_vertex)(*arg_this);
          if (return_value != nullptr) {
            return_value->ref();
          }
          if (Dtool_CheckErrorOccurred()) {
            if (return_value != nullptr) {
              unref_delete(return_value);
            }
            return nullptr;
          }
          if (return_value == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
          }
        }
      }

      {
        // -2 inline EggVertex *EggVertexPool::make_new_vertex(LPoint3d const &pos)
        LPoint3d arg_local;
        LPoint3d const *arg_this = Dtool_Coerce_LPoint3d(arg, arg_local);
        if ((arg_this != nullptr)) {
          EggVertex *return_value = ((*local_this).make_new_vertex)(*arg_this);
          if (return_value != nullptr) {
            return_value->ref();
          }
          if (Dtool_CheckErrorOccurred()) {
            if (return_value != nullptr) {
              unref_delete(return_value);
            }
            return nullptr;
          }
          if (return_value == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
          }
        }
      }

      {
        // -2 inline EggVertex *EggVertexPool::make_new_vertex(LPoint4d const &pos)
        LPoint4d arg_local;
        LPoint4d const *arg_this = Dtool_Coerce_LPoint4d(arg, arg_local);
        if ((arg_this != nullptr)) {
          EggVertex *return_value = ((*local_this).make_new_vertex)(*arg_this);
          if (return_value != nullptr) {
            return_value->ref();
          }
          if (Dtool_CheckErrorOccurred()) {
            if (return_value != nullptr) {
              unref_delete(return_value);
            }
            return nullptr;
          }
          if (return_value == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
          }
        }
      }

      // No coercion possible: inline EggVertex *EggVertexPool::make_new_vertex(double pos)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make_new_vertex() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_new_vertex(const EggVertexPool self)\n"
      "make_new_vertex(const EggVertexPool self, const LPoint2d pos)\n"
      "make_new_vertex(const EggVertexPool self, const LPoint3d pos)\n"
      "make_new_vertex(const EggVertexPool self, const LPoint4d pos)\n"
      "make_new_vertex(const EggVertexPool self, double pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_make_new_vertex_290_comment =
  "C++ Interface:\n"
  "make_new_vertex(const EggVertexPool self)\n"
  "make_new_vertex(const EggVertexPool self, const LPoint2d pos)\n"
  "make_new_vertex(const EggVertexPool self, const LPoint3d pos)\n"
  "make_new_vertex(const EggVertexPool self, const LPoint4d pos)\n"
  "make_new_vertex(const EggVertexPool self, double pos)\n"
  "\n"
  "// make_new_vertex() allocates and returns a new vertex from the pool.\n"
  "\n"
  "/**\n"
  " * Allocates and returns a new vertex from the pool.  This is one of three\n"
  " * ways to add new vertices to a vertex pool.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Allocates and returns a new vertex from the pool.  This is one of three\n"
  " * ways to add new vertices to a vertex pool.\n"
  " *\n"
  " * This flavor of make_new_vertex() explicitly sets the vertex position as it\n"
  " * is allocated.  It does not attempt to share vertices.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Allocates and returns a new vertex from the pool.  This is one of three\n"
  " * ways to add new vertices to a vertex pool.\n"
  " *\n"
  " * This flavor of make_new_vertex() explicitly sets the vertex position as it\n"
  " * is allocated.  It does not attempt to share vertices.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Allocates and returns a new vertex from the pool.  This is one of three\n"
  " * ways to add new vertices to a vertex pool.\n"
  " *\n"
  " * This flavor of make_new_vertex() explicitly sets the vertex position as it\n"
  " * is allocated.  It does not attempt to share vertices.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Allocates and returns a new vertex from the pool.  This is one of three\n"
  " * ways to add new vertices to a vertex pool.\n"
  " *\n"
  " * This flavor of make_new_vertex() explicitly sets the vertex position as it\n"
  " * is allocated.  It does not attempt to share vertices.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_make_new_vertex_290_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggVertex *EggVertexPool::create_unique_vertex(EggVertex const &copy)
 */
static PyObject *Dtool_EggVertexPool_create_unique_vertex_291(PyObject *self, PyObject *arg) {
  EggVertexPool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexPool, (void **)&local_this, "EggVertexPool.create_unique_vertex")) {
    return nullptr;
  }
  // 1-EggVertex *EggVertexPool::create_unique_vertex(EggVertex const &copy)
  EggVertex const *arg_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertex, 1, "EggVertexPool.create_unique_vertex", true, true);
  if (arg_this != nullptr) {
    EggVertex *return_value = ((*local_this).create_unique_vertex)(*arg_this);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "create_unique_vertex(const EggVertexPool self, const EggVertex copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_create_unique_vertex_291_comment =
  "C++ Interface:\n"
  "create_unique_vertex(const EggVertexPool self, const EggVertex copy)\n"
  "\n"
  "// create_unique_vertex() creates a new vertex if there is not already one\n"
  "// identical to the indicated vertex, or returns the existing one if there\n"
  "// is.\n"
  "\n"
  "/**\n"
  " * Creates a new vertex in the pool that is a copy of the indicated one and\n"
  " * returns it.  If there is already a vertex in the pool like the indicated\n"
  " * one, simply returns that one.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_create_unique_vertex_291_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggVertex *EggVertexPool::find_matching_vertex(EggVertex const &copy)
 */
static PyObject *Dtool_EggVertexPool_find_matching_vertex_292(PyObject *self, PyObject *arg) {
  EggVertexPool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexPool, (void **)&local_this, "EggVertexPool.find_matching_vertex")) {
    return nullptr;
  }
  // 1-EggVertex *EggVertexPool::find_matching_vertex(EggVertex const &copy)
  EggVertex const *arg_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertex, 1, "EggVertexPool.find_matching_vertex", true, true);
  if (arg_this != nullptr) {
    EggVertex *return_value = ((*local_this).find_matching_vertex)(*arg_this);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_matching_vertex(const EggVertexPool self, const EggVertex copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_find_matching_vertex_292_comment =
  "C++ Interface:\n"
  "find_matching_vertex(const EggVertexPool self, const EggVertex copy)\n"
  "\n"
  "/**\n"
  " * If the EggVertexPool already has a vertex matching the indicated vertex,\n"
  " * returns it; otherwise, returns NULL.  This is similar to\n"
  " * create_unique_vertex() except that a new vertex is never created.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_find_matching_vertex_292_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggVertexPool::remove_vertex(EggVertex *vertex)
 */
static PyObject *Dtool_EggVertexPool_remove_vertex_293(PyObject *self, PyObject *arg) {
  EggVertexPool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexPool, (void **)&local_this, "EggVertexPool.remove_vertex")) {
    return nullptr;
  }
  // 1-void EggVertexPool::remove_vertex(EggVertex *vertex)
  EggVertex *arg_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertex, 1, "EggVertexPool.remove_vertex", false, true);
  if (arg_this != nullptr) {
    ((*local_this).remove_vertex)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_vertex(const EggVertexPool self, EggVertex vertex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_remove_vertex_293_comment =
  "C++ Interface:\n"
  "remove_vertex(const EggVertexPool self, EggVertex vertex)\n"
  "\n"
  "/**\n"
  " * Removes the vertex from the pool.  It is an error if the vertex is not\n"
  " * already a member of the pool.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_remove_vertex_293_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int EggVertexPool::remove_unused_vertices(void)
 */
static PyObject *Dtool_EggVertexPool_remove_unused_vertices_294(PyObject *self, PyObject *) {
  EggVertexPool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexPool, (void **)&local_this, "EggVertexPool.remove_unused_vertices")) {
    return nullptr;
  }
  // 1-int EggVertexPool::remove_unused_vertices(void)
  int return_value = ((*local_this).remove_unused_vertices)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_remove_unused_vertices_294_comment =
  "C++ Interface:\n"
  "remove_unused_vertices(const EggVertexPool self)\n"
  "\n"
  "/**\n"
  " * Removes all vertices from the pool that are not referenced by at least one\n"
  " * primitive.  Also collapses together equivalent vertices, and renumbers all\n"
  " * vertices after the operation so their indices are consecutive, beginning at\n"
  " * zero.  Returns the number of vertices removed.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_remove_unused_vertices_294_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggVertexPool::add_unused_vertices_to_prim(EggPrimitive *prim)
 */
static PyObject *Dtool_EggVertexPool_add_unused_vertices_to_prim_295(PyObject *self, PyObject *arg) {
  EggVertexPool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexPool, (void **)&local_this, "EggVertexPool.add_unused_vertices_to_prim")) {
    return nullptr;
  }
  // 1-void EggVertexPool::add_unused_vertices_to_prim(EggPrimitive *prim)
  EggPrimitive *arg_this = (EggPrimitive *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggPrimitive, 1, "EggVertexPool.add_unused_vertices_to_prim", false, true);
  if (arg_this != nullptr) {
    ((*local_this).add_unused_vertices_to_prim)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_unused_vertices_to_prim(const EggVertexPool self, EggPrimitive prim)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_add_unused_vertices_to_prim_295_comment =
  "C++ Interface:\n"
  "add_unused_vertices_to_prim(const EggVertexPool self, EggPrimitive prim)\n"
  "\n"
  "/**\n"
  " * Adds all of the unused vertices in this vertex pool to the indicated\n"
  " * primitive, in ascending order.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_add_unused_vertices_to_prim_295_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggVertexPool::transform(LMatrix4d const &mat)
 */
static PyObject *Dtool_EggVertexPool_transform_296(PyObject *self, PyObject *arg) {
  EggVertexPool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexPool, (void **)&local_this, "EggVertexPool.transform")) {
    return nullptr;
  }
  // 1-void EggVertexPool::transform(LMatrix4d const &mat)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggVertexPool.transform", "LMatrix4d");
  }
  ((*local_this).transform)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "transform(const EggVertexPool self, const LMatrix4d mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_transform_296_comment =
  "C++ Interface:\n"
  "transform(const EggVertexPool self, const LMatrix4d mat)\n"
  "\n"
  "/**\n"
  " * Applies the indicated transformation matrix to all the vertices.  However,\n"
  " * vertices that are attached to primitives that believe their vertices are in\n"
  " * a local coordinate system are transformed only by the scale and rotation\n"
  " * component.  If a vertex happens to be attached both to a local and a global\n"
  " * primitive, and the transformation includes a translation component, the\n"
  " * vertex will be split.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_transform_296_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggVertexPool::sort_by_external_index(void)
 */
static PyObject *Dtool_EggVertexPool_sort_by_external_index_297(PyObject *self, PyObject *) {
  EggVertexPool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggVertexPool, (void **)&local_this, "EggVertexPool.sort_by_external_index")) {
    return nullptr;
  }
  // 1-void EggVertexPool::sort_by_external_index(void)
  ((*local_this).sort_by_external_index)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_sort_by_external_index_297_comment =
  "C++ Interface:\n"
  "sort_by_external_index(const EggVertexPool self)\n"
  "\n"
  "/**\n"
  " * Re-orders (and re-numbers) the vertices in this vertex pool so that they\n"
  " * appear in increasing order by the optional external_index that has been\n"
  " * assigned to each vertex.\n"
  " */";
#else
static const char *Dtool_EggVertexPool_sort_by_external_index_297_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggVertexPool::get_class_type(void)
 */
static PyObject *Dtool_EggVertexPool_get_class_type_298(PyObject *, PyObject *) {
  // 1-static TypeHandle EggVertexPool::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggVertexPool::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggVertexPool_get_class_type_298_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggVertexPool_get_class_type_298_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggVertexPool::EggVertexPool(EggVertexPool const &copy)
 * explicit EggVertexPool::EggVertexPool(std::string const &name)
 */
static int Dtool_Init_EggVertexPool(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "EggVertexPool() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 EggVertexPool::EggVertexPool(EggVertexPool const &copy)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
      EggVertexPool const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_EggVertexPool);
      if (param0_this != nullptr) {
        EggVertexPool *return_value = new EggVertexPool(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggVertexPool, true, false);
      }
    }
  }

  {
    // -2 explicit EggVertexPool::EggVertexPool(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:EggVertexPool", (char **)keyword_list, &param0_str, &param0_len)) {
      EggVertexPool *return_value = new EggVertexPool(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggVertexPool, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: EggVertexPool::EggVertexPool(EggVertexPool const &copy)
  // No coercion possible: explicit EggVertexPool::EggVertexPool(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggVertexPool(const EggVertexPool copy)\n"
      "EggVertexPool(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggVertexPool(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggVertexPool) {
    printf("EggVertexPool ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggVertexPool *local_this = (EggVertexPool *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggVertexPool) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggVertexPool(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggVertexPool) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggVertexPool*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggVertexPool*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggVertexPool*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggVertexPool*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggVertexPool*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggVertexPool*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggVertexPool*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggRenderMode
 */
/**
 * Python function wrapper for:
 * void EggRenderMode::operator =(EggRenderMode const &copy)
 */
static PyObject *Dtool_EggRenderMode_operator_301(PyObject *self, PyObject *arg) {
  EggRenderMode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggRenderMode, (void **)&local_this, "EggRenderMode.assign")) {
    return nullptr;
  }
  // 1-void EggRenderMode::operator =(EggRenderMode const &copy)
  EggRenderMode const *arg_this = (EggRenderMode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggRenderMode, 1, "EggRenderMode.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggRenderMode *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggRenderMode self, const EggRenderMode copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_operator_301_comment =
  "C++ Interface:\n"
  "assign(const EggRenderMode self, const EggRenderMode copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggRenderMode_operator_301_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggRenderMode::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_EggRenderMode_write_302(PyObject *self, PyObject *args, PyObject *kwds) {
  EggRenderMode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggRenderMode)) {
    return nullptr;
  }
  // 1-void EggRenderMode::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "EggRenderMode.write", false, true);
    if (param1_this != nullptr) {
      ((*(const EggRenderMode*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(EggRenderMode self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_write_302_comment =
  "C++ Interface:\n"
  "write(EggRenderMode self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes the attributes to the indicated output stream in Egg format.\n"
  " */";
#else
static const char *Dtool_EggRenderMode_write_302_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggRenderMode::set_alpha_mode(EggRenderMode::AlphaMode mode)
 */
static PyObject *Dtool_EggRenderMode_set_alpha_mode_307(PyObject *self, PyObject *arg) {
  EggRenderMode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggRenderMode, (void **)&local_this, "EggRenderMode.set_alpha_mode")) {
    return nullptr;
  }
  // 1-inline void EggRenderMode::set_alpha_mode(EggRenderMode::AlphaMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_alpha_mode)((EggRenderMode::AlphaMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_alpha_mode(const EggRenderMode self, int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_set_alpha_mode_307_comment =
  "C++ Interface:\n"
  "set_alpha_mode(const EggRenderMode self, int mode)\n"
  "\n"
  "/**\n"
  " * Specifies precisely how the transparency for this geometry should be\n"
  " * achieved, or if it should be used.  The default, AM_unspecified, is to use\n"
  " * transparency if the geometry has a color whose alpha value is non-1, or if\n"
  " * it has a four-channel texture applied; otherwise, AM_on forces transparency\n"
  " * on, and AM_off forces it off.  The other flavors of transparency are\n"
  " * specific ways to turn on transparency, which may or may not be supported by\n"
  " * a particular rendering backend.\n"
  " */";
#else
static const char *Dtool_EggRenderMode_set_alpha_mode_307_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggRenderMode::AlphaMode EggRenderMode::get_alpha_mode(void) const
 */
static PyObject *Dtool_EggRenderMode_get_alpha_mode_308(PyObject *self, PyObject *) {
  EggRenderMode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggRenderMode)) {
    return nullptr;
  }
  // 1-inline EggRenderMode::AlphaMode EggRenderMode::get_alpha_mode(void) const
  EggRenderMode::AlphaMode return_value = ((*(const EggRenderMode*)local_this).get_alpha_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_get_alpha_mode_308_comment =
  "C++ Interface:\n"
  "get_alpha_mode(EggRenderMode self)\n"
  "\n"
  "/**\n"
  " * Returns the alpha mode that was set, or AM_unspecified if nothing was set.\n"
  " * See set_alpha_mode().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_get_alpha_mode_308_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggRenderMode::set_depth_write_mode(EggRenderMode::DepthWriteMode mode)
 */
static PyObject *Dtool_EggRenderMode_set_depth_write_mode_309(PyObject *self, PyObject *arg) {
  EggRenderMode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggRenderMode, (void **)&local_this, "EggRenderMode.set_depth_write_mode")) {
    return nullptr;
  }
  // 1-inline void EggRenderMode::set_depth_write_mode(EggRenderMode::DepthWriteMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_depth_write_mode)((EggRenderMode::DepthWriteMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_depth_write_mode(const EggRenderMode self, int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_set_depth_write_mode_309_comment =
  "C++ Interface:\n"
  "set_depth_write_mode(const EggRenderMode self, int mode)\n"
  "\n"
  "/**\n"
  " * Specifies whether writes should be made to the depth buffer (assuming the\n"
  " * rendering backend provides a depth buffer) when rendering this geometry.\n"
  " */";
#else
static const char *Dtool_EggRenderMode_set_depth_write_mode_309_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggRenderMode::DepthWriteMode EggRenderMode::get_depth_write_mode(void) const
 */
static PyObject *Dtool_EggRenderMode_get_depth_write_mode_310(PyObject *self, PyObject *) {
  EggRenderMode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggRenderMode)) {
    return nullptr;
  }
  // 1-inline EggRenderMode::DepthWriteMode EggRenderMode::get_depth_write_mode(void) const
  EggRenderMode::DepthWriteMode return_value = ((*(const EggRenderMode*)local_this).get_depth_write_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_get_depth_write_mode_310_comment =
  "C++ Interface:\n"
  "get_depth_write_mode(EggRenderMode self)\n"
  "\n"
  "/**\n"
  " * Returns the depth_write mode that was set, or DWM_unspecified if nothing\n"
  " * was set.  See set_depth_write_mode().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_get_depth_write_mode_310_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggRenderMode::set_depth_test_mode(EggRenderMode::DepthTestMode mode)
 */
static PyObject *Dtool_EggRenderMode_set_depth_test_mode_311(PyObject *self, PyObject *arg) {
  EggRenderMode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggRenderMode, (void **)&local_this, "EggRenderMode.set_depth_test_mode")) {
    return nullptr;
  }
  // 1-inline void EggRenderMode::set_depth_test_mode(EggRenderMode::DepthTestMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_depth_test_mode)((EggRenderMode::DepthTestMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_depth_test_mode(const EggRenderMode self, int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_set_depth_test_mode_311_comment =
  "C++ Interface:\n"
  "set_depth_test_mode(const EggRenderMode self, int mode)\n"
  "\n"
  "/**\n"
  " * Specifies whether this geometry should be tested against the depth buffer\n"
  " * when it is drawn (assuming the rendering backend provides a depth buffer).\n"
  " * Note that this is different, and independent from, the depth_write mode.\n"
  " */";
#else
static const char *Dtool_EggRenderMode_set_depth_test_mode_311_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggRenderMode::DepthTestMode EggRenderMode::get_depth_test_mode(void) const
 */
static PyObject *Dtool_EggRenderMode_get_depth_test_mode_312(PyObject *self, PyObject *) {
  EggRenderMode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggRenderMode)) {
    return nullptr;
  }
  // 1-inline EggRenderMode::DepthTestMode EggRenderMode::get_depth_test_mode(void) const
  EggRenderMode::DepthTestMode return_value = ((*(const EggRenderMode*)local_this).get_depth_test_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_get_depth_test_mode_312_comment =
  "C++ Interface:\n"
  "get_depth_test_mode(EggRenderMode self)\n"
  "\n"
  "/**\n"
  " * Returns the depth_test mode that was set, or DTM_unspecified if nothing was\n"
  " * set.  See set_depth_test_mode().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_get_depth_test_mode_312_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggRenderMode::set_visibility_mode(EggRenderMode::VisibilityMode mode)
 */
static PyObject *Dtool_EggRenderMode_set_visibility_mode_313(PyObject *self, PyObject *arg) {
  EggRenderMode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggRenderMode, (void **)&local_this, "EggRenderMode.set_visibility_mode")) {
    return nullptr;
  }
  // 1-inline void EggRenderMode::set_visibility_mode(EggRenderMode::VisibilityMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_visibility_mode)((EggRenderMode::VisibilityMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_visibility_mode(const EggRenderMode self, int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_set_visibility_mode_313_comment =
  "C++ Interface:\n"
  "set_visibility_mode(const EggRenderMode self, int mode)\n"
  "\n"
  "/**\n"
  " * Specifies whether this geometry is to be considered normally visible, or\n"
  " * hidden.  If it is hidden, it is either not loaded into the scene graph at\n"
  " * all, or loaded as a \"stashed\" node, according to the setting of egg-\n"
  " * suppress-hidden.\n"
  " */";
#else
static const char *Dtool_EggRenderMode_set_visibility_mode_313_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggRenderMode::VisibilityMode EggRenderMode::get_visibility_mode(void) const
 */
static PyObject *Dtool_EggRenderMode_get_visibility_mode_314(PyObject *self, PyObject *) {
  EggRenderMode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggRenderMode)) {
    return nullptr;
  }
  // 1-inline EggRenderMode::VisibilityMode EggRenderMode::get_visibility_mode(void) const
  EggRenderMode::VisibilityMode return_value = ((*(const EggRenderMode*)local_this).get_visibility_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_get_visibility_mode_314_comment =
  "C++ Interface:\n"
  "get_visibility_mode(EggRenderMode self)\n"
  "\n"
  "/**\n"
  " * Returns the visibility mode that was set, or VM_unspecified if nothing was\n"
  " * set.  See set_visibility_mode().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_get_visibility_mode_314_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggRenderMode::set_depth_offset(int bias)
 */
static PyObject *Dtool_EggRenderMode_set_depth_offset_315(PyObject *self, PyObject *arg) {
  EggRenderMode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggRenderMode, (void **)&local_this, "EggRenderMode.set_depth_offset")) {
    return nullptr;
  }
  // 1-inline void EggRenderMode::set_depth_offset(int bias)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_depth_offset)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_depth_offset(const EggRenderMode self, int bias)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_set_depth_offset_315_comment =
  "C++ Interface:\n"
  "set_depth_offset(const EggRenderMode self, int bias)\n"
  "\n"
  "/**\n"
  " * Sets the \"depth-offset\" flag associated with this object.  This adds or\n"
  " * subtracts an offset bias into the depth buffer.  See also DepthOffsetAttrib\n"
  " * and NodePath::set_depth_offset().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_set_depth_offset_315_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggRenderMode::get_depth_offset(void) const
 */
static PyObject *Dtool_EggRenderMode_get_depth_offset_316(PyObject *self, PyObject *) {
  EggRenderMode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggRenderMode)) {
    return nullptr;
  }
  // 1-inline int EggRenderMode::get_depth_offset(void) const
  int return_value = ((*(const EggRenderMode*)local_this).get_depth_offset)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_get_depth_offset_316_comment =
  "C++ Interface:\n"
  "get_depth_offset(EggRenderMode self)\n"
  "\n"
  "/**\n"
  " * Returns the \"depth-offset\" flag as set for this particular object.  See\n"
  " * set_depth_offset().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_get_depth_offset_316_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggRenderMode::has_depth_offset(void) const
 */
static PyObject *Dtool_EggRenderMode_has_depth_offset_317(PyObject *self, PyObject *) {
  EggRenderMode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggRenderMode)) {
    return nullptr;
  }
  // 1-inline bool EggRenderMode::has_depth_offset(void) const
  bool return_value = ((*(const EggRenderMode*)local_this).has_depth_offset)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_has_depth_offset_317_comment =
  "C++ Interface:\n"
  "has_depth_offset(EggRenderMode self)\n"
  "\n"
  "/**\n"
  " * Returns true if the depth-offset flag has been set for this particular\n"
  " * object.  See set_depth_offset().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_has_depth_offset_317_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggRenderMode::clear_depth_offset(void)
 */
static PyObject *Dtool_EggRenderMode_clear_depth_offset_318(PyObject *self, PyObject *) {
  EggRenderMode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggRenderMode, (void **)&local_this, "EggRenderMode.clear_depth_offset")) {
    return nullptr;
  }
  // 1-inline void EggRenderMode::clear_depth_offset(void)
  ((*local_this).clear_depth_offset)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_clear_depth_offset_318_comment =
  "C++ Interface:\n"
  "clear_depth_offset(const EggRenderMode self)\n"
  "\n"
  "/**\n"
  " * Removes the depth-offset flag from this particular object.  See\n"
  " * set_depth_offset().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_clear_depth_offset_318_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggRenderMode::set_draw_order(int order)
 */
static PyObject *Dtool_EggRenderMode_set_draw_order_319(PyObject *self, PyObject *arg) {
  EggRenderMode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggRenderMode, (void **)&local_this, "EggRenderMode.set_draw_order")) {
    return nullptr;
  }
  // 1-inline void EggRenderMode::set_draw_order(int order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_draw_order)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_draw_order(const EggRenderMode self, int order)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_set_draw_order_319_comment =
  "C++ Interface:\n"
  "set_draw_order(const EggRenderMode self, int order)\n"
  "\n"
  "/**\n"
  " * Sets the \"draw-order\" flag associated with this object.  This specifies a\n"
  " * particular order in which objects of this type should be drawn, within the\n"
  " * specified bin.  If a bin is not explicitly specified, \"fixed\" is used.  See\n"
  " * also set_bin().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_set_draw_order_319_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggRenderMode::get_draw_order(void) const
 */
static PyObject *Dtool_EggRenderMode_get_draw_order_320(PyObject *self, PyObject *) {
  EggRenderMode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggRenderMode)) {
    return nullptr;
  }
  // 1-inline int EggRenderMode::get_draw_order(void) const
  int return_value = ((*(const EggRenderMode*)local_this).get_draw_order)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_get_draw_order_320_comment =
  "C++ Interface:\n"
  "get_draw_order(EggRenderMode self)\n"
  "\n"
  "/**\n"
  " * Returns the \"draw-order\" flag as set for this particular object.  See\n"
  " * set_draw_order().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_get_draw_order_320_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggRenderMode::has_draw_order(void) const
 */
static PyObject *Dtool_EggRenderMode_has_draw_order_321(PyObject *self, PyObject *) {
  EggRenderMode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggRenderMode)) {
    return nullptr;
  }
  // 1-inline bool EggRenderMode::has_draw_order(void) const
  bool return_value = ((*(const EggRenderMode*)local_this).has_draw_order)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_has_draw_order_321_comment =
  "C++ Interface:\n"
  "has_draw_order(EggRenderMode self)\n"
  "\n"
  "/**\n"
  " * Returns true if the draw-order flag has been set for this particular\n"
  " * object.  See set_draw_order().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_has_draw_order_321_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggRenderMode::clear_draw_order(void)
 */
static PyObject *Dtool_EggRenderMode_clear_draw_order_322(PyObject *self, PyObject *) {
  EggRenderMode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggRenderMode, (void **)&local_this, "EggRenderMode.clear_draw_order")) {
    return nullptr;
  }
  // 1-inline void EggRenderMode::clear_draw_order(void)
  ((*local_this).clear_draw_order)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_clear_draw_order_322_comment =
  "C++ Interface:\n"
  "clear_draw_order(const EggRenderMode self)\n"
  "\n"
  "/**\n"
  " * Removes the draw-order flag from this particular object.  See\n"
  " * set_draw_order().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_clear_draw_order_322_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggRenderMode::set_bin(std::string const &bin)
 */
static PyObject *Dtool_EggRenderMode_set_bin_323(PyObject *self, PyObject *arg) {
  EggRenderMode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggRenderMode, (void **)&local_this, "EggRenderMode.set_bin")) {
    return nullptr;
  }
  // 1-inline void EggRenderMode::set_bin(std::string const &bin)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_bin)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bin(const EggRenderMode self, str bin)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_set_bin_323_comment =
  "C++ Interface:\n"
  "set_bin(const EggRenderMode self, str bin)\n"
  "\n"
  "/**\n"
  " * Sets the \"bin\" string for this particular object.  This names a particular\n"
  " * bin in which the object should be rendered.  The exact meaning of a bin is\n"
  " * implementation defined, but generally a GeomBin matching each bin name must\n"
  " * also be specifically added to the rendering engine (e.g.  the\n"
  " * CullTraverser) in use for this to work.  See also set_draw_order().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_set_bin_323_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string EggRenderMode::get_bin(void) const
 */
static PyObject *Dtool_EggRenderMode_get_bin_324(PyObject *self, PyObject *) {
  EggRenderMode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggRenderMode)) {
    return nullptr;
  }
  // 1-inline std::string EggRenderMode::get_bin(void) const
  std::string return_value = ((*(const EggRenderMode*)local_this).get_bin)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_get_bin_324_comment =
  "C++ Interface:\n"
  "get_bin(EggRenderMode self)\n"
  "\n"
  "/**\n"
  " * Returns the bin name that has been set for this particular object, if any.\n"
  " * See set_bin().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_get_bin_324_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggRenderMode::has_bin(void) const
 */
static PyObject *Dtool_EggRenderMode_has_bin_325(PyObject *self, PyObject *) {
  EggRenderMode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggRenderMode)) {
    return nullptr;
  }
  // 1-inline bool EggRenderMode::has_bin(void) const
  bool return_value = ((*(const EggRenderMode*)local_this).has_bin)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_has_bin_325_comment =
  "C++ Interface:\n"
  "has_bin(EggRenderMode self)\n"
  "\n"
  "/**\n"
  " * Returns true if a bin name has been set for this particular object.  See\n"
  " * set_bin().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_has_bin_325_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggRenderMode::clear_bin(void)
 */
static PyObject *Dtool_EggRenderMode_clear_bin_326(PyObject *self, PyObject *) {
  EggRenderMode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggRenderMode, (void **)&local_this, "EggRenderMode.clear_bin")) {
    return nullptr;
  }
  // 1-inline void EggRenderMode::clear_bin(void)
  ((*local_this).clear_bin)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_clear_bin_326_comment =
  "C++ Interface:\n"
  "clear_bin(const EggRenderMode self)\n"
  "\n"
  "/**\n"
  " * Removes the bin name that was set for this particular object.  See\n"
  " * set_bin().\n"
  " */";
#else
static const char *Dtool_EggRenderMode_clear_bin_326_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static EggRenderMode::AlphaMode EggRenderMode::string_alpha_mode(std::string const &string)
 */
static PyObject *Dtool_EggRenderMode_string_alpha_mode_330(PyObject *, PyObject *arg) {
  // 1-static EggRenderMode::AlphaMode EggRenderMode::string_alpha_mode(std::string const &string)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    EggRenderMode::AlphaMode return_value = (EggRenderMode::string_alpha_mode)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_alpha_mode(str string)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_string_alpha_mode_330_comment =
  "C++ Interface:\n"
  "string_alpha_mode(str string)\n"
  "\n"
  "/**\n"
  " * Returns the AlphaMode value associated with the given string\n"
  " * representation, or AM_unspecified if the string does not match any known\n"
  " * AlphaMode value.\n"
  " */";
#else
static const char *Dtool_EggRenderMode_string_alpha_mode_330_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static EggRenderMode::DepthWriteMode EggRenderMode::string_depth_write_mode(std::string const &string)
 */
static PyObject *Dtool_EggRenderMode_string_depth_write_mode_331(PyObject *, PyObject *arg) {
  // 1-static EggRenderMode::DepthWriteMode EggRenderMode::string_depth_write_mode(std::string const &string)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    EggRenderMode::DepthWriteMode return_value = (EggRenderMode::string_depth_write_mode)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_depth_write_mode(str string)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_string_depth_write_mode_331_comment =
  "C++ Interface:\n"
  "string_depth_write_mode(str string)\n"
  "\n"
  "/**\n"
  " * Returns the DepthWriteMode value associated with the given string\n"
  " * representation, or DWM_unspecified if the string does not match any known\n"
  " * DepthWriteMode value.\n"
  " */";
#else
static const char *Dtool_EggRenderMode_string_depth_write_mode_331_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static EggRenderMode::DepthTestMode EggRenderMode::string_depth_test_mode(std::string const &string)
 */
static PyObject *Dtool_EggRenderMode_string_depth_test_mode_332(PyObject *, PyObject *arg) {
  // 1-static EggRenderMode::DepthTestMode EggRenderMode::string_depth_test_mode(std::string const &string)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    EggRenderMode::DepthTestMode return_value = (EggRenderMode::string_depth_test_mode)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_depth_test_mode(str string)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_string_depth_test_mode_332_comment =
  "C++ Interface:\n"
  "string_depth_test_mode(str string)\n"
  "\n"
  "/**\n"
  " * Returns the DepthTestMode value associated with the given string\n"
  " * representation, or DTM_unspecified if the string does not match any known\n"
  " * DepthTestMode value.\n"
  " */";
#else
static const char *Dtool_EggRenderMode_string_depth_test_mode_332_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static EggRenderMode::VisibilityMode EggRenderMode::string_visibility_mode(std::string const &string)
 */
static PyObject *Dtool_EggRenderMode_string_visibility_mode_333(PyObject *, PyObject *arg) {
  // 1-static EggRenderMode::VisibilityMode EggRenderMode::string_visibility_mode(std::string const &string)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    EggRenderMode::VisibilityMode return_value = (EggRenderMode::string_visibility_mode)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_visibility_mode(str string)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_string_visibility_mode_333_comment =
  "C++ Interface:\n"
  "string_visibility_mode(str string)\n"
  "\n"
  "/**\n"
  " * Returns the HiddenMode value associated with the given string\n"
  " * representation, or VM_unspecified if the string does not match any known\n"
  " * HiddenMode value.\n"
  " */";
#else
static const char *Dtool_EggRenderMode_string_visibility_mode_333_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggRenderMode::get_class_type(void)
 */
static PyObject *Dtool_EggRenderMode_get_class_type_334(PyObject *, PyObject *) {
  // 1-static TypeHandle EggRenderMode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggRenderMode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggRenderMode_get_class_type_334_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggRenderMode_get_class_type_334_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggRenderMode::EggRenderMode(void)
 * inline EggRenderMode::EggRenderMode(EggRenderMode const &copy)
 */
static int Dtool_Init_EggRenderMode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-EggRenderMode::EggRenderMode(void)
      EggRenderMode *return_value = new EggRenderMode();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggRenderMode, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-inline EggRenderMode::EggRenderMode(EggRenderMode const &copy)
        EggRenderMode const *arg_this = (EggRenderMode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggRenderMode, 0, "EggRenderMode.EggRenderMode", true, true);
        if (arg_this != nullptr) {
          EggRenderMode *return_value = new EggRenderMode(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggRenderMode, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggRenderMode() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggRenderMode()\n"
      "EggRenderMode(const EggRenderMode copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggRenderMode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggRenderMode) {
    printf("EggRenderMode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggRenderMode *local_this = (EggRenderMode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggRenderMode) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggRenderMode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggTransform
 */
/**
 * Python function wrapper for:
 * void EggTransform::operator =(EggTransform const &copy)
 */
static PyObject *Dtool_EggTransform_operator_338(PyObject *self, PyObject *arg) {
  EggTransform *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.assign")) {
    return nullptr;
  }
  // 1-void EggTransform::operator =(EggTransform const &copy)
  EggTransform const *arg_this = (EggTransform *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggTransform, 1, "EggTransform.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggTransform *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggTransform, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggTransform self, const EggTransform copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_operator_338_comment =
  "C++ Interface:\n"
  "assign(const EggTransform self, const EggTransform copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTransform_operator_338_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTransform::clear_transform(void)
 */
static PyObject *Dtool_EggTransform_clear_transform_340(PyObject *self, PyObject *) {
  EggTransform *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.clear_transform")) {
    return nullptr;
  }
  // 1-inline void EggTransform::clear_transform(void)
  ((*local_this).clear_transform)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_clear_transform_340_comment =
  "C++ Interface:\n"
  "clear_transform(const EggTransform self)\n"
  "\n"
  "/**\n"
  " * Resets the transform to empty, identity.\n"
  " */";
#else
static const char *Dtool_EggTransform_clear_transform_340_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggTransform::add_translate2d(LVector2d const &translate)
 */
static PyObject *Dtool_EggTransform_add_translate2d_341(PyObject *self, PyObject *arg) {
  EggTransform *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.add_translate2d")) {
    return nullptr;
  }
  // 1-void EggTransform::add_translate2d(LVector2d const &translate)
  LVector2d arg_local;
  LVector2d const *arg_this = Dtool_Coerce_LVector2d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTransform.add_translate2d", "LVector2d");
  }
  ((*local_this).add_translate2d)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_translate2d(const EggTransform self, const LVector2d translate)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_add_translate2d_341_comment =
  "C++ Interface:\n"
  "add_translate2d(const EggTransform self, const LVector2d translate)\n"
  "\n"
  "/**\n"
  " * Appends a 2-d translation operation to the current transform.\n"
  " */";
#else
static const char *Dtool_EggTransform_add_translate2d_341_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggTransform::add_translate3d(LVector3d const &translate)
 */
static PyObject *Dtool_EggTransform_add_translate3d_342(PyObject *self, PyObject *arg) {
  EggTransform *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.add_translate3d")) {
    return nullptr;
  }
  // 1-void EggTransform::add_translate3d(LVector3d const &translate)
  LVector3d arg_local;
  LVector3d const *arg_this = Dtool_Coerce_LVector3d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTransform.add_translate3d", "LVector3d");
  }
  ((*local_this).add_translate3d)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_translate3d(const EggTransform self, const LVector3d translate)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_add_translate3d_342_comment =
  "C++ Interface:\n"
  "add_translate3d(const EggTransform self, const LVector3d translate)\n"
  "\n"
  "/**\n"
  " * Appends a 3-d translation operation to the current transform.\n"
  " */";
#else
static const char *Dtool_EggTransform_add_translate3d_342_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggTransform::add_rotate2d(double angle)
 */
static PyObject *Dtool_EggTransform_add_rotate2d_343(PyObject *self, PyObject *arg) {
  EggTransform *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.add_rotate2d")) {
    return nullptr;
  }
  // 1-void EggTransform::add_rotate2d(double angle)
  if (PyNumber_Check(arg)) {
    ((*local_this).add_rotate2d)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_rotate2d(const EggTransform self, double angle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_add_rotate2d_343_comment =
  "C++ Interface:\n"
  "add_rotate2d(const EggTransform self, double angle)\n"
  "\n"
  "/**\n"
  " * Appends a 2-d rotation to the current transform.  The rotation angle is\n"
  " * specified in degrees counterclockwise about the origin.\n"
  " */";
#else
static const char *Dtool_EggTransform_add_rotate2d_343_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggTransform::add_rotx(double angle)
 */
static PyObject *Dtool_EggTransform_add_rotx_344(PyObject *self, PyObject *arg) {
  EggTransform *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.add_rotx")) {
    return nullptr;
  }
  // 1-void EggTransform::add_rotx(double angle)
  if (PyNumber_Check(arg)) {
    ((*local_this).add_rotx)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_rotx(const EggTransform self, double angle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_add_rotx_344_comment =
  "C++ Interface:\n"
  "add_rotx(const EggTransform self, double angle)\n"
  "\n"
  "/**\n"
  " * Appends a rotation about the X axis to the current transform.  The rotation\n"
  " * angle is specified in degrees counterclockwise about the axis.\n"
  " */";
#else
static const char *Dtool_EggTransform_add_rotx_344_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggTransform::add_roty(double angle)
 */
static PyObject *Dtool_EggTransform_add_roty_345(PyObject *self, PyObject *arg) {
  EggTransform *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.add_roty")) {
    return nullptr;
  }
  // 1-void EggTransform::add_roty(double angle)
  if (PyNumber_Check(arg)) {
    ((*local_this).add_roty)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_roty(const EggTransform self, double angle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_add_roty_345_comment =
  "C++ Interface:\n"
  "add_roty(const EggTransform self, double angle)\n"
  "\n"
  "/**\n"
  " * Appends a rotation about the Y axis to the current transform.  The rotation\n"
  " * angle is specified in degrees counterclockwise about the axis.\n"
  " */";
#else
static const char *Dtool_EggTransform_add_roty_345_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggTransform::add_rotz(double angle)
 */
static PyObject *Dtool_EggTransform_add_rotz_346(PyObject *self, PyObject *arg) {
  EggTransform *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.add_rotz")) {
    return nullptr;
  }
  // 1-void EggTransform::add_rotz(double angle)
  if (PyNumber_Check(arg)) {
    ((*local_this).add_rotz)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_rotz(const EggTransform self, double angle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_add_rotz_346_comment =
  "C++ Interface:\n"
  "add_rotz(const EggTransform self, double angle)\n"
  "\n"
  "/**\n"
  " * Appends a rotation about the Z axis to the current transform.  The rotation\n"
  " * angle is specified in degrees counterclockwise about the axis.\n"
  " */";
#else
static const char *Dtool_EggTransform_add_rotz_346_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggTransform::add_rotate3d(LQuaterniond const &quat)
 * void EggTransform::add_rotate3d(double angle, LVector3d const &axis)
 */
static PyObject *Dtool_EggTransform_add_rotate3d_347(PyObject *self, PyObject *args, PyObject *kwds) {
  EggTransform *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.add_rotate3d")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "quat")) {
        // 1-void EggTransform::add_rotate3d(LQuaterniond const &quat)
        LQuaterniond arg_local;
        LQuaterniond const *arg_this = Dtool_Coerce_LQuaterniond(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "EggTransform.add_rotate3d", "LQuaterniond");
        }
        ((*local_this).add_rotate3d)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-void EggTransform::add_rotate3d(double angle, LVector3d const &axis)
      double param1;
      PyObject *param2;
      static const char *keyword_list[] = {"angle", "axis", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dO:add_rotate3d", (char **)keyword_list, &param1, &param2)) {
        LVector3d param2_local;
        LVector3d const *param2_this = Dtool_Coerce_LVector3d(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "EggTransform.add_rotate3d", "LVector3d");
        }
        ((*local_this).add_rotate3d)((double)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_rotate3d() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_rotate3d(const EggTransform self, const LQuaterniond quat)\n"
      "add_rotate3d(const EggTransform self, double angle, const LVector3d axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_add_rotate3d_347_comment =
  "C++ Interface:\n"
  "add_rotate3d(const EggTransform self, const LQuaterniond quat)\n"
  "add_rotate3d(const EggTransform self, double angle, const LVector3d axis)\n"
  "\n"
  "/**\n"
  " * Appends a 3-d rotation about an arbitrary axis to the current transform.\n"
  " * The rotation angle is specified in degrees counterclockwise about the axis.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Appends an arbitrary 3-d rotation to the current transform, expressed as a\n"
  " * quaternion.  This is converted to axis-angle notation for the egg file.\n"
  " */";
#else
static const char *Dtool_EggTransform_add_rotate3d_347_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggTransform::add_scale2d(LVecBase2d const &scale)
 */
static PyObject *Dtool_EggTransform_add_scale2d_348(PyObject *self, PyObject *arg) {
  EggTransform *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.add_scale2d")) {
    return nullptr;
  }
  // 1-void EggTransform::add_scale2d(LVecBase2d const &scale)
  LVecBase2d arg_local;
  LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTransform.add_scale2d", "LVecBase2d");
  }
  ((*local_this).add_scale2d)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_scale2d(const EggTransform self, const LVecBase2d scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_add_scale2d_348_comment =
  "C++ Interface:\n"
  "add_scale2d(const EggTransform self, const LVecBase2d scale)\n"
  "\n"
  "/**\n"
  " * Appends a possibly non-uniform scale to the current transform.\n"
  " */";
#else
static const char *Dtool_EggTransform_add_scale2d_348_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggTransform::add_scale3d(LVecBase3d const &scale)
 */
static PyObject *Dtool_EggTransform_add_scale3d_349(PyObject *self, PyObject *arg) {
  EggTransform *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.add_scale3d")) {
    return nullptr;
  }
  // 1-void EggTransform::add_scale3d(LVecBase3d const &scale)
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTransform.add_scale3d", "LVecBase3d");
  }
  ((*local_this).add_scale3d)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_scale3d(const EggTransform self, const LVecBase3d scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_add_scale3d_349_comment =
  "C++ Interface:\n"
  "add_scale3d(const EggTransform self, const LVecBase3d scale)\n"
  "\n"
  "/**\n"
  " * Appends a possibly non-uniform scale to the current transform.\n"
  " */";
#else
static const char *Dtool_EggTransform_add_scale3d_349_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggTransform::add_uniform_scale(double scale)
 */
static PyObject *Dtool_EggTransform_add_uniform_scale_350(PyObject *self, PyObject *arg) {
  EggTransform *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.add_uniform_scale")) {
    return nullptr;
  }
  // 1-void EggTransform::add_uniform_scale(double scale)
  if (PyNumber_Check(arg)) {
    ((*local_this).add_uniform_scale)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_uniform_scale(const EggTransform self, double scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_add_uniform_scale_350_comment =
  "C++ Interface:\n"
  "add_uniform_scale(const EggTransform self, double scale)\n"
  "\n"
  "/**\n"
  " * Appends a uniform scale to the current transform.\n"
  " */";
#else
static const char *Dtool_EggTransform_add_uniform_scale_350_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTransform::add_matrix3(LMatrix3d const &mat)
 */
static PyObject *Dtool_EggTransform_add_matrix3_351(PyObject *self, PyObject *arg) {
  EggTransform *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.add_matrix3")) {
    return nullptr;
  }
  // 1-inline void EggTransform::add_matrix3(LMatrix3d const &mat)
  LMatrix3d arg_local;
  LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTransform.add_matrix3", "LMatrix3d");
  }
  ((*local_this).add_matrix3)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_matrix3(const EggTransform self, const LMatrix3d mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_add_matrix3_351_comment =
  "C++ Interface:\n"
  "add_matrix3(const EggTransform self, const LMatrix3d mat)\n"
  "\n"
  "/**\n"
  " * Appends an arbitrary 3x3 matrix to the current transform.\n"
  " */";
#else
static const char *Dtool_EggTransform_add_matrix3_351_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTransform::add_matrix4(LMatrix4d const &mat)
 */
static PyObject *Dtool_EggTransform_add_matrix4_352(PyObject *self, PyObject *arg) {
  EggTransform *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.add_matrix4")) {
    return nullptr;
  }
  // 1-inline void EggTransform::add_matrix4(LMatrix4d const &mat)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTransform.add_matrix4", "LMatrix4d");
  }
  ((*local_this).add_matrix4)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_matrix4(const EggTransform self, const LMatrix4d mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_add_matrix4_352_comment =
  "C++ Interface:\n"
  "add_matrix4(const EggTransform self, const LMatrix4d mat)\n"
  "\n"
  "/**\n"
  " * Appends an arbitrary 4x4 matrix to the current transform.\n"
  " */";
#else
static const char *Dtool_EggTransform_add_matrix4_352_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTransform::has_transform(void) const
 */
static PyObject *Dtool_EggTransform_has_transform_353(PyObject *self, PyObject *) {
  EggTransform *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTransform)) {
    return nullptr;
  }
  // 1-inline bool EggTransform::has_transform(void) const
  bool return_value = ((*(const EggTransform*)local_this).has_transform)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_has_transform_353_comment =
  "C++ Interface:\n"
  "has_transform(EggTransform self)\n"
  "\n"
  "/**\n"
  " * Returns true if the transform is nonempty, false if it is empty (no\n"
  " * transform components have been added).  This is true for either a 2-d or a\n"
  " * 3-d transform.\n"
  " */";
#else
static const char *Dtool_EggTransform_has_transform_353_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTransform::has_transform2d(void) const
 */
static PyObject *Dtool_EggTransform_has_transform2d_354(PyObject *self, PyObject *) {
  EggTransform *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTransform)) {
    return nullptr;
  }
  // 1-inline bool EggTransform::has_transform2d(void) const
  bool return_value = ((*(const EggTransform*)local_this).has_transform2d)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_has_transform2d_354_comment =
  "C++ Interface:\n"
  "has_transform2d(EggTransform self)\n"
  "\n"
  "/**\n"
  " * Returns true if the transform is specified as a 2-d transform, e.g.  with a\n"
  " * 3x3 matrix, or false if it is specified as a 3-d transform (with a 4x4\n"
  " * matrix), or not specified at all.\n"
  " *\n"
  " * Normally, EggTextures have a 2-d matrix (but occasionally they use a 3-d\n"
  " * matrix), and EggGroups always have a 3-d matrix.\n"
  " */";
#else
static const char *Dtool_EggTransform_has_transform2d_354_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTransform::set_transform2d(LMatrix3d const &mat)
 */
static PyObject *Dtool_EggTransform_set_transform2d_355(PyObject *self, PyObject *arg) {
  EggTransform *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.set_transform2d")) {
    return nullptr;
  }
  // 1-inline void EggTransform::set_transform2d(LMatrix3d const &mat)
  LMatrix3d arg_local;
  LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTransform.set_transform2d", "LMatrix3d");
  }
  ((*local_this).set_transform2d)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_transform2d(const EggTransform self, const LMatrix3d mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_set_transform2d_355_comment =
  "C++ Interface:\n"
  "set_transform2d(const EggTransform self, const LMatrix3d mat)\n"
  "\n"
  "/**\n"
  " * Sets the overall transform as a 3x3 matrix.  This completely replaces\n"
  " * whatever componentwise transform may have been defined.\n"
  " */";
#else
static const char *Dtool_EggTransform_set_transform2d_355_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTransform::has_transform3d(void) const
 */
static PyObject *Dtool_EggTransform_has_transform3d_356(PyObject *self, PyObject *) {
  EggTransform *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTransform)) {
    return nullptr;
  }
  // 1-inline bool EggTransform::has_transform3d(void) const
  bool return_value = ((*(const EggTransform*)local_this).has_transform3d)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_has_transform3d_356_comment =
  "C++ Interface:\n"
  "has_transform3d(EggTransform self)\n"
  "\n"
  "/**\n"
  " * Returns true if the transform is specified as a 3-d transform, e.g.  with a\n"
  " * 4x4 matrix, or false if it is specified as a 2-d transform (with a 2x2\n"
  " * matrix), or not specified at all.\n"
  " *\n"
  " * Normally, EggTextures have a 3-d matrix (but occasionally they use a 3-d\n"
  " * matrix), and EggGroups always have a 3-d matrix.\n"
  " */";
#else
static const char *Dtool_EggTransform_has_transform3d_356_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTransform::set_transform3d(LMatrix4d const &mat)
 */
static PyObject *Dtool_EggTransform_set_transform3d_357(PyObject *self, PyObject *arg) {
  EggTransform *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTransform, (void **)&local_this, "EggTransform.set_transform3d")) {
    return nullptr;
  }
  // 1-inline void EggTransform::set_transform3d(LMatrix4d const &mat)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTransform.set_transform3d", "LMatrix4d");
  }
  ((*local_this).set_transform3d)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_transform3d(const EggTransform self, const LMatrix4d mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_set_transform3d_357_comment =
  "C++ Interface:\n"
  "set_transform3d(const EggTransform self, const LMatrix4d mat)\n"
  "\n"
  "/**\n"
  " * Sets the overall transform as a 4x4 matrix.  This completely replaces\n"
  " * whatever componentwise transform may have been defined.\n"
  " */";
#else
static const char *Dtool_EggTransform_set_transform3d_357_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3d EggTransform::get_transform2d(void) const
 */
static PyObject *Dtool_EggTransform_get_transform2d_358(PyObject *self, PyObject *) {
  EggTransform *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTransform)) {
    return nullptr;
  }
  // 1-inline LMatrix3d EggTransform::get_transform2d(void) const
  LMatrix3d *return_value = new LMatrix3d(((*(const EggTransform*)local_this).get_transform2d)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_get_transform2d_358_comment =
  "C++ Interface:\n"
  "get_transform2d(EggTransform self)\n"
  "\n"
  "/**\n"
  " * Returns the overall transform as a 3x3 matrix.  It is an error to call this\n"
  " * if has_transform3d() is true.\n"
  " */";
#else
static const char *Dtool_EggTransform_get_transform2d_358_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d const &EggTransform::get_transform3d(void) const
 */
static PyObject *Dtool_EggTransform_get_transform3d_359(PyObject *self, PyObject *) {
  EggTransform *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTransform)) {
    return nullptr;
  }
  // 1-inline LMatrix4d const &EggTransform::get_transform3d(void) const
  LMatrix4d const *return_value = &(((*(const EggTransform*)local_this).get_transform3d)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_get_transform3d_359_comment =
  "C++ Interface:\n"
  "get_transform3d(EggTransform self)\n"
  "\n"
  "/**\n"
  " * Returns the overall transform as a 4x4 matrix.  It is valid to call this\n"
  " * even if has_transform2d() is true; in this case, the 3x3 transform will be\n"
  " * expanded to a 4x4 matrix.\n"
  " */";
#else
static const char *Dtool_EggTransform_get_transform3d_359_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTransform::transform_is_identity(void) const
 */
static PyObject *Dtool_EggTransform_transform_is_identity_360(PyObject *self, PyObject *) {
  EggTransform *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTransform)) {
    return nullptr;
  }
  // 1-inline bool EggTransform::transform_is_identity(void) const
  bool return_value = ((*(const EggTransform*)local_this).transform_is_identity)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_transform_is_identity_360_comment =
  "C++ Interface:\n"
  "transform_is_identity(EggTransform self)\n"
  "\n"
  "/**\n"
  " * Returns true if the described transform is identity, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggTransform_transform_is_identity_360_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggTransform::get_num_components(void) const
 */
static PyObject *Dtool_EggTransform_get_num_components_362(PyObject *self, PyObject *) {
  EggTransform *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTransform)) {
    return nullptr;
  }
  // 1-inline int EggTransform::get_num_components(void) const
  int return_value = ((*(const EggTransform*)local_this).get_num_components)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_get_num_components_362_comment =
  "C++ Interface:\n"
  "get_num_components(EggTransform self)\n"
  "\n"
  "/**\n"
  " * Returns the number of components that make up the transform.\n"
  " */";
#else
static const char *Dtool_EggTransform_get_num_components_362_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggTransform::ComponentType EggTransform::get_component_type(int n) const
 */
static PyObject *Dtool_EggTransform_get_component_type_363(PyObject *self, PyObject *arg) {
  EggTransform *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTransform)) {
    return nullptr;
  }
  // 1-inline EggTransform::ComponentType EggTransform::get_component_type(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    EggTransform::ComponentType return_value = ((*(const EggTransform*)local_this).get_component_type)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_component_type(EggTransform self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_get_component_type_363_comment =
  "C++ Interface:\n"
  "get_component_type(EggTransform self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the type of the nth component.\n"
  " */";
#else
static const char *Dtool_EggTransform_get_component_type_363_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double EggTransform::get_component_number(int n) const
 */
static PyObject *Dtool_EggTransform_get_component_number_364(PyObject *self, PyObject *arg) {
  EggTransform *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTransform)) {
    return nullptr;
  }
  // 1-inline double EggTransform::get_component_number(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    double return_value = ((*(const EggTransform*)local_this).get_component_number)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_component_number(EggTransform self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_get_component_number_364_comment =
  "C++ Interface:\n"
  "get_component_number(EggTransform self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the solitary number associated with the nth component.  In the case\n"
  " * of a rotation, this is the angle in degrees to rotate; in the case of\n"
  " * uniform scale, this is the amount of the scale.  Other types do not use\n"
  " * this property.\n"
  " */";
#else
static const char *Dtool_EggTransform_get_component_number_364_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2d const &EggTransform::get_component_vec2(int n) const
 */
static PyObject *Dtool_EggTransform_get_component_vec2_365(PyObject *self, PyObject *arg) {
  EggTransform *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTransform)) {
    return nullptr;
  }
  // 1-inline LVecBase2d const &EggTransform::get_component_vec2(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase2d const *return_value = &(((*(const EggTransform*)local_this).get_component_vec2)((int)arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_component_vec2(EggTransform self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_get_component_vec2_365_comment =
  "C++ Interface:\n"
  "get_component_vec2(EggTransform self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the 2-component vector associated with the nth component.  This may\n"
  " * be the translate vector, rotate axis, or non-uniform scale.  It is an error\n"
  " * to call this if the component type does not use a 2-d vector property.\n"
  " */";
#else
static const char *Dtool_EggTransform_get_component_vec2_365_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3d const &EggTransform::get_component_vec3(int n) const
 */
static PyObject *Dtool_EggTransform_get_component_vec3_366(PyObject *self, PyObject *arg) {
  EggTransform *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTransform)) {
    return nullptr;
  }
  // 1-inline LVecBase3d const &EggTransform::get_component_vec3(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase3d const *return_value = &(((*(const EggTransform*)local_this).get_component_vec3)((int)arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_component_vec3(EggTransform self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_get_component_vec3_366_comment =
  "C++ Interface:\n"
  "get_component_vec3(EggTransform self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the 3-component vector associated with the nth component.  This may\n"
  " * be the translate vector, rotate axis, or non-uniform scale.  It is an error\n"
  " * to call this if the component type does not use a 3-d vector property.\n"
  " */";
#else
static const char *Dtool_EggTransform_get_component_vec3_366_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3d const &EggTransform::get_component_mat3(int n) const
 */
static PyObject *Dtool_EggTransform_get_component_mat3_367(PyObject *self, PyObject *arg) {
  EggTransform *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTransform)) {
    return nullptr;
  }
  // 1-inline LMatrix3d const &EggTransform::get_component_mat3(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LMatrix3d const *return_value = &(((*(const EggTransform*)local_this).get_component_mat3)((int)arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_component_mat3(EggTransform self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_get_component_mat3_367_comment =
  "C++ Interface:\n"
  "get_component_mat3(EggTransform self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the 3x3 matrix associated with the nth component.  It is an error\n"
  " * to call this if the component type is not CT_matrix3.\n"
  " */";
#else
static const char *Dtool_EggTransform_get_component_mat3_367_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d const &EggTransform::get_component_mat4(int n) const
 */
static PyObject *Dtool_EggTransform_get_component_mat4_368(PyObject *self, PyObject *arg) {
  EggTransform *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTransform)) {
    return nullptr;
  }
  // 1-inline LMatrix4d const &EggTransform::get_component_mat4(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LMatrix4d const *return_value = &(((*(const EggTransform*)local_this).get_component_mat4)((int)arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_component_mat4(EggTransform self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_get_component_mat4_368_comment =
  "C++ Interface:\n"
  "get_component_mat4(EggTransform self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the 4x4 matrix associated with the nth component.  It is an error\n"
  " * to call this if the component type is not CT_matrix4.\n"
  " */";
#else
static const char *Dtool_EggTransform_get_component_mat4_368_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggTransform::write(std::ostream &out, int indent_level, std::string const &label) const
 */
static PyObject *Dtool_EggTransform_write_369(PyObject *self, PyObject *args, PyObject *kwds) {
  EggTransform *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTransform)) {
    return nullptr;
  }
  // 1-void EggTransform::write(std::ostream &out, int indent_level, std::string const &label) const
  PyObject *param1;
  int param2;
  const char *param3_str = nullptr;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"out", "indent_level", "label", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Ois#:write", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "EggTransform.write", false, true);
    if (param1_this != nullptr) {
      ((*(const EggTransform*)local_this).write)(*param1_this, (int)param2, std::string(param3_str, param3_len));
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(EggTransform self, ostream out, int indent_level, str label)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTransform_write_369_comment =
  "C++ Interface:\n"
  "write(EggTransform self, ostream out, int indent_level, str label)\n"
  "\n"
  "/**\n"
  " * Writes the transform to the indicated stream in Egg format.\n"
  " */";
#else
static const char *Dtool_EggTransform_write_369_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggTransform::EggTransform(void)
 * EggTransform::EggTransform(EggTransform const &copy)
 */
static int Dtool_Init_EggTransform(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-EggTransform::EggTransform(void)
      EggTransform *return_value = new EggTransform();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggTransform, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-EggTransform::EggTransform(EggTransform const &copy)
        EggTransform const *arg_this = (EggTransform *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggTransform, 0, "EggTransform.EggTransform", true, true);
        if (arg_this != nullptr) {
          EggTransform *return_value = new EggTransform(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggTransform, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggTransform() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggTransform()\n"
      "EggTransform(const EggTransform copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggTransform(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggTransform) {
    printf("EggTransform ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggTransform *local_this = (EggTransform *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggTransform) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggTransform(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggTransform) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggSwitchCondition
 */
/**
 * Python function wrapper for:
 * virtual EggSwitchCondition *EggSwitchCondition::make_copy(void) const = 0
 */
static PyObject *Dtool_EggSwitchCondition_make_copy_371(PyObject *self, PyObject *) {
  EggSwitchCondition *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggSwitchCondition)) {
    return nullptr;
  }
  // 1-virtual EggSwitchCondition *EggSwitchCondition::make_copy(void) const = 0
  EggSwitchCondition *return_value = ((*(const EggSwitchCondition*)local_this).make_copy)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggSwitchCondition, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggSwitchCondition_make_copy_371_comment =
  "C++ Interface:\n"
  "make_copy(EggSwitchCondition self)\n";
#else
static const char *Dtool_EggSwitchCondition_make_copy_371_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void EggSwitchCondition::write(std::ostream &out, int indent_level) const = 0
 */
static PyObject *Dtool_EggSwitchCondition_write_372(PyObject *self, PyObject *args, PyObject *kwds) {
  EggSwitchCondition *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggSwitchCondition)) {
    return nullptr;
  }
  // 1-virtual void EggSwitchCondition::write(std::ostream &out, int indent_level) const = 0
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "EggSwitchCondition.write", false, true);
    if (param1_this != nullptr) {
      ((*(const EggSwitchCondition*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(EggSwitchCondition self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggSwitchCondition_write_372_comment =
  "C++ Interface:\n"
  "write(EggSwitchCondition self, ostream out, int indent_level)\n";
#else
static const char *Dtool_EggSwitchCondition_write_372_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void EggSwitchCondition::transform(LMatrix4d const &mat) = 0
 */
static PyObject *Dtool_EggSwitchCondition_transform_373(PyObject *self, PyObject *arg) {
  EggSwitchCondition *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggSwitchCondition, (void **)&local_this, "EggSwitchCondition.transform")) {
    return nullptr;
  }
  // 1-virtual void EggSwitchCondition::transform(LMatrix4d const &mat) = 0
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggSwitchCondition.transform", "LMatrix4d");
  }
  ((*local_this).transform)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "transform(const EggSwitchCondition self, const LMatrix4d mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggSwitchCondition_transform_373_comment =
  "C++ Interface:\n"
  "transform(const EggSwitchCondition self, const LMatrix4d mat)\n";
#else
static const char *Dtool_EggSwitchCondition_transform_373_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggSwitchCondition::get_class_type(void)
 */
static PyObject *Dtool_EggSwitchCondition_get_class_type_374(PyObject *, PyObject *) {
  // 1-static TypeHandle EggSwitchCondition::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggSwitchCondition::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggSwitchCondition_get_class_type_374_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggSwitchCondition_get_class_type_374_comment = nullptr;
#endif

static int Dtool_Init_EggSwitchCondition(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_EggSwitchCondition(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggSwitchCondition) {
    printf("EggSwitchCondition ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggSwitchCondition *local_this = (EggSwitchCondition *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggSwitchCondition) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggSwitchCondition(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggSwitchCondition) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggSwitchCondition*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggSwitchCondition*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggSwitchCondition*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggSwitchCondition*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggSwitchConditionDistance
 */
/**
 * Python function wrapper for:
 * static TypeHandle EggSwitchConditionDistance::get_class_type(void)
 */
static PyObject *Dtool_EggSwitchConditionDistance_get_class_type_378(PyObject *, PyObject *) {
  // 1-static TypeHandle EggSwitchConditionDistance::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggSwitchConditionDistance::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggSwitchConditionDistance_get_class_type_378_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggSwitchConditionDistance_get_class_type_378_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit EggSwitchConditionDistance::EggSwitchConditionDistance(double switch_in, double switch_out, LPoint3d const &center, double fade = 0.0)
 */
static int Dtool_Init_EggSwitchConditionDistance(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-explicit EggSwitchConditionDistance::EggSwitchConditionDistance(double switch_in, double switch_out, LPoint3d const &center, double fade = 0.0)
  double param0;
  double param1;
  PyObject *param2;
  double param3 = 0.0;
  static const char *keyword_list[] = {"switch_in", "switch_out", "center", "fade", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ddO|d:EggSwitchConditionDistance", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
    LPoint3d param2_local;
    LPoint3d const *param2_this = Dtool_Coerce_LPoint3d(param2, param2_local);
    if (!(param2_this != nullptr)) {
      Dtool_Raise_ArgTypeError(param2, 2, "EggSwitchConditionDistance.EggSwitchConditionDistance", "LPoint3d");
      return -1;
    }
    EggSwitchConditionDistance *return_value = new EggSwitchConditionDistance((double)param0, (double)param1, *param2_this, (double)param3);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggSwitchConditionDistance, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggSwitchConditionDistance(double switch_in, double switch_out, const LPoint3d center, double fade)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggSwitchConditionDistance(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggSwitchConditionDistance) {
    printf("EggSwitchConditionDistance ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggSwitchConditionDistance *local_this = (EggSwitchConditionDistance *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggSwitchConditionDistance) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggSwitchCondition *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggSwitchCondition) {
    return (EggSwitchCondition *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggSwitchCondition *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggSwitchCondition *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggSwitchCondition *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggSwitchConditionDistance(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggSwitchConditionDistance) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggSwitchConditionDistance*)other_this;
  }
  if (from_type == Dtool_Ptr_EggSwitchCondition) {
    EggSwitchCondition* other_this = (EggSwitchCondition*)from_this;
    return (EggSwitchConditionDistance*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggSwitchConditionDistance*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggSwitchConditionDistance*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggSwitchConditionDistance*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggGroup
 */
/**
 * Python function wrapper for:
 * void EggGroup::operator =(EggGroup const &copy)
 */
static PyObject *Dtool_EggGroup_operator_400(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.assign")) {
    return nullptr;
  }
  // 1-void EggGroup::operator =(EggGroup const &copy)
  EggGroup const *arg_this = (EggGroup *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggGroup, 1, "EggGroup.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggGroup *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggGroup, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggGroup self, const EggGroup copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_operator_400_comment =
  "C++ Interface:\n"
  "assign(const EggGroup self, const EggGroup copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_operator_400_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void EggGroup::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_EggGroup_write_402(PyObject *self, PyObject *args, PyObject *kwds) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-virtual void EggGroup::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "EggGroup.write", false, true);
    if (param1_this != nullptr) {
      ((*(const EggGroup*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(EggGroup self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_write_402_comment =
  "C++ Interface:\n"
  "write(EggGroup self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes the group and all of its children to the indicated output stream in\n"
  " * Egg format.\n"
  " */";
#else
static const char *Dtool_EggGroup_write_402_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::write_billboard_flags(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_EggGroup_write_billboard_flags_403(PyObject *self, PyObject *args, PyObject *kwds) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-void EggGroup::write_billboard_flags(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write_billboard_flags", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "EggGroup.write_billboard_flags", false, true);
    if (param1_this != nullptr) {
      ((*(const EggGroup*)local_this).write_billboard_flags)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_billboard_flags(EggGroup self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_write_billboard_flags_403_comment =
  "C++ Interface:\n"
  "write_billboard_flags(EggGroup self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes just the <Billboard> entry and related fields to the indicated\n"
  " * ostream.\n"
  " */";
#else
static const char *Dtool_EggGroup_write_billboard_flags_403_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::write_collide_flags(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_EggGroup_write_collide_flags_404(PyObject *self, PyObject *args, PyObject *kwds) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-void EggGroup::write_collide_flags(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write_collide_flags", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "EggGroup.write_collide_flags", false, true);
    if (param1_this != nullptr) {
      ((*(const EggGroup*)local_this).write_collide_flags)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_collide_flags(EggGroup self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_write_collide_flags_404_comment =
  "C++ Interface:\n"
  "write_collide_flags(EggGroup self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes just the <Collide> entry and related fields to the indicated\n"
  " * ostream.\n"
  " */";
#else
static const char *Dtool_EggGroup_write_collide_flags_404_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::write_model_flags(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_EggGroup_write_model_flags_405(PyObject *self, PyObject *args, PyObject *kwds) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-void EggGroup::write_model_flags(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write_model_flags", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "EggGroup.write_model_flags", false, true);
    if (param1_this != nullptr) {
      ((*(const EggGroup*)local_this).write_model_flags)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_model_flags(EggGroup self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_write_model_flags_405_comment =
  "C++ Interface:\n"
  "write_model_flags(EggGroup self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes the <Model> flag and related flags to the indicated ostream.\n"
  " */";
#else
static const char *Dtool_EggGroup_write_model_flags_405_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::write_switch_flags(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_EggGroup_write_switch_flags_406(PyObject *self, PyObject *args, PyObject *kwds) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-void EggGroup::write_switch_flags(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write_switch_flags", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "EggGroup.write_switch_flags", false, true);
    if (param1_this != nullptr) {
      ((*(const EggGroup*)local_this).write_switch_flags)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_switch_flags(EggGroup self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_write_switch_flags_406_comment =
  "C++ Interface:\n"
  "write_switch_flags(EggGroup self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes the <Switch> flag and related flags to the indicated ostream.\n"
  " */";
#else
static const char *Dtool_EggGroup_write_switch_flags_406_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::write_object_types(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_EggGroup_write_object_types_407(PyObject *self, PyObject *args, PyObject *kwds) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-void EggGroup::write_object_types(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write_object_types", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "EggGroup.write_object_types", false, true);
    if (param1_this != nullptr) {
      ((*(const EggGroup*)local_this).write_object_types)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_object_types(EggGroup self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_write_object_types_407_comment =
  "C++ Interface:\n"
  "write_object_types(EggGroup self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes just the <ObjectTypes> entries, if any, to the indicated ostream.\n"
  " */";
#else
static const char *Dtool_EggGroup_write_object_types_407_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::write_decal_flags(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_EggGroup_write_decal_flags_408(PyObject *self, PyObject *args, PyObject *kwds) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-void EggGroup::write_decal_flags(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write_decal_flags", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "EggGroup.write_decal_flags", false, true);
    if (param1_this != nullptr) {
      ((*(const EggGroup*)local_this).write_decal_flags)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_decal_flags(EggGroup self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_write_decal_flags_408_comment =
  "C++ Interface:\n"
  "write_decal_flags(EggGroup self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes the flags related to decaling, if any.\n"
  " */";
#else
static const char *Dtool_EggGroup_write_decal_flags_408_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::write_tags(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_EggGroup_write_tags_409(PyObject *self, PyObject *args, PyObject *kwds) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-void EggGroup::write_tags(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write_tags", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "EggGroup.write_tags", false, true);
    if (param1_this != nullptr) {
      ((*(const EggGroup*)local_this).write_tags)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_tags(EggGroup self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_write_tags_409_comment =
  "C++ Interface:\n"
  "write_tags(EggGroup self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes just the <Tag> entries, if any, to the indicated ostream.\n"
  " */";
#else
static const char *Dtool_EggGroup_write_tags_409_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::write_render_mode(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_EggGroup_write_render_mode_410(PyObject *self, PyObject *args, PyObject *kwds) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-void EggGroup::write_render_mode(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write_render_mode", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "EggGroup.write_render_mode", false, true);
    if (param1_this != nullptr) {
      ((*(const EggGroup*)local_this).write_render_mode)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_render_mode(EggGroup self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_write_render_mode_410_comment =
  "C++ Interface:\n"
  "write_render_mode(EggGroup self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes the flags inherited from EggRenderMode and similar flags that\n"
  " * control obscure render effects.\n"
  " */";
#else
static const char *Dtool_EggGroup_write_render_mode_410_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggGroup::is_joint(void) const
 */
static PyObject *Dtool_EggGroup_is_joint_411(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-virtual bool EggGroup::is_joint(void) const
  bool return_value = ((*(const EggGroup*)local_this).is_joint)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_is_joint_411_comment =
  "C++ Interface:\n"
  "is_joint(EggGroup self)\n"
  "\n"
  "/**\n"
  " * Returns true if this particular node represents a <Joint> entry or not.\n"
  " * This is a handy thing to know since Joints are sorted to the end of their\n"
  " * sibling list when writing an egg file.  See EggGroupNode::write().\n"
  " */";
#else
static const char *Dtool_EggGroup_is_joint_411_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggGroup::determine_alpha_mode(void)
 */
static PyObject *Dtool_EggGroup_determine_alpha_mode_412(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.determine_alpha_mode")) {
    return nullptr;
  }
  // 1-virtual EggRenderMode *EggGroup::determine_alpha_mode(void)
  EggRenderMode *return_value = ((*local_this).determine_alpha_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_determine_alpha_mode_412_comment =
  "C++ Interface:\n"
  "determine_alpha_mode(const EggGroup self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this group that has an alpha_mode\n"
  " * other than AM_unspecified.  Returns a valid EggRenderMode pointer if one is\n"
  " * found, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_EggGroup_determine_alpha_mode_412_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggGroup::determine_depth_write_mode(void)
 */
static PyObject *Dtool_EggGroup_determine_depth_write_mode_413(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.determine_depth_write_mode")) {
    return nullptr;
  }
  // 1-virtual EggRenderMode *EggGroup::determine_depth_write_mode(void)
  EggRenderMode *return_value = ((*local_this).determine_depth_write_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_determine_depth_write_mode_413_comment =
  "C++ Interface:\n"
  "determine_depth_write_mode(const EggGroup self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this group that has a\n"
  " * depth_write_mode other than DWM_unspecified.  Returns a valid EggRenderMode\n"
  " * pointer if one is found, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_EggGroup_determine_depth_write_mode_413_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggGroup::determine_depth_test_mode(void)
 */
static PyObject *Dtool_EggGroup_determine_depth_test_mode_414(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.determine_depth_test_mode")) {
    return nullptr;
  }
  // 1-virtual EggRenderMode *EggGroup::determine_depth_test_mode(void)
  EggRenderMode *return_value = ((*local_this).determine_depth_test_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_determine_depth_test_mode_414_comment =
  "C++ Interface:\n"
  "determine_depth_test_mode(const EggGroup self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this group that has a\n"
  " * depth_test_mode other than DTM_unspecified.  Returns a valid EggRenderMode\n"
  " * pointer if one is found, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_EggGroup_determine_depth_test_mode_414_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggGroup::determine_visibility_mode(void)
 */
static PyObject *Dtool_EggGroup_determine_visibility_mode_415(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.determine_visibility_mode")) {
    return nullptr;
  }
  // 1-virtual EggRenderMode *EggGroup::determine_visibility_mode(void)
  EggRenderMode *return_value = ((*local_this).determine_visibility_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_determine_visibility_mode_415_comment =
  "C++ Interface:\n"
  "determine_visibility_mode(const EggGroup self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this group that has a\n"
  " * visibility_mode other than VM_unspecified.  Returns a valid EggRenderMode\n"
  " * pointer if one is found, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_EggGroup_determine_visibility_mode_415_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggGroup::determine_depth_offset(void)
 */
static PyObject *Dtool_EggGroup_determine_depth_offset_416(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.determine_depth_offset")) {
    return nullptr;
  }
  // 1-virtual EggRenderMode *EggGroup::determine_depth_offset(void)
  EggRenderMode *return_value = ((*local_this).determine_depth_offset)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_determine_depth_offset_416_comment =
  "C++ Interface:\n"
  "determine_depth_offset(const EggGroup self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this group that has a depth_offset\n"
  " * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_EggGroup_determine_depth_offset_416_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggGroup::determine_draw_order(void)
 */
static PyObject *Dtool_EggGroup_determine_draw_order_417(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.determine_draw_order")) {
    return nullptr;
  }
  // 1-virtual EggRenderMode *EggGroup::determine_draw_order(void)
  EggRenderMode *return_value = ((*local_this).determine_draw_order)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_determine_draw_order_417_comment =
  "C++ Interface:\n"
  "determine_draw_order(const EggGroup self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this group that has a draw_order\n"
  " * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_EggGroup_determine_draw_order_417_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggGroup::determine_bin(void)
 */
static PyObject *Dtool_EggGroup_determine_bin_418(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.determine_bin")) {
    return nullptr;
  }
  // 1-virtual EggRenderMode *EggGroup::determine_bin(void)
  EggRenderMode *return_value = ((*local_this).determine_bin)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_determine_bin_418_comment =
  "C++ Interface:\n"
  "determine_bin(const EggGroup self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this group that has a bin\n"
  " * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_EggGroup_determine_bin_418_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggGroup::determine_indexed(void)
 */
static PyObject *Dtool_EggGroup_determine_indexed_419(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.determine_indexed")) {
    return nullptr;
  }
  // 1-virtual bool EggGroup::determine_indexed(void)
  bool return_value = ((*local_this).determine_indexed)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_determine_indexed_419_comment =
  "C++ Interface:\n"
  "determine_indexed(const EggGroup self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup at this level or above\n"
  " * that has the \"indexed\" scalar set.  Returns the value of the indexed scalar\n"
  " * if it is found, or false if it is not.\n"
  " *\n"
  " * In other words, returns true if the \"indexed\" flag is in effect for the\n"
  " * indicated node, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggGroup_determine_indexed_419_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggGroup::determine_decal(void)
 */
static PyObject *Dtool_EggGroup_determine_decal_420(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.determine_decal")) {
    return nullptr;
  }
  // 1-virtual bool EggGroup::determine_decal(void)
  bool return_value = ((*local_this).determine_decal)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_determine_decal_420_comment =
  "C++ Interface:\n"
  "determine_decal(const EggGroup self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup at this level or above\n"
  " * that has the \"decal\" flag set.  Returns the value of the decal flag if it\n"
  " * is found, or false if it is not.\n"
  " *\n"
  " * In other words, returns true if the \"decal\" flag is in effect for the\n"
  " * indicated node, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggGroup_determine_decal_420_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::set_group_type(EggGroup::GroupType type)
 */
static PyObject *Dtool_EggGroup_set_group_type_421(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_group_type")) {
    return nullptr;
  }
  // 1-void EggGroup::set_group_type(EggGroup::GroupType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_group_type)((EggGroup::GroupType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_group_type(const EggGroup self, int type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_group_type_421_comment =
  "C++ Interface:\n"
  "set_group_type(const EggGroup self, int type)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_group_type_421_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggGroup::GroupType EggGroup::get_group_type(void) const
 */
static PyObject *Dtool_EggGroup_get_group_type_422(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline EggGroup::GroupType EggGroup::get_group_type(void) const
  EggGroup::GroupType return_value = ((*(const EggGroup*)local_this).get_group_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_group_type_422_comment =
  "C++ Interface:\n"
  "get_group_type(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_group_type_422_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::is_instance_type(void) const
 */
static PyObject *Dtool_EggGroup_is_instance_type_423(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline bool EggGroup::is_instance_type(void) const
  bool return_value = ((*(const EggGroup*)local_this).is_instance_type)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_is_instance_type_423_comment =
  "C++ Interface:\n"
  "is_instance_type(EggGroup self)\n"
  "\n"
  "/**\n"
  " * Returns true if this group is an instance type node; i.e.  it begins the\n"
  " * root of a local coordinate space.  This is not related to instancing\n"
  " * (multiple copies of a node in a scene graph).\n"
  " *\n"
  " * This also includes the case of the node including a billboard flag without\n"
  " * an explicit center, which implicitly makes the node behave like an\n"
  " * instance.\n"
  " */";
#else
static const char *Dtool_EggGroup_is_instance_type_423_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_billboard_type(EggGroup::BillboardType type)
 */
static PyObject *Dtool_EggGroup_set_billboard_type_424(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_billboard_type")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_billboard_type(EggGroup::BillboardType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_billboard_type)((EggGroup::BillboardType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_billboard_type(const EggGroup self, int type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_billboard_type_424_comment =
  "C++ Interface:\n"
  "set_billboard_type(const EggGroup self, int type)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_billboard_type_424_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggGroup::BillboardType EggGroup::get_billboard_type(void) const
 */
static PyObject *Dtool_EggGroup_get_billboard_type_425(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline EggGroup::BillboardType EggGroup::get_billboard_type(void) const
  EggGroup::BillboardType return_value = ((*(const EggGroup*)local_this).get_billboard_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_billboard_type_425_comment =
  "C++ Interface:\n"
  "get_billboard_type(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_billboard_type_425_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_billboard_center(LPoint3d const &billboard_center)
 */
static PyObject *Dtool_EggGroup_set_billboard_center_426(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_billboard_center")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_billboard_center(LPoint3d const &billboard_center)
  LPoint3d arg_local;
  LPoint3d const *arg_this = Dtool_Coerce_LPoint3d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggGroup.set_billboard_center", "LPoint3d");
  }
  ((*local_this).set_billboard_center)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_billboard_center(const EggGroup self, const LPoint3d billboard_center)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_billboard_center_426_comment =
  "C++ Interface:\n"
  "set_billboard_center(const EggGroup self, const LPoint3d billboard_center)\n"
  "\n"
  "/**\n"
  " * Sets the point around which the billboard will rotate, if this node\n"
  " * contains a billboard specification.\n"
  " *\n"
  " * If a billboard type is given but no billboard_center is specified, then the\n"
  " * group node is treated as an <Instance>, and the billboard rotates around\n"
  " * the origin.  If, however, a billboard_center is specified, then the group\n"
  " * node is *not* treated as an <Instance>, and the billboard rotates around\n"
  " * the specified point.\n"
  " *\n"
  " * The point is in the same coordinate system as the vertices of this node:\n"
  " * usually global, but possibly local if there is an <Instance> somewhere\n"
  " * above.  Specifically, this is the coordinate system defined by\n"
  " * get_vertex_frame().\n"
  " */";
#else
static const char *Dtool_EggGroup_set_billboard_center_426_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::clear_billboard_center(void)
 */
static PyObject *Dtool_EggGroup_clear_billboard_center_427(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.clear_billboard_center")) {
    return nullptr;
  }
  // 1-inline void EggGroup::clear_billboard_center(void)
  ((*local_this).clear_billboard_center)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_clear_billboard_center_427_comment =
  "C++ Interface:\n"
  "clear_billboard_center(const EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_clear_billboard_center_427_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::has_billboard_center(void) const
 */
static PyObject *Dtool_EggGroup_has_billboard_center_428(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline bool EggGroup::has_billboard_center(void) const
  bool return_value = ((*(const EggGroup*)local_this).has_billboard_center)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_has_billboard_center_428_comment =
  "C++ Interface:\n"
  "has_billboard_center(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_has_billboard_center_428_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3d const &EggGroup::get_billboard_center(void) const
 */
static PyObject *Dtool_EggGroup_get_billboard_center_429(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline LPoint3d const &EggGroup::get_billboard_center(void) const
  LPoint3d const *return_value = &(((*(const EggGroup*)local_this).get_billboard_center)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_billboard_center_429_comment =
  "C++ Interface:\n"
  "get_billboard_center(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_billboard_center_429_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_cs_type(EggGroup::CollisionSolidType type)
 */
static PyObject *Dtool_EggGroup_set_cs_type_430(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_cs_type")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_cs_type(EggGroup::CollisionSolidType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_cs_type)((EggGroup::CollisionSolidType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cs_type(const EggGroup self, int type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_cs_type_430_comment =
  "C++ Interface:\n"
  "set_cs_type(const EggGroup self, int type)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_cs_type_430_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggGroup::CollisionSolidType EggGroup::get_cs_type(void) const
 */
static PyObject *Dtool_EggGroup_get_cs_type_431(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline EggGroup::CollisionSolidType EggGroup::get_cs_type(void) const
  EggGroup::CollisionSolidType return_value = ((*(const EggGroup*)local_this).get_cs_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_cs_type_431_comment =
  "C++ Interface:\n"
  "get_cs_type(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_cs_type_431_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_collide_flags(int flags)
 */
static PyObject *Dtool_EggGroup_set_collide_flags_432(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_collide_flags")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_collide_flags(int flags)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_collide_flags)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collide_flags(const EggGroup self, int flags)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_collide_flags_432_comment =
  "C++ Interface:\n"
  "set_collide_flags(const EggGroup self, int flags)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_collide_flags_432_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggGroup::CollideFlags EggGroup::get_collide_flags(void) const
 */
static PyObject *Dtool_EggGroup_get_collide_flags_433(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline EggGroup::CollideFlags EggGroup::get_collide_flags(void) const
  EggGroup::CollideFlags return_value = ((*(const EggGroup*)local_this).get_collide_flags)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_collide_flags_433_comment =
  "C++ Interface:\n"
  "get_collide_flags(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_collide_flags_433_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_collision_name(std::string const &collision_name)
 */
static PyObject *Dtool_EggGroup_set_collision_name_434(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_collision_name")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_collision_name(std::string const &collision_name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_collision_name)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collision_name(const EggGroup self, str collision_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_collision_name_434_comment =
  "C++ Interface:\n"
  "set_collision_name(const EggGroup self, str collision_name)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_collision_name_434_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::clear_collision_name(void)
 */
static PyObject *Dtool_EggGroup_clear_collision_name_435(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.clear_collision_name")) {
    return nullptr;
  }
  // 1-inline void EggGroup::clear_collision_name(void)
  ((*local_this).clear_collision_name)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_clear_collision_name_435_comment =
  "C++ Interface:\n"
  "clear_collision_name(const EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_clear_collision_name_435_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::has_collision_name(void) const
 */
static PyObject *Dtool_EggGroup_has_collision_name_436(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline bool EggGroup::has_collision_name(void) const
  bool return_value = ((*(const EggGroup*)local_this).has_collision_name)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_has_collision_name_436_comment =
  "C++ Interface:\n"
  "has_collision_name(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_has_collision_name_436_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &EggGroup::get_collision_name(void) const
 */
static PyObject *Dtool_EggGroup_get_collision_name_437(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline std::string const &EggGroup::get_collision_name(void) const
  std::string const &return_value = ((*(const EggGroup*)local_this).get_collision_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_collision_name_437_comment =
  "C++ Interface:\n"
  "get_collision_name(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_collision_name_437_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_dcs_type(EggGroup::DCSType type)
 */
static PyObject *Dtool_EggGroup_set_dcs_type_438(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_dcs_type")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_dcs_type(EggGroup::DCSType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_dcs_type)((EggGroup::DCSType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_dcs_type(const EggGroup self, int type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_dcs_type_438_comment =
  "C++ Interface:\n"
  "set_dcs_type(const EggGroup self, int type)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_dcs_type_438_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggGroup::DCSType EggGroup::get_dcs_type(void) const
 */
static PyObject *Dtool_EggGroup_get_dcs_type_439(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline EggGroup::DCSType EggGroup::get_dcs_type(void) const
  EggGroup::DCSType return_value = ((*(const EggGroup*)local_this).get_dcs_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_dcs_type_439_comment =
  "C++ Interface:\n"
  "get_dcs_type(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_dcs_type_439_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::has_dcs_type(void) const
 */
static PyObject *Dtool_EggGroup_has_dcs_type_440(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline bool EggGroup::has_dcs_type(void) const
  bool return_value = ((*(const EggGroup*)local_this).has_dcs_type)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_has_dcs_type_440_comment =
  "C++ Interface:\n"
  "has_dcs_type(EggGroup self)\n"
  "\n"
  "/**\n"
  " * Returns true if the specified DCS type is not DC_none and not\n"
  " * DC_unspecified.\n"
  " */";
#else
static const char *Dtool_EggGroup_has_dcs_type_440_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_dart_type(EggGroup::DartType type)
 */
static PyObject *Dtool_EggGroup_set_dart_type_441(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_dart_type")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_dart_type(EggGroup::DartType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_dart_type)((EggGroup::DartType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_dart_type(const EggGroup self, int type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_dart_type_441_comment =
  "C++ Interface:\n"
  "set_dart_type(const EggGroup self, int type)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_dart_type_441_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggGroup::DartType EggGroup::get_dart_type(void) const
 */
static PyObject *Dtool_EggGroup_get_dart_type_442(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline EggGroup::DartType EggGroup::get_dart_type(void) const
  EggGroup::DartType return_value = ((*(const EggGroup*)local_this).get_dart_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_dart_type_442_comment =
  "C++ Interface:\n"
  "get_dart_type(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_dart_type_442_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_switch_flag(bool flag)
 */
static PyObject *Dtool_EggGroup_set_switch_flag_443(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_switch_flag")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_switch_flag(bool flag)
  ((*local_this).set_switch_flag)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_switch_flag(const EggGroup self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_switch_flag_443_comment =
  "C++ Interface:\n"
  "set_switch_flag(const EggGroup self, bool flag)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_switch_flag_443_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::get_switch_flag(void) const
 */
static PyObject *Dtool_EggGroup_get_switch_flag_444(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline bool EggGroup::get_switch_flag(void) const
  bool return_value = ((*(const EggGroup*)local_this).get_switch_flag)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_switch_flag_444_comment =
  "C++ Interface:\n"
  "get_switch_flag(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_switch_flag_444_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_switch_fps(double fps)
 */
static PyObject *Dtool_EggGroup_set_switch_fps_445(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_switch_fps")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_switch_fps(double fps)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_switch_fps)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_switch_fps(const EggGroup self, double fps)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_switch_fps_445_comment =
  "C++ Interface:\n"
  "set_switch_fps(const EggGroup self, double fps)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_switch_fps_445_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double EggGroup::get_switch_fps(void) const
 */
static PyObject *Dtool_EggGroup_get_switch_fps_446(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline double EggGroup::get_switch_fps(void) const
  double return_value = ((*(const EggGroup*)local_this).get_switch_fps)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_switch_fps_446_comment =
  "C++ Interface:\n"
  "get_switch_fps(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_switch_fps_446_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::add_object_type(std::string const &object_type)
 */
static PyObject *Dtool_EggGroup_add_object_type_447(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.add_object_type")) {
    return nullptr;
  }
  // 1-inline void EggGroup::add_object_type(std::string const &object_type)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).add_object_type)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_object_type(const EggGroup self, str object_type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_add_object_type_447_comment =
  "C++ Interface:\n"
  "add_object_type(const EggGroup self, str object_type)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_add_object_type_447_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::clear_object_types(void)
 */
static PyObject *Dtool_EggGroup_clear_object_types_448(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.clear_object_types")) {
    return nullptr;
  }
  // 1-inline void EggGroup::clear_object_types(void)
  ((*local_this).clear_object_types)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_clear_object_types_448_comment =
  "C++ Interface:\n"
  "clear_object_types(const EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_clear_object_types_448_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggGroup::get_num_object_types(void) const
 */
static PyObject *Dtool_EggGroup_get_num_object_types_449(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline int EggGroup::get_num_object_types(void) const
  int return_value = ((*(const EggGroup*)local_this).get_num_object_types)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_num_object_types_449_comment =
  "C++ Interface:\n"
  "get_num_object_types(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_num_object_types_449_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string EggGroup::get_object_type(int index) const
 */
static PyObject *Dtool_EggGroup_get_object_type_450(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline std::string EggGroup::get_object_type(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = ((*(const EggGroup*)local_this).get_object_type)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_object_type(EggGroup self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_object_type_450_comment =
  "C++ Interface:\n"
  "get_object_type(EggGroup self, int index)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_object_type_450_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggGroup::has_object_type(std::string const &object_type) const
 */
static PyObject *Dtool_EggGroup_has_object_type_452(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-bool EggGroup::has_object_type(std::string const &object_type) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*(const EggGroup*)local_this).has_object_type)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_object_type(EggGroup self, str object_type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_has_object_type_452_comment =
  "C++ Interface:\n"
  "has_object_type(EggGroup self, str object_type)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated object type has been added to the group, or\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_EggGroup_has_object_type_452_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggGroup::remove_object_type(std::string const &object_type)
 */
static PyObject *Dtool_EggGroup_remove_object_type_453(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.remove_object_type")) {
    return nullptr;
  }
  // 1-bool EggGroup::remove_object_type(std::string const &object_type)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*local_this).remove_object_type)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_object_type(const EggGroup self, str object_type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_remove_object_type_453_comment =
  "C++ Interface:\n"
  "remove_object_type(const EggGroup self, str object_type)\n"
  "\n"
  "/**\n"
  " * Removes the first instance of the indicated object type from the group if\n"
  " * it is present.  Returns true if the object type was found and removed,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_EggGroup_remove_object_type_453_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_model_flag(bool flag)
 */
static PyObject *Dtool_EggGroup_set_model_flag_454(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_model_flag")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_model_flag(bool flag)
  ((*local_this).set_model_flag)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_model_flag(const EggGroup self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_model_flag_454_comment =
  "C++ Interface:\n"
  "set_model_flag(const EggGroup self, bool flag)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_model_flag_454_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::get_model_flag(void) const
 */
static PyObject *Dtool_EggGroup_get_model_flag_455(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline bool EggGroup::get_model_flag(void) const
  bool return_value = ((*(const EggGroup*)local_this).get_model_flag)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_model_flag_455_comment =
  "C++ Interface:\n"
  "get_model_flag(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_model_flag_455_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_texlist_flag(bool flag)
 */
static PyObject *Dtool_EggGroup_set_texlist_flag_456(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_texlist_flag")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_texlist_flag(bool flag)
  ((*local_this).set_texlist_flag)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_texlist_flag(const EggGroup self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_texlist_flag_456_comment =
  "C++ Interface:\n"
  "set_texlist_flag(const EggGroup self, bool flag)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_texlist_flag_456_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::get_texlist_flag(void) const
 */
static PyObject *Dtool_EggGroup_get_texlist_flag_457(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline bool EggGroup::get_texlist_flag(void) const
  bool return_value = ((*(const EggGroup*)local_this).get_texlist_flag)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_texlist_flag_457_comment =
  "C++ Interface:\n"
  "get_texlist_flag(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_texlist_flag_457_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_nofog_flag(bool flag)
 */
static PyObject *Dtool_EggGroup_set_nofog_flag_458(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_nofog_flag")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_nofog_flag(bool flag)
  ((*local_this).set_nofog_flag)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_nofog_flag(const EggGroup self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_nofog_flag_458_comment =
  "C++ Interface:\n"
  "set_nofog_flag(const EggGroup self, bool flag)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_nofog_flag_458_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::get_nofog_flag(void) const
 */
static PyObject *Dtool_EggGroup_get_nofog_flag_459(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline bool EggGroup::get_nofog_flag(void) const
  bool return_value = ((*(const EggGroup*)local_this).get_nofog_flag)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_nofog_flag_459_comment =
  "C++ Interface:\n"
  "get_nofog_flag(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_nofog_flag_459_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_decal_flag(bool flag)
 */
static PyObject *Dtool_EggGroup_set_decal_flag_460(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_decal_flag")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_decal_flag(bool flag)
  ((*local_this).set_decal_flag)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_decal_flag(const EggGroup self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_decal_flag_460_comment =
  "C++ Interface:\n"
  "set_decal_flag(const EggGroup self, bool flag)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_decal_flag_460_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::get_decal_flag(void) const
 */
static PyObject *Dtool_EggGroup_get_decal_flag_461(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline bool EggGroup::get_decal_flag(void) const
  bool return_value = ((*(const EggGroup*)local_this).get_decal_flag)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_decal_flag_461_comment =
  "C++ Interface:\n"
  "get_decal_flag(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_decal_flag_461_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_direct_flag(bool flag)
 */
static PyObject *Dtool_EggGroup_set_direct_flag_462(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_direct_flag")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_direct_flag(bool flag)
  ((*local_this).set_direct_flag)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_direct_flag(const EggGroup self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_direct_flag_462_comment =
  "C++ Interface:\n"
  "set_direct_flag(const EggGroup self, bool flag)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_direct_flag_462_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::get_direct_flag(void) const
 */
static PyObject *Dtool_EggGroup_get_direct_flag_463(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline bool EggGroup::get_direct_flag(void) const
  bool return_value = ((*(const EggGroup*)local_this).get_direct_flag)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_direct_flag_463_comment =
  "C++ Interface:\n"
  "get_direct_flag(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_direct_flag_463_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_portal_flag(bool flag)
 */
static PyObject *Dtool_EggGroup_set_portal_flag_464(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_portal_flag")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_portal_flag(bool flag)
  ((*local_this).set_portal_flag)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_portal_flag(const EggGroup self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_portal_flag_464_comment =
  "C++ Interface:\n"
  "set_portal_flag(const EggGroup self, bool flag)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_portal_flag_464_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::get_portal_flag(void) const
 */
static PyObject *Dtool_EggGroup_get_portal_flag_465(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline bool EggGroup::get_portal_flag(void) const
  bool return_value = ((*(const EggGroup*)local_this).get_portal_flag)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_portal_flag_465_comment =
  "C++ Interface:\n"
  "get_portal_flag(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_portal_flag_465_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_occluder_flag(bool flag)
 */
static PyObject *Dtool_EggGroup_set_occluder_flag_466(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_occluder_flag")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_occluder_flag(bool flag)
  ((*local_this).set_occluder_flag)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_occluder_flag(const EggGroup self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_occluder_flag_466_comment =
  "C++ Interface:\n"
  "set_occluder_flag(const EggGroup self, bool flag)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_occluder_flag_466_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::get_occluder_flag(void) const
 */
static PyObject *Dtool_EggGroup_get_occluder_flag_467(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline bool EggGroup::get_occluder_flag(void) const
  bool return_value = ((*(const EggGroup*)local_this).get_occluder_flag)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_occluder_flag_467_comment =
  "C++ Interface:\n"
  "get_occluder_flag(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_occluder_flag_467_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_polylight_flag(bool flag)
 */
static PyObject *Dtool_EggGroup_set_polylight_flag_468(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_polylight_flag")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_polylight_flag(bool flag)
  ((*local_this).set_polylight_flag)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_polylight_flag(const EggGroup self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_polylight_flag_468_comment =
  "C++ Interface:\n"
  "set_polylight_flag(const EggGroup self, bool flag)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_polylight_flag_468_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::get_polylight_flag(void) const
 */
static PyObject *Dtool_EggGroup_get_polylight_flag_469(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline bool EggGroup::get_polylight_flag(void) const
  bool return_value = ((*(const EggGroup*)local_this).get_polylight_flag)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_polylight_flag_469_comment =
  "C++ Interface:\n"
  "get_polylight_flag(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_polylight_flag_469_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_indexed_flag(bool flag)
 */
static PyObject *Dtool_EggGroup_set_indexed_flag_470(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_indexed_flag")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_indexed_flag(bool flag)
  ((*local_this).set_indexed_flag)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_indexed_flag(const EggGroup self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_indexed_flag_470_comment =
  "C++ Interface:\n"
  "set_indexed_flag(const EggGroup self, bool flag)\n"
  "\n"
  "/**\n"
  " * If this flag is true, geometry at this node and below will be generated as\n"
  " * indexed geometry.\n"
  " */";
#else
static const char *Dtool_EggGroup_set_indexed_flag_470_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::clear_indexed_flag(void)
 */
static PyObject *Dtool_EggGroup_clear_indexed_flag_471(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.clear_indexed_flag")) {
    return nullptr;
  }
  // 1-inline void EggGroup::clear_indexed_flag(void)
  ((*local_this).clear_indexed_flag)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_clear_indexed_flag_471_comment =
  "C++ Interface:\n"
  "clear_indexed_flag(const EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_clear_indexed_flag_471_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::has_indexed_flag(void) const
 */
static PyObject *Dtool_EggGroup_has_indexed_flag_472(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline bool EggGroup::has_indexed_flag(void) const
  bool return_value = ((*(const EggGroup*)local_this).has_indexed_flag)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_has_indexed_flag_472_comment =
  "C++ Interface:\n"
  "has_indexed_flag(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_has_indexed_flag_472_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::get_indexed_flag(void) const
 */
static PyObject *Dtool_EggGroup_get_indexed_flag_473(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline bool EggGroup::get_indexed_flag(void) const
  bool return_value = ((*(const EggGroup*)local_this).get_indexed_flag)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_indexed_flag_473_comment =
  "C++ Interface:\n"
  "get_indexed_flag(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_indexed_flag_473_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_collide_mask(CollideMask mask)
 */
static PyObject *Dtool_EggGroup_set_collide_mask_474(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_collide_mask")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_collide_mask(CollideMask mask)
  BitMask< uint32_t, 32 > arg_local;
  CollideMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggGroup.set_collide_mask", "BitMask");
  }
  ((*local_this).set_collide_mask)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collide_mask(const EggGroup self, BitMask mask)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_collide_mask_474_comment =
  "C++ Interface:\n"
  "set_collide_mask(const EggGroup self, BitMask mask)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_collide_mask_474_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::clear_collide_mask(void)
 */
static PyObject *Dtool_EggGroup_clear_collide_mask_475(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.clear_collide_mask")) {
    return nullptr;
  }
  // 1-inline void EggGroup::clear_collide_mask(void)
  ((*local_this).clear_collide_mask)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_clear_collide_mask_475_comment =
  "C++ Interface:\n"
  "clear_collide_mask(const EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_clear_collide_mask_475_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::has_collide_mask(void) const
 */
static PyObject *Dtool_EggGroup_has_collide_mask_476(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline bool EggGroup::has_collide_mask(void) const
  bool return_value = ((*(const EggGroup*)local_this).has_collide_mask)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_has_collide_mask_476_comment =
  "C++ Interface:\n"
  "has_collide_mask(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_has_collide_mask_476_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CollideMask EggGroup::get_collide_mask(void) const
 */
static PyObject *Dtool_EggGroup_get_collide_mask_477(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline CollideMask EggGroup::get_collide_mask(void) const
  CollideMask *return_value = new CollideMask(((*(const EggGroup*)local_this).get_collide_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_collide_mask_477_comment =
  "C++ Interface:\n"
  "get_collide_mask(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_collide_mask_477_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_from_collide_mask(CollideMask mask)
 */
static PyObject *Dtool_EggGroup_set_from_collide_mask_478(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_from_collide_mask")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_from_collide_mask(CollideMask mask)
  BitMask< uint32_t, 32 > arg_local;
  CollideMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggGroup.set_from_collide_mask", "BitMask");
  }
  ((*local_this).set_from_collide_mask)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_from_collide_mask(const EggGroup self, BitMask mask)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_from_collide_mask_478_comment =
  "C++ Interface:\n"
  "set_from_collide_mask(const EggGroup self, BitMask mask)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_from_collide_mask_478_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::clear_from_collide_mask(void)
 */
static PyObject *Dtool_EggGroup_clear_from_collide_mask_479(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.clear_from_collide_mask")) {
    return nullptr;
  }
  // 1-inline void EggGroup::clear_from_collide_mask(void)
  ((*local_this).clear_from_collide_mask)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_clear_from_collide_mask_479_comment =
  "C++ Interface:\n"
  "clear_from_collide_mask(const EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_clear_from_collide_mask_479_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::has_from_collide_mask(void) const
 */
static PyObject *Dtool_EggGroup_has_from_collide_mask_480(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline bool EggGroup::has_from_collide_mask(void) const
  bool return_value = ((*(const EggGroup*)local_this).has_from_collide_mask)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_has_from_collide_mask_480_comment =
  "C++ Interface:\n"
  "has_from_collide_mask(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_has_from_collide_mask_480_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CollideMask EggGroup::get_from_collide_mask(void) const
 */
static PyObject *Dtool_EggGroup_get_from_collide_mask_481(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline CollideMask EggGroup::get_from_collide_mask(void) const
  CollideMask *return_value = new CollideMask(((*(const EggGroup*)local_this).get_from_collide_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_from_collide_mask_481_comment =
  "C++ Interface:\n"
  "get_from_collide_mask(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_from_collide_mask_481_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_into_collide_mask(CollideMask mask)
 */
static PyObject *Dtool_EggGroup_set_into_collide_mask_482(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_into_collide_mask")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_into_collide_mask(CollideMask mask)
  BitMask< uint32_t, 32 > arg_local;
  CollideMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggGroup.set_into_collide_mask", "BitMask");
  }
  ((*local_this).set_into_collide_mask)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_into_collide_mask(const EggGroup self, BitMask mask)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_into_collide_mask_482_comment =
  "C++ Interface:\n"
  "set_into_collide_mask(const EggGroup self, BitMask mask)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_into_collide_mask_482_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::clear_into_collide_mask(void)
 */
static PyObject *Dtool_EggGroup_clear_into_collide_mask_483(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.clear_into_collide_mask")) {
    return nullptr;
  }
  // 1-inline void EggGroup::clear_into_collide_mask(void)
  ((*local_this).clear_into_collide_mask)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_clear_into_collide_mask_483_comment =
  "C++ Interface:\n"
  "clear_into_collide_mask(const EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_clear_into_collide_mask_483_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::has_into_collide_mask(void) const
 */
static PyObject *Dtool_EggGroup_has_into_collide_mask_484(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline bool EggGroup::has_into_collide_mask(void) const
  bool return_value = ((*(const EggGroup*)local_this).has_into_collide_mask)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_has_into_collide_mask_484_comment =
  "C++ Interface:\n"
  "has_into_collide_mask(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_has_into_collide_mask_484_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CollideMask EggGroup::get_into_collide_mask(void) const
 */
static PyObject *Dtool_EggGroup_get_into_collide_mask_485(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline CollideMask EggGroup::get_into_collide_mask(void) const
  CollideMask *return_value = new CollideMask(((*(const EggGroup*)local_this).get_into_collide_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_into_collide_mask_485_comment =
  "C++ Interface:\n"
  "get_into_collide_mask(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_into_collide_mask_485_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_blend_mode(EggGroup::BlendMode blend_mode)
 */
static PyObject *Dtool_EggGroup_set_blend_mode_486(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_blend_mode")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_blend_mode(EggGroup::BlendMode blend_mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_blend_mode)((EggGroup::BlendMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_blend_mode(const EggGroup self, int blend_mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_blend_mode_486_comment =
  "C++ Interface:\n"
  "set_blend_mode(const EggGroup self, int blend_mode)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_blend_mode_486_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggGroup::BlendMode EggGroup::get_blend_mode(void) const
 */
static PyObject *Dtool_EggGroup_get_blend_mode_487(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline EggGroup::BlendMode EggGroup::get_blend_mode(void) const
  EggGroup::BlendMode return_value = ((*(const EggGroup*)local_this).get_blend_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_blend_mode_487_comment =
  "C++ Interface:\n"
  "get_blend_mode(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_blend_mode_487_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_blend_operand_a(EggGroup::BlendOperand blend_operand_a)
 */
static PyObject *Dtool_EggGroup_set_blend_operand_a_488(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_blend_operand_a")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_blend_operand_a(EggGroup::BlendOperand blend_operand_a)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_blend_operand_a)((EggGroup::BlendOperand)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_blend_operand_a(const EggGroup self, int blend_operand_a)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_blend_operand_a_488_comment =
  "C++ Interface:\n"
  "set_blend_operand_a(const EggGroup self, int blend_operand_a)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_blend_operand_a_488_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggGroup::BlendOperand EggGroup::get_blend_operand_a(void) const
 */
static PyObject *Dtool_EggGroup_get_blend_operand_a_489(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline EggGroup::BlendOperand EggGroup::get_blend_operand_a(void) const
  EggGroup::BlendOperand return_value = ((*(const EggGroup*)local_this).get_blend_operand_a)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_blend_operand_a_489_comment =
  "C++ Interface:\n"
  "get_blend_operand_a(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_blend_operand_a_489_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_blend_operand_b(EggGroup::BlendOperand blend_operand_b)
 */
static PyObject *Dtool_EggGroup_set_blend_operand_b_490(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_blend_operand_b")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_blend_operand_b(EggGroup::BlendOperand blend_operand_b)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_blend_operand_b)((EggGroup::BlendOperand)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_blend_operand_b(const EggGroup self, int blend_operand_b)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_blend_operand_b_490_comment =
  "C++ Interface:\n"
  "set_blend_operand_b(const EggGroup self, int blend_operand_b)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_blend_operand_b_490_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggGroup::BlendOperand EggGroup::get_blend_operand_b(void) const
 */
static PyObject *Dtool_EggGroup_get_blend_operand_b_491(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline EggGroup::BlendOperand EggGroup::get_blend_operand_b(void) const
  EggGroup::BlendOperand return_value = ((*(const EggGroup*)local_this).get_blend_operand_b)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_blend_operand_b_491_comment =
  "C++ Interface:\n"
  "get_blend_operand_b(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_blend_operand_b_491_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_blend_color(LColor const &blend_color)
 */
static PyObject *Dtool_EggGroup_set_blend_color_492(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_blend_color")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_blend_color(LColor const &blend_color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggGroup.set_blend_color", "LVecBase4f");
  }
  ((*local_this).set_blend_color)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_blend_color(const EggGroup self, const LVecBase4f blend_color)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_blend_color_492_comment =
  "C++ Interface:\n"
  "set_blend_color(const EggGroup self, const LVecBase4f blend_color)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_blend_color_492_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::clear_blend_color(void)
 */
static PyObject *Dtool_EggGroup_clear_blend_color_493(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.clear_blend_color")) {
    return nullptr;
  }
  // 1-inline void EggGroup::clear_blend_color(void)
  ((*local_this).clear_blend_color)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_clear_blend_color_493_comment =
  "C++ Interface:\n"
  "clear_blend_color(const EggGroup self)\n"
  "\n"
  "/**\n"
  " * Removes the blend color specification.\n"
  " */";
#else
static const char *Dtool_EggGroup_clear_blend_color_493_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::has_blend_color(void) const
 */
static PyObject *Dtool_EggGroup_has_blend_color_494(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline bool EggGroup::has_blend_color(void) const
  bool return_value = ((*(const EggGroup*)local_this).has_blend_color)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_has_blend_color_494_comment =
  "C++ Interface:\n"
  "has_blend_color(EggGroup self)\n"
  "\n"
  "/**\n"
  " * Returns true if the blend color has been specified, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggGroup_has_blend_color_494_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &EggGroup::get_blend_color(void) const
 */
static PyObject *Dtool_EggGroup_get_blend_color_495(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline LColor const &EggGroup::get_blend_color(void) const
  LColor const *return_value = &(((*(const EggGroup*)local_this).get_blend_color)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_blend_color_495_comment =
  "C++ Interface:\n"
  "get_blend_color(EggGroup self)\n"
  "\n"
  "/**\n"
  " * Returns the blend color if one has been specified, or (0, 0, 0, 0) if one\n"
  " * has not.\n"
  " */";
#else
static const char *Dtool_EggGroup_get_blend_color_495_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_lod(EggSwitchCondition const &lod)
 */
static PyObject *Dtool_EggGroup_set_lod_496(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_lod")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_lod(EggSwitchCondition const &lod)
  EggSwitchCondition const *arg_this = (EggSwitchCondition *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggSwitchCondition, 1, "EggGroup.set_lod", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_lod)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_lod(const EggGroup self, const EggSwitchCondition lod)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_lod_496_comment =
  "C++ Interface:\n"
  "set_lod(const EggGroup self, const EggSwitchCondition lod)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_set_lod_496_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::clear_lod(void)
 */
static PyObject *Dtool_EggGroup_clear_lod_497(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.clear_lod")) {
    return nullptr;
  }
  // 1-inline void EggGroup::clear_lod(void)
  ((*local_this).clear_lod)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_clear_lod_497_comment =
  "C++ Interface:\n"
  "clear_lod(const EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_clear_lod_497_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::has_lod(void) const
 */
static PyObject *Dtool_EggGroup_has_lod_498(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline bool EggGroup::has_lod(void) const
  bool return_value = ((*(const EggGroup*)local_this).has_lod)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_has_lod_498_comment =
  "C++ Interface:\n"
  "has_lod(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_has_lod_498_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggSwitchCondition const &EggGroup::get_lod(void) const
 */
static PyObject *Dtool_EggGroup_get_lod_499(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline EggSwitchCondition const &EggGroup::get_lod(void) const
  EggSwitchCondition const *return_value = &(((*(const EggGroup*)local_this).get_lod)());
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggSwitchCondition, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_lod_499_comment =
  "C++ Interface:\n"
  "get_lod(EggGroup self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggGroup_get_lod_499_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_tag(std::string const &key, std::string const &value)
 */
static PyObject *Dtool_EggGroup_set_tag_500(PyObject *self, PyObject *args, PyObject *kwds) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_tag")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_tag(std::string const &key, std::string const &value)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"key", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:set_tag", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
    ((*local_this).set_tag)(std::string(param1_str, param1_len), std::string(param2_str, param2_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tag(const EggGroup self, str key, str value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_tag_500_comment =
  "C++ Interface:\n"
  "set_tag(const EggGroup self, str key, str value)\n"
  "\n"
  "/**\n"
  " * Associates a user-defined value with a user-defined key which is stored on\n"
  " * the node.  This value has no meaning to Panda; but it is stored\n"
  " * indefinitely on the node until it is requested again.  This value will be\n"
  " * copied to the PandaNode that is created for this particular EggGroup if the\n"
  " * egg file is loaded as a scene.\n"
  " *\n"
  " * Each unique key stores a different string value.  There is no effective\n"
  " * limit on the number of different keys that may be stored or on the length\n"
  " * of any one key's value.\n"
  " */";
#else
static const char *Dtool_EggGroup_set_tag_500_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string EggGroup::get_tag(std::string const &key) const
 */
static PyObject *Dtool_EggGroup_get_tag_501(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline std::string EggGroup::get_tag(std::string const &key) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    std::string return_value = ((*(const EggGroup*)local_this).get_tag)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_tag(EggGroup self, str key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_tag_501_comment =
  "C++ Interface:\n"
  "get_tag(EggGroup self, str key)\n"
  "\n"
  "/**\n"
  " * Retrieves the user-defined value that was previously set on this node for\n"
  " * the particular key, if any.  If no value has been previously set, returns\n"
  " * the empty string.\n"
  " */";
#else
static const char *Dtool_EggGroup_get_tag_501_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::has_tag(std::string const &key) const
 */
static PyObject *Dtool_EggGroup_has_tag_502(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline bool EggGroup::has_tag(std::string const &key) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*(const EggGroup*)local_this).has_tag)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_tag(EggGroup self, str key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_has_tag_502_comment =
  "C++ Interface:\n"
  "has_tag(EggGroup self, str key)\n"
  "\n"
  "/**\n"
  " * Returns true if a value has been defined on this node for the particular\n"
  " * key (even if that value is the empty string), or false if no value has been\n"
  " * set.\n"
  " */";
#else
static const char *Dtool_EggGroup_has_tag_502_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::clear_tag(std::string const &key)
 */
static PyObject *Dtool_EggGroup_clear_tag_503(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.clear_tag")) {
    return nullptr;
  }
  // 1-inline void EggGroup::clear_tag(std::string const &key)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).clear_tag)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_tag(const EggGroup self, str key)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_clear_tag_503_comment =
  "C++ Interface:\n"
  "clear_tag(const EggGroup self, str key)\n"
  "\n"
  "/**\n"
  " * Removes the value defined for this key on this particular node.  After a\n"
  " * call to clear_tag(), has_tag() will return false for the indicated key.\n"
  " */";
#else
static const char *Dtool_EggGroup_clear_tag_503_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggTransform const &EggGroup::get_default_pose(void) const
 */
static PyObject *Dtool_EggGroup_get_default_pose_504(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline EggTransform const &EggGroup::get_default_pose(void) const
  EggTransform const *return_value = &(((*(const EggGroup*)local_this).get_default_pose)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggTransform, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_default_pose_504_comment =
  "C++ Interface:\n"
  "get_default_pose(EggGroup self)\n"
  "\n"
  "/**\n"
  " * Returns a read-only accessor to the initial pose transform.  This is the\n"
  " * <DefaultPose> entry for a Joint, and defines only the initial transform\n"
  " * pose for the unanimated joint; it has nothing to do with the group's\n"
  " * <Transform> entry, which defines the (eventual) space of the group's\n"
  " * vertices.\n"
  " */";
#else
static const char *Dtool_EggGroup_get_default_pose_504_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggTransform &EggGroup::modify_default_pose(void)
 */
static PyObject *Dtool_EggGroup_modify_default_pose_505(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.modify_default_pose")) {
    return nullptr;
  }
  // 1-inline EggTransform &EggGroup::modify_default_pose(void)
  EggTransform *return_value = &(((*local_this).modify_default_pose)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggTransform, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_modify_default_pose_505_comment =
  "C++ Interface:\n"
  "modify_default_pose(const EggGroup self)\n"
  "\n"
  "/**\n"
  " * Returns a writable accessor to the initial pose transform.  This is the\n"
  " * <DefaultPose> entry for a Joint, and defines only the initial transform\n"
  " * pose for the unanimated joint; it has nothing to do with the group's\n"
  " * <Transform> entry, which defines the (eventual) space of the group's\n"
  " * vertices.\n"
  " */";
#else
static const char *Dtool_EggGroup_modify_default_pose_505_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_default_pose(EggTransform const &transform)
 */
static PyObject *Dtool_EggGroup_set_default_pose_506(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_default_pose")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_default_pose(EggTransform const &transform)
  EggTransform const *arg_this = (EggTransform *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggTransform, 1, "EggGroup.set_default_pose", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_default_pose)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_default_pose(const EggGroup self, const EggTransform transform)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_default_pose_506_comment =
  "C++ Interface:\n"
  "set_default_pose(const EggGroup self, const EggTransform transform)\n"
  "\n"
  "/**\n"
  " * Replaces the initial pose transform.  This is the <DefaultPose> entry for a\n"
  " * Joint, and defines only the initial transform pose for the unanimated\n"
  " * joint; it has nothing to do with the group's <Transform> entry, which\n"
  " * defines the (eventual) space of the group's vertices.\n"
  " */";
#else
static const char *Dtool_EggGroup_set_default_pose_506_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::clear_default_pose(void)
 */
static PyObject *Dtool_EggGroup_clear_default_pose_507(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.clear_default_pose")) {
    return nullptr;
  }
  // 1-inline void EggGroup::clear_default_pose(void)
  ((*local_this).clear_default_pose)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_clear_default_pose_507_comment =
  "C++ Interface:\n"
  "clear_default_pose(const EggGroup self)\n"
  "\n"
  "/**\n"
  " * Removes the initial pose transform.  See set_default_pose().\n"
  " */";
#else
static const char *Dtool_EggGroup_clear_default_pose_507_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_scroll_u(double const u_speed)
 */
static PyObject *Dtool_EggGroup_set_scroll_u_508(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_scroll_u")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_scroll_u(double const u_speed)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_scroll_u)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scroll_u(const EggGroup self, double u_speed)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_scroll_u_508_comment =
  "C++ Interface:\n"
  "set_scroll_u(const EggGroup self, double u_speed)\n";
#else
static const char *Dtool_EggGroup_set_scroll_u_508_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_scroll_v(double const v_speed)
 */
static PyObject *Dtool_EggGroup_set_scroll_v_509(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_scroll_v")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_scroll_v(double const v_speed)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_scroll_v)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scroll_v(const EggGroup self, double v_speed)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_scroll_v_509_comment =
  "C++ Interface:\n"
  "set_scroll_v(const EggGroup self, double v_speed)\n";
#else
static const char *Dtool_EggGroup_set_scroll_v_509_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_scroll_w(double const w_speed)
 */
static PyObject *Dtool_EggGroup_set_scroll_w_510(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_scroll_w")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_scroll_w(double const w_speed)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_scroll_w)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scroll_w(const EggGroup self, double w_speed)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_scroll_w_510_comment =
  "C++ Interface:\n"
  "set_scroll_w(const EggGroup self, double w_speed)\n";
#else
static const char *Dtool_EggGroup_set_scroll_w_510_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggGroup::set_scroll_r(double const r_speed)
 */
static PyObject *Dtool_EggGroup_set_scroll_r_511(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_scroll_r")) {
    return nullptr;
  }
  // 1-inline void EggGroup::set_scroll_r(double const r_speed)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_scroll_r)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scroll_r(const EggGroup self, double r_speed)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_scroll_r_511_comment =
  "C++ Interface:\n"
  "set_scroll_r(const EggGroup self, double r_speed)\n";
#else
static const char *Dtool_EggGroup_set_scroll_r_511_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double EggGroup::get_scroll_u(void) const
 */
static PyObject *Dtool_EggGroup_get_scroll_u_512(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline double EggGroup::get_scroll_u(void) const
  double return_value = ((*(const EggGroup*)local_this).get_scroll_u)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_scroll_u_512_comment =
  "C++ Interface:\n"
  "get_scroll_u(EggGroup self)\n";
#else
static const char *Dtool_EggGroup_get_scroll_u_512_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double EggGroup::get_scroll_v(void) const
 */
static PyObject *Dtool_EggGroup_get_scroll_v_513(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline double EggGroup::get_scroll_v(void) const
  double return_value = ((*(const EggGroup*)local_this).get_scroll_v)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_scroll_v_513_comment =
  "C++ Interface:\n"
  "get_scroll_v(EggGroup self)\n";
#else
static const char *Dtool_EggGroup_get_scroll_v_513_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double EggGroup::get_scroll_w(void) const
 */
static PyObject *Dtool_EggGroup_get_scroll_w_514(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline double EggGroup::get_scroll_w(void) const
  double return_value = ((*(const EggGroup*)local_this).get_scroll_w)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_scroll_w_514_comment =
  "C++ Interface:\n"
  "get_scroll_w(EggGroup self)\n";
#else
static const char *Dtool_EggGroup_get_scroll_w_514_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double EggGroup::get_scroll_r(void) const
 */
static PyObject *Dtool_EggGroup_get_scroll_r_515(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-inline double EggGroup::get_scroll_r(void) const
  double return_value = ((*(const EggGroup*)local_this).get_scroll_r)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_scroll_r_515_comment =
  "C++ Interface:\n"
  "get_scroll_r(EggGroup self)\n";
#else
static const char *Dtool_EggGroup_get_scroll_r_515_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggGroup::has_scrolling_uvs(void)
 */
static PyObject *Dtool_EggGroup_has_scrolling_uvs_516(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.has_scrolling_uvs")) {
    return nullptr;
  }
  // 1-inline bool EggGroup::has_scrolling_uvs(void)
  bool return_value = ((*local_this).has_scrolling_uvs)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_has_scrolling_uvs_516_comment =
  "C++ Interface:\n"
  "has_scrolling_uvs(const EggGroup self)\n";
#else
static const char *Dtool_EggGroup_has_scrolling_uvs_516_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::ref_vertex(EggVertex *vert, double membership = 1.0)
 */
static PyObject *Dtool_EggGroup_ref_vertex_565(PyObject *self, PyObject *args, PyObject *kwds) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.ref_vertex")) {
    return nullptr;
  }
  // 1-void EggGroup::ref_vertex(EggVertex *vert, double membership = 1.0)
  PyObject *param1;
  double param2 = 1.0;
  static const char *keyword_list[] = {"vert", "membership", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|d:ref_vertex", (char **)keyword_list, &param1, &param2)) {
    EggVertex *param1_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_EggVertex, 1, "EggGroup.ref_vertex", false, true);
    if (param1_this != nullptr) {
      ((*local_this).ref_vertex)(param1_this, (double)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ref_vertex(const EggGroup self, EggVertex vert, double membership)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_ref_vertex_565_comment =
  "C++ Interface:\n"
  "ref_vertex(const EggGroup self, EggVertex vert, double membership)\n"
  "\n"
  "/**\n"
  " * Adds the vertex to the set of those referenced by the group, at the\n"
  " * indicated membership level.  If the vertex is already being referenced,\n"
  " * increases the membership amount by the indicated amount.\n"
  " */";
#else
static const char *Dtool_EggGroup_ref_vertex_565_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::unref_vertex(EggVertex *vert)
 */
static PyObject *Dtool_EggGroup_unref_vertex_566(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.unref_vertex")) {
    return nullptr;
  }
  // 1-void EggGroup::unref_vertex(EggVertex *vert)
  EggVertex *arg_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertex, 1, "EggGroup.unref_vertex", false, true);
  if (arg_this != nullptr) {
    ((*local_this).unref_vertex)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unref_vertex(const EggGroup self, EggVertex vert)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_unref_vertex_566_comment =
  "C++ Interface:\n"
  "unref_vertex(const EggGroup self, EggVertex vert)\n"
  "\n"
  "/**\n"
  " * Removes the vertex from the set of those referenced by the group.  Does\n"
  " * nothing if the vertex is not already reffed.\n"
  " */";
#else
static const char *Dtool_EggGroup_unref_vertex_566_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::unref_all_vertices(void)
 */
static PyObject *Dtool_EggGroup_unref_all_vertices_567(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.unref_all_vertices")) {
    return nullptr;
  }
  // 1-void EggGroup::unref_all_vertices(void)
  ((*local_this).unref_all_vertices)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_unref_all_vertices_567_comment =
  "C++ Interface:\n"
  "unref_all_vertices(const EggGroup self)\n"
  "\n"
  "/**\n"
  " * Removes all vertices from the reference list.\n"
  " */";
#else
static const char *Dtool_EggGroup_unref_all_vertices_567_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * double EggGroup::get_vertex_membership(EggVertex const *vert) const
 */
static PyObject *Dtool_EggGroup_get_vertex_membership_568(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-double EggGroup::get_vertex_membership(EggVertex const *vert) const
  EggVertex const *arg_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertex, 1, "EggGroup.get_vertex_membership", true, true);
  if (arg_this != nullptr) {
    double return_value = ((*(const EggGroup*)local_this).get_vertex_membership)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex_membership(EggGroup self, const EggVertex vert)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_vertex_membership_568_comment =
  "C++ Interface:\n"
  "get_vertex_membership(EggGroup self, const EggVertex vert)\n"
  "\n"
  "/**\n"
  " * Returns the amount of membership of the indicated vertex in this group.  If\n"
  " * the vertex is not reffed by the group, returns 0.\n"
  " */";
#else
static const char *Dtool_EggGroup_get_vertex_membership_568_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::set_vertex_membership(EggVertex *vert, double membership)
 */
static PyObject *Dtool_EggGroup_set_vertex_membership_569(PyObject *self, PyObject *args, PyObject *kwds) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.set_vertex_membership")) {
    return nullptr;
  }
  // 1-void EggGroup::set_vertex_membership(EggVertex *vert, double membership)
  PyObject *param1;
  double param2;
  static const char *keyword_list[] = {"vert", "membership", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Od:set_vertex_membership", (char **)keyword_list, &param1, &param2)) {
    EggVertex *param1_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_EggVertex, 1, "EggGroup.set_vertex_membership", false, true);
    if (param1_this != nullptr) {
      ((*local_this).set_vertex_membership)(param1_this, (double)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vertex_membership(const EggGroup self, EggVertex vert, double membership)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_set_vertex_membership_569_comment =
  "C++ Interface:\n"
  "set_vertex_membership(const EggGroup self, EggVertex vert, double membership)\n"
  "\n"
  "/**\n"
  " * Explicitly sets the net membership of the indicated vertex in this group to\n"
  " * the given value.\n"
  " */";
#else
static const char *Dtool_EggGroup_set_vertex_membership_569_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::steal_vrefs(EggGroup *other)
 */
static PyObject *Dtool_EggGroup_steal_vrefs_570(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.steal_vrefs")) {
    return nullptr;
  }
  // 1-void EggGroup::steal_vrefs(EggGroup *other)
  EggGroup *arg_this = (EggGroup *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggGroup, 1, "EggGroup.steal_vrefs", false, true);
  if (arg_this != nullptr) {
    ((*local_this).steal_vrefs)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "steal_vrefs(const EggGroup self, EggGroup other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_steal_vrefs_570_comment =
  "C++ Interface:\n"
  "steal_vrefs(const EggGroup self, EggGroup other)\n"
  "\n"
  "/**\n"
  " * Moves all of the vertex references from the indicated other group into this\n"
  " * one.  If a given vertex was previously shared by both groups, the relative\n"
  " * memberships will be summed.\n"
  " */";
#else
static const char *Dtool_EggGroup_steal_vrefs_570_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::test_vref_integrity(void) const
 */
static PyObject *Dtool_EggGroup_test_vref_integrity_571(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-void EggGroup::test_vref_integrity(void) const
  ((*(const EggGroup*)local_this).test_vref_integrity)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_test_vref_integrity_571_comment =
  "C++ Interface:\n"
  "test_vref_integrity(EggGroup self)\n";
#else
static const char *Dtool_EggGroup_test_vref_integrity_571_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::add_group_ref(EggGroup *group)
 */
static PyObject *Dtool_EggGroup_add_group_ref_572(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.add_group_ref")) {
    return nullptr;
  }
  // 1-void EggGroup::add_group_ref(EggGroup *group)
  EggGroup *arg_this = (EggGroup *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggGroup, 1, "EggGroup.add_group_ref", false, true);
  if (arg_this != nullptr) {
    ((*local_this).add_group_ref)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_group_ref(const EggGroup self, EggGroup group)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_add_group_ref_572_comment =
  "C++ Interface:\n"
  "add_group_ref(const EggGroup self, EggGroup group)\n"
  "\n"
  "/**\n"
  " * Adds a new <Ref> entry to the group.  This declares an internal reference\n"
  " * to another node, and is used to implement scene-graph instancing; it is\n"
  " * only valid if the group_type is GT_instance.\n"
  " */";
#else
static const char *Dtool_EggGroup_add_group_ref_572_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int EggGroup::get_num_group_refs(void) const
 */
static PyObject *Dtool_EggGroup_get_num_group_refs_573(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-int EggGroup::get_num_group_refs(void) const
  int return_value = ((*(const EggGroup*)local_this).get_num_group_refs)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_num_group_refs_573_comment =
  "C++ Interface:\n"
  "get_num_group_refs(EggGroup self)\n"
  "\n"
  "/**\n"
  " * Returns the number of <Ref> entries within this group.  See\n"
  " * add_group_ref().\n"
  " */";
#else
static const char *Dtool_EggGroup_get_num_group_refs_573_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggGroup *EggGroup::get_group_ref(int n) const
 */
static PyObject *Dtool_EggGroup_get_group_ref_574(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggGroup)) {
    return nullptr;
  }
  // 1-EggGroup *EggGroup::get_group_ref(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    EggGroup *return_value = ((*(const EggGroup*)local_this).get_group_ref)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggGroup, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_group_ref(EggGroup self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_group_ref_574_comment =
  "C++ Interface:\n"
  "get_group_ref(EggGroup self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth <Ref> entry within this group.  See add_group_ref().\n"
  " */";
#else
static const char *Dtool_EggGroup_get_group_ref_574_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::remove_group_ref(int n)
 */
static PyObject *Dtool_EggGroup_remove_group_ref_576(PyObject *self, PyObject *arg) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.remove_group_ref")) {
    return nullptr;
  }
  // 1-void EggGroup::remove_group_ref(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).remove_group_ref)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_group_ref(const EggGroup self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_remove_group_ref_576_comment =
  "C++ Interface:\n"
  "remove_group_ref(const EggGroup self, int n)\n"
  "\n"
  "/**\n"
  " * Removes the nth <Ref> entry within this group.  See add_group_ref().\n"
  " */";
#else
static const char *Dtool_EggGroup_remove_group_ref_576_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggGroup::clear_group_refs(void)
 */
static PyObject *Dtool_EggGroup_clear_group_refs_577(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.clear_group_refs")) {
    return nullptr;
  }
  // 1-void EggGroup::clear_group_refs(void)
  ((*local_this).clear_group_refs)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_clear_group_refs_577_comment =
  "C++ Interface:\n"
  "clear_group_refs(const EggGroup self)\n"
  "\n"
  "/**\n"
  " * Removes all of the <Ref> entries within this group.  See add_group_ref().\n"
  " */";
#else
static const char *Dtool_EggGroup_clear_group_refs_577_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static EggGroup::GroupType EggGroup::string_group_type(std::string const &strval)
 */
static PyObject *Dtool_EggGroup_string_group_type_578(PyObject *, PyObject *arg) {
  // 1-static EggGroup::GroupType EggGroup::string_group_type(std::string const &strval)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    EggGroup::GroupType return_value = (EggGroup::string_group_type)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_group_type(str strval)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_string_group_type_578_comment =
  "C++ Interface:\n"
  "string_group_type(str strval)\n"
  "\n"
  "/**\n"
  " * Returns the GroupType value associated with the given string\n"
  " * representation, or GT_invalid if the string does not match any known\n"
  " * GroupType value.\n"
  " */";
#else
static const char *Dtool_EggGroup_string_group_type_578_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static EggGroup::DartType EggGroup::string_dart_type(std::string const &strval)
 */
static PyObject *Dtool_EggGroup_string_dart_type_579(PyObject *, PyObject *arg) {
  // 1-static EggGroup::DartType EggGroup::string_dart_type(std::string const &strval)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    EggGroup::DartType return_value = (EggGroup::string_dart_type)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_dart_type(str strval)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_string_dart_type_579_comment =
  "C++ Interface:\n"
  "string_dart_type(str strval)\n"
  "\n"
  "/**\n"
  " * Returns the DartType value associated with the given string representation,\n"
  " * or DT_none if the string does not match any known DartType value.\n"
  " */";
#else
static const char *Dtool_EggGroup_string_dart_type_579_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static EggGroup::DCSType EggGroup::string_dcs_type(std::string const &strval)
 */
static PyObject *Dtool_EggGroup_string_dcs_type_580(PyObject *, PyObject *arg) {
  // 1-static EggGroup::DCSType EggGroup::string_dcs_type(std::string const &strval)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    EggGroup::DCSType return_value = (EggGroup::string_dcs_type)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_dcs_type(str strval)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_string_dcs_type_580_comment =
  "C++ Interface:\n"
  "string_dcs_type(str strval)\n"
  "\n"
  "/**\n"
  " * Returns the DCSType value associated with the given string representation,\n"
  " * or DC_unspecified if the string does not match any known DCSType value.\n"
  " */";
#else
static const char *Dtool_EggGroup_string_dcs_type_580_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static EggGroup::BillboardType EggGroup::string_billboard_type(std::string const &strval)
 */
static PyObject *Dtool_EggGroup_string_billboard_type_581(PyObject *, PyObject *arg) {
  // 1-static EggGroup::BillboardType EggGroup::string_billboard_type(std::string const &strval)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    EggGroup::BillboardType return_value = (EggGroup::string_billboard_type)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_billboard_type(str strval)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_string_billboard_type_581_comment =
  "C++ Interface:\n"
  "string_billboard_type(str strval)\n"
  "\n"
  "/**\n"
  " * Returns the BillboardType value associated with the given string\n"
  " * representation, or BT_none if the string does not match any known\n"
  " * BillboardType value.\n"
  " */";
#else
static const char *Dtool_EggGroup_string_billboard_type_581_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static EggGroup::CollisionSolidType EggGroup::string_cs_type(std::string const &strval)
 */
static PyObject *Dtool_EggGroup_string_cs_type_582(PyObject *, PyObject *arg) {
  // 1-static EggGroup::CollisionSolidType EggGroup::string_cs_type(std::string const &strval)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    EggGroup::CollisionSolidType return_value = (EggGroup::string_cs_type)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_cs_type(str strval)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_string_cs_type_582_comment =
  "C++ Interface:\n"
  "string_cs_type(str strval)\n"
  "\n"
  "/**\n"
  " * Returns the CollisionSolidType value associated with the given string\n"
  " * representation, or CST_none if the string does not match any known\n"
  " * CollisionSolidType value.\n"
  " */";
#else
static const char *Dtool_EggGroup_string_cs_type_582_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static EggGroup::CollideFlags EggGroup::string_collide_flags(std::string const &strval)
 */
static PyObject *Dtool_EggGroup_string_collide_flags_583(PyObject *, PyObject *arg) {
  // 1-static EggGroup::CollideFlags EggGroup::string_collide_flags(std::string const &strval)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    EggGroup::CollideFlags return_value = (EggGroup::string_collide_flags)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_collide_flags(str strval)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_string_collide_flags_583_comment =
  "C++ Interface:\n"
  "string_collide_flags(str strval)\n"
  "\n"
  "/**\n"
  " * Returns the CollideFlags value associated with the given string\n"
  " * representation, or CF_none if the string does not match any known\n"
  " * CollideFlags value.  This only recognizes a single keyword; it does not\n"
  " * attempt to parse a string of keywords.\n"
  " */";
#else
static const char *Dtool_EggGroup_string_collide_flags_583_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static EggGroup::BlendMode EggGroup::string_blend_mode(std::string const &strval)
 */
static PyObject *Dtool_EggGroup_string_blend_mode_584(PyObject *, PyObject *arg) {
  // 1-static EggGroup::BlendMode EggGroup::string_blend_mode(std::string const &strval)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    EggGroup::BlendMode return_value = (EggGroup::string_blend_mode)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_blend_mode(str strval)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_string_blend_mode_584_comment =
  "C++ Interface:\n"
  "string_blend_mode(str strval)\n"
  "\n"
  "/**\n"
  " * Returns the BlendMode value associated with the given string\n"
  " * representation, or BM_none if the string does not match any known\n"
  " * BlendMode.\n"
  " */";
#else
static const char *Dtool_EggGroup_string_blend_mode_584_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static EggGroup::BlendOperand EggGroup::string_blend_operand(std::string const &strval)
 */
static PyObject *Dtool_EggGroup_string_blend_operand_585(PyObject *, PyObject *arg) {
  // 1-static EggGroup::BlendOperand EggGroup::string_blend_operand(std::string const &strval)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    EggGroup::BlendOperand return_value = (EggGroup::string_blend_operand)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_blend_operand(str strval)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_string_blend_operand_585_comment =
  "C++ Interface:\n"
  "string_blend_operand(str strval)\n"
  "\n"
  "/**\n"
  " * Returns the BlendOperand value associated with the given string\n"
  " * representation, or BO_none if the string does not match any known\n"
  " * BlendOperand.\n"
  " */";
#else
static const char *Dtool_EggGroup_string_blend_operand_585_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggGroup::get_class_type(void)
 */
static PyObject *Dtool_EggGroup_get_class_type_586(PyObject *, PyObject *) {
  // 1-static TypeHandle EggGroup::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggGroup::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_get_class_type_586_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggGroup_get_class_type_586_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggGroupNode *EggGroup::upcast_to_EggGroupNode(void)
 */
static PyObject *Dtool_EggGroup_upcast_to_EggGroupNode_381(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.upcast_to_EggGroupNode")) {
    return nullptr;
  }
  // 1-EggGroupNode *EggGroup::upcast_to_EggGroupNode(void)
  EggGroupNode *return_value = (EggGroupNode *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggGroupNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_upcast_to_EggGroupNode_381_comment =
  "C++ Interface:\n"
  "upcast_to_EggGroupNode(const EggGroup self)\n"
  "\n"
  "upcast from EggGroup to EggGroupNode";
#else
static const char *Dtool_EggGroup_upcast_to_EggGroupNode_381_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggRenderMode *EggGroup::upcast_to_EggRenderMode(void)
 */
static PyObject *Dtool_EggGroup_upcast_to_EggRenderMode_383(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.upcast_to_EggRenderMode")) {
    return nullptr;
  }
  // 1-EggRenderMode *EggGroup::upcast_to_EggRenderMode(void)
  EggRenderMode *return_value = (EggRenderMode *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_upcast_to_EggRenderMode_383_comment =
  "C++ Interface:\n"
  "upcast_to_EggRenderMode(const EggGroup self)\n"
  "\n"
  "upcast from EggGroup to EggRenderMode";
#else
static const char *Dtool_EggGroup_upcast_to_EggRenderMode_383_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggTransform *EggGroup::upcast_to_EggTransform(void)
 */
static PyObject *Dtool_EggGroup_upcast_to_EggTransform_385(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.upcast_to_EggTransform")) {
    return nullptr;
  }
  // 1-EggTransform *EggGroup::upcast_to_EggTransform(void)
  EggTransform *return_value = (EggTransform *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggTransform, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroup_upcast_to_EggTransform_385_comment =
  "C++ Interface:\n"
  "upcast_to_EggTransform(const EggGroup self)\n"
  "\n"
  "upcast from EggGroup to EggTransform";
#else
static const char *Dtool_EggGroup_upcast_to_EggTransform_385_comment = nullptr;
#endif

static PyObject *Dtool_EggGroup_group_type_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline EggGroup::GroupType EggGroup::get_group_type(void) const
  EggGroup::GroupType return_value = ((*(const EggGroup*)local_this).get_group_type)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_group_type_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.group_type")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete group_type attribute");
    return -1;
  }
  // 1-void EggGroup::set_group_type(EggGroup::GroupType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_group_type)((EggGroup::GroupType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_group_type(const EggGroup self, int type)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_billboard_type_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline EggGroup::BillboardType EggGroup::get_billboard_type(void) const
  EggGroup::BillboardType return_value = ((*(const EggGroup*)local_this).get_billboard_type)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_billboard_type_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.billboard_type")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete billboard_type attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_billboard_type(EggGroup::BillboardType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_billboard_type)((EggGroup::BillboardType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_billboard_type(const EggGroup self, int type)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_billboard_center_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_billboard_center()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LPoint3d const &EggGroup::get_billboard_center(void) const
  LPoint3d const *return_value = &(((*(const EggGroup*)local_this).get_billboard_center)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, false, true);
}

static int Dtool_EggGroup_billboard_center_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.billboard_center")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete billboard_center attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_billboard_center();
    return 0;
  }
  // 1-inline void EggGroup::set_billboard_center(LPoint3d const &billboard_center)
  LPoint3d arg_local;
  LPoint3d const *arg_this = Dtool_Coerce_LPoint3d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggGroup.set_billboard_center", "LPoint3d");
    return -1;
  }
  ((*local_this).set_billboard_center)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_billboard_center(const EggGroup self, const LPoint3d billboard_center)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_cs_type_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline EggGroup::CollisionSolidType EggGroup::get_cs_type(void) const
  EggGroup::CollisionSolidType return_value = ((*(const EggGroup*)local_this).get_cs_type)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_cs_type_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.cs_type")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete cs_type attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_cs_type(EggGroup::CollisionSolidType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_cs_type)((EggGroup::CollisionSolidType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_cs_type(const EggGroup self, int type)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_collide_flags_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline EggGroup::CollideFlags EggGroup::get_collide_flags(void) const
  EggGroup::CollideFlags return_value = ((*(const EggGroup*)local_this).get_collide_flags)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_collide_flags_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.collide_flags")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete collide_flags attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_collide_flags(int flags)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_collide_flags)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_collide_flags(const EggGroup self, int flags)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_collision_name_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &EggGroup::get_collision_name(void) const
  std::string const &return_value = ((*(const EggGroup*)local_this).get_collision_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_collision_name_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.collision_name")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete collision_name attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_collision_name(std::string const &collision_name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_collision_name)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_collision_name(const EggGroup self, str collision_name)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_dcs_type_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline EggGroup::DCSType EggGroup::get_dcs_type(void) const
  EggGroup::DCSType return_value = ((*(const EggGroup*)local_this).get_dcs_type)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_dcs_type_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.dcs_type")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete dcs_type attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_dcs_type(EggGroup::DCSType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_dcs_type)((EggGroup::DCSType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_dcs_type(const EggGroup self, int type)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_dart_type_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline EggGroup::DartType EggGroup::get_dart_type(void) const
  EggGroup::DartType return_value = ((*(const EggGroup*)local_this).get_dart_type)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_dart_type_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.dart_type")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete dart_type attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_dart_type(EggGroup::DartType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_dart_type)((EggGroup::DartType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_dart_type(const EggGroup self, int type)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_switch_flag_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool EggGroup::get_switch_flag(void) const
  bool return_value = ((*(const EggGroup*)local_this).get_switch_flag)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_switch_flag_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.switch_flag")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete switch_flag attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_switch_flag(bool flag)
  ((*local_this).set_switch_flag)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_switch_flag(const EggGroup self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_switch_fps_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline double EggGroup::get_switch_fps(void) const
  double return_value = ((*(const EggGroup*)local_this).get_switch_fps)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_switch_fps_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.switch_fps")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete switch_fps attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_switch_fps(double fps)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_switch_fps)(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_switch_fps(const EggGroup self, double fps)\n");
  }
  return -1;
}

/**
 * sequence length function for property EggGroup::object_types
 */
static Py_ssize_t Dtool_EggGroup_object_types_Len(PyObject *self) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_object_types)();
}

/**
 * sequence getter for property EggGroup::object_types
 */
static PyObject *Dtool_EggGroup_object_types_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_object_types)()) {
    PyErr_SetString(PyExc_IndexError, "EggGroup.object_types[] index out of range");
    return nullptr;
  }
  // 1-inline std::string EggGroup::get_object_type(int index) const
  std::string return_value = ((*(const EggGroup*)local_this).get_object_type)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_object_type(EggGroup self, index)\n");
  }
}

static PyObject *Dtool_EggGroup_object_types_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "EggGroup.object_types");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_EggGroup_object_types_Len;
    wrap->_getitem_func = &Dtool_EggGroup_object_types_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

static PyObject *Dtool_EggGroup_model_flag_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool EggGroup::get_model_flag(void) const
  bool return_value = ((*(const EggGroup*)local_this).get_model_flag)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_model_flag_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.model_flag")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete model_flag attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_model_flag(bool flag)
  ((*local_this).set_model_flag)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_model_flag(const EggGroup self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_texlist_flag_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool EggGroup::get_texlist_flag(void) const
  bool return_value = ((*(const EggGroup*)local_this).get_texlist_flag)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_texlist_flag_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.texlist_flag")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete texlist_flag attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_texlist_flag(bool flag)
  ((*local_this).set_texlist_flag)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_texlist_flag(const EggGroup self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_nofog_flag_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool EggGroup::get_nofog_flag(void) const
  bool return_value = ((*(const EggGroup*)local_this).get_nofog_flag)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_nofog_flag_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.nofog_flag")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete nofog_flag attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_nofog_flag(bool flag)
  ((*local_this).set_nofog_flag)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_nofog_flag(const EggGroup self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_decal_flag_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool EggGroup::get_decal_flag(void) const
  bool return_value = ((*(const EggGroup*)local_this).get_decal_flag)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_decal_flag_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.decal_flag")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete decal_flag attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_decal_flag(bool flag)
  ((*local_this).set_decal_flag)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_decal_flag(const EggGroup self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_direct_flag_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool EggGroup::get_direct_flag(void) const
  bool return_value = ((*(const EggGroup*)local_this).get_direct_flag)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_direct_flag_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.direct_flag")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete direct_flag attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_direct_flag(bool flag)
  ((*local_this).set_direct_flag)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_direct_flag(const EggGroup self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_portal_flag_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool EggGroup::get_portal_flag(void) const
  bool return_value = ((*(const EggGroup*)local_this).get_portal_flag)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_portal_flag_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.portal_flag")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete portal_flag attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_portal_flag(bool flag)
  ((*local_this).set_portal_flag)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_portal_flag(const EggGroup self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_occluder_flag_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool EggGroup::get_occluder_flag(void) const
  bool return_value = ((*(const EggGroup*)local_this).get_occluder_flag)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_occluder_flag_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.occluder_flag")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete occluder_flag attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_occluder_flag(bool flag)
  ((*local_this).set_occluder_flag)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_occluder_flag(const EggGroup self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_indexed_flag_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_indexed_flag()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline bool EggGroup::get_indexed_flag(void) const
  bool return_value = ((*(const EggGroup*)local_this).get_indexed_flag)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_indexed_flag_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.indexed_flag")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete indexed_flag attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_indexed_flag();
    return 0;
  }
  // 1-inline void EggGroup::set_indexed_flag(bool flag)
  ((*local_this).set_indexed_flag)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_indexed_flag(const EggGroup self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_collide_mask_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_collide_mask()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline CollideMask EggGroup::get_collide_mask(void) const
  CollideMask *return_value = new CollideMask(((*(const EggGroup*)local_this).get_collide_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

static int Dtool_EggGroup_collide_mask_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.collide_mask")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete collide_mask attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_collide_mask();
    return 0;
  }
  // 1-inline void EggGroup::set_collide_mask(CollideMask mask)
  BitMask< uint32_t, 32 > arg_local;
  CollideMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggGroup.set_collide_mask", "BitMask");
    return -1;
  }
  ((*local_this).set_collide_mask)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_collide_mask(const EggGroup self, BitMask mask)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_from_collide_mask_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_from_collide_mask()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline CollideMask EggGroup::get_from_collide_mask(void) const
  CollideMask *return_value = new CollideMask(((*(const EggGroup*)local_this).get_from_collide_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

static int Dtool_EggGroup_from_collide_mask_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.from_collide_mask")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete from_collide_mask attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_from_collide_mask();
    return 0;
  }
  // 1-inline void EggGroup::set_from_collide_mask(CollideMask mask)
  BitMask< uint32_t, 32 > arg_local;
  CollideMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggGroup.set_from_collide_mask", "BitMask");
    return -1;
  }
  ((*local_this).set_from_collide_mask)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_from_collide_mask(const EggGroup self, BitMask mask)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_into_collide_mask_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_into_collide_mask()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline CollideMask EggGroup::get_into_collide_mask(void) const
  CollideMask *return_value = new CollideMask(((*(const EggGroup*)local_this).get_into_collide_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

static int Dtool_EggGroup_into_collide_mask_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.into_collide_mask")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete into_collide_mask attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_into_collide_mask();
    return 0;
  }
  // 1-inline void EggGroup::set_into_collide_mask(CollideMask mask)
  BitMask< uint32_t, 32 > arg_local;
  CollideMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggGroup.set_into_collide_mask", "BitMask");
    return -1;
  }
  ((*local_this).set_into_collide_mask)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_into_collide_mask(const EggGroup self, BitMask mask)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_blend_mode_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline EggGroup::BlendMode EggGroup::get_blend_mode(void) const
  EggGroup::BlendMode return_value = ((*(const EggGroup*)local_this).get_blend_mode)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_blend_mode_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.blend_mode")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete blend_mode attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_blend_mode(EggGroup::BlendMode blend_mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_blend_mode)((EggGroup::BlendMode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_blend_mode(const EggGroup self, int blend_mode)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_blend_operand_a_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline EggGroup::BlendOperand EggGroup::get_blend_operand_a(void) const
  EggGroup::BlendOperand return_value = ((*(const EggGroup*)local_this).get_blend_operand_a)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_blend_operand_a_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.blend_operand_a")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete blend_operand_a attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_blend_operand_a(EggGroup::BlendOperand blend_operand_a)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_blend_operand_a)((EggGroup::BlendOperand)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_blend_operand_a(const EggGroup self, int blend_operand_a)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_blend_operand_b_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline EggGroup::BlendOperand EggGroup::get_blend_operand_b(void) const
  EggGroup::BlendOperand return_value = ((*(const EggGroup*)local_this).get_blend_operand_b)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_blend_operand_b_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.blend_operand_b")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete blend_operand_b attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_blend_operand_b(EggGroup::BlendOperand blend_operand_b)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_blend_operand_b)((EggGroup::BlendOperand)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_blend_operand_b(const EggGroup self, int blend_operand_b)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_blend_color_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_blend_color()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LColor const &EggGroup::get_blend_color(void) const
  LColor const *return_value = &(((*(const EggGroup*)local_this).get_blend_color)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static int Dtool_EggGroup_blend_color_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.blend_color")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete blend_color attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_blend_color();
    return 0;
  }
  // 1-inline void EggGroup::set_blend_color(LColor const &blend_color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggGroup.set_blend_color", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_blend_color)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_blend_color(const EggGroup self, const LVecBase4f blend_color)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_lod_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_lod()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline EggSwitchCondition const &EggGroup::get_lod(void) const
  EggSwitchCondition const *return_value = &(((*(const EggGroup*)local_this).get_lod)());
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggSwitchCondition, true, true, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_EggGroup_lod_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.lod")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete lod attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_lod();
    return 0;
  }
  // 1-inline void EggGroup::set_lod(EggSwitchCondition const &lod)
  EggSwitchCondition const *arg_this = (EggSwitchCondition *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggSwitchCondition, 1, "EggGroup.set_lod", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_lod)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_lod(const EggGroup self, const EggSwitchCondition lod)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_default_pose_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline EggTransform const &EggGroup::get_default_pose(void) const
  EggTransform const *return_value = &(((*(const EggGroup*)local_this).get_default_pose)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggTransform, false, true);
}

static int Dtool_EggGroup_default_pose_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.default_pose")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete default_pose attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_default_pose(EggTransform const &transform)
  EggTransform const *arg_this = (EggTransform *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggTransform, 1, "EggGroup.set_default_pose", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_default_pose)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_default_pose(const EggGroup self, const EggTransform transform)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_scroll_u_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline double EggGroup::get_scroll_u(void) const
  double return_value = ((*(const EggGroup*)local_this).get_scroll_u)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_scroll_u_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.scroll_u")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete scroll_u attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_scroll_u(double const u_speed)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_scroll_u)(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_scroll_u(const EggGroup self, double u_speed)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_scroll_v_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline double EggGroup::get_scroll_v(void) const
  double return_value = ((*(const EggGroup*)local_this).get_scroll_v)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_scroll_v_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.scroll_v")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete scroll_v attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_scroll_v(double const v_speed)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_scroll_v)(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_scroll_v(const EggGroup self, double v_speed)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_scroll_w_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline double EggGroup::get_scroll_w(void) const
  double return_value = ((*(const EggGroup*)local_this).get_scroll_w)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_scroll_w_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.scroll_w")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete scroll_w attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_scroll_w(double const w_speed)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_scroll_w)(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_scroll_w(const EggGroup self, double w_speed)\n");
  }
  return -1;
}

static PyObject *Dtool_EggGroup_scroll_r_Getter(PyObject *self, void *) {
  const EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline double EggGroup::get_scroll_r(void) const
  double return_value = ((*(const EggGroup*)local_this).get_scroll_r)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggGroup_scroll_r_Setter(PyObject *self, PyObject *arg, void *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggGroup, (void **)&local_this, "EggGroup.scroll_r")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete scroll_r attribute");
    return -1;
  }
  // 1-inline void EggGroup::set_scroll_r(double const r_speed)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_scroll_r)(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_scroll_r(const EggGroup self, double r_speed)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * EggGroup::EggGroup(EggGroup const &copy)
 * explicit EggGroup::EggGroup(std::string const &name = "")
 */
static int Dtool_Init_EggGroup(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-explicit EggGroup::EggGroup(std::string const &name)
      EggGroup *return_value = new EggGroup();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggGroup, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 EggGroup::EggGroup(EggGroup const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          EggGroup const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_EggGroup);
          if (param0_this != nullptr) {
            EggGroup *return_value = new EggGroup(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggGroup, true, false);
          }
        }
      }

      {
        // -2 explicit EggGroup::EggGroup(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:EggGroup", (char **)keyword_list, &param0_str, &param0_len)) {
          EggGroup *return_value = new EggGroup(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggGroup, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: EggGroup::EggGroup(EggGroup const &copy)
      // No coercion possible: explicit EggGroup::EggGroup(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggGroup() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggGroup()\n"
      "EggGroup(const EggGroup copy)\n"
      "EggGroup(str name)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_EggGroup_get_object_types(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_object_types)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_EggGroup_get_object_type_450(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_EggGroup_get_group_refs(PyObject *self, PyObject *) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_group_refs)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_EggGroup_get_group_ref_574(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_EggGroup(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggGroup) {
    printf("EggGroup ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggGroup *local_this = (EggGroup *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggGroup) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggGroupNode) {
    return (EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return (EggRenderMode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggTransform) {
    return (EggTransform *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggGroup(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggGroup) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggGroupNode) {
    EggGroupNode* other_this = (EggGroupNode*)from_this;
    return (EggGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    EggRenderMode* other_this = (EggRenderMode*)from_this;
    return (EggGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_EggTransform) {
    EggTransform* other_this = (EggTransform*)from_this;
    return (EggGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggGroup*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggBin
 */
/**
 * Python function wrapper for:
 * void EggBin::set_bin_number(int bin_number)
 */
static PyObject *Dtool_EggBin_set_bin_number_589(PyObject *self, PyObject *arg) {
  EggBin *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggBin, (void **)&local_this, "EggBin.set_bin_number")) {
    return nullptr;
  }
  // 1-void EggBin::set_bin_number(int bin_number)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_bin_number)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bin_number(const EggBin self, int bin_number)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggBin_set_bin_number_589_comment =
  "C++ Interface:\n"
  "set_bin_number(const EggBin self, int bin_number)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggBin_set_bin_number_589_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int EggBin::get_bin_number(void) const
 */
static PyObject *Dtool_EggBin_get_bin_number_590(PyObject *self, PyObject *) {
  EggBin *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggBin)) {
    return nullptr;
  }
  // 1-int EggBin::get_bin_number(void) const
  int return_value = ((*(const EggBin*)local_this).get_bin_number)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggBin_get_bin_number_590_comment =
  "C++ Interface:\n"
  "get_bin_number(EggBin self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggBin_get_bin_number_590_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggBin::get_class_type(void)
 */
static PyObject *Dtool_EggBin_get_class_type_591(PyObject *, PyObject *) {
  // 1-static TypeHandle EggBin::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggBin::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggBin_get_class_type_591_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggBin_get_class_type_591_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggBin::EggBin(EggBin const &copy)
 * EggBin::EggBin(EggGroup const &copy)
 * explicit EggBin::EggBin(std::string const &name = "")
 */
static int Dtool_Init_EggBin(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-explicit EggBin::EggBin(std::string const &name)
      EggBin *return_value = new EggBin();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggBin, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 EggBin::EggBin(EggBin const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          EggBin const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_EggBin);
          if (param0_this != nullptr) {
            EggBin *return_value = new EggBin(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggBin, true, false);
          }
        }
      }

      {
        // -2 EggBin::EggBin(EggGroup const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          EggGroup const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_EggGroup);
          if (param0_this != nullptr) {
            EggBin *return_value = new EggBin(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggBin, true, false);
          }
        }
      }

      {
        // -2 explicit EggBin::EggBin(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:EggBin", (char **)keyword_list, &param0_str, &param0_len)) {
          EggBin *return_value = new EggBin(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggBin, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 EggBin::EggBin(EggBin const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          CPT(EggBin) param0_this;
          if (Dtool_ConstCoerce_EggBin(param0, param0_this)) {
            EggBin *return_value = new EggBin(*std::move(param0_this));
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggBin, true, false);
          }
        }
      }

      // No coercion possible: EggBin::EggBin(EggGroup const &copy)
      // No coercion possible: explicit EggBin::EggBin(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggBin() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggBin()\n"
      "EggBin(const EggBin copy)\n"
      "EggBin(const EggGroup copy)\n"
      "EggBin(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_EggBin(PyObject *args, CPT(EggBin) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_EggBin)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-EggBin::EggBin(EggGroup const &copy)
    EggGroup const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_EggGroup);
    if (arg_this != nullptr) {
      EggBin *return_value = new EggBin(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_EggBin(PyObject *args, PT(EggBin) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_EggBin)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-EggBin::EggBin(EggGroup const &copy)
    EggGroup const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_EggGroup);
    if (arg_this != nullptr) {
      EggBin *return_value = new EggBin(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_EggBin(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggBin) {
    printf("EggBin ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggBin *local_this = (EggBin *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggBin) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggGroup) {
    return (EggGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggGroupNode) {
    return (EggGroupNode *)(EggGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggGroupNode *)(EggGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggGroupNode *)(EggGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *)(EggGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return (EggRenderMode *)(EggGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggTransform) {
    return (EggTransform *)(EggGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggGroupNode *)(EggGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *)(EggGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *)(EggGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *)(EggGroup *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggBin(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggBin) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggGroup) {
    EggGroup* other_this = (EggGroup*)from_this;
    return (EggBin*)other_this;
  }
  if (from_type == Dtool_Ptr_EggGroupNode) {
    EggGroupNode* other_this = (EggGroupNode*)from_this;
    return (EggBin*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggBin*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggBin*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggBin*)other_this;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    EggRenderMode* other_this = (EggRenderMode*)from_this;
    return (EggBin*)other_this;
  }
  if (from_type == Dtool_Ptr_EggTransform) {
    EggTransform* other_this = (EggTransform*)from_this;
    return (EggBin*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggBin*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggBin*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggBin*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggBin*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggBinMaker
 */
/**
 * Python function wrapper for:
 * int EggBinMaker::make_bins(EggGroupNode *root_group)
 */
static PyObject *Dtool_EggBinMaker_make_bins_594(PyObject *self, PyObject *arg) {
  EggBinMaker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggBinMaker, (void **)&local_this, "EggBinMaker.make_bins")) {
    return nullptr;
  }
  // 1-int EggBinMaker::make_bins(EggGroupNode *root_group)
  EggGroupNode *arg_this = (EggGroupNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggGroupNode, 1, "EggBinMaker.make_bins", false, true);
  if (arg_this != nullptr) {
    int return_value = ((*local_this).make_bins)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_bins(const EggBinMaker self, EggGroupNode root_group)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggBinMaker_make_bins_594_comment =
  "C++ Interface:\n"
  "make_bins(const EggBinMaker self, EggGroupNode root_group)\n"
  "\n"
  "/**\n"
  " * The main entry point to EggBinMaker.  Walks the egg scene graph beginning\n"
  " * at the indicated root node, and moves all binnable nodes into EggBin\n"
  " * objects.  Returns the number of EggBins created.\n"
  " */";
#else
static const char *Dtool_EggBinMaker_make_bins_594_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void EggBinMaker::prepare_node(EggNode *node)
 */
static PyObject *Dtool_EggBinMaker_prepare_node_595(PyObject *self, PyObject *arg) {
  EggBinMaker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggBinMaker, (void **)&local_this, "EggBinMaker.prepare_node")) {
    return nullptr;
  }
  // 1-virtual void EggBinMaker::prepare_node(EggNode *node)
  EggNode *arg_this = (EggNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggNode, 1, "EggBinMaker.prepare_node", false, true);
  if (arg_this != nullptr) {
    ((*local_this).prepare_node)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "prepare_node(const EggBinMaker self, EggNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggBinMaker_prepare_node_595_comment =
  "C++ Interface:\n"
  "prepare_node(const EggBinMaker self, EggNode node)\n"
  "\n"
  "/**\n"
  " * May be overridden in derived classes to perform some setup work as each\n"
  " * node is encountered.  This will be called once for each node in the egg\n"
  " * hierarchy.\n"
  " */";
#else
static const char *Dtool_EggBinMaker_prepare_node_595_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual int EggBinMaker::get_bin_number(EggNode const *node) = 0
 */
static PyObject *Dtool_EggBinMaker_get_bin_number_596(PyObject *self, PyObject *arg) {
  EggBinMaker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggBinMaker, (void **)&local_this, "EggBinMaker.get_bin_number")) {
    return nullptr;
  }
  // 1-virtual int EggBinMaker::get_bin_number(EggNode const *node) = 0
  EggNode const *arg_this = (EggNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggNode, 1, "EggBinMaker.get_bin_number", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*local_this).get_bin_number)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bin_number(const EggBinMaker self, const EggNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggBinMaker_get_bin_number_596_comment =
  "C++ Interface:\n"
  "get_bin_number(const EggBinMaker self, const EggNode node)\n";
#else
static const char *Dtool_EggBinMaker_get_bin_number_596_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggBinMaker::sorts_less(int bin_number, EggNode const *a, EggNode const *b)
 */
static PyObject *Dtool_EggBinMaker_sorts_less_597(PyObject *self, PyObject *args, PyObject *kwds) {
  EggBinMaker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggBinMaker, (void **)&local_this, "EggBinMaker.sorts_less")) {
    return nullptr;
  }
  // 1-virtual bool EggBinMaker::sorts_less(int bin_number, EggNode const *a, EggNode const *b)
  int param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"bin_number", "a", "b", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iOO:sorts_less", (char **)keyword_list, &param1, &param2, &param3)) {
    EggNode const *param2_this = (EggNode *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_EggNode, 2, "EggBinMaker.sorts_less", true, true);
    EggNode const *param3_this = (EggNode *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_EggNode, 3, "EggBinMaker.sorts_less", true, true);
    if (param2_this != nullptr && param3_this != nullptr) {
      bool return_value = ((*local_this).sorts_less)((int)param1, param2_this, param3_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "sorts_less(const EggBinMaker self, int bin_number, const EggNode a, const EggNode b)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggBinMaker_sorts_less_597_comment =
  "C++ Interface:\n"
  "sorts_less(const EggBinMaker self, int bin_number, const EggNode a, const EggNode b)\n"
  "\n"
  "/**\n"
  " * May be overridden in derived classes to create additional bins within a\n"
  " * particular bin number, based on some arbitrary property of nodes.  This\n"
  " * function establishes an arbitrary but fixed ordering between nodes; if two\n"
  " * nodes do not sort to the same position, different bins are created for each\n"
  " * one (with the same bin number on each bin).\n"
  " */";
#else
static const char *Dtool_EggBinMaker_sorts_less_597_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggBinMaker::collapse_group(EggGroup const *group, int bin_number)
 */
static PyObject *Dtool_EggBinMaker_collapse_group_598(PyObject *self, PyObject *args, PyObject *kwds) {
  EggBinMaker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggBinMaker, (void **)&local_this, "EggBinMaker.collapse_group")) {
    return nullptr;
  }
  // 1-virtual bool EggBinMaker::collapse_group(EggGroup const *group, int bin_number)
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"group", "bin_number", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:collapse_group", (char **)keyword_list, &param1, &param2)) {
    EggGroup const *param1_this = (EggGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_EggGroup, 1, "EggBinMaker.collapse_group", true, true);
    if (param1_this != nullptr) {
      bool return_value = ((*local_this).collapse_group)(param1_this, (int)param2);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "collapse_group(const EggBinMaker self, const EggGroup group, int bin_number)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggBinMaker_collapse_group_598_comment =
  "C++ Interface:\n"
  "collapse_group(const EggBinMaker self, const EggGroup group, int bin_number)\n"
  "\n"
  "/**\n"
  " * May be overridden in derived classes to specify whether a particular group\n"
  " * node, apparently redundant, may be safely collapsed out.\n"
  " */";
#else
static const char *Dtool_EggBinMaker_collapse_group_598_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual std::string EggBinMaker::get_bin_name(int bin_number, EggNode const *child)
 */
static PyObject *Dtool_EggBinMaker_get_bin_name_599(PyObject *self, PyObject *args, PyObject *kwds) {
  EggBinMaker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggBinMaker, (void **)&local_this, "EggBinMaker.get_bin_name")) {
    return nullptr;
  }
  // 1-virtual std::string EggBinMaker::get_bin_name(int bin_number, EggNode const *child)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"bin_number", "child", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_bin_name", (char **)keyword_list, &param1, &param2)) {
    EggNode const *param2_this = (EggNode *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_EggNode, 2, "EggBinMaker.get_bin_name", true, true);
    if (param2_this != nullptr) {
      std::string return_value = ((*local_this).get_bin_name)((int)param1, param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bin_name(const EggBinMaker self, int bin_number, const EggNode child)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggBinMaker_get_bin_name_599_comment =
  "C++ Interface:\n"
  "get_bin_name(const EggBinMaker self, int bin_number, const EggNode child)\n"
  "\n"
  "/**\n"
  " * May be overridden in derived classes to define a name for each new bin,\n"
  " * based on its bin number, and a sample child.\n"
  " */";
#else
static const char *Dtool_EggBinMaker_get_bin_name_599_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PointerTo< EggBin > EggBinMaker::make_bin(int bin_number, EggNode const *child, EggGroup *collapse_from)
 */
static PyObject *Dtool_EggBinMaker_make_bin_600(PyObject *self, PyObject *args, PyObject *kwds) {
  EggBinMaker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggBinMaker, (void **)&local_this, "EggBinMaker.make_bin")) {
    return nullptr;
  }
  // 1-virtual PointerTo< EggBin > EggBinMaker::make_bin(int bin_number, EggNode const *child, EggGroup *collapse_from)
  int param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"bin_number", "child", "collapse_from", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iOO:make_bin", (char **)keyword_list, &param1, &param2, &param3)) {
    EggNode const *param2_this = (EggNode *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_EggNode, 2, "EggBinMaker.make_bin", true, true);
    EggGroup *param3_this = (EggGroup *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_EggGroup, 3, "EggBinMaker.make_bin", false, true);
    if (param2_this != nullptr && param3_this != nullptr) {
      PointerTo< EggBin > return_value = ((*local_this).make_bin)((int)param1, param2_this, param3_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      EggBin *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_EggBin, true, false, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_bin(const EggBinMaker self, int bin_number, const EggNode child, EggGroup collapse_from)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggBinMaker_make_bin_600_comment =
  "C++ Interface:\n"
  "make_bin(const EggBinMaker self, int bin_number, const EggNode child, EggGroup collapse_from)\n"
  "\n"
  "/**\n"
  " * May be overridden in derived classes to construct a new EggBin object (or\n"
  " * some derived class, if needed), and preload some initial data into as\n"
  " * required.\n"
  " *\n"
  " * child is an arbitrary child of the bin, and collapse_from is the group the\n"
  " * bin is being collapsed with, if any (implying collapse_group() returned\n"
  " * true), or NULL if not.\n"
  " */";
#else
static const char *Dtool_EggBinMaker_make_bin_600_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggBinMaker::get_class_type(void)
 */
static PyObject *Dtool_EggBinMaker_get_class_type_601(PyObject *, PyObject *) {
  // 1-static TypeHandle EggBinMaker::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggBinMaker::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggBinMaker_get_class_type_601_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggBinMaker_get_class_type_601_comment = nullptr;
#endif

static int Dtool_Init_EggBinMaker(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_EggBinMaker(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggBinMaker) {
    printf("EggBinMaker ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggBinMaker *local_this = (EggBinMaker *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggBinMaker) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggBinMaker(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggBinMaker) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggBinMaker*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggBinMaker*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggBinMaker*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggBinMaker*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggComment
 */
/**
 * Python function wrapper for:
 * inline void EggComment::operator =(EggComment const &copy)
 * inline void EggComment::operator =(std::string const &comment)
 */
static PyObject *Dtool_EggComment_operator_604(PyObject *self, PyObject *arg) {
  EggComment *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggComment, (void **)&local_this, "EggComment.assign")) {
    return nullptr;
  }
  {
    // -2 inline void EggComment::operator =(EggComment const &copy)
    EggComment const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_EggComment);
    if (arg_this != nullptr) {
      ((*local_this).operator =)(*arg_this);
      EggComment *return_value = local_this;
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggComment, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }

  {
    // -2 inline void EggComment::operator =(std::string const &comment)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      ((*local_this).operator =)(std::string(param1_str, param1_len));
      EggComment *return_value = local_this;
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggComment, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: inline void EggComment::operator =(EggComment const &copy)
  // No coercion possible: inline void EggComment::operator =(std::string const &comment)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggComment self, const EggComment copy)\n"
      "assign(const EggComment self, str comment)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggComment_operator_604_comment =
  "C++ Interface:\n"
  "assign(const EggComment self, const EggComment copy)\n"
  "assign(const EggComment self, str comment)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggComment_operator_604_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggComment::set_comment(std::string const &comment)
 */
static PyObject *Dtool_EggComment_set_comment_606(PyObject *self, PyObject *arg) {
  EggComment *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggComment, (void **)&local_this, "EggComment.set_comment")) {
    return nullptr;
  }
  // 1-inline void EggComment::set_comment(std::string const &comment)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_comment)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_comment(const EggComment self, str comment)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggComment_set_comment_606_comment =
  "C++ Interface:\n"
  "set_comment(const EggComment self, str comment)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggComment_set_comment_606_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string EggComment::get_comment(void) const
 */
static PyObject *Dtool_EggComment_get_comment_607(PyObject *self, PyObject *) {
  EggComment *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggComment)) {
    return nullptr;
  }
  // 1-inline std::string EggComment::get_comment(void) const
  std::string return_value = ((*(const EggComment*)local_this).get_comment)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggComment_get_comment_607_comment =
  "C++ Interface:\n"
  "get_comment(EggComment self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggComment_get_comment_607_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggComment::get_class_type(void)
 */
static PyObject *Dtool_EggComment_get_class_type_608(PyObject *, PyObject *) {
  // 1-static TypeHandle EggComment::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggComment::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggComment_get_class_type_608_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggComment_get_class_type_608_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggComment::EggComment(EggComment const &copy)
 * inline explicit EggComment::EggComment(std::string const &node_name, std::string const &comment)
 */
static int Dtool_Init_EggComment(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-inline EggComment::EggComment(EggComment const &copy)
        EggComment const *arg_this = (EggComment *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggComment, 0, "EggComment.EggComment", true, true);
        if (arg_this != nullptr) {
          EggComment *return_value = new EggComment(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggComment, true, false);
        }
      }
    }
    break;
  case 2:
    {
      // 1-inline explicit EggComment::EggComment(std::string const &node_name, std::string const &comment)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      static const char *keyword_list[] = {"node_name", "comment", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:EggComment", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len)) {
        EggComment *return_value = new EggComment(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggComment, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggComment() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggComment(const EggComment copy)\n"
      "EggComment(str node_name, str comment)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggComment(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggComment) {
    printf("EggComment ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggComment *local_this = (EggComment *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggComment) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggComment(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggComment) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggComment*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggComment*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggComment*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggComment*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggComment*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggComment*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggComment*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggFilenameNode
 */
/**
 * Python function wrapper for:
 * inline void EggFilenameNode::operator =(EggFilenameNode const &copy)
 */
static PyObject *Dtool_EggFilenameNode_operator_611(PyObject *self, PyObject *arg) {
  EggFilenameNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggFilenameNode, (void **)&local_this, "EggFilenameNode.assign")) {
    return nullptr;
  }
  // 1-inline void EggFilenameNode::operator =(EggFilenameNode const &copy)
  EggFilenameNode const *arg_this = (EggFilenameNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggFilenameNode, 1, "EggFilenameNode.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggFilenameNode *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggFilenameNode, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggFilenameNode self, const EggFilenameNode copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggFilenameNode_operator_611_comment =
  "C++ Interface:\n"
  "assign(const EggFilenameNode self, const EggFilenameNode copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggFilenameNode_operator_611_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual std::string EggFilenameNode::get_default_extension(void) const
 */
static PyObject *Dtool_EggFilenameNode_get_default_extension_612(PyObject *self, PyObject *) {
  EggFilenameNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggFilenameNode)) {
    return nullptr;
  }
  // 1-virtual std::string EggFilenameNode::get_default_extension(void) const
  std::string return_value = ((*(const EggFilenameNode*)local_this).get_default_extension)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggFilenameNode_get_default_extension_612_comment =
  "C++ Interface:\n"
  "get_default_extension(EggFilenameNode self)\n"
  "\n"
  "/**\n"
  " * Returns the default extension for this filename type.\n"
  " */";
#else
static const char *Dtool_EggFilenameNode_get_default_extension_612_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &EggFilenameNode::get_filename(void) const
 */
static PyObject *Dtool_EggFilenameNode_get_filename_613(PyObject *self, PyObject *) {
  EggFilenameNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggFilenameNode)) {
    return nullptr;
  }
  // 1-inline Filename const &EggFilenameNode::get_filename(void) const
  Filename const *return_value = &(((*(const EggFilenameNode*)local_this).get_filename)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggFilenameNode_get_filename_613_comment =
  "C++ Interface:\n"
  "get_filename(EggFilenameNode self)\n"
  "\n"
  "/**\n"
  " * Returns a nonmodifiable reference to the filename.\n"
  " */";
#else
static const char *Dtool_EggFilenameNode_get_filename_613_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggFilenameNode::set_filename(Filename const &filename)
 */
static PyObject *Dtool_EggFilenameNode_set_filename_614(PyObject *self, PyObject *arg) {
  EggFilenameNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggFilenameNode, (void **)&local_this, "EggFilenameNode.set_filename")) {
    return nullptr;
  }
  // 1-inline void EggFilenameNode::set_filename(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggFilenameNode.set_filename", "Filename");
  }
  ((*local_this).set_filename)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_filename(const EggFilenameNode self, const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggFilenameNode_set_filename_614_comment =
  "C++ Interface:\n"
  "set_filename(const EggFilenameNode self, const Filename filename)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggFilenameNode_set_filename_614_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &EggFilenameNode::get_fullpath(void) const
 */
static PyObject *Dtool_EggFilenameNode_get_fullpath_615(PyObject *self, PyObject *) {
  EggFilenameNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggFilenameNode)) {
    return nullptr;
  }
  // 1-inline Filename const &EggFilenameNode::get_fullpath(void) const
  Filename const *return_value = &(((*(const EggFilenameNode*)local_this).get_fullpath)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggFilenameNode_get_fullpath_615_comment =
  "C++ Interface:\n"
  "get_fullpath(EggFilenameNode self)\n"
  "\n"
  "/**\n"
  " * Returns the full pathname to the file, if it is known; otherwise, returns\n"
  " * the same thing as get_filename().\n"
  " *\n"
  " * This function simply returns whatever was set by the last call to\n"
  " * set_fullpath().  This string is not written to the egg file; its main\n"
  " * purpose is to record the full path to a filename (for instance, a texture\n"
  " * filename) if it is known, for egg structures that are generated in-memory\n"
  " * and then immediately converted to a scene graph.\n"
  " */";
#else
static const char *Dtool_EggFilenameNode_get_fullpath_615_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggFilenameNode::set_fullpath(Filename const &fullpath)
 */
static PyObject *Dtool_EggFilenameNode_set_fullpath_616(PyObject *self, PyObject *arg) {
  EggFilenameNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggFilenameNode, (void **)&local_this, "EggFilenameNode.set_fullpath")) {
    return nullptr;
  }
  // 1-inline void EggFilenameNode::set_fullpath(Filename const &fullpath)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggFilenameNode.set_fullpath", "Filename");
  }
  ((*local_this).set_fullpath)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fullpath(const EggFilenameNode self, const Filename fullpath)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggFilenameNode_set_fullpath_616_comment =
  "C++ Interface:\n"
  "set_fullpath(const EggFilenameNode self, const Filename fullpath)\n"
  "\n"
  "/**\n"
  " * Records the full pathname to the file, for the benefit of get_fullpath().\n"
  " */";
#else
static const char *Dtool_EggFilenameNode_set_fullpath_616_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggFilenameNode::get_class_type(void)
 */
static PyObject *Dtool_EggFilenameNode_get_class_type_617(PyObject *, PyObject *) {
  // 1-static TypeHandle EggFilenameNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggFilenameNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggFilenameNode_get_class_type_617_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggFilenameNode_get_class_type_617_comment = nullptr;
#endif

static int Dtool_Init_EggFilenameNode(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_EggFilenameNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggFilenameNode) {
    printf("EggFilenameNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggFilenameNode *local_this = (EggFilenameNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggFilenameNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggFilenameNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggFilenameNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggFilenameNode*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggFilenameNode*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggFilenameNode*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggFilenameNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggFilenameNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggFilenameNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggFilenameNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggTexture
 */
/**
 * Python function wrapper for:
 * void EggTexture::operator =(EggTexture const &copy)
 */
static PyObject *Dtool_EggTexture_operator_627(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.assign")) {
    return nullptr;
  }
  // 1-void EggTexture::operator =(EggTexture const &copy)
  EggTexture const *arg_this = (EggTexture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggTexture, 1, "EggTexture.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggTexture *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggTexture, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggTexture self, const EggTexture copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_operator_627_comment =
  "C++ Interface:\n"
  "assign(const EggTexture self, const EggTexture copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_operator_627_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void EggTexture::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_EggTexture_write_629(PyObject *self, PyObject *args, PyObject *kwds) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-virtual void EggTexture::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "EggTexture.write", false, true);
    if (param1_this != nullptr) {
      ((*(const EggTexture*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(EggTexture self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_write_629_comment =
  "C++ Interface:\n"
  "write(EggTexture self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes the texture definition to the indicated output stream in Egg format.\n"
  " */";
#else
static const char *Dtool_EggTexture_write_629_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggTexture::is_equivalent_to(EggTexture const &other, int eq) const
 */
static PyObject *Dtool_EggTexture_is_equivalent_to_631(PyObject *self, PyObject *args, PyObject *kwds) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-bool EggTexture::is_equivalent_to(EggTexture const &other, int eq) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"other", "eq", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:is_equivalent_to", (char **)keyword_list, &param1, &param2)) {
    EggTexture const *param1_this = (EggTexture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_EggTexture, 1, "EggTexture.is_equivalent_to", true, true);
    if (param1_this != nullptr) {
      bool return_value = ((*(const EggTexture*)local_this).is_equivalent_to)(*param1_this, (int)param2);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_equivalent_to(EggTexture self, const EggTexture other, int eq)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_is_equivalent_to_631_comment =
  "C++ Interface:\n"
  "is_equivalent_to(EggTexture self, const EggTexture other, int eq)\n"
  "\n"
  "/**\n"
  " * Returns true if the two textures are equivalent in all relevant properties\n"
  " * (according to eq), false otherwise.\n"
  " *\n"
  " * The Equivalence parameter, eq, should be set to the bitwise OR of the\n"
  " * following properties, according to what you consider relevant:\n"
  " *\n"
  " * EggTexture::E_basename: The basename part of the texture filename, without\n"
  " * the directory prefix *or* the filename extension.\n"
  " *\n"
  " * EggTexture::E_extension: The extension part of the texture filename.\n"
  " *\n"
  " * EggTexture::E_dirname: The directory prefix of the texture filename.\n"
  " *\n"
  " * EggTexture::E_complete_filename: The union of the above three; that is, the\n"
  " * complete filename, with directory, basename, and extension.\n"
  " *\n"
  " * EggTexture::E_transform: The texture matrix.\n"
  " *\n"
  " * EggTexture::E_attributes: All remaining texture attributes (mode, mipmap,\n"
  " * etc.) except TRef name.\n"
  " *\n"
  " * EggTexture::E_tref_name: The TRef name.\n"
  " */";
#else
static const char *Dtool_EggTexture_is_equivalent_to_631_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggTexture::sorts_less_than(EggTexture const &other, int eq) const
 */
static PyObject *Dtool_EggTexture_sorts_less_than_632(PyObject *self, PyObject *args, PyObject *kwds) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-bool EggTexture::sorts_less_than(EggTexture const &other, int eq) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"other", "eq", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:sorts_less_than", (char **)keyword_list, &param1, &param2)) {
    EggTexture const *param1_this = (EggTexture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_EggTexture, 1, "EggTexture.sorts_less_than", true, true);
    if (param1_this != nullptr) {
      bool return_value = ((*(const EggTexture*)local_this).sorts_less_than)(*param1_this, (int)param2);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "sorts_less_than(EggTexture self, const EggTexture other, int eq)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_sorts_less_than_632_comment =
  "C++ Interface:\n"
  "sorts_less_than(EggTexture self, const EggTexture other, int eq)\n"
  "\n"
  "/**\n"
  " * An ordering operator to compare two textures for sorting order.  This\n"
  " * imposes an arbitrary ordering useful to identify unique textures, according\n"
  " * to the indicated Equivalence factor.  See is_equivalent_to().\n"
  " */";
#else
static const char *Dtool_EggTexture_sorts_less_than_632_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggTexture::has_alpha_channel(int num_components) const
 */
static PyObject *Dtool_EggTexture_has_alpha_channel_633(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-bool EggTexture::has_alpha_channel(int num_components) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*(const EggTexture*)local_this).has_alpha_channel)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_alpha_channel(EggTexture self, int num_components)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_has_alpha_channel_633_comment =
  "C++ Interface:\n"
  "has_alpha_channel(EggTexture self, int num_components)\n"
  "\n"
  "/**\n"
  " * Given the number of color components (channels) in the image file as\n"
  " * actually read from the disk, return true if this texture seems to have an\n"
  " * alpha channel or not.  This depends on the EggTexture's format as well as\n"
  " * the number of channels.\n"
  " */";
#else
static const char *Dtool_EggTexture_has_alpha_channel_633_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_texture_type(EggTexture::TextureType texture_type)
 */
static PyObject *Dtool_EggTexture_set_texture_type_647(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_texture_type")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_texture_type(EggTexture::TextureType texture_type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_texture_type)((EggTexture::TextureType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_texture_type(const EggTexture self, int texture_type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_texture_type_647_comment =
  "C++ Interface:\n"
  "set_texture_type(const EggTexture self, int texture_type)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_texture_type_647_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::TextureType EggTexture::get_texture_type(void) const
 */
static PyObject *Dtool_EggTexture_get_texture_type_648(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline EggTexture::TextureType EggTexture::get_texture_type(void) const
  EggTexture::TextureType return_value = ((*(const EggTexture*)local_this).get_texture_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_texture_type_648_comment =
  "C++ Interface:\n"
  "get_texture_type(EggTexture self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_get_texture_type_648_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_format(EggTexture::Format format)
 */
static PyObject *Dtool_EggTexture_set_format_649(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_format")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_format(EggTexture::Format format)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_format)((EggTexture::Format)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_format(const EggTexture self, int format)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_format_649_comment =
  "C++ Interface:\n"
  "set_format(const EggTexture self, int format)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_format_649_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::Format EggTexture::get_format(void) const
 */
static PyObject *Dtool_EggTexture_get_format_650(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline EggTexture::Format EggTexture::get_format(void) const
  EggTexture::Format return_value = ((*(const EggTexture*)local_this).get_format)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_format_650_comment =
  "C++ Interface:\n"
  "get_format(EggTexture self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_get_format_650_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_compression_mode(EggTexture::CompressionMode mode)
 */
static PyObject *Dtool_EggTexture_set_compression_mode_651(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_compression_mode")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_compression_mode(EggTexture::CompressionMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_compression_mode)((EggTexture::CompressionMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_compression_mode(const EggTexture self, int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_compression_mode_651_comment =
  "C++ Interface:\n"
  "set_compression_mode(const EggTexture self, int mode)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_compression_mode_651_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::CompressionMode EggTexture::get_compression_mode(void) const
 */
static PyObject *Dtool_EggTexture_get_compression_mode_652(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline EggTexture::CompressionMode EggTexture::get_compression_mode(void) const
  EggTexture::CompressionMode return_value = ((*(const EggTexture*)local_this).get_compression_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_compression_mode_652_comment =
  "C++ Interface:\n"
  "get_compression_mode(EggTexture self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_get_compression_mode_652_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_wrap_mode(EggTexture::WrapMode mode)
 */
static PyObject *Dtool_EggTexture_set_wrap_mode_653(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_wrap_mode")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_wrap_mode(EggTexture::WrapMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_wrap_mode)((EggTexture::WrapMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wrap_mode(const EggTexture self, int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_wrap_mode_653_comment =
  "C++ Interface:\n"
  "set_wrap_mode(const EggTexture self, int mode)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_wrap_mode_653_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::WrapMode EggTexture::get_wrap_mode(void) const
 */
static PyObject *Dtool_EggTexture_get_wrap_mode_654(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline EggTexture::WrapMode EggTexture::get_wrap_mode(void) const
  EggTexture::WrapMode return_value = ((*(const EggTexture*)local_this).get_wrap_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_wrap_mode_654_comment =
  "C++ Interface:\n"
  "get_wrap_mode(EggTexture self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_get_wrap_mode_654_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_wrap_u(EggTexture::WrapMode mode)
 */
static PyObject *Dtool_EggTexture_set_wrap_u_655(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_wrap_u")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_wrap_u(EggTexture::WrapMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_wrap_u)((EggTexture::WrapMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wrap_u(const EggTexture self, int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_wrap_u_655_comment =
  "C++ Interface:\n"
  "set_wrap_u(const EggTexture self, int mode)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_wrap_u_655_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::WrapMode EggTexture::get_wrap_u(void) const
 */
static PyObject *Dtool_EggTexture_get_wrap_u_656(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline EggTexture::WrapMode EggTexture::get_wrap_u(void) const
  EggTexture::WrapMode return_value = ((*(const EggTexture*)local_this).get_wrap_u)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_wrap_u_656_comment =
  "C++ Interface:\n"
  "get_wrap_u(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the amount specified for U wrap.  This may be unspecified, even if\n"
  " * there is an overall wrap value.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_wrap_u_656_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::WrapMode EggTexture::determine_wrap_u(void) const
 */
static PyObject *Dtool_EggTexture_determine_wrap_u_657(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline EggTexture::WrapMode EggTexture::determine_wrap_u(void) const
  EggTexture::WrapMode return_value = ((*(const EggTexture*)local_this).determine_wrap_u)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_determine_wrap_u_657_comment =
  "C++ Interface:\n"
  "determine_wrap_u(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Determines the appropriate wrap in the U direction.  This is different from\n"
  " * get_wrap_u() in that if the U wrap is unspecified, it returns the overall\n"
  " * wrap value.\n"
  " */";
#else
static const char *Dtool_EggTexture_determine_wrap_u_657_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_wrap_v(EggTexture::WrapMode mode)
 */
static PyObject *Dtool_EggTexture_set_wrap_v_658(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_wrap_v")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_wrap_v(EggTexture::WrapMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_wrap_v)((EggTexture::WrapMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wrap_v(const EggTexture self, int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_wrap_v_658_comment =
  "C++ Interface:\n"
  "set_wrap_v(const EggTexture self, int mode)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_wrap_v_658_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::WrapMode EggTexture::get_wrap_v(void) const
 */
static PyObject *Dtool_EggTexture_get_wrap_v_659(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline EggTexture::WrapMode EggTexture::get_wrap_v(void) const
  EggTexture::WrapMode return_value = ((*(const EggTexture*)local_this).get_wrap_v)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_wrap_v_659_comment =
  "C++ Interface:\n"
  "get_wrap_v(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the amount specified for V wrap.  This may be unspecified, even if\n"
  " * there is an overall wrap value.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_wrap_v_659_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::WrapMode EggTexture::determine_wrap_v(void) const
 */
static PyObject *Dtool_EggTexture_determine_wrap_v_660(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline EggTexture::WrapMode EggTexture::determine_wrap_v(void) const
  EggTexture::WrapMode return_value = ((*(const EggTexture*)local_this).determine_wrap_v)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_determine_wrap_v_660_comment =
  "C++ Interface:\n"
  "determine_wrap_v(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Determines the appropriate wrap in the V direction.  This is different from\n"
  " * get_wrap_v() in that if the V wrap is unspecified, it returns the overall\n"
  " * wrap value.\n"
  " */";
#else
static const char *Dtool_EggTexture_determine_wrap_v_660_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_wrap_w(EggTexture::WrapMode mode)
 */
static PyObject *Dtool_EggTexture_set_wrap_w_661(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_wrap_w")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_wrap_w(EggTexture::WrapMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_wrap_w)((EggTexture::WrapMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wrap_w(const EggTexture self, int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_wrap_w_661_comment =
  "C++ Interface:\n"
  "set_wrap_w(const EggTexture self, int mode)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_wrap_w_661_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::WrapMode EggTexture::get_wrap_w(void) const
 */
static PyObject *Dtool_EggTexture_get_wrap_w_662(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline EggTexture::WrapMode EggTexture::get_wrap_w(void) const
  EggTexture::WrapMode return_value = ((*(const EggTexture*)local_this).get_wrap_w)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_wrap_w_662_comment =
  "C++ Interface:\n"
  "get_wrap_w(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the amount specified for W wrap.  This may be unspecified, even if\n"
  " * there is an overall wrap value.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_wrap_w_662_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::WrapMode EggTexture::determine_wrap_w(void) const
 */
static PyObject *Dtool_EggTexture_determine_wrap_w_663(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline EggTexture::WrapMode EggTexture::determine_wrap_w(void) const
  EggTexture::WrapMode return_value = ((*(const EggTexture*)local_this).determine_wrap_w)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_determine_wrap_w_663_comment =
  "C++ Interface:\n"
  "determine_wrap_w(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Determines the appropriate wrap in the W direction.  This is different from\n"
  " * get_wrap_w() in that if the W wrap is unspecified, it returns the overall\n"
  " * wrap value.\n"
  " */";
#else
static const char *Dtool_EggTexture_determine_wrap_w_663_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_minfilter(EggTexture::FilterType type)
 */
static PyObject *Dtool_EggTexture_set_minfilter_664(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_minfilter")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_minfilter(EggTexture::FilterType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_minfilter)((EggTexture::FilterType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_minfilter(const EggTexture self, int type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_minfilter_664_comment =
  "C++ Interface:\n"
  "set_minfilter(const EggTexture self, int type)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_minfilter_664_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::FilterType EggTexture::get_minfilter(void) const
 */
static PyObject *Dtool_EggTexture_get_minfilter_665(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline EggTexture::FilterType EggTexture::get_minfilter(void) const
  EggTexture::FilterType return_value = ((*(const EggTexture*)local_this).get_minfilter)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_minfilter_665_comment =
  "C++ Interface:\n"
  "get_minfilter(EggTexture self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_get_minfilter_665_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_magfilter(EggTexture::FilterType type)
 */
static PyObject *Dtool_EggTexture_set_magfilter_666(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_magfilter")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_magfilter(EggTexture::FilterType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_magfilter)((EggTexture::FilterType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_magfilter(const EggTexture self, int type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_magfilter_666_comment =
  "C++ Interface:\n"
  "set_magfilter(const EggTexture self, int type)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_magfilter_666_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::FilterType EggTexture::get_magfilter(void) const
 */
static PyObject *Dtool_EggTexture_get_magfilter_667(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline EggTexture::FilterType EggTexture::get_magfilter(void) const
  EggTexture::FilterType return_value = ((*(const EggTexture*)local_this).get_magfilter)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_magfilter_667_comment =
  "C++ Interface:\n"
  "get_magfilter(EggTexture self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_get_magfilter_667_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_anisotropic_degree(int anisotropic_degree)
 */
static PyObject *Dtool_EggTexture_set_anisotropic_degree_668(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_anisotropic_degree")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_anisotropic_degree(int anisotropic_degree)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_anisotropic_degree)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_anisotropic_degree(const EggTexture self, int anisotropic_degree)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_anisotropic_degree_668_comment =
  "C++ Interface:\n"
  "set_anisotropic_degree(const EggTexture self, int anisotropic_degree)\n"
  "\n"
  "/**\n"
  " * Sets the degree of anisotropic filtering for this texture.  1 is off;\n"
  " * higher levels indicate filtering in effect.\n"
  " */";
#else
static const char *Dtool_EggTexture_set_anisotropic_degree_668_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::clear_anisotropic_degree(void)
 */
static PyObject *Dtool_EggTexture_clear_anisotropic_degree_669(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.clear_anisotropic_degree")) {
    return nullptr;
  }
  // 1-inline void EggTexture::clear_anisotropic_degree(void)
  ((*local_this).clear_anisotropic_degree)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_clear_anisotropic_degree_669_comment =
  "C++ Interface:\n"
  "clear_anisotropic_degree(const EggTexture self)\n"
  "\n"
  "/**\n"
  " * Removes the specification of anisotropic filtering from the texture.\n"
  " */";
#else
static const char *Dtool_EggTexture_clear_anisotropic_degree_669_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::has_anisotropic_degree(void) const
 */
static PyObject *Dtool_EggTexture_has_anisotropic_degree_670(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline bool EggTexture::has_anisotropic_degree(void) const
  bool return_value = ((*(const EggTexture*)local_this).has_anisotropic_degree)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_has_anisotropic_degree_670_comment =
  "C++ Interface:\n"
  "has_anisotropic_degree(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if a value for the anisotropic filtering degree has been\n"
  " * specified for this texture, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggTexture_has_anisotropic_degree_670_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggTexture::get_anisotropic_degree(void) const
 */
static PyObject *Dtool_EggTexture_get_anisotropic_degree_671(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline int EggTexture::get_anisotropic_degree(void) const
  int return_value = ((*(const EggTexture*)local_this).get_anisotropic_degree)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_anisotropic_degree_671_comment =
  "C++ Interface:\n"
  "get_anisotropic_degree(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the anisotropic filtering degree that has been specified for this\n"
  " * texture, or 0 if nothing has been specified.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_anisotropic_degree_671_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_env_type(EggTexture::EnvType type)
 */
static PyObject *Dtool_EggTexture_set_env_type_672(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_env_type")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_env_type(EggTexture::EnvType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_env_type)((EggTexture::EnvType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_env_type(const EggTexture self, int type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_env_type_672_comment =
  "C++ Interface:\n"
  "set_env_type(const EggTexture self, int type)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_env_type_672_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::EnvType EggTexture::get_env_type(void) const
 */
static PyObject *Dtool_EggTexture_get_env_type_673(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline EggTexture::EnvType EggTexture::get_env_type(void) const
  EggTexture::EnvType return_value = ((*(const EggTexture*)local_this).get_env_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_env_type_673_comment =
  "C++ Interface:\n"
  "get_env_type(EggTexture self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_get_env_type_673_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggTexture::affects_polygon_alpha(void) const
 */
static PyObject *Dtool_EggTexture_affects_polygon_alpha_674(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-bool EggTexture::affects_polygon_alpha(void) const
  bool return_value = ((*(const EggTexture*)local_this).affects_polygon_alpha)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_affects_polygon_alpha_674_comment =
  "C++ Interface:\n"
  "affects_polygon_alpha(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if this texture's environment type or combine mode allows the\n"
  " * texture to have an effect on the polygon's alpha values, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggTexture_affects_polygon_alpha_674_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_combine_mode(EggTexture::CombineChannel channel, EggTexture::CombineMode cm)
 */
static PyObject *Dtool_EggTexture_set_combine_mode_675(PyObject *self, PyObject *args, PyObject *kwds) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_combine_mode")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_combine_mode(EggTexture::CombineChannel channel, EggTexture::CombineMode cm)
  int param1;
  int param2;
  static const char *keyword_list[] = {"channel", "cm", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_combine_mode", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_combine_mode)((EggTexture::CombineChannel)param1, (EggTexture::CombineMode)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_combine_mode(const EggTexture self, int channel, int cm)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_combine_mode_675_comment =
  "C++ Interface:\n"
  "set_combine_mode(const EggTexture self, int channel, int cm)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_combine_mode_675_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::CombineMode EggTexture::get_combine_mode(EggTexture::CombineChannel channel) const
 */
static PyObject *Dtool_EggTexture_get_combine_mode_676(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline EggTexture::CombineMode EggTexture::get_combine_mode(EggTexture::CombineChannel channel) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    EggTexture::CombineMode return_value = ((*(const EggTexture*)local_this).get_combine_mode)((EggTexture::CombineChannel)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_combine_mode(EggTexture self, int channel)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_combine_mode_676_comment =
  "C++ Interface:\n"
  "get_combine_mode(EggTexture self, int channel)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_get_combine_mode_676_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_combine_source(EggTexture::CombineChannel channel, int n, EggTexture::CombineSource cs)
 */
static PyObject *Dtool_EggTexture_set_combine_source_677(PyObject *self, PyObject *args, PyObject *kwds) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_combine_source")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_combine_source(EggTexture::CombineChannel channel, int n, EggTexture::CombineSource cs)
  int param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"channel", "n", "cs", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:set_combine_source", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).set_combine_source)((EggTexture::CombineChannel)param1, (int)param2, (EggTexture::CombineSource)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_combine_source(const EggTexture self, int channel, int n, int cs)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_combine_source_677_comment =
  "C++ Interface:\n"
  "set_combine_source(const EggTexture self, int channel, int n, int cs)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_combine_source_677_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::CombineSource EggTexture::get_combine_source(EggTexture::CombineChannel channel, int n) const
 */
static PyObject *Dtool_EggTexture_get_combine_source_678(PyObject *self, PyObject *args, PyObject *kwds) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline EggTexture::CombineSource EggTexture::get_combine_source(EggTexture::CombineChannel channel, int n) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"channel", "n", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_combine_source", (char **)keyword_list, &param1, &param2)) {
    EggTexture::CombineSource return_value = ((*(const EggTexture*)local_this).get_combine_source)((EggTexture::CombineChannel)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_combine_source(EggTexture self, int channel, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_combine_source_678_comment =
  "C++ Interface:\n"
  "get_combine_source(EggTexture self, int channel, int n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_get_combine_source_678_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_combine_operand(EggTexture::CombineChannel channel, int n, EggTexture::CombineOperand co)
 */
static PyObject *Dtool_EggTexture_set_combine_operand_679(PyObject *self, PyObject *args, PyObject *kwds) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_combine_operand")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_combine_operand(EggTexture::CombineChannel channel, int n, EggTexture::CombineOperand co)
  int param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"channel", "n", "co", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:set_combine_operand", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).set_combine_operand)((EggTexture::CombineChannel)param1, (int)param2, (EggTexture::CombineOperand)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_combine_operand(const EggTexture self, int channel, int n, int co)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_combine_operand_679_comment =
  "C++ Interface:\n"
  "set_combine_operand(const EggTexture self, int channel, int n, int co)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_combine_operand_679_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::CombineOperand EggTexture::get_combine_operand(EggTexture::CombineChannel channel, int n) const
 */
static PyObject *Dtool_EggTexture_get_combine_operand_680(PyObject *self, PyObject *args, PyObject *kwds) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline EggTexture::CombineOperand EggTexture::get_combine_operand(EggTexture::CombineChannel channel, int n) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"channel", "n", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_combine_operand", (char **)keyword_list, &param1, &param2)) {
    EggTexture::CombineOperand return_value = ((*(const EggTexture*)local_this).get_combine_operand)((EggTexture::CombineChannel)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_combine_operand(EggTexture self, int channel, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_combine_operand_680_comment =
  "C++ Interface:\n"
  "get_combine_operand(EggTexture self, int channel, int n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_get_combine_operand_680_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_saved_result(bool saved_result)
 */
static PyObject *Dtool_EggTexture_set_saved_result_681(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_saved_result")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_saved_result(bool saved_result)
  ((*local_this).set_saved_result)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_saved_result(const EggTexture self, bool saved_result)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_saved_result_681_comment =
  "C++ Interface:\n"
  "set_saved_result(const EggTexture self, bool saved_result)\n"
  "\n"
  "/**\n"
  " * Sets the saved_result flag.  When this is true, the output of this stage is\n"
  " * not part of the normal pipeline--that is, it will not be supplied as the\n"
  " * \"previous\" source for the next texture stage--but it will instead be\n"
  " * supplied as the \"last_saved_result\" source for any future stages, until the\n"
  " * next TextureStage with a saved_result set true is encountered.\n"
  " *\n"
  " * This can be used to reuse the results of this texture stage as input to\n"
  " * more than one stage later in the pipeline.\n"
  " *\n"
  " * The last texture in the pipeline (the one with the highest sort value)\n"
  " * should not have this flag set.\n"
  " */";
#else
static const char *Dtool_EggTexture_set_saved_result_681_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::get_saved_result(void) const
 */
static PyObject *Dtool_EggTexture_get_saved_result_682(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline bool EggTexture::get_saved_result(void) const
  bool return_value = ((*(const EggTexture*)local_this).get_saved_result)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_saved_result_682_comment =
  "C++ Interface:\n"
  "get_saved_result(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the saved_result flag.  See\n"
  " * set_saved_result().\n"
  " */";
#else
static const char *Dtool_EggTexture_get_saved_result_682_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_tex_gen(EggTexture::TexGen tex_gen)
 */
static PyObject *Dtool_EggTexture_set_tex_gen_683(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_tex_gen")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_tex_gen(EggTexture::TexGen tex_gen)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_tex_gen)((EggTexture::TexGen)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tex_gen(const EggTexture self, int tex_gen)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_tex_gen_683_comment =
  "C++ Interface:\n"
  "set_tex_gen(const EggTexture self, int tex_gen)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_tex_gen_683_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::TexGen EggTexture::get_tex_gen(void) const
 */
static PyObject *Dtool_EggTexture_get_tex_gen_684(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline EggTexture::TexGen EggTexture::get_tex_gen(void) const
  EggTexture::TexGen return_value = ((*(const EggTexture*)local_this).get_tex_gen)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_tex_gen_684_comment =
  "C++ Interface:\n"
  "get_tex_gen(EggTexture self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_get_tex_gen_684_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_quality_level(EggTexture::QualityLevel quality_level)
 */
static PyObject *Dtool_EggTexture_set_quality_level_685(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_quality_level")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_quality_level(EggTexture::QualityLevel quality_level)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_quality_level)((EggTexture::QualityLevel)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_quality_level(const EggTexture self, int quality_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_quality_level_685_comment =
  "C++ Interface:\n"
  "set_quality_level(const EggTexture self, int quality_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_quality_level_685_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture::QualityLevel EggTexture::get_quality_level(void) const
 */
static PyObject *Dtool_EggTexture_get_quality_level_686(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline EggTexture::QualityLevel EggTexture::get_quality_level(void) const
  EggTexture::QualityLevel return_value = ((*(const EggTexture*)local_this).get_quality_level)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_quality_level_686_comment =
  "C++ Interface:\n"
  "get_quality_level(EggTexture self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_get_quality_level_686_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_stage_name(std::string const &stage_name)
 */
static PyObject *Dtool_EggTexture_set_stage_name_687(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_stage_name")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_stage_name(std::string const &stage_name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_stage_name)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_stage_name(const EggTexture self, str stage_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_stage_name_687_comment =
  "C++ Interface:\n"
  "set_stage_name(const EggTexture self, str stage_name)\n"
  "\n"
  "/**\n"
  " * Specifies the particular TextureStage this texture will be rendered on by\n"
  " * name.  If this is omitted, the texture will be rendered on the default\n"
  " * TextureStage, unless some other stage-specific property is specificied, in\n"
  " * which case the texture will be rendered on a TextureStage with the same\n"
  " * name as the tref.  This is in support of multitexturing.\n"
  " *\n"
  " * Each different TextureStage in the world must be uniquely named.\n"
  " */";
#else
static const char *Dtool_EggTexture_set_stage_name_687_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::clear_stage_name(void)
 */
static PyObject *Dtool_EggTexture_clear_stage_name_688(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.clear_stage_name")) {
    return nullptr;
  }
  // 1-inline void EggTexture::clear_stage_name(void)
  ((*local_this).clear_stage_name)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_clear_stage_name_688_comment =
  "C++ Interface:\n"
  "clear_stage_name(const EggTexture self)\n"
  "\n"
  "/**\n"
  " * Removes the named TextureStage specification.\n"
  " */";
#else
static const char *Dtool_EggTexture_clear_stage_name_688_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::has_stage_name(void) const
 */
static PyObject *Dtool_EggTexture_has_stage_name_689(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline bool EggTexture::has_stage_name(void) const
  bool return_value = ((*(const EggTexture*)local_this).has_stage_name)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_has_stage_name_689_comment =
  "C++ Interface:\n"
  "has_stage_name(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if a stage name has been explicitly specified for this\n"
  " * texture, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggTexture_has_stage_name_689_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &EggTexture::get_stage_name(void) const
 */
static PyObject *Dtool_EggTexture_get_stage_name_690(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline std::string const &EggTexture::get_stage_name(void) const
  std::string const &return_value = ((*(const EggTexture*)local_this).get_stage_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_stage_name_690_comment =
  "C++ Interface:\n"
  "get_stage_name(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the stage name that has been specified for this texture, or the\n"
  " * tref name if no texture stage has explicitly been specified.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_stage_name_690_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_priority(int priority)
 */
static PyObject *Dtool_EggTexture_set_priority_691(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_priority")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_priority(int priority)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_priority)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_priority(const EggTexture self, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_priority_691_comment =
  "C++ Interface:\n"
  "set_priority(const EggTexture self, int priority)\n"
  "\n"
  "/**\n"
  " * Sets the importance of this texture with respect to other textures also\n"
  " * applied on the same geometry.  This is only meaningful in the presence of\n"
  " * multitexturing.\n"
  " */";
#else
static const char *Dtool_EggTexture_set_priority_691_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::clear_priority(void)
 */
static PyObject *Dtool_EggTexture_clear_priority_692(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.clear_priority")) {
    return nullptr;
  }
  // 1-inline void EggTexture::clear_priority(void)
  ((*local_this).clear_priority)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_clear_priority_692_comment =
  "C++ Interface:\n"
  "clear_priority(const EggTexture self)\n"
  "\n"
  "/**\n"
  " * Removes the specification of multitexture priority from the texture.  The\n"
  " * default priority value is 0.\n"
  " */";
#else
static const char *Dtool_EggTexture_clear_priority_692_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::has_priority(void) const
 */
static PyObject *Dtool_EggTexture_has_priority_693(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline bool EggTexture::has_priority(void) const
  bool return_value = ((*(const EggTexture*)local_this).has_priority)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_has_priority_693_comment =
  "C++ Interface:\n"
  "has_priority(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if a priority value for multitexture importance has been\n"
  " * specified for the texture, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggTexture_has_priority_693_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggTexture::get_priority(void) const
 */
static PyObject *Dtool_EggTexture_get_priority_694(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline int EggTexture::get_priority(void) const
  int return_value = ((*(const EggTexture*)local_this).get_priority)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_priority_694_comment =
  "C++ Interface:\n"
  "get_priority(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the multitexture importance value that has been specified for the\n"
  " * texture, or 0 if no priority value has been specified.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_priority_694_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_color(LColor const &color)
 */
static PyObject *Dtool_EggTexture_set_color_695(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_color")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTexture.set_color", "LVecBase4f");
  }
  ((*local_this).set_color)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color(const EggTexture self, const LVecBase4f color)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_color_695_comment =
  "C++ Interface:\n"
  "set_color(const EggTexture self, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_color_695_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::clear_color(void)
 */
static PyObject *Dtool_EggTexture_clear_color_696(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.clear_color")) {
    return nullptr;
  }
  // 1-inline void EggTexture::clear_color(void)
  ((*local_this).clear_color)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_clear_color_696_comment =
  "C++ Interface:\n"
  "clear_color(const EggTexture self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_clear_color_696_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::has_color(void) const
 */
static PyObject *Dtool_EggTexture_has_color_697(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline bool EggTexture::has_color(void) const
  bool return_value = ((*(const EggTexture*)local_this).has_color)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_has_color_697_comment =
  "C++ Interface:\n"
  "has_color(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if a blend color has been specified for the texture.\n"
  " */";
#else
static const char *Dtool_EggTexture_has_color_697_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &EggTexture::get_color(void) const
 */
static PyObject *Dtool_EggTexture_get_color_698(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline LColor const &EggTexture::get_color(void) const
  LColor const *return_value = &(((*(const EggTexture*)local_this).get_color)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_color_698_comment =
  "C++ Interface:\n"
  "get_color(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the blend color if one has been specified, or (0, 0, 0, 1)\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_color_698_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_border_color(LColor const &border_color)
 */
static PyObject *Dtool_EggTexture_set_border_color_699(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_border_color")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_border_color(LColor const &border_color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTexture.set_border_color", "LVecBase4f");
  }
  ((*local_this).set_border_color)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_border_color(const EggTexture self, const LVecBase4f border_color)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_border_color_699_comment =
  "C++ Interface:\n"
  "set_border_color(const EggTexture self, const LVecBase4f border_color)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_set_border_color_699_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::clear_border_color(void)
 */
static PyObject *Dtool_EggTexture_clear_border_color_700(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.clear_border_color")) {
    return nullptr;
  }
  // 1-inline void EggTexture::clear_border_color(void)
  ((*local_this).clear_border_color)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_clear_border_color_700_comment =
  "C++ Interface:\n"
  "clear_border_color(const EggTexture self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_clear_border_color_700_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::has_border_color(void) const
 */
static PyObject *Dtool_EggTexture_has_border_color_701(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline bool EggTexture::has_border_color(void) const
  bool return_value = ((*(const EggTexture*)local_this).has_border_color)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_has_border_color_701_comment =
  "C++ Interface:\n"
  "has_border_color(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if a border color has been specified for the texture.\n"
  " */";
#else
static const char *Dtool_EggTexture_has_border_color_701_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &EggTexture::get_border_color(void) const
 */
static PyObject *Dtool_EggTexture_get_border_color_702(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline LColor const &EggTexture::get_border_color(void) const
  LColor const *return_value = &(((*(const EggTexture*)local_this).get_border_color)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_border_color_702_comment =
  "C++ Interface:\n"
  "get_border_color(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the border color if one has been specified, or (0, 0, 0, 1)\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_border_color_702_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_uv_name(std::string const &uv_name)
 */
static PyObject *Dtool_EggTexture_set_uv_name_703(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_uv_name")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_uv_name(std::string const &uv_name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_uv_name)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_uv_name(const EggTexture self, str uv_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_uv_name_703_comment =
  "C++ Interface:\n"
  "set_uv_name(const EggTexture self, str uv_name)\n"
  "\n"
  "/**\n"
  " * Specifies the named set of texture coordinates that this texture will use\n"
  " * when it is applied to geometry.  Geometry may have multiple sets of texture\n"
  " * coordinates defined, by name.\n"
  " *\n"
  " * If this is not specified for a particular texture, the default set of\n"
  " * texture coordinates will be used.\n"
  " */";
#else
static const char *Dtool_EggTexture_set_uv_name_703_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::clear_uv_name(void)
 */
static PyObject *Dtool_EggTexture_clear_uv_name_704(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.clear_uv_name")) {
    return nullptr;
  }
  // 1-inline void EggTexture::clear_uv_name(void)
  ((*local_this).clear_uv_name)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_clear_uv_name_704_comment =
  "C++ Interface:\n"
  "clear_uv_name(const EggTexture self)\n"
  "\n"
  "/**\n"
  " * Removes the restriction to a particular named set of texture coordinates\n"
  " * and restores the texture to using the default texture coordinates.\n"
  " */";
#else
static const char *Dtool_EggTexture_clear_uv_name_704_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::has_uv_name(void) const
 */
static PyObject *Dtool_EggTexture_has_uv_name_705(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline bool EggTexture::has_uv_name(void) const
  bool return_value = ((*(const EggTexture*)local_this).has_uv_name)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_has_uv_name_705_comment =
  "C++ Interface:\n"
  "has_uv_name(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if a texcoord name has been explicitly specified for this\n"
  " * texture, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggTexture_has_uv_name_705_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &EggTexture::get_uv_name(void) const
 */
static PyObject *Dtool_EggTexture_get_uv_name_706(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline std::string const &EggTexture::get_uv_name(void) const
  std::string const &return_value = ((*(const EggTexture*)local_this).get_uv_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_uv_name_706_comment =
  "C++ Interface:\n"
  "get_uv_name(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the texcoord name that has been specified for this texture, or the\n"
  " * empty string if no texcoord name has explicitly been specified.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_uv_name_706_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_rgb_scale(int rgb_scale)
 */
static PyObject *Dtool_EggTexture_set_rgb_scale_707(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_rgb_scale")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_rgb_scale(int rgb_scale)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_rgb_scale)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_rgb_scale(const EggTexture self, int rgb_scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_rgb_scale_707_comment =
  "C++ Interface:\n"
  "set_rgb_scale(const EggTexture self, int rgb_scale)\n"
  "\n"
  "/**\n"
  " * Sets an additional factor that will scale all three r, g, b components\n"
  " * after the texture has been applied.  This is used only when a combine mode\n"
  " * is in effect.\n"
  " *\n"
  " * The only legal values are 1, 2, or 4.\n"
  " */";
#else
static const char *Dtool_EggTexture_set_rgb_scale_707_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::clear_rgb_scale(void)
 */
static PyObject *Dtool_EggTexture_clear_rgb_scale_708(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.clear_rgb_scale")) {
    return nullptr;
  }
  // 1-inline void EggTexture::clear_rgb_scale(void)
  ((*local_this).clear_rgb_scale)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_clear_rgb_scale_708_comment =
  "C++ Interface:\n"
  "clear_rgb_scale(const EggTexture self)\n"
  "\n"
  "/**\n"
  " * Removes the rgb_scale from the texture and restores it to the default value\n"
  " * of 1.\n"
  " */";
#else
static const char *Dtool_EggTexture_clear_rgb_scale_708_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::has_rgb_scale(void) const
 */
static PyObject *Dtool_EggTexture_has_rgb_scale_709(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline bool EggTexture::has_rgb_scale(void) const
  bool return_value = ((*(const EggTexture*)local_this).has_rgb_scale)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_has_rgb_scale_709_comment =
  "C++ Interface:\n"
  "has_rgb_scale(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if an rgb_scale has been specified for the texture, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_EggTexture_has_rgb_scale_709_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggTexture::get_rgb_scale(void) const
 */
static PyObject *Dtool_EggTexture_get_rgb_scale_710(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline int EggTexture::get_rgb_scale(void) const
  int return_value = ((*(const EggTexture*)local_this).get_rgb_scale)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_rgb_scale_710_comment =
  "C++ Interface:\n"
  "get_rgb_scale(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the rgb_scale value that has been specified for the texture, or 1\n"
  " * if no rgb_scale value has been specified.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_rgb_scale_710_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_alpha_scale(int alpha_scale)
 */
static PyObject *Dtool_EggTexture_set_alpha_scale_711(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_alpha_scale")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_alpha_scale(int alpha_scale)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_alpha_scale)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_alpha_scale(const EggTexture self, int alpha_scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_alpha_scale_711_comment =
  "C++ Interface:\n"
  "set_alpha_scale(const EggTexture self, int alpha_scale)\n"
  "\n"
  "/**\n"
  " * Sets an additional factor that will scale the alpha component after the\n"
  " * texture has been applied.  This is used only when a combine mode is in\n"
  " * effect.\n"
  " *\n"
  " * The only legal values are 1, 2, or 4.\n"
  " */";
#else
static const char *Dtool_EggTexture_set_alpha_scale_711_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::clear_alpha_scale(void)
 */
static PyObject *Dtool_EggTexture_clear_alpha_scale_712(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.clear_alpha_scale")) {
    return nullptr;
  }
  // 1-inline void EggTexture::clear_alpha_scale(void)
  ((*local_this).clear_alpha_scale)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_clear_alpha_scale_712_comment =
  "C++ Interface:\n"
  "clear_alpha_scale(const EggTexture self)\n"
  "\n"
  "/**\n"
  " * Removes the alpha_scale from the texture and restores it to the default\n"
  " * value of 1.\n"
  " */";
#else
static const char *Dtool_EggTexture_clear_alpha_scale_712_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::has_alpha_scale(void) const
 */
static PyObject *Dtool_EggTexture_has_alpha_scale_713(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline bool EggTexture::has_alpha_scale(void) const
  bool return_value = ((*(const EggTexture*)local_this).has_alpha_scale)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_has_alpha_scale_713_comment =
  "C++ Interface:\n"
  "has_alpha_scale(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if an alpha_scale has been specified for the texture, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_EggTexture_has_alpha_scale_713_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggTexture::get_alpha_scale(void) const
 */
static PyObject *Dtool_EggTexture_get_alpha_scale_714(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline int EggTexture::get_alpha_scale(void) const
  int return_value = ((*(const EggTexture*)local_this).get_alpha_scale)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_alpha_scale_714_comment =
  "C++ Interface:\n"
  "get_alpha_scale(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the alpha_scale value that has been specified for the texture, or 1\n"
  " * if no alpha_scale value has been specified.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_alpha_scale_714_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_alpha_filename(Filename const &filename)
 */
static PyObject *Dtool_EggTexture_set_alpha_filename_715(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_alpha_filename")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_alpha_filename(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTexture.set_alpha_filename", "Filename");
  }
  ((*local_this).set_alpha_filename)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_alpha_filename(const EggTexture self, const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_alpha_filename_715_comment =
  "C++ Interface:\n"
  "set_alpha_filename(const EggTexture self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Specifies a separate file that will be loaded in with the 1- or 3-component\n"
  " * texture and applied as the alpha channel.  This is useful when loading\n"
  " * textures from file formats that do not support alpha, for instance jpg.\n"
  " */";
#else
static const char *Dtool_EggTexture_set_alpha_filename_715_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::clear_alpha_filename(void)
 */
static PyObject *Dtool_EggTexture_clear_alpha_filename_716(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.clear_alpha_filename")) {
    return nullptr;
  }
  // 1-inline void EggTexture::clear_alpha_filename(void)
  ((*local_this).clear_alpha_filename)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_clear_alpha_filename_716_comment =
  "C++ Interface:\n"
  "clear_alpha_filename(const EggTexture self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTexture_clear_alpha_filename_716_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::has_alpha_filename(void) const
 */
static PyObject *Dtool_EggTexture_has_alpha_filename_717(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline bool EggTexture::has_alpha_filename(void) const
  bool return_value = ((*(const EggTexture*)local_this).has_alpha_filename)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_has_alpha_filename_717_comment =
  "C++ Interface:\n"
  "has_alpha_filename(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if a separate file for the alpha component has been applied,\n"
  " * false otherwise.  See set_alpha_filename().\n"
  " */";
#else
static const char *Dtool_EggTexture_has_alpha_filename_717_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &EggTexture::get_alpha_filename(void) const
 */
static PyObject *Dtool_EggTexture_get_alpha_filename_718(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline Filename const &EggTexture::get_alpha_filename(void) const
  Filename const *return_value = &(((*(const EggTexture*)local_this).get_alpha_filename)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_alpha_filename_718_comment =
  "C++ Interface:\n"
  "get_alpha_filename(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the separate file assigned for the alpha channel.  It is an error\n"
  " * to call this unless has_alpha_filename() returns true.  See\n"
  " * set_alpha_filename().\n"
  " */";
#else
static const char *Dtool_EggTexture_get_alpha_filename_718_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_alpha_fullpath(Filename const &fullpath)
 */
static PyObject *Dtool_EggTexture_set_alpha_fullpath_719(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_alpha_fullpath")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_alpha_fullpath(Filename const &fullpath)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTexture.set_alpha_fullpath", "Filename");
  }
  ((*local_this).set_alpha_fullpath)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_alpha_fullpath(const EggTexture self, const Filename fullpath)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_alpha_fullpath_719_comment =
  "C++ Interface:\n"
  "set_alpha_fullpath(const EggTexture self, const Filename fullpath)\n"
  "\n"
  "/**\n"
  " * Records the full pathname to the file, for the benefit of\n"
  " * get_alpha_fullpath().\n"
  " */";
#else
static const char *Dtool_EggTexture_set_alpha_fullpath_719_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &EggTexture::get_alpha_fullpath(void) const
 */
static PyObject *Dtool_EggTexture_get_alpha_fullpath_720(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline Filename const &EggTexture::get_alpha_fullpath(void) const
  Filename const *return_value = &(((*(const EggTexture*)local_this).get_alpha_fullpath)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_alpha_fullpath_720_comment =
  "C++ Interface:\n"
  "get_alpha_fullpath(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the full pathname to the alpha file, if it is known; otherwise,\n"
  " * returns the same thing as get_alpha_filename().\n"
  " *\n"
  " * This function simply returns whatever was set by the last call to\n"
  " * set_alpha_fullpath().  This string is not written to the egg file; its main\n"
  " * purpose is to record the full path to the alpha filename if it is known,\n"
  " * for egg structures that are generated in-memory and then immediately\n"
  " * converted to a scene graph.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_alpha_fullpath_720_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_alpha_file_channel(int alpha_file_channel)
 */
static PyObject *Dtool_EggTexture_set_alpha_file_channel_721(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_alpha_file_channel")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_alpha_file_channel(int alpha_file_channel)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_alpha_file_channel)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_alpha_file_channel(const EggTexture self, int alpha_file_channel)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_alpha_file_channel_721_comment =
  "C++ Interface:\n"
  "set_alpha_file_channel(const EggTexture self, int alpha_file_channel)\n"
  "\n"
  "/**\n"
  " * If a separate alpha-file is specified, this indicates which channel number\n"
  " * should be extracted from this file to derive the alpha channel for the\n"
  " * final image.  The default is 0, which means the grayscale combination of r,\n"
  " * g, b.  Otherwise, this should be the 1-based channel number, for instance\n"
  " * 1, 2, or 3 for r, g, or b, respectively, or 4 for the alpha channel of a\n"
  " * four-component image.\n"
  " */";
#else
static const char *Dtool_EggTexture_set_alpha_file_channel_721_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::clear_alpha_file_channel(void)
 */
static PyObject *Dtool_EggTexture_clear_alpha_file_channel_722(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.clear_alpha_file_channel")) {
    return nullptr;
  }
  // 1-inline void EggTexture::clear_alpha_file_channel(void)
  ((*local_this).clear_alpha_file_channel)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_clear_alpha_file_channel_722_comment =
  "C++ Interface:\n"
  "clear_alpha_file_channel(const EggTexture self)\n"
  "\n"
  "/**\n"
  " * Removes the specification of a particular channel to use from the alpha-\n"
  " * file image.\n"
  " */";
#else
static const char *Dtool_EggTexture_clear_alpha_file_channel_722_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::has_alpha_file_channel(void) const
 */
static PyObject *Dtool_EggTexture_has_alpha_file_channel_723(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline bool EggTexture::has_alpha_file_channel(void) const
  bool return_value = ((*(const EggTexture*)local_this).has_alpha_file_channel)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_has_alpha_file_channel_723_comment =
  "C++ Interface:\n"
  "has_alpha_file_channel(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if a particular channel has been specified for the alpha-file\n"
  " * image, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggTexture_has_alpha_file_channel_723_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggTexture::get_alpha_file_channel(void) const
 */
static PyObject *Dtool_EggTexture_get_alpha_file_channel_724(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline int EggTexture::get_alpha_file_channel(void) const
  int return_value = ((*(const EggTexture*)local_this).get_alpha_file_channel)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_alpha_file_channel_724_comment =
  "C++ Interface:\n"
  "get_alpha_file_channel(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the particular channel that has been specified for the alpha-file\n"
  " * image, or 0 if no channel has been specified.  See\n"
  " * set_alpha_file_channel().\n"
  " */";
#else
static const char *Dtool_EggTexture_get_alpha_file_channel_724_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_multiview(bool multiview)
 */
static PyObject *Dtool_EggTexture_set_multiview_725(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_multiview")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_multiview(bool multiview)
  ((*local_this).set_multiview)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_multiview(const EggTexture self, bool multiview)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_multiview_725_comment =
  "C++ Interface:\n"
  "set_multiview(const EggTexture self, bool multiview)\n"
  "\n"
  "/**\n"
  " * Sets the multiview flag.\n"
  " *\n"
  " * If multiview is true, the filename should contain a hash mark ('#'), which\n"
  " * will be filled in with the view number; and a multiview texture will be\n"
  " * defined with a series of images, one for each view.\n"
  " *\n"
  " * A multiview texture is most often used for stereo textures, but other uses\n"
  " * are also possible, such as for texture animation.\n"
  " */";
#else
static const char *Dtool_EggTexture_set_multiview_725_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::get_multiview(void) const
 */
static PyObject *Dtool_EggTexture_get_multiview_726(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline bool EggTexture::get_multiview(void) const
  bool return_value = ((*(const EggTexture*)local_this).get_multiview)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_multiview_726_comment =
  "C++ Interface:\n"
  "get_multiview(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the multiview flag.  See set_multiview().\n"
  " */";
#else
static const char *Dtool_EggTexture_get_multiview_726_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_num_views(int num_views)
 */
static PyObject *Dtool_EggTexture_set_num_views_727(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_num_views")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_num_views(int num_views)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_num_views)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_views(const EggTexture self, int num_views)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_num_views_727_comment =
  "C++ Interface:\n"
  "set_num_views(const EggTexture self, int num_views)\n"
  "\n"
  "/**\n"
  " * When loading a 3-D multiview texture, this parameter is necessary to\n"
  " * specify how many views will be expected.  The z size is determined\n"
  " * implicitly from the number of images loaded.\n"
  " */";
#else
static const char *Dtool_EggTexture_set_num_views_727_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::clear_num_views(void)
 */
static PyObject *Dtool_EggTexture_clear_num_views_728(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.clear_num_views")) {
    return nullptr;
  }
  // 1-inline void EggTexture::clear_num_views(void)
  ((*local_this).clear_num_views)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_clear_num_views_728_comment =
  "C++ Interface:\n"
  "clear_num_views(const EggTexture self)\n"
  "\n"
  "/**\n"
  " * Removes the specification of the number of views for a 3-D multiview\n"
  " * texture.\n"
  " */";
#else
static const char *Dtool_EggTexture_clear_num_views_728_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::has_num_views(void) const
 */
static PyObject *Dtool_EggTexture_has_num_views_729(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline bool EggTexture::has_num_views(void) const
  bool return_value = ((*(const EggTexture*)local_this).has_num_views)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_has_num_views_729_comment =
  "C++ Interface:\n"
  "has_num_views(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if the number of views has been specified for the 3-D\n"
  " * multiview texture, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggTexture_has_num_views_729_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggTexture::get_num_views(void) const
 */
static PyObject *Dtool_EggTexture_get_num_views_730(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline int EggTexture::get_num_views(void) const
  int return_value = ((*(const EggTexture*)local_this).get_num_views)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_num_views_730_comment =
  "C++ Interface:\n"
  "get_num_views(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the specified number of views specified for the 3-D multiview\n"
  " * texture.  See set_num_views().\n"
  " */";
#else
static const char *Dtool_EggTexture_get_num_views_730_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_read_mipmaps(bool read_mipmaps)
 */
static PyObject *Dtool_EggTexture_set_read_mipmaps_731(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_read_mipmaps")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_read_mipmaps(bool read_mipmaps)
  ((*local_this).set_read_mipmaps)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_read_mipmaps(const EggTexture self, bool read_mipmaps)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_read_mipmaps_731_comment =
  "C++ Interface:\n"
  "set_read_mipmaps(const EggTexture self, bool read_mipmaps)\n"
  "\n"
  "/**\n"
  " * Sets the read_mipmaps flag.\n"
  " *\n"
  " * If read_mipmaps is true, the filename should contain a hash mark ('#'),\n"
  " * which will be filled in with the mipmap level number; and the texture will\n"
  " * be defined with a series of images, one for each mipmap level.\n"
  " *\n"
  " * If the filename is of a type that already requires a hash mark, such as a\n"
  " * cube map or a 3-d texture, then the filename should now require two hash\n"
  " * marks, and the first one indicates the mipmap level number, while the\n"
  " * second indicates the face number or 3-d level number.\n"
  " */";
#else
static const char *Dtool_EggTexture_set_read_mipmaps_731_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::get_read_mipmaps(void) const
 */
static PyObject *Dtool_EggTexture_get_read_mipmaps_732(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline bool EggTexture::get_read_mipmaps(void) const
  bool return_value = ((*(const EggTexture*)local_this).get_read_mipmaps)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_read_mipmaps_732_comment =
  "C++ Interface:\n"
  "get_read_mipmaps(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the read_mipmaps flag.  See\n"
  " * set_read_mipmaps().\n"
  " */";
#else
static const char *Dtool_EggTexture_get_read_mipmaps_732_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_min_lod(double min_lod)
 */
static PyObject *Dtool_EggTexture_set_min_lod_733(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_min_lod")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_min_lod(double min_lod)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_min_lod)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_min_lod(const EggTexture self, double min_lod)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_min_lod_733_comment =
  "C++ Interface:\n"
  "set_min_lod(const EggTexture self, double min_lod)\n"
  "\n"
  "/**\n"
  " * Sets the minimum mipmap level that may be sampled.\n"
  " */";
#else
static const char *Dtool_EggTexture_set_min_lod_733_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::clear_min_lod(void)
 */
static PyObject *Dtool_EggTexture_clear_min_lod_734(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.clear_min_lod")) {
    return nullptr;
  }
  // 1-inline void EggTexture::clear_min_lod(void)
  ((*local_this).clear_min_lod)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_clear_min_lod_734_comment =
  "C++ Interface:\n"
  "clear_min_lod(const EggTexture self)\n"
  "\n"
  "/**\n"
  " * Removes the specification of a minimum mipmap level from the texture.\n"
  " */";
#else
static const char *Dtool_EggTexture_clear_min_lod_734_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::has_min_lod(void) const
 */
static PyObject *Dtool_EggTexture_has_min_lod_735(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline bool EggTexture::has_min_lod(void) const
  bool return_value = ((*(const EggTexture*)local_this).has_min_lod)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_has_min_lod_735_comment =
  "C++ Interface:\n"
  "has_min_lod(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if a value for the minimum mipmap level has been specified for\n"
  " * this texture, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggTexture_has_min_lod_735_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double EggTexture::get_min_lod(void) const
 */
static PyObject *Dtool_EggTexture_get_min_lod_736(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline double EggTexture::get_min_lod(void) const
  double return_value = ((*(const EggTexture*)local_this).get_min_lod)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_min_lod_736_comment =
  "C++ Interface:\n"
  "get_min_lod(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the minimum mipmap level that has been specified for this texture.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_min_lod_736_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_max_lod(double max_lod)
 */
static PyObject *Dtool_EggTexture_set_max_lod_737(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_max_lod")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_max_lod(double max_lod)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_max_lod)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_lod(const EggTexture self, double max_lod)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_max_lod_737_comment =
  "C++ Interface:\n"
  "set_max_lod(const EggTexture self, double max_lod)\n"
  "\n"
  "/**\n"
  " * Sets the maximum mipmap level that may be sampled.\n"
  " */";
#else
static const char *Dtool_EggTexture_set_max_lod_737_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::clear_max_lod(void)
 */
static PyObject *Dtool_EggTexture_clear_max_lod_738(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.clear_max_lod")) {
    return nullptr;
  }
  // 1-inline void EggTexture::clear_max_lod(void)
  ((*local_this).clear_max_lod)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_clear_max_lod_738_comment =
  "C++ Interface:\n"
  "clear_max_lod(const EggTexture self)\n"
  "\n"
  "/**\n"
  " * Removes the specification of a maximum mipmap level from the texture.\n"
  " */";
#else
static const char *Dtool_EggTexture_clear_max_lod_738_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::has_max_lod(void) const
 */
static PyObject *Dtool_EggTexture_has_max_lod_739(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline bool EggTexture::has_max_lod(void) const
  bool return_value = ((*(const EggTexture*)local_this).has_max_lod)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_has_max_lod_739_comment =
  "C++ Interface:\n"
  "has_max_lod(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if a value for the maximum mipmap level has been specified for\n"
  " * this texture, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggTexture_has_max_lod_739_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double EggTexture::get_max_lod(void) const
 */
static PyObject *Dtool_EggTexture_get_max_lod_740(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline double EggTexture::get_max_lod(void) const
  double return_value = ((*(const EggTexture*)local_this).get_max_lod)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_max_lod_740_comment =
  "C++ Interface:\n"
  "get_max_lod(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum mipmap level that has been specified for this texture.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_max_lod_740_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::set_lod_bias(double lod_bias)
 */
static PyObject *Dtool_EggTexture_set_lod_bias_741(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.set_lod_bias")) {
    return nullptr;
  }
  // 1-inline void EggTexture::set_lod_bias(double lod_bias)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_lod_bias)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_lod_bias(const EggTexture self, double lod_bias)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_set_lod_bias_741_comment =
  "C++ Interface:\n"
  "set_lod_bias(const EggTexture self, double lod_bias)\n"
  "\n"
  "/**\n"
  " * Sets the mipmap level bias that is added to the mipmap level to be sampled.\n"
  " */";
#else
static const char *Dtool_EggTexture_set_lod_bias_741_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTexture::clear_lod_bias(void)
 */
static PyObject *Dtool_EggTexture_clear_lod_bias_742(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.clear_lod_bias")) {
    return nullptr;
  }
  // 1-inline void EggTexture::clear_lod_bias(void)
  ((*local_this).clear_lod_bias)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_clear_lod_bias_742_comment =
  "C++ Interface:\n"
  "clear_lod_bias(const EggTexture self)\n"
  "\n"
  "/**\n"
  " * Removes the specification of a maximum mipmap level from the texture.\n"
  " */";
#else
static const char *Dtool_EggTexture_clear_lod_bias_742_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggTexture::has_lod_bias(void) const
 */
static PyObject *Dtool_EggTexture_has_lod_bias_743(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline bool EggTexture::has_lod_bias(void) const
  bool return_value = ((*(const EggTexture*)local_this).has_lod_bias)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_has_lod_bias_743_comment =
  "C++ Interface:\n"
  "has_lod_bias(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns true if a value for the maximum mipmap level has been specified for\n"
  " * this texture, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggTexture_has_lod_bias_743_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double EggTexture::get_lod_bias(void) const
 */
static PyObject *Dtool_EggTexture_get_lod_bias_744(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline double EggTexture::get_lod_bias(void) const
  double return_value = ((*(const EggTexture*)local_this).get_lod_bias)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_lod_bias_744_comment =
  "C++ Interface:\n"
  "get_lod_bias(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum mipmap level that has been specified for this texture.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_lod_bias_744_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggTexture::clear_multitexture(void)
 */
static PyObject *Dtool_EggTexture_clear_multitexture_745(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.clear_multitexture")) {
    return nullptr;
  }
  // 1-void EggTexture::clear_multitexture(void)
  ((*local_this).clear_multitexture)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_clear_multitexture_745_comment =
  "C++ Interface:\n"
  "clear_multitexture(const EggTexture self)\n"
  "\n"
  "/**\n"
  " * Resets the multitexture flags set by multitexture_over().  After this call,\n"
  " * get_multitexture() will return false, and get_multitexture_sort() will\n"
  " * return 0.\n"
  " */";
#else
static const char *Dtool_EggTexture_clear_multitexture_745_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggTexture::multitexture_over(EggTexture *other)
 */
static PyObject *Dtool_EggTexture_multitexture_over_746(PyObject *self, PyObject *arg) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.multitexture_over")) {
    return nullptr;
  }
  // 1-bool EggTexture::multitexture_over(EggTexture *other)
  EggTexture *arg_this = (EggTexture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggTexture, 1, "EggTexture.multitexture_over", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).multitexture_over)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "multitexture_over(const EggTexture self, EggTexture other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_multitexture_over_746_comment =
  "C++ Interface:\n"
  "multitexture_over(const EggTexture self, EggTexture other)\n"
  "\n"
  "/**\n"
  " * Indicates that this texture should be layered on top of the other texture.\n"
  " * This will guarantee that this->get_multitexture_sort() >\n"
  " * other->get_multitexture_sort(), at least until clear_multitexture() is\n"
  " * called on either one.\n"
  " *\n"
  " * The return value is true if successful, or false if there is a failure\n"
  " * because the other texture was already layered on top of this one (or there\n"
  " * is a three- or more-way cycle).\n"
  " */";
#else
static const char *Dtool_EggTexture_multitexture_over_746_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggTexture::get_multitexture_sort(void) const
 */
static PyObject *Dtool_EggTexture_get_multitexture_sort_747(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTexture)) {
    return nullptr;
  }
  // 1-inline int EggTexture::get_multitexture_sort(void) const
  int return_value = ((*(const EggTexture*)local_this).get_multitexture_sort)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_multitexture_sort_747_comment =
  "C++ Interface:\n"
  "get_multitexture_sort(EggTexture self)\n"
  "\n"
  "/**\n"
  " * Returns an integer that represents the depth to which this texture is\n"
  " * layered on all other textures in the egg file.  In general, if texture A is\n"
  " * layered over texture B, then sort(A) > sort(B).  If texture A is never\n"
  " * layered over any other texture, then sort(A) == 0.  More than that is\n"
  " * difficult to guarantee.\n"
  " */";
#else
static const char *Dtool_EggTexture_get_multitexture_sort_747_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static EggTexture::TextureType EggTexture::string_texture_type(std::string const &string)
 */
static PyObject *Dtool_EggTexture_string_texture_type_748(PyObject *, PyObject *arg) {
  // 1-static EggTexture::TextureType EggTexture::string_texture_type(std::string const &string)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    EggTexture::TextureType return_value = (EggTexture::string_texture_type)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_texture_type(str string)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_string_texture_type_748_comment =
  "C++ Interface:\n"
  "string_texture_type(str string)\n"
  "\n"
  "/**\n"
  " * Returns the Texture_ype value associated with the given string\n"
  " * representation, or TT_unspecified if the string does not match any known\n"
  " * TextureType value.\n"
  " */";
#else
static const char *Dtool_EggTexture_string_texture_type_748_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static EggTexture::Format EggTexture::string_format(std::string const &string)
 */
static PyObject *Dtool_EggTexture_string_format_749(PyObject *, PyObject *arg) {
  // 1-static EggTexture::Format EggTexture::string_format(std::string const &string)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    EggTexture::Format return_value = (EggTexture::string_format)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_format(str string)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_string_format_749_comment =
  "C++ Interface:\n"
  "string_format(str string)\n"
  "\n"
  "/**\n"
  " * Returns the Format value associated with the given string representation,\n"
  " * or F_unspecified if the string does not match any known Format value.\n"
  " */";
#else
static const char *Dtool_EggTexture_string_format_749_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static EggTexture::CompressionMode EggTexture::string_compression_mode(std::string const &string)
 */
static PyObject *Dtool_EggTexture_string_compression_mode_750(PyObject *, PyObject *arg) {
  // 1-static EggTexture::CompressionMode EggTexture::string_compression_mode(std::string const &string)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    EggTexture::CompressionMode return_value = (EggTexture::string_compression_mode)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_compression_mode(str string)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_string_compression_mode_750_comment =
  "C++ Interface:\n"
  "string_compression_mode(str string)\n"
  "\n"
  "/**\n"
  " * Returns the CompressionMode value associated with the given string\n"
  " * representation, or CM_default if the string does not match any known\n"
  " * CompressionMode value.\n"
  " */";
#else
static const char *Dtool_EggTexture_string_compression_mode_750_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static EggTexture::WrapMode EggTexture::string_wrap_mode(std::string const &string)
 */
static PyObject *Dtool_EggTexture_string_wrap_mode_751(PyObject *, PyObject *arg) {
  // 1-static EggTexture::WrapMode EggTexture::string_wrap_mode(std::string const &string)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    EggTexture::WrapMode return_value = (EggTexture::string_wrap_mode)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_wrap_mode(str string)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_string_wrap_mode_751_comment =
  "C++ Interface:\n"
  "string_wrap_mode(str string)\n"
  "\n"
  "/**\n"
  " * Returns the WrapMode value associated with the given string representation,\n"
  " * or WM_unspecified if the string does not match any known WrapMode value.\n"
  " */";
#else
static const char *Dtool_EggTexture_string_wrap_mode_751_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static EggTexture::FilterType EggTexture::string_filter_type(std::string const &string)
 */
static PyObject *Dtool_EggTexture_string_filter_type_752(PyObject *, PyObject *arg) {
  // 1-static EggTexture::FilterType EggTexture::string_filter_type(std::string const &string)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    EggTexture::FilterType return_value = (EggTexture::string_filter_type)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_filter_type(str string)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_string_filter_type_752_comment =
  "C++ Interface:\n"
  "string_filter_type(str string)\n"
  "\n"
  "/**\n"
  " * Returns the FilterType value associated with the given string\n"
  " * representation, or FT_unspecified if the string does not match any known\n"
  " * FilterType value.\n"
  " */";
#else
static const char *Dtool_EggTexture_string_filter_type_752_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static EggTexture::EnvType EggTexture::string_env_type(std::string const &string)
 */
static PyObject *Dtool_EggTexture_string_env_type_753(PyObject *, PyObject *arg) {
  // 1-static EggTexture::EnvType EggTexture::string_env_type(std::string const &string)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    EggTexture::EnvType return_value = (EggTexture::string_env_type)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_env_type(str string)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_string_env_type_753_comment =
  "C++ Interface:\n"
  "string_env_type(str string)\n"
  "\n"
  "/**\n"
  " * Returns the EnvType value associated with the given string representation,\n"
  " * or ET_unspecified if the string does not match any known EnvType value.\n"
  " */";
#else
static const char *Dtool_EggTexture_string_env_type_753_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static EggTexture::CombineMode EggTexture::string_combine_mode(std::string const &string)
 */
static PyObject *Dtool_EggTexture_string_combine_mode_754(PyObject *, PyObject *arg) {
  // 1-static EggTexture::CombineMode EggTexture::string_combine_mode(std::string const &string)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    EggTexture::CombineMode return_value = (EggTexture::string_combine_mode)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_combine_mode(str string)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_string_combine_mode_754_comment =
  "C++ Interface:\n"
  "string_combine_mode(str string)\n"
  "\n"
  "/**\n"
  " * Returns the CombineMode value associated with the given string\n"
  " * representation, or CM_unspecified if the string does not match any known\n"
  " * CombineMode value.\n"
  " */";
#else
static const char *Dtool_EggTexture_string_combine_mode_754_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static EggTexture::CombineSource EggTexture::string_combine_source(std::string const &string)
 */
static PyObject *Dtool_EggTexture_string_combine_source_755(PyObject *, PyObject *arg) {
  // 1-static EggTexture::CombineSource EggTexture::string_combine_source(std::string const &string)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    EggTexture::CombineSource return_value = (EggTexture::string_combine_source)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_combine_source(str string)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_string_combine_source_755_comment =
  "C++ Interface:\n"
  "string_combine_source(str string)\n"
  "\n"
  "/**\n"
  " * Returns the CombineSource value associated with the given string\n"
  " * representation, or CS_unspecified if the string does not match any known\n"
  " * CombineSource value.\n"
  " */";
#else
static const char *Dtool_EggTexture_string_combine_source_755_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static EggTexture::CombineOperand EggTexture::string_combine_operand(std::string const &string)
 */
static PyObject *Dtool_EggTexture_string_combine_operand_756(PyObject *, PyObject *arg) {
  // 1-static EggTexture::CombineOperand EggTexture::string_combine_operand(std::string const &string)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    EggTexture::CombineOperand return_value = (EggTexture::string_combine_operand)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_combine_operand(str string)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_string_combine_operand_756_comment =
  "C++ Interface:\n"
  "string_combine_operand(str string)\n"
  "\n"
  "/**\n"
  " * Returns the CombineOperand value associated with the given string\n"
  " * representation, or CO_unspecified if the string does not match any known\n"
  " * CombineOperand value.\n"
  " */";
#else
static const char *Dtool_EggTexture_string_combine_operand_756_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static EggTexture::TexGen EggTexture::string_tex_gen(std::string const &string)
 */
static PyObject *Dtool_EggTexture_string_tex_gen_757(PyObject *, PyObject *arg) {
  // 1-static EggTexture::TexGen EggTexture::string_tex_gen(std::string const &string)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    EggTexture::TexGen return_value = (EggTexture::string_tex_gen)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_tex_gen(str string)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_string_tex_gen_757_comment =
  "C++ Interface:\n"
  "string_tex_gen(str string)\n"
  "\n"
  "/**\n"
  " * Returns the TexGen value associated with the given string representation,\n"
  " * or ET_unspecified if the string does not match any known TexGen value.\n"
  " */";
#else
static const char *Dtool_EggTexture_string_tex_gen_757_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static EggTexture::QualityLevel EggTexture::string_quality_level(std::string const &string)
 */
static PyObject *Dtool_EggTexture_string_quality_level_758(PyObject *, PyObject *arg) {
  // 1-static EggTexture::QualityLevel EggTexture::string_quality_level(std::string const &string)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    EggTexture::QualityLevel return_value = (EggTexture::string_quality_level)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_quality_level(str string)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_string_quality_level_758_comment =
  "C++ Interface:\n"
  "string_quality_level(str string)\n"
  "\n"
  "/**\n"
  " * Returns the TexGen value associated with the given string representation,\n"
  " * or ET_unspecified if the string does not match any known TexGen value.\n"
  " */";
#else
static const char *Dtool_EggTexture_string_quality_level_758_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggTexture::get_class_type(void)
 */
static PyObject *Dtool_EggTexture_get_class_type_792(PyObject *, PyObject *) {
  // 1-static TypeHandle EggTexture::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggTexture::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_get_class_type_792_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggTexture_get_class_type_792_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggFilenameNode *EggTexture::upcast_to_EggFilenameNode(void)
 */
static PyObject *Dtool_EggTexture_upcast_to_EggFilenameNode_620(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.upcast_to_EggFilenameNode")) {
    return nullptr;
  }
  // 1-EggFilenameNode *EggTexture::upcast_to_EggFilenameNode(void)
  EggFilenameNode *return_value = (EggFilenameNode *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggFilenameNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_upcast_to_EggFilenameNode_620_comment =
  "C++ Interface:\n"
  "upcast_to_EggFilenameNode(const EggTexture self)\n"
  "\n"
  "upcast from EggTexture to EggFilenameNode";
#else
static const char *Dtool_EggTexture_upcast_to_EggFilenameNode_620_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggRenderMode *EggTexture::upcast_to_EggRenderMode(void)
 */
static PyObject *Dtool_EggTexture_upcast_to_EggRenderMode_622(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.upcast_to_EggRenderMode")) {
    return nullptr;
  }
  // 1-EggRenderMode *EggTexture::upcast_to_EggRenderMode(void)
  EggRenderMode *return_value = (EggRenderMode *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_upcast_to_EggRenderMode_622_comment =
  "C++ Interface:\n"
  "upcast_to_EggRenderMode(const EggTexture self)\n"
  "\n"
  "upcast from EggTexture to EggRenderMode";
#else
static const char *Dtool_EggTexture_upcast_to_EggRenderMode_622_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggTransform *EggTexture::upcast_to_EggTransform(void)
 */
static PyObject *Dtool_EggTexture_upcast_to_EggTransform_624(PyObject *self, PyObject *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.upcast_to_EggTransform")) {
    return nullptr;
  }
  // 1-EggTransform *EggTexture::upcast_to_EggTransform(void)
  EggTransform *return_value = (EggTransform *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggTransform, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggTexture_upcast_to_EggTransform_624_comment =
  "C++ Interface:\n"
  "upcast_to_EggTransform(const EggTexture self)\n"
  "\n"
  "upcast from EggTexture to EggTransform";
#else
static const char *Dtool_EggTexture_upcast_to_EggTransform_624_comment = nullptr;
#endif

static PyObject *Dtool_EggTexture_texture_type_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline EggTexture::TextureType EggTexture::get_texture_type(void) const
  EggTexture::TextureType return_value = ((*(const EggTexture*)local_this).get_texture_type)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_texture_type_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.texture_type")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete texture_type attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_texture_type(EggTexture::TextureType texture_type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_texture_type)((EggTexture::TextureType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_texture_type(const EggTexture self, int texture_type)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_format_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline EggTexture::Format EggTexture::get_format(void) const
  EggTexture::Format return_value = ((*(const EggTexture*)local_this).get_format)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_format_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.format")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete format attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_format(EggTexture::Format format)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_format)((EggTexture::Format)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_format(const EggTexture self, int format)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_compression_mode_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline EggTexture::CompressionMode EggTexture::get_compression_mode(void) const
  EggTexture::CompressionMode return_value = ((*(const EggTexture*)local_this).get_compression_mode)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_compression_mode_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.compression_mode")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete compression_mode attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_compression_mode(EggTexture::CompressionMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_compression_mode)((EggTexture::CompressionMode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_compression_mode(const EggTexture self, int mode)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_wrap_mode_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline EggTexture::WrapMode EggTexture::get_wrap_mode(void) const
  EggTexture::WrapMode return_value = ((*(const EggTexture*)local_this).get_wrap_mode)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_wrap_mode_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.wrap_mode")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete wrap_mode attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_wrap_mode(EggTexture::WrapMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_wrap_mode)((EggTexture::WrapMode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_wrap_mode(const EggTexture self, int mode)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_wrap_u_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline EggTexture::WrapMode EggTexture::get_wrap_u(void) const
  EggTexture::WrapMode return_value = ((*(const EggTexture*)local_this).get_wrap_u)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_wrap_u_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.wrap_u")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete wrap_u attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_wrap_u(EggTexture::WrapMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_wrap_u)((EggTexture::WrapMode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_wrap_u(const EggTexture self, int mode)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_wrap_v_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline EggTexture::WrapMode EggTexture::get_wrap_v(void) const
  EggTexture::WrapMode return_value = ((*(const EggTexture*)local_this).get_wrap_v)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_wrap_v_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.wrap_v")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete wrap_v attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_wrap_v(EggTexture::WrapMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_wrap_v)((EggTexture::WrapMode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_wrap_v(const EggTexture self, int mode)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_wrap_w_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline EggTexture::WrapMode EggTexture::get_wrap_w(void) const
  EggTexture::WrapMode return_value = ((*(const EggTexture*)local_this).get_wrap_w)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_wrap_w_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.wrap_w")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete wrap_w attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_wrap_w(EggTexture::WrapMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_wrap_w)((EggTexture::WrapMode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_wrap_w(const EggTexture self, int mode)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_minfilter_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline EggTexture::FilterType EggTexture::get_minfilter(void) const
  EggTexture::FilterType return_value = ((*(const EggTexture*)local_this).get_minfilter)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_minfilter_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.minfilter")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete minfilter attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_minfilter(EggTexture::FilterType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_minfilter)((EggTexture::FilterType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_minfilter(const EggTexture self, int type)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_magfilter_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline EggTexture::FilterType EggTexture::get_magfilter(void) const
  EggTexture::FilterType return_value = ((*(const EggTexture*)local_this).get_magfilter)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_magfilter_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.magfilter")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete magfilter attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_magfilter(EggTexture::FilterType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_magfilter)((EggTexture::FilterType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_magfilter(const EggTexture self, int type)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_anisotropic_degree_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_anisotropic_degree()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline int EggTexture::get_anisotropic_degree(void) const
  int return_value = ((*(const EggTexture*)local_this).get_anisotropic_degree)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_anisotropic_degree_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.anisotropic_degree")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete anisotropic_degree attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_anisotropic_degree();
    return 0;
  }
  // 1-inline void EggTexture::set_anisotropic_degree(int anisotropic_degree)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_anisotropic_degree)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_anisotropic_degree(const EggTexture self, int anisotropic_degree)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_env_type_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline EggTexture::EnvType EggTexture::get_env_type(void) const
  EggTexture::EnvType return_value = ((*(const EggTexture*)local_this).get_env_type)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_env_type_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.env_type")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete env_type attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_env_type(EggTexture::EnvType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_env_type)((EggTexture::EnvType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_env_type(const EggTexture self, int type)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_saved_result_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool EggTexture::get_saved_result(void) const
  bool return_value = ((*(const EggTexture*)local_this).get_saved_result)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_saved_result_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.saved_result")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete saved_result attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_saved_result(bool saved_result)
  ((*local_this).set_saved_result)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_saved_result(const EggTexture self, bool saved_result)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_tex_gen_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline EggTexture::TexGen EggTexture::get_tex_gen(void) const
  EggTexture::TexGen return_value = ((*(const EggTexture*)local_this).get_tex_gen)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_tex_gen_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.tex_gen")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete tex_gen attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_tex_gen(EggTexture::TexGen tex_gen)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_tex_gen)((EggTexture::TexGen)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_tex_gen(const EggTexture self, int tex_gen)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_quality_level_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline EggTexture::QualityLevel EggTexture::get_quality_level(void) const
  EggTexture::QualityLevel return_value = ((*(const EggTexture*)local_this).get_quality_level)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_quality_level_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.quality_level")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete quality_level attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_quality_level(EggTexture::QualityLevel quality_level)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_quality_level)((EggTexture::QualityLevel)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_quality_level(const EggTexture self, int quality_level)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_stage_name_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_stage_name()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline std::string const &EggTexture::get_stage_name(void) const
  std::string const &return_value = ((*(const EggTexture*)local_this).get_stage_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_stage_name_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.stage_name")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete stage_name attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_stage_name();
    return 0;
  }
  // 1-inline void EggTexture::set_stage_name(std::string const &stage_name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_stage_name)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_stage_name(const EggTexture self, str stage_name)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_priority_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_priority()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline int EggTexture::get_priority(void) const
  int return_value = ((*(const EggTexture*)local_this).get_priority)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_priority_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.priority")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete priority attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_priority();
    return 0;
  }
  // 1-inline void EggTexture::set_priority(int priority)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_priority)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_priority(const EggTexture self, int priority)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_color_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_color()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LColor const &EggTexture::get_color(void) const
  LColor const *return_value = &(((*(const EggTexture*)local_this).get_color)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static int Dtool_EggTexture_color_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.color")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete color attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_color();
    return 0;
  }
  // 1-inline void EggTexture::set_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggTexture.set_color", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_color)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_color(const EggTexture self, const LVecBase4f color)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_border_color_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_border_color()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LColor const &EggTexture::get_border_color(void) const
  LColor const *return_value = &(((*(const EggTexture*)local_this).get_border_color)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static int Dtool_EggTexture_border_color_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.border_color")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete border_color attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_border_color();
    return 0;
  }
  // 1-inline void EggTexture::set_border_color(LColor const &border_color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggTexture.set_border_color", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_border_color)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_border_color(const EggTexture self, const LVecBase4f border_color)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_uv_name_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_uv_name()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline std::string const &EggTexture::get_uv_name(void) const
  std::string const &return_value = ((*(const EggTexture*)local_this).get_uv_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_uv_name_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.uv_name")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete uv_name attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_uv_name();
    return 0;
  }
  // 1-inline void EggTexture::set_uv_name(std::string const &uv_name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_uv_name)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_uv_name(const EggTexture self, str uv_name)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_rgb_scale_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_rgb_scale()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline int EggTexture::get_rgb_scale(void) const
  int return_value = ((*(const EggTexture*)local_this).get_rgb_scale)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_rgb_scale_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.rgb_scale")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete rgb_scale attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_rgb_scale();
    return 0;
  }
  // 1-inline void EggTexture::set_rgb_scale(int rgb_scale)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_rgb_scale)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_rgb_scale(const EggTexture self, int rgb_scale)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_alpha_scale_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_alpha_scale()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline int EggTexture::get_alpha_scale(void) const
  int return_value = ((*(const EggTexture*)local_this).get_alpha_scale)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_alpha_scale_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.alpha_scale")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete alpha_scale attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_alpha_scale();
    return 0;
  }
  // 1-inline void EggTexture::set_alpha_scale(int alpha_scale)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_alpha_scale)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_alpha_scale(const EggTexture self, int alpha_scale)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_alpha_filename_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_alpha_filename()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline Filename const &EggTexture::get_alpha_filename(void) const
  Filename const *return_value = &(((*(const EggTexture*)local_this).get_alpha_filename)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

static int Dtool_EggTexture_alpha_filename_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.alpha_filename")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete alpha_filename attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_alpha_filename();
    return 0;
  }
  // 1-inline void EggTexture::set_alpha_filename(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggTexture.set_alpha_filename", "Filename");
    return -1;
  }
  ((*local_this).set_alpha_filename)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_alpha_filename(const EggTexture self, const Filename filename)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_alpha_fullpath_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Filename const &EggTexture::get_alpha_fullpath(void) const
  Filename const *return_value = &(((*(const EggTexture*)local_this).get_alpha_fullpath)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

static int Dtool_EggTexture_alpha_fullpath_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.alpha_fullpath")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete alpha_fullpath attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_alpha_fullpath(Filename const &fullpath)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggTexture.set_alpha_fullpath", "Filename");
    return -1;
  }
  ((*local_this).set_alpha_fullpath)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_alpha_fullpath(const EggTexture self, const Filename fullpath)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_alpha_file_channel_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_alpha_file_channel()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline int EggTexture::get_alpha_file_channel(void) const
  int return_value = ((*(const EggTexture*)local_this).get_alpha_file_channel)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_alpha_file_channel_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.alpha_file_channel")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete alpha_file_channel attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_alpha_file_channel();
    return 0;
  }
  // 1-inline void EggTexture::set_alpha_file_channel(int alpha_file_channel)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_alpha_file_channel)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_alpha_file_channel(const EggTexture self, int alpha_file_channel)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_multiview_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool EggTexture::get_multiview(void) const
  bool return_value = ((*(const EggTexture*)local_this).get_multiview)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_multiview_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.multiview")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete multiview attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_multiview(bool multiview)
  ((*local_this).set_multiview)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_multiview(const EggTexture self, bool multiview)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_num_views_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_num_views()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline int EggTexture::get_num_views(void) const
  int return_value = ((*(const EggTexture*)local_this).get_num_views)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_num_views_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.num_views")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete num_views attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_num_views();
    return 0;
  }
  // 1-inline void EggTexture::set_num_views(int num_views)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_num_views)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_num_views(const EggTexture self, int num_views)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_read_mipmaps_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool EggTexture::get_read_mipmaps(void) const
  bool return_value = ((*(const EggTexture*)local_this).get_read_mipmaps)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_read_mipmaps_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.read_mipmaps")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete read_mipmaps attribute");
    return -1;
  }
  // 1-inline void EggTexture::set_read_mipmaps(bool read_mipmaps)
  ((*local_this).set_read_mipmaps)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_read_mipmaps(const EggTexture self, bool read_mipmaps)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_min_lod_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_min_lod()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline double EggTexture::get_min_lod(void) const
  double return_value = ((*(const EggTexture*)local_this).get_min_lod)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_min_lod_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.min_lod")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete min_lod attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_min_lod();
    return 0;
  }
  // 1-inline void EggTexture::set_min_lod(double min_lod)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_min_lod)(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_min_lod(const EggTexture self, double min_lod)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_max_lod_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_max_lod()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline double EggTexture::get_max_lod(void) const
  double return_value = ((*(const EggTexture*)local_this).get_max_lod)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_max_lod_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.max_lod")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete max_lod attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_max_lod();
    return 0;
  }
  // 1-inline void EggTexture::set_max_lod(double max_lod)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_max_lod)(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_max_lod(const EggTexture self, double max_lod)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_lod_bias_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_lod_bias()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline double EggTexture::get_lod_bias(void) const
  double return_value = ((*(const EggTexture*)local_this).get_lod_bias)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggTexture_lod_bias_Setter(PyObject *self, PyObject *arg, void *) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTexture, (void **)&local_this, "EggTexture.lod_bias")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete lod_bias attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_lod_bias();
    return 0;
  }
  // 1-inline void EggTexture::set_lod_bias(double lod_bias)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_lod_bias)(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_lod_bias(const EggTexture self, double lod_bias)\n");
  }
  return -1;
}

static PyObject *Dtool_EggTexture_multitexture_sort_Getter(PyObject *self, void *) {
  const EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int EggTexture::get_multitexture_sort(void) const
  int return_value = ((*(const EggTexture*)local_this).get_multitexture_sort)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * EggTexture::EggTexture(EggTexture const &copy)
 * explicit EggTexture::EggTexture(std::string const &tref_name, Filename const &filename)
 */
static int Dtool_Init_EggTexture(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-EggTexture::EggTexture(EggTexture const &copy)
        EggTexture const *arg_this = (EggTexture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggTexture, 0, "EggTexture.EggTexture", true, true);
        if (arg_this != nullptr) {
          EggTexture *return_value = new EggTexture(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggTexture, true, false);
        }
      }
    }
    break;
  case 2:
    {
      // 1-explicit EggTexture::EggTexture(std::string const &tref_name, Filename const &filename)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      PyObject *param1;
      static const char *keyword_list[] = {"tref_name", "filename", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:EggTexture", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
        Filename param1_local;
        Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param1, 1, "EggTexture.EggTexture", "Filename");
          return -1;
        }
        EggTexture *return_value = new EggTexture(std::string(param0_str, param0_len), *param1_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggTexture, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggTexture() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggTexture(const EggTexture copy)\n"
      "EggTexture(str tref_name, const Filename filename)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggTexture(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggTexture) {
    printf("EggTexture ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggTexture *local_this = (EggTexture *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggTexture) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggFilenameNode) {
    return (EggFilenameNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggFilenameNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggFilenameNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggFilenameNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return (EggRenderMode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggTransform) {
    return (EggTransform *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggFilenameNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggFilenameNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggFilenameNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggFilenameNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggTexture(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggTexture) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggFilenameNode) {
    EggFilenameNode* other_this = (EggFilenameNode*)from_this;
    return (EggTexture*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggTexture*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggTexture*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggTexture*)other_this;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    EggRenderMode* other_this = (EggRenderMode*)from_this;
    return (EggTexture*)other_this;
  }
  if (from_type == Dtool_Ptr_EggTransform) {
    EggTransform* other_this = (EggTransform*)from_this;
    return (EggTexture*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggTexture*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggTexture*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggTexture*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggTexture*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggMaterial
 */
/**
 * Python function wrapper for:
 * bool EggMaterial::is_equivalent_to(EggMaterial const &other, int eq) const
 */
static PyObject *Dtool_EggMaterial_is_equivalent_to_796(PyObject *self, PyObject *args, PyObject *kwds) {
  EggMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggMaterial)) {
    return nullptr;
  }
  // 1-bool EggMaterial::is_equivalent_to(EggMaterial const &other, int eq) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"other", "eq", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:is_equivalent_to", (char **)keyword_list, &param1, &param2)) {
    EggMaterial const *param1_this = (EggMaterial *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_EggMaterial, 1, "EggMaterial.is_equivalent_to", true, true);
    if (param1_this != nullptr) {
      bool return_value = ((*(const EggMaterial*)local_this).is_equivalent_to)(*param1_this, (int)param2);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_equivalent_to(EggMaterial self, const EggMaterial other, int eq)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_is_equivalent_to_796_comment =
  "C++ Interface:\n"
  "is_equivalent_to(EggMaterial self, const EggMaterial other, int eq)\n"
  "\n"
  "/**\n"
  " * Returns true if the two materials are equivalent in all relevant properties\n"
  " * (according to eq), false otherwise.\n"
  " *\n"
  " * The Equivalence parameter, eq, should be set to the bitwise OR of the\n"
  " * following properties, according to what you consider relevant:\n"
  " *\n"
  " * EggMaterial::E_attributes: All material attributes (diff, spec, etc.)\n"
  " * except MRef name.\n"
  " *\n"
  " * EggMaterial::E_mref_name: The MRef name.\n"
  " */";
#else
static const char *Dtool_EggMaterial_is_equivalent_to_796_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggMaterial::sorts_less_than(EggMaterial const &other, int eq) const
 */
static PyObject *Dtool_EggMaterial_sorts_less_than_797(PyObject *self, PyObject *args, PyObject *kwds) {
  EggMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggMaterial)) {
    return nullptr;
  }
  // 1-bool EggMaterial::sorts_less_than(EggMaterial const &other, int eq) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"other", "eq", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:sorts_less_than", (char **)keyword_list, &param1, &param2)) {
    EggMaterial const *param1_this = (EggMaterial *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_EggMaterial, 1, "EggMaterial.sorts_less_than", true, true);
    if (param1_this != nullptr) {
      bool return_value = ((*(const EggMaterial*)local_this).sorts_less_than)(*param1_this, (int)param2);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "sorts_less_than(EggMaterial self, const EggMaterial other, int eq)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_sorts_less_than_797_comment =
  "C++ Interface:\n"
  "sorts_less_than(EggMaterial self, const EggMaterial other, int eq)\n"
  "\n"
  "/**\n"
  " * An ordering operator to compare two materials for sorting order.  This\n"
  " * imposes an arbitrary ordering useful to identify unique materials,\n"
  " * according to the indicated Equivalence factor.  See is_equivalent_to().\n"
  " */";
#else
static const char *Dtool_EggMaterial_sorts_less_than_797_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::set_base(LColor const &base)
 */
static PyObject *Dtool_EggMaterial_set_base_798(PyObject *self, PyObject *arg) {
  EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.set_base")) {
    return nullptr;
  }
  // 1-inline void EggMaterial::set_base(LColor const &base)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggMaterial.set_base", "LVecBase4f");
  }
  ((*local_this).set_base)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_base(const EggMaterial self, const LVecBase4f base)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_set_base_798_comment =
  "C++ Interface:\n"
  "set_base(const EggMaterial self, const LVecBase4f base)\n"
  "\n"
  "/**\n"
  " * @since 1.10.0\n"
  " */";
#else
static const char *Dtool_EggMaterial_set_base_798_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::clear_base(void)
 */
static PyObject *Dtool_EggMaterial_clear_base_799(PyObject *self, PyObject *) {
  EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.clear_base")) {
    return nullptr;
  }
  // 1-inline void EggMaterial::clear_base(void)
  ((*local_this).clear_base)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_clear_base_799_comment =
  "C++ Interface:\n"
  "clear_base(const EggMaterial self)\n"
  "\n"
  "/**\n"
  " * @since 1.10.0\n"
  " */";
#else
static const char *Dtool_EggMaterial_clear_base_799_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggMaterial::has_base(void) const
 */
static PyObject *Dtool_EggMaterial_has_base_800(PyObject *self, PyObject *) {
  EggMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggMaterial)) {
    return nullptr;
  }
  // 1-inline bool EggMaterial::has_base(void) const
  bool return_value = ((*(const EggMaterial*)local_this).has_base)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_has_base_800_comment =
  "C++ Interface:\n"
  "has_base(EggMaterial self)\n"
  "\n"
  "/**\n"
  " * @since 1.10.0\n"
  " */";
#else
static const char *Dtool_EggMaterial_has_base_800_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor EggMaterial::get_base(void) const
 */
static PyObject *Dtool_EggMaterial_get_base_801(PyObject *self, PyObject *) {
  EggMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggMaterial)) {
    return nullptr;
  }
  // 1-inline LColor EggMaterial::get_base(void) const
  LColor *return_value = new LColor(((*(const EggMaterial*)local_this).get_base)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_get_base_801_comment =
  "C++ Interface:\n"
  "get_base(EggMaterial self)\n"
  "\n"
  "/**\n"
  " * It is legal to call this even if has_base() returns false.  If so, it\n"
  " * simply returns the default base color.\n"
  " *\n"
  " * @since 1.10.0\n"
  " */";
#else
static const char *Dtool_EggMaterial_get_base_801_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::set_diff(LColor const &diff)
 */
static PyObject *Dtool_EggMaterial_set_diff_802(PyObject *self, PyObject *arg) {
  EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.set_diff")) {
    return nullptr;
  }
  // 1-inline void EggMaterial::set_diff(LColor const &diff)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggMaterial.set_diff", "LVecBase4f");
  }
  ((*local_this).set_diff)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_diff(const EggMaterial self, const LVecBase4f diff)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_set_diff_802_comment =
  "C++ Interface:\n"
  "set_diff(const EggMaterial self, const LVecBase4f diff)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_set_diff_802_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::clear_diff(void)
 */
static PyObject *Dtool_EggMaterial_clear_diff_803(PyObject *self, PyObject *) {
  EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.clear_diff")) {
    return nullptr;
  }
  // 1-inline void EggMaterial::clear_diff(void)
  ((*local_this).clear_diff)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_clear_diff_803_comment =
  "C++ Interface:\n"
  "clear_diff(const EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_clear_diff_803_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggMaterial::has_diff(void) const
 */
static PyObject *Dtool_EggMaterial_has_diff_804(PyObject *self, PyObject *) {
  EggMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggMaterial)) {
    return nullptr;
  }
  // 1-inline bool EggMaterial::has_diff(void) const
  bool return_value = ((*(const EggMaterial*)local_this).has_diff)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_has_diff_804_comment =
  "C++ Interface:\n"
  "has_diff(EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_has_diff_804_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor EggMaterial::get_diff(void) const
 */
static PyObject *Dtool_EggMaterial_get_diff_805(PyObject *self, PyObject *) {
  EggMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggMaterial)) {
    return nullptr;
  }
  // 1-inline LColor EggMaterial::get_diff(void) const
  LColor *return_value = new LColor(((*(const EggMaterial*)local_this).get_diff)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_get_diff_805_comment =
  "C++ Interface:\n"
  "get_diff(EggMaterial self)\n"
  "\n"
  "/**\n"
  " * It is legal to call this even if has_diff() returns false.  If so, it\n"
  " * simply returns the default diff color.\n"
  " */";
#else
static const char *Dtool_EggMaterial_get_diff_805_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::set_amb(LColor const &amb)
 */
static PyObject *Dtool_EggMaterial_set_amb_806(PyObject *self, PyObject *arg) {
  EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.set_amb")) {
    return nullptr;
  }
  // 1-inline void EggMaterial::set_amb(LColor const &amb)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggMaterial.set_amb", "LVecBase4f");
  }
  ((*local_this).set_amb)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_amb(const EggMaterial self, const LVecBase4f amb)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_set_amb_806_comment =
  "C++ Interface:\n"
  "set_amb(const EggMaterial self, const LVecBase4f amb)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_set_amb_806_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::clear_amb(void)
 */
static PyObject *Dtool_EggMaterial_clear_amb_807(PyObject *self, PyObject *) {
  EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.clear_amb")) {
    return nullptr;
  }
  // 1-inline void EggMaterial::clear_amb(void)
  ((*local_this).clear_amb)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_clear_amb_807_comment =
  "C++ Interface:\n"
  "clear_amb(const EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_clear_amb_807_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggMaterial::has_amb(void) const
 */
static PyObject *Dtool_EggMaterial_has_amb_808(PyObject *self, PyObject *) {
  EggMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggMaterial)) {
    return nullptr;
  }
  // 1-inline bool EggMaterial::has_amb(void) const
  bool return_value = ((*(const EggMaterial*)local_this).has_amb)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_has_amb_808_comment =
  "C++ Interface:\n"
  "has_amb(EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_has_amb_808_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor EggMaterial::get_amb(void) const
 */
static PyObject *Dtool_EggMaterial_get_amb_809(PyObject *self, PyObject *) {
  EggMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggMaterial)) {
    return nullptr;
  }
  // 1-inline LColor EggMaterial::get_amb(void) const
  LColor *return_value = new LColor(((*(const EggMaterial*)local_this).get_amb)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_get_amb_809_comment =
  "C++ Interface:\n"
  "get_amb(EggMaterial self)\n"
  "\n"
  "/**\n"
  " * It is legal to call this even if has_amb() returns false.  If so, it simply\n"
  " * returns the default amb color.\n"
  " */";
#else
static const char *Dtool_EggMaterial_get_amb_809_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::set_emit(LColor const &emit)
 */
static PyObject *Dtool_EggMaterial_set_emit_810(PyObject *self, PyObject *arg) {
  EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.set_emit")) {
    return nullptr;
  }
  // 1-inline void EggMaterial::set_emit(LColor const &emit)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggMaterial.set_emit", "LVecBase4f");
  }
  ((*local_this).set_emit)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_emit(const EggMaterial self, const LVecBase4f emit)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_set_emit_810_comment =
  "C++ Interface:\n"
  "set_emit(const EggMaterial self, const LVecBase4f emit)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_set_emit_810_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::clear_emit(void)
 */
static PyObject *Dtool_EggMaterial_clear_emit_811(PyObject *self, PyObject *) {
  EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.clear_emit")) {
    return nullptr;
  }
  // 1-inline void EggMaterial::clear_emit(void)
  ((*local_this).clear_emit)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_clear_emit_811_comment =
  "C++ Interface:\n"
  "clear_emit(const EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_clear_emit_811_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggMaterial::has_emit(void) const
 */
static PyObject *Dtool_EggMaterial_has_emit_812(PyObject *self, PyObject *) {
  EggMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggMaterial)) {
    return nullptr;
  }
  // 1-inline bool EggMaterial::has_emit(void) const
  bool return_value = ((*(const EggMaterial*)local_this).has_emit)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_has_emit_812_comment =
  "C++ Interface:\n"
  "has_emit(EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_has_emit_812_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor EggMaterial::get_emit(void) const
 */
static PyObject *Dtool_EggMaterial_get_emit_813(PyObject *self, PyObject *) {
  EggMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggMaterial)) {
    return nullptr;
  }
  // 1-inline LColor EggMaterial::get_emit(void) const
  LColor *return_value = new LColor(((*(const EggMaterial*)local_this).get_emit)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_get_emit_813_comment =
  "C++ Interface:\n"
  "get_emit(EggMaterial self)\n"
  "\n"
  "/**\n"
  " * It is legal to call this even if has_emit() returns false.  If so, it\n"
  " * simply returns the default emit color.\n"
  " */";
#else
static const char *Dtool_EggMaterial_get_emit_813_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::set_spec(LColor const &spec)
 */
static PyObject *Dtool_EggMaterial_set_spec_814(PyObject *self, PyObject *arg) {
  EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.set_spec")) {
    return nullptr;
  }
  // 1-inline void EggMaterial::set_spec(LColor const &spec)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggMaterial.set_spec", "LVecBase4f");
  }
  ((*local_this).set_spec)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_spec(const EggMaterial self, const LVecBase4f spec)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_set_spec_814_comment =
  "C++ Interface:\n"
  "set_spec(const EggMaterial self, const LVecBase4f spec)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_set_spec_814_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::clear_spec(void)
 */
static PyObject *Dtool_EggMaterial_clear_spec_815(PyObject *self, PyObject *) {
  EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.clear_spec")) {
    return nullptr;
  }
  // 1-inline void EggMaterial::clear_spec(void)
  ((*local_this).clear_spec)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_clear_spec_815_comment =
  "C++ Interface:\n"
  "clear_spec(const EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_clear_spec_815_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggMaterial::has_spec(void) const
 */
static PyObject *Dtool_EggMaterial_has_spec_816(PyObject *self, PyObject *) {
  EggMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggMaterial)) {
    return nullptr;
  }
  // 1-inline bool EggMaterial::has_spec(void) const
  bool return_value = ((*(const EggMaterial*)local_this).has_spec)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_has_spec_816_comment =
  "C++ Interface:\n"
  "has_spec(EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_has_spec_816_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor EggMaterial::get_spec(void) const
 */
static PyObject *Dtool_EggMaterial_get_spec_817(PyObject *self, PyObject *) {
  EggMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggMaterial)) {
    return nullptr;
  }
  // 1-inline LColor EggMaterial::get_spec(void) const
  LColor *return_value = new LColor(((*(const EggMaterial*)local_this).get_spec)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_get_spec_817_comment =
  "C++ Interface:\n"
  "get_spec(EggMaterial self)\n"
  "\n"
  "/**\n"
  " * It is legal to call this even if has_spec() returns false.  If so, it\n"
  " * simply returns the default spec color.\n"
  " */";
#else
static const char *Dtool_EggMaterial_get_spec_817_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::set_shininess(double shininess)
 */
static PyObject *Dtool_EggMaterial_set_shininess_818(PyObject *self, PyObject *arg) {
  EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.set_shininess")) {
    return nullptr;
  }
  // 1-inline void EggMaterial::set_shininess(double shininess)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_shininess)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shininess(const EggMaterial self, double shininess)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_set_shininess_818_comment =
  "C++ Interface:\n"
  "set_shininess(const EggMaterial self, double shininess)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_set_shininess_818_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::clear_shininess(void)
 */
static PyObject *Dtool_EggMaterial_clear_shininess_819(PyObject *self, PyObject *) {
  EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.clear_shininess")) {
    return nullptr;
  }
  // 1-inline void EggMaterial::clear_shininess(void)
  ((*local_this).clear_shininess)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_clear_shininess_819_comment =
  "C++ Interface:\n"
  "clear_shininess(const EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_clear_shininess_819_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggMaterial::has_shininess(void) const
 */
static PyObject *Dtool_EggMaterial_has_shininess_820(PyObject *self, PyObject *) {
  EggMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggMaterial)) {
    return nullptr;
  }
  // 1-inline bool EggMaterial::has_shininess(void) const
  bool return_value = ((*(const EggMaterial*)local_this).has_shininess)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_has_shininess_820_comment =
  "C++ Interface:\n"
  "has_shininess(EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_has_shininess_820_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double EggMaterial::get_shininess(void) const
 */
static PyObject *Dtool_EggMaterial_get_shininess_821(PyObject *self, PyObject *) {
  EggMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggMaterial)) {
    return nullptr;
  }
  // 1-inline double EggMaterial::get_shininess(void) const
  double return_value = ((*(const EggMaterial*)local_this).get_shininess)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_get_shininess_821_comment =
  "C++ Interface:\n"
  "get_shininess(EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_get_shininess_821_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::set_roughness(double roughness)
 */
static PyObject *Dtool_EggMaterial_set_roughness_822(PyObject *self, PyObject *arg) {
  EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.set_roughness")) {
    return nullptr;
  }
  // 1-inline void EggMaterial::set_roughness(double roughness)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_roughness)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_roughness(const EggMaterial self, double roughness)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_set_roughness_822_comment =
  "C++ Interface:\n"
  "set_roughness(const EggMaterial self, double roughness)\n"
  "\n"
  "/**\n"
  " * @since 1.10.0\n"
  " */";
#else
static const char *Dtool_EggMaterial_set_roughness_822_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::clear_roughness(void)
 */
static PyObject *Dtool_EggMaterial_clear_roughness_823(PyObject *self, PyObject *) {
  EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.clear_roughness")) {
    return nullptr;
  }
  // 1-inline void EggMaterial::clear_roughness(void)
  ((*local_this).clear_roughness)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_clear_roughness_823_comment =
  "C++ Interface:\n"
  "clear_roughness(const EggMaterial self)\n"
  "\n"
  "/**\n"
  " * @since 1.10.0\n"
  " */";
#else
static const char *Dtool_EggMaterial_clear_roughness_823_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggMaterial::has_roughness(void) const
 */
static PyObject *Dtool_EggMaterial_has_roughness_824(PyObject *self, PyObject *) {
  EggMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggMaterial)) {
    return nullptr;
  }
  // 1-inline bool EggMaterial::has_roughness(void) const
  bool return_value = ((*(const EggMaterial*)local_this).has_roughness)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_has_roughness_824_comment =
  "C++ Interface:\n"
  "has_roughness(EggMaterial self)\n"
  "\n"
  "/**\n"
  " * @since 1.10.0\n"
  " */";
#else
static const char *Dtool_EggMaterial_has_roughness_824_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double EggMaterial::get_roughness(void) const
 */
static PyObject *Dtool_EggMaterial_get_roughness_825(PyObject *self, PyObject *) {
  EggMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggMaterial)) {
    return nullptr;
  }
  // 1-inline double EggMaterial::get_roughness(void) const
  double return_value = ((*(const EggMaterial*)local_this).get_roughness)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_get_roughness_825_comment =
  "C++ Interface:\n"
  "get_roughness(EggMaterial self)\n"
  "\n"
  "/**\n"
  " * @since 1.10.0\n"
  " */";
#else
static const char *Dtool_EggMaterial_get_roughness_825_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::set_metallic(double metallic)
 */
static PyObject *Dtool_EggMaterial_set_metallic_826(PyObject *self, PyObject *arg) {
  EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.set_metallic")) {
    return nullptr;
  }
  // 1-inline void EggMaterial::set_metallic(double metallic)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_metallic)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_metallic(const EggMaterial self, double metallic)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_set_metallic_826_comment =
  "C++ Interface:\n"
  "set_metallic(const EggMaterial self, double metallic)\n"
  "\n"
  "/**\n"
  " * @since 1.10.0\n"
  " */";
#else
static const char *Dtool_EggMaterial_set_metallic_826_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::clear_metallic(void)
 */
static PyObject *Dtool_EggMaterial_clear_metallic_827(PyObject *self, PyObject *) {
  EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.clear_metallic")) {
    return nullptr;
  }
  // 1-inline void EggMaterial::clear_metallic(void)
  ((*local_this).clear_metallic)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_clear_metallic_827_comment =
  "C++ Interface:\n"
  "clear_metallic(const EggMaterial self)\n"
  "\n"
  "/**\n"
  " * @since 1.10.0\n"
  " */";
#else
static const char *Dtool_EggMaterial_clear_metallic_827_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggMaterial::has_metallic(void) const
 */
static PyObject *Dtool_EggMaterial_has_metallic_828(PyObject *self, PyObject *) {
  EggMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggMaterial)) {
    return nullptr;
  }
  // 1-inline bool EggMaterial::has_metallic(void) const
  bool return_value = ((*(const EggMaterial*)local_this).has_metallic)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_has_metallic_828_comment =
  "C++ Interface:\n"
  "has_metallic(EggMaterial self)\n"
  "\n"
  "/**\n"
  " * @since 1.10.0\n"
  " */";
#else
static const char *Dtool_EggMaterial_has_metallic_828_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double EggMaterial::get_metallic(void) const
 */
static PyObject *Dtool_EggMaterial_get_metallic_829(PyObject *self, PyObject *) {
  EggMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggMaterial)) {
    return nullptr;
  }
  // 1-inline double EggMaterial::get_metallic(void) const
  double return_value = ((*(const EggMaterial*)local_this).get_metallic)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_get_metallic_829_comment =
  "C++ Interface:\n"
  "get_metallic(EggMaterial self)\n"
  "\n"
  "/**\n"
  " * @since 1.10.0\n"
  " */";
#else
static const char *Dtool_EggMaterial_get_metallic_829_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::set_ior(double ior)
 */
static PyObject *Dtool_EggMaterial_set_ior_830(PyObject *self, PyObject *arg) {
  EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.set_ior")) {
    return nullptr;
  }
  // 1-inline void EggMaterial::set_ior(double ior)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_ior)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_ior(const EggMaterial self, double ior)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_set_ior_830_comment =
  "C++ Interface:\n"
  "set_ior(const EggMaterial self, double ior)\n"
  "\n"
  "/**\n"
  " * @since 1.10.0\n"
  " */";
#else
static const char *Dtool_EggMaterial_set_ior_830_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::clear_ior(void)
 */
static PyObject *Dtool_EggMaterial_clear_ior_831(PyObject *self, PyObject *) {
  EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.clear_ior")) {
    return nullptr;
  }
  // 1-inline void EggMaterial::clear_ior(void)
  ((*local_this).clear_ior)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_clear_ior_831_comment =
  "C++ Interface:\n"
  "clear_ior(const EggMaterial self)\n"
  "\n"
  "/**\n"
  " * @since 1.10.0\n"
  " */";
#else
static const char *Dtool_EggMaterial_clear_ior_831_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggMaterial::has_ior(void) const
 */
static PyObject *Dtool_EggMaterial_has_ior_832(PyObject *self, PyObject *) {
  EggMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggMaterial)) {
    return nullptr;
  }
  // 1-inline bool EggMaterial::has_ior(void) const
  bool return_value = ((*(const EggMaterial*)local_this).has_ior)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_has_ior_832_comment =
  "C++ Interface:\n"
  "has_ior(EggMaterial self)\n"
  "\n"
  "/**\n"
  " * @since 1.10.0\n"
  " */";
#else
static const char *Dtool_EggMaterial_has_ior_832_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double EggMaterial::get_ior(void) const
 */
static PyObject *Dtool_EggMaterial_get_ior_833(PyObject *self, PyObject *) {
  EggMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggMaterial)) {
    return nullptr;
  }
  // 1-inline double EggMaterial::get_ior(void) const
  double return_value = ((*(const EggMaterial*)local_this).get_ior)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_get_ior_833_comment =
  "C++ Interface:\n"
  "get_ior(EggMaterial self)\n"
  "\n"
  "/**\n"
  " * @since 1.10.0\n"
  " */";
#else
static const char *Dtool_EggMaterial_get_ior_833_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::set_local(bool local)
 */
static PyObject *Dtool_EggMaterial_set_local_834(PyObject *self, PyObject *arg) {
  EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.set_local")) {
    return nullptr;
  }
  // 1-inline void EggMaterial::set_local(bool local)
  ((*local_this).set_local)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_local(const EggMaterial self, bool local)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_set_local_834_comment =
  "C++ Interface:\n"
  "set_local(const EggMaterial self, bool local)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_set_local_834_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggMaterial::clear_local(void)
 */
static PyObject *Dtool_EggMaterial_clear_local_835(PyObject *self, PyObject *) {
  EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.clear_local")) {
    return nullptr;
  }
  // 1-inline void EggMaterial::clear_local(void)
  ((*local_this).clear_local)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_clear_local_835_comment =
  "C++ Interface:\n"
  "clear_local(const EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_clear_local_835_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggMaterial::has_local(void) const
 */
static PyObject *Dtool_EggMaterial_has_local_836(PyObject *self, PyObject *) {
  EggMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggMaterial)) {
    return nullptr;
  }
  // 1-inline bool EggMaterial::has_local(void) const
  bool return_value = ((*(const EggMaterial*)local_this).has_local)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_has_local_836_comment =
  "C++ Interface:\n"
  "has_local(EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_has_local_836_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggMaterial::get_local(void) const
 */
static PyObject *Dtool_EggMaterial_get_local_837(PyObject *self, PyObject *) {
  EggMaterial *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggMaterial)) {
    return nullptr;
  }
  // 1-inline bool EggMaterial::get_local(void) const
  bool return_value = ((*(const EggMaterial*)local_this).get_local)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_get_local_837_comment =
  "C++ Interface:\n"
  "get_local(EggMaterial self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterial_get_local_837_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggMaterial::get_class_type(void)
 */
static PyObject *Dtool_EggMaterial_get_class_type_848(PyObject *, PyObject *) {
  // 1-static TypeHandle EggMaterial::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggMaterial::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggMaterial_get_class_type_848_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggMaterial_get_class_type_848_comment = nullptr;
#endif

static PyObject *Dtool_EggMaterial_base_Getter(PyObject *self, void *) {
  const EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_base()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LColor EggMaterial::get_base(void) const
  LColor *return_value = new LColor(((*(const EggMaterial*)local_this).get_base)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

static int Dtool_EggMaterial_base_Setter(PyObject *self, PyObject *arg, void *) {
  EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.base")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete base attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_base();
    return 0;
  }
  // 1-inline void EggMaterial::set_base(LColor const &base)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggMaterial.set_base", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_base)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_base(const EggMaterial self, const LVecBase4f base)\n");
  }
  return -1;
}

static PyObject *Dtool_EggMaterial_diff_Getter(PyObject *self, void *) {
  const EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_diff()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LColor EggMaterial::get_diff(void) const
  LColor *return_value = new LColor(((*(const EggMaterial*)local_this).get_diff)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

static int Dtool_EggMaterial_diff_Setter(PyObject *self, PyObject *arg, void *) {
  EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.diff")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete diff attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_diff();
    return 0;
  }
  // 1-inline void EggMaterial::set_diff(LColor const &diff)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggMaterial.set_diff", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_diff)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_diff(const EggMaterial self, const LVecBase4f diff)\n");
  }
  return -1;
}

static PyObject *Dtool_EggMaterial_amb_Getter(PyObject *self, void *) {
  const EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_amb()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LColor EggMaterial::get_amb(void) const
  LColor *return_value = new LColor(((*(const EggMaterial*)local_this).get_amb)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

static int Dtool_EggMaterial_amb_Setter(PyObject *self, PyObject *arg, void *) {
  EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.amb")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete amb attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_amb();
    return 0;
  }
  // 1-inline void EggMaterial::set_amb(LColor const &amb)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggMaterial.set_amb", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_amb)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_amb(const EggMaterial self, const LVecBase4f amb)\n");
  }
  return -1;
}

static PyObject *Dtool_EggMaterial_emit_Getter(PyObject *self, void *) {
  const EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_emit()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LColor EggMaterial::get_emit(void) const
  LColor *return_value = new LColor(((*(const EggMaterial*)local_this).get_emit)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

static int Dtool_EggMaterial_emit_Setter(PyObject *self, PyObject *arg, void *) {
  EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.emit")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete emit attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_emit();
    return 0;
  }
  // 1-inline void EggMaterial::set_emit(LColor const &emit)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggMaterial.set_emit", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_emit)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_emit(const EggMaterial self, const LVecBase4f emit)\n");
  }
  return -1;
}

static PyObject *Dtool_EggMaterial_spec_Getter(PyObject *self, void *) {
  const EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_spec()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LColor EggMaterial::get_spec(void) const
  LColor *return_value = new LColor(((*(const EggMaterial*)local_this).get_spec)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

static int Dtool_EggMaterial_spec_Setter(PyObject *self, PyObject *arg, void *) {
  EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.spec")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete spec attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_spec();
    return 0;
  }
  // 1-inline void EggMaterial::set_spec(LColor const &spec)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggMaterial.set_spec", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_spec)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_spec(const EggMaterial self, const LVecBase4f spec)\n");
  }
  return -1;
}

static PyObject *Dtool_EggMaterial_shininess_Getter(PyObject *self, void *) {
  const EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_shininess()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline double EggMaterial::get_shininess(void) const
  double return_value = ((*(const EggMaterial*)local_this).get_shininess)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggMaterial_shininess_Setter(PyObject *self, PyObject *arg, void *) {
  EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.shininess")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete shininess attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_shininess();
    return 0;
  }
  // 1-inline void EggMaterial::set_shininess(double shininess)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_shininess)(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_shininess(const EggMaterial self, double shininess)\n");
  }
  return -1;
}

static PyObject *Dtool_EggMaterial_roughness_Getter(PyObject *self, void *) {
  const EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_roughness()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline double EggMaterial::get_roughness(void) const
  double return_value = ((*(const EggMaterial*)local_this).get_roughness)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggMaterial_roughness_Setter(PyObject *self, PyObject *arg, void *) {
  EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.roughness")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete roughness attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_roughness();
    return 0;
  }
  // 1-inline void EggMaterial::set_roughness(double roughness)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_roughness)(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_roughness(const EggMaterial self, double roughness)\n");
  }
  return -1;
}

static PyObject *Dtool_EggMaterial_metallic_Getter(PyObject *self, void *) {
  const EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_metallic()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline double EggMaterial::get_metallic(void) const
  double return_value = ((*(const EggMaterial*)local_this).get_metallic)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggMaterial_metallic_Setter(PyObject *self, PyObject *arg, void *) {
  EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.metallic")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete metallic attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_metallic();
    return 0;
  }
  // 1-inline void EggMaterial::set_metallic(double metallic)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_metallic)(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_metallic(const EggMaterial self, double metallic)\n");
  }
  return -1;
}

static PyObject *Dtool_EggMaterial_ior_Getter(PyObject *self, void *) {
  const EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_ior()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline double EggMaterial::get_ior(void) const
  double return_value = ((*(const EggMaterial*)local_this).get_ior)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggMaterial_ior_Setter(PyObject *self, PyObject *arg, void *) {
  EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.ior")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete ior attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_ior();
    return 0;
  }
  // 1-inline void EggMaterial::set_ior(double ior)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_ior)(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_ior(const EggMaterial self, double ior)\n");
  }
  return -1;
}

static PyObject *Dtool_EggMaterial_local_Getter(PyObject *self, void *) {
  const EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggMaterial, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_local()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline bool EggMaterial::get_local(void) const
  bool return_value = ((*(const EggMaterial*)local_this).get_local)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggMaterial_local_Setter(PyObject *self, PyObject *arg, void *) {
  EggMaterial *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterial, (void **)&local_this, "EggMaterial.local")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete local attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_local();
    return 0;
  }
  // 1-inline void EggMaterial::set_local(bool local)
  ((*local_this).set_local)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_local(const EggMaterial self, bool local)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * EggMaterial::EggMaterial(EggMaterial const &copy)
 * explicit EggMaterial::EggMaterial(std::string const &mref_name)
 */
static int Dtool_Init_EggMaterial(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "EggMaterial() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 EggMaterial::EggMaterial(EggMaterial const &copy)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
      EggMaterial const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_EggMaterial);
      if (param0_this != nullptr) {
        EggMaterial *return_value = new EggMaterial(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggMaterial, true, false);
      }
    }
  }

  {
    // -2 explicit EggMaterial::EggMaterial(std::string const &mref_name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"mref_name", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:EggMaterial", (char **)keyword_list, &param0_str, &param0_len)) {
      EggMaterial *return_value = new EggMaterial(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggMaterial, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: EggMaterial::EggMaterial(EggMaterial const &copy)
  // No coercion possible: explicit EggMaterial::EggMaterial(std::string const &mref_name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggMaterial(const EggMaterial copy)\n"
      "EggMaterial(str mref_name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggMaterial(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggMaterial) {
    printf("EggMaterial ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggMaterial *local_this = (EggMaterial *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggMaterial) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggMaterial(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggMaterial) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggMaterial*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggMaterial*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggMaterial*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggMaterial*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggMaterial*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggMaterial*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggMaterial*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggPrimitive
 */
/**
 * Python function wrapper for:
 * inline void EggPrimitive::operator =(EggPrimitive const &copy)
 */
static PyObject *Dtool_EggPrimitive_operator_858(PyObject *self, PyObject *arg) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.assign")) {
    return nullptr;
  }
  // 1-inline void EggPrimitive::operator =(EggPrimitive const &copy)
  EggPrimitive const *arg_this = (EggPrimitive *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggPrimitive, 1, "EggPrimitive.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggPrimitive *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggPrimitive, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggPrimitive self, const EggPrimitive copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_operator_858_comment =
  "C++ Interface:\n"
  "assign(const EggPrimitive self, const EggPrimitive copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggPrimitive_operator_858_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual EggPrimitive *EggPrimitive::make_copy(void) const = 0
 */
static PyObject *Dtool_EggPrimitive_make_copy_860(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggPrimitive)) {
    return nullptr;
  }
  // 1-virtual EggPrimitive *EggPrimitive::make_copy(void) const = 0
  EggPrimitive *return_value = ((*(const EggPrimitive*)local_this).make_copy)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggPrimitive, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_make_copy_860_comment =
  "C++ Interface:\n"
  "make_copy(EggPrimitive self)\n";
#else
static const char *Dtool_EggPrimitive_make_copy_860_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggPrimitive::determine_alpha_mode(void)
 */
static PyObject *Dtool_EggPrimitive_determine_alpha_mode_861(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.determine_alpha_mode")) {
    return nullptr;
  }
  // 1-virtual EggRenderMode *EggPrimitive::determine_alpha_mode(void)
  EggRenderMode *return_value = ((*local_this).determine_alpha_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_determine_alpha_mode_861_comment =
  "C++ Interface:\n"
  "determine_alpha_mode(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this primitive that has an\n"
  " * alpha_mode other than AM_unspecified.  Returns a valid EggRenderMode\n"
  " * pointer if one is found, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_determine_alpha_mode_861_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggPrimitive::determine_depth_write_mode(void)
 */
static PyObject *Dtool_EggPrimitive_determine_depth_write_mode_862(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.determine_depth_write_mode")) {
    return nullptr;
  }
  // 1-virtual EggRenderMode *EggPrimitive::determine_depth_write_mode(void)
  EggRenderMode *return_value = ((*local_this).determine_depth_write_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_determine_depth_write_mode_862_comment =
  "C++ Interface:\n"
  "determine_depth_write_mode(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this node that has a\n"
  " * depth_write_mode other than DWM_unspecified.  Returns a valid EggRenderMode\n"
  " * pointer if one is found, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_determine_depth_write_mode_862_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggPrimitive::determine_depth_test_mode(void)
 */
static PyObject *Dtool_EggPrimitive_determine_depth_test_mode_863(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.determine_depth_test_mode")) {
    return nullptr;
  }
  // 1-virtual EggRenderMode *EggPrimitive::determine_depth_test_mode(void)
  EggRenderMode *return_value = ((*local_this).determine_depth_test_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_determine_depth_test_mode_863_comment =
  "C++ Interface:\n"
  "determine_depth_test_mode(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this node that has a\n"
  " * depth_test_mode other than DTM_unspecified.  Returns a valid EggRenderMode\n"
  " * pointer if one is found, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_determine_depth_test_mode_863_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggPrimitive::determine_visibility_mode(void)
 */
static PyObject *Dtool_EggPrimitive_determine_visibility_mode_864(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.determine_visibility_mode")) {
    return nullptr;
  }
  // 1-virtual EggRenderMode *EggPrimitive::determine_visibility_mode(void)
  EggRenderMode *return_value = ((*local_this).determine_visibility_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_determine_visibility_mode_864_comment =
  "C++ Interface:\n"
  "determine_visibility_mode(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this node that has a\n"
  " * visibility_mode other than VM_unspecified.  Returns a valid EggRenderMode\n"
  " * pointer if one is found, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_determine_visibility_mode_864_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggPrimitive::determine_depth_offset(void)
 */
static PyObject *Dtool_EggPrimitive_determine_depth_offset_865(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.determine_depth_offset")) {
    return nullptr;
  }
  // 1-virtual EggRenderMode *EggPrimitive::determine_depth_offset(void)
  EggRenderMode *return_value = ((*local_this).determine_depth_offset)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_determine_depth_offset_865_comment =
  "C++ Interface:\n"
  "determine_depth_offset(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this primitive that has a\n"
  " * depth_offset specified.  Returns a valid EggRenderMode pointer if one is\n"
  " * found, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_determine_depth_offset_865_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggPrimitive::determine_draw_order(void)
 */
static PyObject *Dtool_EggPrimitive_determine_draw_order_866(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.determine_draw_order")) {
    return nullptr;
  }
  // 1-virtual EggRenderMode *EggPrimitive::determine_draw_order(void)
  EggRenderMode *return_value = ((*local_this).determine_draw_order)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_determine_draw_order_866_comment =
  "C++ Interface:\n"
  "determine_draw_order(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this primitive that has a\n"
  " * draw_order specified.  Returns a valid EggRenderMode pointer if one is\n"
  " * found, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_determine_draw_order_866_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual EggRenderMode *EggPrimitive::determine_bin(void)
 */
static PyObject *Dtool_EggPrimitive_determine_bin_867(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.determine_bin")) {
    return nullptr;
  }
  // 1-virtual EggRenderMode *EggPrimitive::determine_bin(void)
  EggRenderMode *return_value = ((*local_this).determine_bin)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_determine_bin_867_comment =
  "C++ Interface:\n"
  "determine_bin(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Walks back up the hierarchy, looking for an EggGroup or EggPrimitive or\n"
  " * some such object at this level or above this primitive that has a bin\n"
  " * specified.  Returns a valid EggRenderMode pointer if one is found, or NULL\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_determine_bin_867_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string EggPrimitive::get_sort_name(void) const
 */
static PyObject *Dtool_EggPrimitive_get_sort_name_868(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggPrimitive)) {
    return nullptr;
  }
  // 1-inline std::string EggPrimitive::get_sort_name(void) const
  std::string return_value = ((*(const EggPrimitive*)local_this).get_sort_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_get_sort_name_868_comment =
  "C++ Interface:\n"
  "get_sort_name(EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the primitive for the purposes of sorting primitives\n"
  " * into different groups, if there is one.\n"
  " *\n"
  " * Presently, this is defined as the primitive name itself, unless it begins\n"
  " * with a digit.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_get_sort_name_868_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual EggPrimitive::Shading EggPrimitive::get_shading(void) const
 */
static PyObject *Dtool_EggPrimitive_get_shading_869(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggPrimitive)) {
    return nullptr;
  }
  // 1-virtual EggPrimitive::Shading EggPrimitive::get_shading(void) const
  EggPrimitive::Shading return_value = ((*(const EggPrimitive*)local_this).get_shading)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_get_shading_869_comment =
  "C++ Interface:\n"
  "get_shading(EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns the shading properties apparent on this particular primitive.  This\n"
  " * returns S_per_vertex if the vertices have colors or normals (and they are\n"
  " * not all the same values), or for a simple primitive, S_overall otherwise.\n"
  " * A composite primitive may also return S_per_face if the individual\n"
  " * component primitives have colors or normals that are not all the same\n"
  " * values.\n"
  " *\n"
  " * To get the most accurate results, you should call clear_shading() on all\n"
  " * connected primitives (or on all primitives in the egg file), followed by\n"
  " * get_shading() on each primitive.  You may find it easiest to call these\n"
  " * methods on the EggData root node (they are defined on EggGroupNode).\n"
  " */";
#else
static const char *Dtool_EggPrimitive_get_shading_869_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggPrimitive::clear_connected_shading(void)
 */
static PyObject *Dtool_EggPrimitive_clear_connected_shading_870(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.clear_connected_shading")) {
    return nullptr;
  }
  // 1-inline void EggPrimitive::clear_connected_shading(void)
  ((*local_this).clear_connected_shading)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_clear_connected_shading_870_comment =
  "C++ Interface:\n"
  "clear_connected_shading(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Resets the connected_shading member in this primitive, so that\n"
  " * get_connected_shading() will recompute a new value.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_clear_connected_shading_870_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggPrimitive::Shading EggPrimitive::get_connected_shading(void) const
 */
static PyObject *Dtool_EggPrimitive_get_connected_shading_871(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggPrimitive)) {
    return nullptr;
  }
  // 1-inline EggPrimitive::Shading EggPrimitive::get_connected_shading(void) const
  EggPrimitive::Shading return_value = ((*(const EggPrimitive*)local_this).get_connected_shading)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_get_connected_shading_871_comment =
  "C++ Interface:\n"
  "get_connected_shading(EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Determines what sort of shading properties this primitive's connected\n"
  " * neighbors have.\n"
  " *\n"
  " * To get the most accurate results, you should first call\n"
  " * clear_connected_shading() on all connected primitives (or on all primitives\n"
  " * in the egg file). It might also be a good idea to call\n"
  " * remove_unused_vertices() to ensure proper connectivity.\n"
  " *\n"
  " * You may find it easiest to call these other methods on the EggData root\n"
  " * node (they are defined on EggGroupNode).\n"
  " */";
#else
static const char *Dtool_EggPrimitive_get_connected_shading_871_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggPrimitive::set_texture(EggTexture *texture)
 */
static PyObject *Dtool_EggPrimitive_set_texture_872(PyObject *self, PyObject *arg) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.set_texture")) {
    return nullptr;
  }
  // 1-inline void EggPrimitive::set_texture(EggTexture *texture)
  EggTexture *arg_this = (EggTexture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggTexture, 1, "EggPrimitive.set_texture", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_texture)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_texture(const EggPrimitive self, EggTexture texture)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_set_texture_872_comment =
  "C++ Interface:\n"
  "set_texture(const EggPrimitive self, EggTexture texture)\n"
  "\n"
  "/**\n"
  " * Replaces the current list of textures with the indicated texture.\n"
  " *\n"
  " * @deprecated This method is used in support of single-texturing only.\n"
  " * Please use the multitexture variant add_texture instead.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_set_texture_872_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggPrimitive::has_texture(void) const
 * inline bool EggPrimitive::has_texture(EggTexture *texture) const
 */
static PyObject *Dtool_EggPrimitive_has_texture_873(PyObject *self, PyObject *args) {
  EggPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggPrimitive)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline bool EggPrimitive::has_texture(void) const
      bool return_value = ((*(const EggPrimitive*)local_this).has_texture)();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline bool EggPrimitive::has_texture(EggTexture *texture) const
      EggTexture *arg_this = (EggTexture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggTexture, 1, "EggPrimitive.has_texture", false, true);
      if (arg_this != nullptr) {
        bool return_value = ((*(const EggPrimitive*)local_this).has_texture)(arg_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "has_texture() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_texture(EggPrimitive self)\n"
      "has_texture(EggPrimitive self, EggTexture texture)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_has_texture_873_comment =
  "C++ Interface:\n"
  "has_texture(EggPrimitive self)\n"
  "has_texture(EggPrimitive self, EggTexture texture)\n"
  "\n"
  "/**\n"
  " * Returns true if the primitive has any textures specified, false otherwise.\n"
  " *\n"
  " * @deprecated This method is used in support of single-texturing only.\n"
  " * New code should be written to use the multitexture variants instead.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if the primitive has the particular indicated texture, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_has_texture_873_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggTexture *EggPrimitive::get_texture(void) const
 * inline EggTexture *EggPrimitive::get_texture(int n) const
 */
static PyObject *Dtool_EggPrimitive_get_texture_874(PyObject *self, PyObject *args) {
  EggPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggPrimitive)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline EggTexture *EggPrimitive::get_texture(void) const
      EggTexture *return_value = ((*(const EggPrimitive*)local_this).get_texture)();
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggTexture, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline EggTexture *EggPrimitive::get_texture(int n) const
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        EggTexture *return_value = ((*(const EggPrimitive*)local_this).get_texture)((int)arg_val);
        if (return_value != nullptr) {
          return_value->ref();
        }
        if (Dtool_CheckErrorOccurred()) {
          if (return_value != nullptr) {
            unref_delete(return_value);
          }
          return nullptr;
        }
        if (return_value == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggTexture, true, false, return_value->as_typed_object()->get_type_index());
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_texture() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_texture(EggPrimitive self)\n"
      "get_texture(EggPrimitive self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_get_texture_874_comment =
  "C++ Interface:\n"
  "get_texture(EggPrimitive self)\n"
  "get_texture(EggPrimitive self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the first texture on the primitive, if any, or NULL if there are no\n"
  " * textures on the primitive.\n"
  " *\n"
  " * @deprecated This method is used in support of single-texturing only.\n"
  " * New code should be written to use the multitexture variants instead.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the nth texture that has been applied to the primitive.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_get_texture_874_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggPrimitive::add_texture(EggTexture *texture)
 */
static PyObject *Dtool_EggPrimitive_add_texture_875(PyObject *self, PyObject *arg) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.add_texture")) {
    return nullptr;
  }
  // 1-inline void EggPrimitive::add_texture(EggTexture *texture)
  EggTexture *arg_this = (EggTexture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggTexture, 1, "EggPrimitive.add_texture", false, true);
  if (arg_this != nullptr) {
    ((*local_this).add_texture)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_texture(const EggPrimitive self, EggTexture texture)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_add_texture_875_comment =
  "C++ Interface:\n"
  "add_texture(const EggPrimitive self, EggTexture texture)\n"
  "\n"
  "/**\n"
  " * Applies the indicated texture to the primitive.\n"
  " *\n"
  " * Note that, in the case of multiple textures being applied to a single\n"
  " * primitive, the order in which the textures are applied does not affect the\n"
  " * rendering order; use EggTexture::set_sort() to specify that.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_add_texture_875_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggPrimitive::clear_texture(void)
 */
static PyObject *Dtool_EggPrimitive_clear_texture_876(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.clear_texture")) {
    return nullptr;
  }
  // 1-inline void EggPrimitive::clear_texture(void)
  ((*local_this).clear_texture)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_clear_texture_876_comment =
  "C++ Interface:\n"
  "clear_texture(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Removes any texturing from the primitive.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_clear_texture_876_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggPrimitive::get_num_textures(void) const
 */
static PyObject *Dtool_EggPrimitive_get_num_textures_877(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggPrimitive)) {
    return nullptr;
  }
  // 1-inline int EggPrimitive::get_num_textures(void) const
  int return_value = ((*(const EggPrimitive*)local_this).get_num_textures)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_get_num_textures_877_comment =
  "C++ Interface:\n"
  "get_num_textures(EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns the number of textures applied to the primitive.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_get_num_textures_877_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggPrimitive::set_material(EggMaterial *material)
 */
static PyObject *Dtool_EggPrimitive_set_material_879(PyObject *self, PyObject *arg) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.set_material")) {
    return nullptr;
  }
  // 1-inline void EggPrimitive::set_material(EggMaterial *material)
  EggMaterial *arg_this = (EggMaterial *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggMaterial, 1, "EggPrimitive.set_material", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_material)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_material(const EggPrimitive self, EggMaterial material)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_set_material_879_comment =
  "C++ Interface:\n"
  "set_material(const EggPrimitive self, EggMaterial material)\n"
  "\n"
  "/**\n"
  " * Applies the indicated material to the primitive.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_set_material_879_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggPrimitive::clear_material(void)
 */
static PyObject *Dtool_EggPrimitive_clear_material_880(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.clear_material")) {
    return nullptr;
  }
  // 1-inline void EggPrimitive::clear_material(void)
  ((*local_this).clear_material)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_clear_material_880_comment =
  "C++ Interface:\n"
  "clear_material(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Removes any material from the primitive.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_clear_material_880_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggMaterial *EggPrimitive::get_material(void) const
 */
static PyObject *Dtool_EggPrimitive_get_material_881(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggPrimitive)) {
    return nullptr;
  }
  // 1-inline EggMaterial *EggPrimitive::get_material(void) const
  EggMaterial *return_value = ((*(const EggPrimitive*)local_this).get_material)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggMaterial, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_get_material_881_comment =
  "C++ Interface:\n"
  "get_material(EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the applied material, or NULL if there is no material\n"
  " * applied.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_get_material_881_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggPrimitive::has_material(void) const
 */
static PyObject *Dtool_EggPrimitive_has_material_882(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggPrimitive)) {
    return nullptr;
  }
  // 1-inline bool EggPrimitive::has_material(void) const
  bool return_value = ((*(const EggPrimitive*)local_this).has_material)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_has_material_882_comment =
  "C++ Interface:\n"
  "has_material(EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns true if the primitive is materiald (and get_material() will return\n"
  " * a real pointer), false otherwise (and get_material() will return NULL).\n"
  " */";
#else
static const char *Dtool_EggPrimitive_has_material_882_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggPrimitive::set_bface_flag(bool flag)
 */
static PyObject *Dtool_EggPrimitive_set_bface_flag_883(PyObject *self, PyObject *arg) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.set_bface_flag")) {
    return nullptr;
  }
  // 1-inline void EggPrimitive::set_bface_flag(bool flag)
  ((*local_this).set_bface_flag)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bface_flag(const EggPrimitive self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_set_bface_flag_883_comment =
  "C++ Interface:\n"
  "set_bface_flag(const EggPrimitive self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets the backfacing flag of the polygon.  If this is true, the polygon will\n"
  " * be rendered so that both faces are visible; if it is false, only the front\n"
  " * face of the polygon will be visible.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_set_bface_flag_883_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggPrimitive::get_bface_flag(void) const
 */
static PyObject *Dtool_EggPrimitive_get_bface_flag_884(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggPrimitive)) {
    return nullptr;
  }
  // 1-inline bool EggPrimitive::get_bface_flag(void) const
  bool return_value = ((*(const EggPrimitive*)local_this).get_bface_flag)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_get_bface_flag_884_comment =
  "C++ Interface:\n"
  "get_bface_flag(EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Retrieves the backfacing flag of the polygon.  See set_bface_flag().\n"
  " */";
#else
static const char *Dtool_EggPrimitive_get_bface_flag_884_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggPrimitive::copy_attributes(EggAttributes const &other)
 * void EggPrimitive::copy_attributes(EggPrimitive const &other)
 */
static PyObject *Dtool_EggPrimitive_copy_attributes_893(PyObject *self, PyObject *arg) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.copy_attributes")) {
    return nullptr;
  }
  {
    // -2 void EggPrimitive::copy_attributes(EggPrimitive const &other)
    EggPrimitive const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_EggPrimitive);
    if (arg_this != nullptr) {
      ((*local_this).copy_attributes)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void EggPrimitive::copy_attributes(EggAttributes const &other)
    EggAttributes const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_EggAttributes);
    if (arg_this != nullptr) {
      ((*local_this).copy_attributes)(*arg_this);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: void EggPrimitive::copy_attributes(EggPrimitive const &other)
  // No coercion possible: void EggPrimitive::copy_attributes(EggAttributes const &other)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_attributes(const EggPrimitive self, const EggPrimitive other)\n"
      "copy_attributes(const EggPrimitive self, const EggAttributes other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_copy_attributes_893_comment =
  "C++ Interface:\n"
  "copy_attributes(const EggPrimitive self, const EggPrimitive other)\n"
  "copy_attributes(const EggPrimitive self, const EggAttributes other)\n"
  "\n"
  "/**\n"
  " * Copies the rendering attributes from the indicated primitive.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Copies the rendering attributes from the indicated primitive.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_copy_attributes_893_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggPrimitive::has_vertex_normal(void) const
 */
static PyObject *Dtool_EggPrimitive_has_vertex_normal_894(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggPrimitive)) {
    return nullptr;
  }
  // 1-bool EggPrimitive::has_vertex_normal(void) const
  bool return_value = ((*(const EggPrimitive*)local_this).has_vertex_normal)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_has_vertex_normal_894_comment =
  "C++ Interface:\n"
  "has_vertex_normal(EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns true if any vertex on the primitive has a specific normal set,\n"
  " * false otherwise.\n"
  " *\n"
  " * If you call unify_attributes() first, this will also return false even if\n"
  " * all the vertices were set to the same value (since unify_attributes()\n"
  " * removes redundant vertex properties).\n"
  " */";
#else
static const char *Dtool_EggPrimitive_has_vertex_normal_894_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggPrimitive::has_vertex_color(void) const
 */
static PyObject *Dtool_EggPrimitive_has_vertex_color_895(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggPrimitive)) {
    return nullptr;
  }
  // 1-bool EggPrimitive::has_vertex_color(void) const
  bool return_value = ((*(const EggPrimitive*)local_this).has_vertex_color)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_has_vertex_color_895_comment =
  "C++ Interface:\n"
  "has_vertex_color(EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns true if any vertex on the primitive has a specific color set, false\n"
  " * otherwise.\n"
  " *\n"
  " * If you call unify_attributes() first, this will also return false even if\n"
  " * all the vertices were set to the same value (since unify_attributes()\n"
  " * removes redundant vertex properties).\n"
  " */";
#else
static const char *Dtool_EggPrimitive_has_vertex_color_895_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void EggPrimitive::unify_attributes(EggPrimitive::Shading shading)
 */
static PyObject *Dtool_EggPrimitive_unify_attributes_896(PyObject *self, PyObject *arg) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.unify_attributes")) {
    return nullptr;
  }
  // 1-virtual void EggPrimitive::unify_attributes(EggPrimitive::Shading shading)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).unify_attributes)((EggPrimitive::Shading)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unify_attributes(const EggPrimitive self, int shading)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_unify_attributes_896_comment =
  "C++ Interface:\n"
  "unify_attributes(const EggPrimitive self, int shading)\n"
  "\n"
  "/**\n"
  " * If the shading property is S_per_vertex, ensures that all vertices have a\n"
  " * normal and a color, and the overall primitive does not.\n"
  " *\n"
  " * If the shading property is S_per_face, and this is a composite primitive,\n"
  " * ensures that all components have a normal and a color, and the vertices and\n"
  " * overall primitive do not.  (If this is a simple primitive, S_per_face works\n"
  " * the same as S_overall, below).\n"
  " *\n"
  " * If the shading property is S_overall, ensures that no vertices or\n"
  " * components have a normal or a color, and the overall primitive does (if any\n"
  " * exists at all).\n"
  " *\n"
  " * After this call, either the primitive will have normals or its vertices\n"
  " * will, but not both.  Ditto for colors.\n"
  " *\n"
  " * This may create redundant vertices in the vertex pool.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_unify_attributes_896_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void EggPrimitive::apply_last_attribute(void)
 */
static PyObject *Dtool_EggPrimitive_apply_last_attribute_897(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.apply_last_attribute")) {
    return nullptr;
  }
  // 1-virtual void EggPrimitive::apply_last_attribute(void)
  ((*local_this).apply_last_attribute)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_apply_last_attribute_897_comment =
  "C++ Interface:\n"
  "apply_last_attribute(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Sets the last vertex of the triangle (or each component) to the primitive\n"
  " * normal and/or color, if the primitive is flat-shaded.  This reflects the\n"
  " * OpenGL convention of storing flat-shaded properties on the last vertex,\n"
  " * although it is not usually a convention in Egg.\n"
  " *\n"
  " * This may introduce redundant vertices to the vertex pool.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_apply_last_attribute_897_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void EggPrimitive::apply_first_attribute(void)
 */
static PyObject *Dtool_EggPrimitive_apply_first_attribute_898(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.apply_first_attribute")) {
    return nullptr;
  }
  // 1-virtual void EggPrimitive::apply_first_attribute(void)
  ((*local_this).apply_first_attribute)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_apply_first_attribute_898_comment =
  "C++ Interface:\n"
  "apply_first_attribute(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Sets the first vertex of the triangle (or each component) to the primitive\n"
  " * normal and/or color, if the primitive is flat-shaded.  This reflects the\n"
  " * DirectX convention of storing flat-shaded properties on the first vertex,\n"
  " * although it is not usually a convention in Egg.\n"
  " *\n"
  " * This may introduce redundant vertices to the vertex pool.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_apply_first_attribute_898_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void EggPrimitive::post_apply_flat_attribute(void)
 */
static PyObject *Dtool_EggPrimitive_post_apply_flat_attribute_899(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.post_apply_flat_attribute")) {
    return nullptr;
  }
  // 1-virtual void EggPrimitive::post_apply_flat_attribute(void)
  ((*local_this).post_apply_flat_attribute)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_post_apply_flat_attribute_899_comment =
  "C++ Interface:\n"
  "post_apply_flat_attribute(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Intended as a followup to apply_last_attribute(), this also sets an\n"
  " * attribute on the first vertices of the primitive, if they don't already\n"
  " * have an attribute set, just so they end up with *something*.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_post_apply_flat_attribute_899_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void EggPrimitive::reverse_vertex_ordering(void)
 */
static PyObject *Dtool_EggPrimitive_reverse_vertex_ordering_900(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.reverse_vertex_ordering")) {
    return nullptr;
  }
  // 1-virtual void EggPrimitive::reverse_vertex_ordering(void)
  ((*local_this).reverse_vertex_ordering)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_reverse_vertex_ordering_900_comment =
  "C++ Interface:\n"
  "reverse_vertex_ordering(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Reverses the ordering of the vertices in this primitive, if appropriate, in\n"
  " * order to change the direction the polygon appears to be facing.  Does not\n"
  " * adjust the surface normal, if any.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_reverse_vertex_ordering_900_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggPrimitive::cleanup(void)
 */
static PyObject *Dtool_EggPrimitive_cleanup_901(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.cleanup")) {
    return nullptr;
  }
  // 1-virtual bool EggPrimitive::cleanup(void)
  bool return_value = ((*local_this).cleanup)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_cleanup_901_comment =
  "C++ Interface:\n"
  "cleanup(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Cleans up modeling errors in whatever context this makes sense.  For\n"
  " * instance, for a polygon, this calls remove_doubled_verts(true).  For a\n"
  " * point, it calls remove_nonunique_verts().  Returns true if the primitive is\n"
  " * valid, or false if it is degenerate.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_cleanup_901_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggPrimitive::remove_doubled_verts(bool closed)
 */
static PyObject *Dtool_EggPrimitive_remove_doubled_verts_902(PyObject *self, PyObject *arg) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.remove_doubled_verts")) {
    return nullptr;
  }
  // 1-void EggPrimitive::remove_doubled_verts(bool closed)
  ((*local_this).remove_doubled_verts)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_doubled_verts(const EggPrimitive self, bool closed)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_remove_doubled_verts_902_comment =
  "C++ Interface:\n"
  "remove_doubled_verts(const EggPrimitive self, bool closed)\n"
  "\n"
  "/**\n"
  " * Certain kinds of primitives, particularly polygons, don't like to have the\n"
  " * same vertex repeated consecutively.  Unfortunately, some modeling programs\n"
  " * (like MultiGen) make this an easy mistake to make.\n"
  " *\n"
  " * It's handy to have a function to remove these redundant vertices.  If\n"
  " * closed is true, it also checks that the first and last vertices are not the\n"
  " * same.\n"
  " *\n"
  " * This function identifies repeated vertices by position only; it does not\n"
  " * consider any other properties, such as color or UV, significant in\n"
  " * differentiating vertices.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_remove_doubled_verts_902_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggPrimitive::remove_nonunique_verts(void)
 */
static PyObject *Dtool_EggPrimitive_remove_nonunique_verts_903(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.remove_nonunique_verts")) {
    return nullptr;
  }
  // 1-void EggPrimitive::remove_nonunique_verts(void)
  ((*local_this).remove_nonunique_verts)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_remove_nonunique_verts_903_comment =
  "C++ Interface:\n"
  "remove_nonunique_verts(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Removes any multiple appearances of the same vertex from the primitive.\n"
  " * This primarily makes sense for a point primitive, which is really a\n"
  " * collection of points and which doesn't make sense to include the same point\n"
  " * twice, in any order.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_remove_nonunique_verts_903_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggPrimitive::has_primitives(void) const
 */
static PyObject *Dtool_EggPrimitive_has_primitives_904(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggPrimitive)) {
    return nullptr;
  }
  // 1-virtual bool EggPrimitive::has_primitives(void) const
  bool return_value = ((*(const EggPrimitive*)local_this).has_primitives)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_has_primitives_904_comment =
  "C++ Interface:\n"
  "has_primitives(EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns true if there are any primitives (e.g.  polygons) defined within\n"
  " * this group or below, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_has_primitives_904_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggPrimitive::joint_has_primitives(void) const
 */
static PyObject *Dtool_EggPrimitive_joint_has_primitives_905(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggPrimitive)) {
    return nullptr;
  }
  // 1-virtual bool EggPrimitive::joint_has_primitives(void) const
  bool return_value = ((*(const EggPrimitive*)local_this).joint_has_primitives)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_joint_has_primitives_905_comment =
  "C++ Interface:\n"
  "joint_has_primitives(EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns true if there are any primitives (e.g.  polygons) defined within\n"
  " * this group or below, but the search does not include nested joints.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_joint_has_primitives_905_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool EggPrimitive::has_normals(void) const
 */
static PyObject *Dtool_EggPrimitive_has_normals_906(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggPrimitive)) {
    return nullptr;
  }
  // 1-virtual bool EggPrimitive::has_normals(void) const
  bool return_value = ((*(const EggPrimitive*)local_this).has_normals)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_has_normals_906_comment =
  "C++ Interface:\n"
  "has_normals(EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns true if any of the primitives (e.g.  polygons) defined within this\n"
  " * group or below have either face or vertex normals defined, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_has_normals_906_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggPrimitive::clear(void)
 */
static PyObject *Dtool_EggPrimitive_clear_907(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.clear")) {
    return nullptr;
  }
  // 1-inline void EggPrimitive::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_clear_907_comment =
  "C++ Interface:\n"
  "clear(const EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Removes all of the vertices from the primitive.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_clear_907_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggVertex *EggPrimitive::add_vertex(EggVertex *vertex)
 */
static PyObject *Dtool_EggPrimitive_add_vertex_908(PyObject *self, PyObject *arg) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.add_vertex")) {
    return nullptr;
  }
  // 1-EggVertex *EggPrimitive::add_vertex(EggVertex *vertex)
  EggVertex *arg_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertex, 1, "EggPrimitive.add_vertex", false, true);
  if (arg_this != nullptr) {
    EggVertex *return_value = ((*local_this).add_vertex)(arg_this);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_vertex(const EggPrimitive self, EggVertex vertex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_add_vertex_908_comment =
  "C++ Interface:\n"
  "add_vertex(const EggPrimitive self, EggVertex vertex)\n"
  "\n"
  "/**\n"
  " * Adds the indicated vertex to the end of the primitive's list of vertices,\n"
  " * and returns it.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_add_vertex_908_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggVertex *EggPrimitive::remove_vertex(EggVertex *vertex)
 * void EggPrimitive::remove_vertex(std::size_t index)
 */
static PyObject *Dtool_EggPrimitive_remove_vertex_909(PyObject *self, PyObject *arg) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.remove_vertex")) {
    return nullptr;
  }
  {
    // -2 EggVertex *EggPrimitive::remove_vertex(EggVertex *vertex)
    EggVertex *arg_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertex, 1, "EggPrimitive.remove_vertex", false, false);
    if (arg_this != nullptr) {
      EggVertex *return_value = ((*local_this).remove_vertex)(arg_this);
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }

  {
    // -2 void EggPrimitive::remove_vertex(std::size_t index)
    if (PyLongOrInt_Check(arg)) {
      size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
      if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
        return nullptr;
      }
#endif
      ((*local_this).remove_vertex)(arg_val);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: EggVertex *EggPrimitive::remove_vertex(EggVertex *vertex)
  // No coercion possible: void EggPrimitive::remove_vertex(std::size_t index)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_vertex(const EggPrimitive self, EggVertex vertex)\n"
      "remove_vertex(const EggPrimitive self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_remove_vertex_909_comment =
  "C++ Interface:\n"
  "remove_vertex(const EggPrimitive self, EggVertex vertex)\n"
  "remove_vertex(const EggPrimitive self, int index)\n"
  "\n"
  "/**\n"
  " * Removes the indicated vertex from the primitive and returns it.  If the\n"
  " * vertex was not already in the primitive, does nothing and returns NULL.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Removes the indicated vertex from the primitive.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_remove_vertex_909_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggPrimitive::copy_vertices(EggPrimitive const &other)
 */
static PyObject *Dtool_EggPrimitive_copy_vertices_910(PyObject *self, PyObject *arg) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.copy_vertices")) {
    return nullptr;
  }
  // 1-void EggPrimitive::copy_vertices(EggPrimitive const &other)
  EggPrimitive const *arg_this = (EggPrimitive *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggPrimitive, 1, "EggPrimitive.copy_vertices", true, true);
  if (arg_this != nullptr) {
    ((*local_this).copy_vertices)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_vertices(const EggPrimitive self, const EggPrimitive other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_copy_vertices_910_comment =
  "C++ Interface:\n"
  "copy_vertices(const EggPrimitive self, const EggPrimitive other)\n"
  "\n"
  "/**\n"
  " * Replaces the current primitive's list of vertices with a copy of the list\n"
  " * of vertices on the other primitive.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_copy_vertices_910_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t EggPrimitive::get_num_vertices(void) const
 */
static PyObject *Dtool_EggPrimitive_get_num_vertices_911(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggPrimitive)) {
    return nullptr;
  }
  // 1-inline std::size_t EggPrimitive::get_num_vertices(void) const
  std::size_t return_value = ((*(const EggPrimitive*)local_this).get_num_vertices)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_get_num_vertices_911_comment =
  "C++ Interface:\n"
  "get_num_vertices(EggPrimitive self)\n"
  "\n"
  "// These are shorthands if you don't want to use the iterators.\n"
  "\n"
  "// These are shorthands if you don't want to use the iterators.\n"
  "\n"
  "// These are shorthands if you don't want to use the iterators.\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggPrimitive_get_num_vertices_911_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggVertex *EggPrimitive::get_vertex(std::size_t index) const
 */
static PyObject *Dtool_EggPrimitive_get_vertex_912(PyObject *self, PyObject *arg) {
  EggPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggPrimitive)) {
    return nullptr;
  }
  // 1-inline EggVertex *EggPrimitive::get_vertex(std::size_t index) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    EggVertex *return_value = ((*(const EggPrimitive*)local_this).get_vertex)(arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex(EggPrimitive self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_get_vertex_912_comment =
  "C++ Interface:\n"
  "get_vertex(EggPrimitive self, int index)\n"
  "\n"
  "/**\n"
  " * Returns a particular index based on its index number.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_get_vertex_912_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggPrimitive::set_vertex(std::size_t index, EggVertex *vertex)
 */
static PyObject *Dtool_EggPrimitive_set_vertex_913(PyObject *self, PyObject *args, PyObject *kwds) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.set_vertex")) {
    return nullptr;
  }
  // 1-inline void EggPrimitive::set_vertex(std::size_t index, EggVertex *vertex)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "vertex", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:set_vertex", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    EggVertex *param2_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_EggVertex, 2, "EggPrimitive.set_vertex", false, true);
    if (param2_this != nullptr) {
      ((*local_this).set_vertex)((std::size_t)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vertex(const EggPrimitive self, int index, EggVertex vertex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_set_vertex_913_comment =
  "C++ Interface:\n"
  "set_vertex(const EggPrimitive self, int index, EggVertex vertex)\n"
  "\n"
  "/**\n"
  " * Replaces a particular vertex based on its index number in the list of\n"
  " * vertices.  This is just a convenience function for people who don't want to\n"
  " * mess with the iterators.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_set_vertex_913_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggPrimitive::insert_vertex(std::size_t index, EggVertex *vertex)
 */
static PyObject *Dtool_EggPrimitive_insert_vertex_914(PyObject *self, PyObject *args, PyObject *kwds) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.insert_vertex")) {
    return nullptr;
  }
  // 1-inline void EggPrimitive::insert_vertex(std::size_t index, EggVertex *vertex)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "vertex", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:insert_vertex", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    EggVertex *param2_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_EggVertex, 2, "EggPrimitive.insert_vertex", false, true);
    if (param2_this != nullptr) {
      ((*local_this).insert_vertex)((std::size_t)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "insert_vertex(const EggPrimitive self, int index, EggVertex vertex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_insert_vertex_914_comment =
  "C++ Interface:\n"
  "insert_vertex(const EggPrimitive self, int index, EggVertex vertex)\n"
  "\n"
  "/**\n"
  " * Inserts a vertex at the given position.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_insert_vertex_914_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggVertexPool *EggPrimitive::get_pool(void) const
 */
static PyObject *Dtool_EggPrimitive_get_pool_916(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggPrimitive)) {
    return nullptr;
  }
  // 1-inline EggVertexPool *EggPrimitive::get_pool(void) const
  EggVertexPool *return_value = ((*(const EggPrimitive*)local_this).get_pool)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertexPool, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_get_pool_916_comment =
  "C++ Interface:\n"
  "get_pool(EggPrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns the vertex pool associated with the vertices of the primitive, or\n"
  " * NULL if the primitive has no vertices.\n"
  " */";
#else
static const char *Dtool_EggPrimitive_get_pool_916_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void EggPrimitive::write(std::ostream &out, int indent_level) const = 0
 */
static PyObject *Dtool_EggPrimitive_write_921(PyObject *self, PyObject *args, PyObject *kwds) {
  EggPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggPrimitive)) {
    return nullptr;
  }
  // 1-virtual void EggPrimitive::write(std::ostream &out, int indent_level) const = 0
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "EggPrimitive.write", false, true);
    if (param1_this != nullptr) {
      ((*(const EggPrimitive*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(EggPrimitive self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_write_921_comment =
  "C++ Interface:\n"
  "write(EggPrimitive self, ostream out, int indent_level)\n";
#else
static const char *Dtool_EggPrimitive_write_921_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggPrimitive::test_vref_integrity(void) const
 */
static PyObject *Dtool_EggPrimitive_test_vref_integrity_922(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggPrimitive)) {
    return nullptr;
  }
  // 1-void EggPrimitive::test_vref_integrity(void) const
  ((*(const EggPrimitive*)local_this).test_vref_integrity)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_test_vref_integrity_922_comment =
  "C++ Interface:\n"
  "test_vref_integrity(EggPrimitive self)\n";
#else
static const char *Dtool_EggPrimitive_test_vref_integrity_922_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggPrimitive::get_class_type(void)
 */
static PyObject *Dtool_EggPrimitive_get_class_type_923(PyObject *, PyObject *) {
  // 1-static TypeHandle EggPrimitive::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggPrimitive::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_get_class_type_923_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggPrimitive_get_class_type_923_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggNode *EggPrimitive::upcast_to_EggNode(void)
 */
static PyObject *Dtool_EggPrimitive_upcast_to_EggNode_851(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.upcast_to_EggNode")) {
    return nullptr;
  }
  // 1-EggNode *EggPrimitive::upcast_to_EggNode(void)
  EggNode *return_value = (EggNode *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_upcast_to_EggNode_851_comment =
  "C++ Interface:\n"
  "upcast_to_EggNode(const EggPrimitive self)\n"
  "\n"
  "upcast from EggPrimitive to EggNode";
#else
static const char *Dtool_EggPrimitive_upcast_to_EggNode_851_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggAttributes *EggPrimitive::upcast_to_EggAttributes(void)
 */
static PyObject *Dtool_EggPrimitive_upcast_to_EggAttributes_853(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.upcast_to_EggAttributes")) {
    return nullptr;
  }
  // 1-EggAttributes *EggPrimitive::upcast_to_EggAttributes(void)
  EggAttributes *return_value = (EggAttributes *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggAttributes, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_upcast_to_EggAttributes_853_comment =
  "C++ Interface:\n"
  "upcast_to_EggAttributes(const EggPrimitive self)\n"
  "\n"
  "upcast from EggPrimitive to EggAttributes";
#else
static const char *Dtool_EggPrimitive_upcast_to_EggAttributes_853_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggRenderMode *EggPrimitive::upcast_to_EggRenderMode(void)
 */
static PyObject *Dtool_EggPrimitive_upcast_to_EggRenderMode_855(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.upcast_to_EggRenderMode")) {
    return nullptr;
  }
  // 1-EggRenderMode *EggPrimitive::upcast_to_EggRenderMode(void)
  EggRenderMode *return_value = (EggRenderMode *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggRenderMode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EggPrimitive_upcast_to_EggRenderMode_855_comment =
  "C++ Interface:\n"
  "upcast_to_EggRenderMode(const EggPrimitive self)\n"
  "\n"
  "upcast from EggPrimitive to EggRenderMode";
#else
static const char *Dtool_EggPrimitive_upcast_to_EggRenderMode_855_comment = nullptr;
#endif

static PyObject *Dtool_EggPrimitive_sort_name_Getter(PyObject *self, void *) {
  const EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string EggPrimitive::get_sort_name(void) const
  std::string return_value = ((*(const EggPrimitive*)local_this).get_sort_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_EggPrimitive_shading_Getter(PyObject *self, void *) {
  const EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual EggPrimitive::Shading EggPrimitive::get_shading(void) const
  EggPrimitive::Shading return_value = ((*(const EggPrimitive*)local_this).get_shading)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_EggPrimitive_connected_shading_Getter(PyObject *self, void *) {
  const EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline EggPrimitive::Shading EggPrimitive::get_connected_shading(void) const
  EggPrimitive::Shading return_value = ((*(const EggPrimitive*)local_this).get_connected_shading)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * sequence length function for property EggPrimitive::textures
 */
static Py_ssize_t Dtool_EggPrimitive_textures_Len(PyObject *self) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_textures)();
}

/**
 * sequence getter for property EggPrimitive::textures
 */
static PyObject *Dtool_EggPrimitive_textures_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_textures)()) {
    PyErr_SetString(PyExc_IndexError, "EggPrimitive.textures[] index out of range");
    return nullptr;
  }
  // 1-inline EggTexture *EggPrimitive::get_texture(int n) const
  EggTexture *return_value = ((*(const EggPrimitive*)local_this).get_texture)(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggTexture, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_texture(EggPrimitive self, index)\n");
  }
}

static PyObject *Dtool_EggPrimitive_textures_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "EggPrimitive.textures");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_EggPrimitive_textures_Len;
    wrap->_getitem_func = &Dtool_EggPrimitive_textures_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

static PyObject *Dtool_EggPrimitive_material_Getter(PyObject *self, void *) {
  const EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_material()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline EggMaterial *EggPrimitive::get_material(void) const
  EggMaterial *return_value = ((*(const EggPrimitive*)local_this).get_material)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggMaterial, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_EggPrimitive_material_Setter(PyObject *self, PyObject *arg, void *) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.material")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete material attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_material();
    return 0;
  }
  // 1-inline void EggPrimitive::set_material(EggMaterial *material)
  EggMaterial *arg_this = (EggMaterial *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggMaterial, 1, "EggPrimitive.set_material", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_material)(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_material(const EggPrimitive self, EggMaterial material)\n");
  }
  return -1;
}

static PyObject *Dtool_EggPrimitive_bface_flag_Getter(PyObject *self, void *) {
  const EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool EggPrimitive::get_bface_flag(void) const
  bool return_value = ((*(const EggPrimitive*)local_this).get_bface_flag)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggPrimitive_bface_flag_Setter(PyObject *self, PyObject *arg, void *) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.bface_flag")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete bface_flag attribute");
    return -1;
  }
  // 1-inline void EggPrimitive::set_bface_flag(bool flag)
  ((*local_this).set_bface_flag)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_bface_flag(const EggPrimitive self, bool flag)\n");
  }
  return -1;
}

/**
 * sequence length function for property EggPrimitive::vertices
 */
static Py_ssize_t Dtool_EggPrimitive_vertices_Len(PyObject *self) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_vertices)();
}

/**
 * sequence getter for property EggPrimitive::vertices
 */
static PyObject *Dtool_EggPrimitive_vertices_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_vertices)()) {
    PyErr_SetString(PyExc_IndexError, "EggPrimitive.vertices[] index out of range");
    return nullptr;
  }
  // 1-inline EggVertex *EggPrimitive::get_vertex(std::size_t index) const
  EggVertex *return_value = ((*(const EggPrimitive*)local_this).get_vertex)(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex(EggPrimitive self, index)\n");
  }
}

static int Dtool_EggPrimitive_vertices_Sequence_Setitem(PyObject *self, Py_ssize_t index, PyObject *arg) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.vertices")) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_vertices)()) {
    PyErr_SetString(PyExc_IndexError, "EggPrimitive.vertices[] index out of range");
    return -1;
  }
  if (arg == nullptr) {
    local_this->remove_vertex(index);
    return 0;
  }
  // 1-inline void EggPrimitive::set_vertex(std::size_t index, EggVertex *vertex)
  EggVertex *arg_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertex, 2, "EggPrimitive.set_vertex", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_vertex)(index, arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_vertex(const EggPrimitive self, index, EggVertex vertex)\n");
  }
  return -1;
}

static PyObject *Dtool_EggPrimitive_vertices_Sequence_insert(PyObject *self, size_t index, PyObject *arg) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPrimitive, (void **)&local_this, "EggPrimitive.vertices")) {
    return nullptr;
  }

  // 1-inline void EggPrimitive::insert_vertex(std::size_t index, EggVertex *vertex)
  EggVertex *arg_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertex, 2, "EggPrimitive.insert_vertex", false, true);
  if (arg_this != nullptr) {
    ((*local_this).insert_vertex)(index, arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(Py_None);
    return Py_None;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "insert_vertex(const EggPrimitive self, index, EggVertex vertex)\n");
  }
  return nullptr;
}

static PyObject *Dtool_EggPrimitive_vertices_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_MutableSequenceWrapper *wrap = Dtool_NewMutableSequenceWrapper(self, "EggPrimitive.vertices");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_EggPrimitive_vertices_Len;
    wrap->_getitem_func = &Dtool_EggPrimitive_vertices_Sequence_Getitem;
    if (!DtoolInstance_IS_CONST(self)) {
      wrap->_setitem_func = &Dtool_EggPrimitive_vertices_Sequence_Setitem;
      wrap->_insert_func = &Dtool_EggPrimitive_vertices_Sequence_insert;
    }
  }
  return (PyObject *)wrap;
}

static PyObject *Dtool_EggPrimitive_pool_Getter(PyObject *self, void *) {
  const EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline EggVertexPool *EggPrimitive::get_pool(void) const
  EggVertexPool *return_value = ((*(const EggPrimitive*)local_this).get_pool)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertexPool, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_Init_EggPrimitive(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_EggPrimitive_get_textures(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_textures)();
  PyTupleObject args;
  (void)PyObject_INIT_VAR((PyVarObject *)&args, &PyTuple_Type, 1);
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyTuple_SET_ITEM(&args, 0, index);
    PyObject *value = Dtool_EggPrimitive_get_texture_874(self, (PyObject *)&args);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  _Py_ForgetReference((PyObject *)&args);
  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_EggPrimitive_get_vertices(PyObject *self, PyObject *) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_vertices)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_EggPrimitive_get_vertex_912(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_EggPrimitive(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggPrimitive) {
    printf("EggPrimitive ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggPrimitive *local_this = (EggPrimitive *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggPrimitive) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggAttributes) {
    return (EggAttributes *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return (EggRenderMode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggPrimitive(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggPrimitive) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggAttributes) {
    EggAttributes* other_this = (EggAttributes*)from_this;
    return (EggPrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggPrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggPrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggPrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    EggRenderMode* other_this = (EggRenderMode*)from_this;
    return (EggPrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggPrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggPrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggPrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggPrimitive*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggCompositePrimitive
 */
/**
 * Python function wrapper for:
 * inline void EggCompositePrimitive::operator =(EggCompositePrimitive const &copy)
 */
static PyObject *Dtool_EggCompositePrimitive_operator_925(PyObject *self, PyObject *arg) {
  EggCompositePrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggCompositePrimitive, (void **)&local_this, "EggCompositePrimitive.assign")) {
    return nullptr;
  }
  // 1-inline void EggCompositePrimitive::operator =(EggCompositePrimitive const &copy)
  EggCompositePrimitive const *arg_this = (EggCompositePrimitive *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggCompositePrimitive, 1, "EggCompositePrimitive.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggCompositePrimitive *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggCompositePrimitive, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggCompositePrimitive self, const EggCompositePrimitive copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggCompositePrimitive_operator_925_comment =
  "C++ Interface:\n"
  "assign(const EggCompositePrimitive self, const EggCompositePrimitive copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggCompositePrimitive_operator_925_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t EggCompositePrimitive::get_num_components(void) const
 */
static PyObject *Dtool_EggCompositePrimitive_get_num_components_926(PyObject *self, PyObject *) {
  EggCompositePrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggCompositePrimitive)) {
    return nullptr;
  }
  // 1-inline std::size_t EggCompositePrimitive::get_num_components(void) const
  std::size_t return_value = ((*(const EggCompositePrimitive*)local_this).get_num_components)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggCompositePrimitive_get_num_components_926_comment =
  "C++ Interface:\n"
  "get_num_components(EggCompositePrimitive self)\n"
  "\n"
  "/**\n"
  " * Returns the number of individual component triangles within the composite.\n"
  " * Each one of these might have a different set of attributes.\n"
  " */";
#else
static const char *Dtool_EggCompositePrimitive_get_num_components_926_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggAttributes *EggCompositePrimitive::get_component(std::size_t i)
 * inline EggAttributes const *EggCompositePrimitive::get_component(std::size_t i) const
 */
static PyObject *Dtool_EggCompositePrimitive_get_component_927(PyObject *self, PyObject *arg) {
  EggCompositePrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggCompositePrimitive)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 inline EggAttributes *EggCompositePrimitive::get_component(std::size_t i)
    if (PyLongOrInt_Check(arg)) {
      size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
      if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
        return nullptr;
      }
#endif
      EggAttributes *return_value = ((*local_this).get_component)(arg_val);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggAttributes, false, false);
    }
  }

  {
    // -2 inline EggAttributes const *EggCompositePrimitive::get_component(std::size_t i) const
    if (PyLongOrInt_Check(arg)) {
      size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
      if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
        return nullptr;
      }
#endif
      EggAttributes const *return_value = ((*(const EggCompositePrimitive*)local_this).get_component)(arg_val);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggAttributes, false, true);
    }
  }

  // No coercion possible: inline EggAttributes *EggCompositePrimitive::get_component(std::size_t i)
  // No coercion possible: inline EggAttributes const *EggCompositePrimitive::get_component(std::size_t i) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_component(const EggCompositePrimitive self, int i)\n"
      "get_component(EggCompositePrimitive self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggCompositePrimitive_get_component_927_comment =
  "C++ Interface:\n"
  "get_component(const EggCompositePrimitive self, int i)\n"
  "get_component(EggCompositePrimitive self, int i)\n"
  "\n"
  "/**\n"
  " * Returns the attributes for the nth component triangle.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the attributes for the nth component triangle.\n"
  " */";
#else
static const char *Dtool_EggCompositePrimitive_get_component_927_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggCompositePrimitive::set_component(std::size_t i, EggAttributes const *attrib)
 */
static PyObject *Dtool_EggCompositePrimitive_set_component_929(PyObject *self, PyObject *args, PyObject *kwds) {
  EggCompositePrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggCompositePrimitive, (void **)&local_this, "EggCompositePrimitive.set_component")) {
    return nullptr;
  }
  // 1-inline void EggCompositePrimitive::set_component(std::size_t i, EggAttributes const *attrib)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"i", "attrib", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:set_component", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    EggAttributes const *param2_this = (EggAttributes *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_EggAttributes, 2, "EggCompositePrimitive.set_component", true, true);
    if (param2_this != nullptr) {
      ((*local_this).set_component)((std::size_t)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_component(const EggCompositePrimitive self, int i, const EggAttributes attrib)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggCompositePrimitive_set_component_929_comment =
  "C++ Interface:\n"
  "set_component(const EggCompositePrimitive self, int i, const EggAttributes attrib)\n"
  "\n"
  "/**\n"
  " * Changes the attributes for the nth component triangle.\n"
  " */";
#else
static const char *Dtool_EggCompositePrimitive_set_component_929_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggCompositePrimitive::triangulate_into(EggGroupNode *container) const
 */
static PyObject *Dtool_EggCompositePrimitive_triangulate_into_932(PyObject *self, PyObject *arg) {
  EggCompositePrimitive *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggCompositePrimitive)) {
    return nullptr;
  }
  // 1-inline bool EggCompositePrimitive::triangulate_into(EggGroupNode *container) const
  EggGroupNode *arg_this = (EggGroupNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggGroupNode, 1, "EggCompositePrimitive.triangulate_into", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const EggCompositePrimitive*)local_this).triangulate_into)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "triangulate_into(EggCompositePrimitive self, EggGroupNode container)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggCompositePrimitive_triangulate_into_932_comment =
  "C++ Interface:\n"
  "triangulate_into(EggCompositePrimitive self, EggGroupNode container)\n"
  "\n"
  "/**\n"
  " * Subdivides the composite primitive into triangles and adds those triangles\n"
  " * to the indicated container.  Does not remove the primitive from its\n"
  " * existing parent or modify it in any way.\n"
  " *\n"
  " * Returns true if the triangulation is successful, or false if there was some\n"
  " * error (in which case the container may contain some partial triangulation).\n"
  " */";
#else
static const char *Dtool_EggCompositePrimitive_triangulate_into_932_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< EggCompositePrimitive > EggCompositePrimitive::triangulate_in_place(void)
 */
static PyObject *Dtool_EggCompositePrimitive_triangulate_in_place_933(PyObject *self, PyObject *) {
  EggCompositePrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggCompositePrimitive, (void **)&local_this, "EggCompositePrimitive.triangulate_in_place")) {
    return nullptr;
  }
  // 1-PointerTo< EggCompositePrimitive > EggCompositePrimitive::triangulate_in_place(void)
  PointerTo< EggCompositePrimitive > return_value = ((*local_this).triangulate_in_place)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  EggCompositePrimitive *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_EggCompositePrimitive, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EggCompositePrimitive_triangulate_in_place_933_comment =
  "C++ Interface:\n"
  "triangulate_in_place(const EggCompositePrimitive self)\n"
  "\n"
  "/**\n"
  " * Subdivides the composite primitive into triangles and adds those triangles\n"
  " * to the parent group node in place of the original primitive.  Returns a\n"
  " * pointer to the original primitive, which is likely about to be destructed.\n"
  " *\n"
  " * If convex_also is true, both concave and convex polygons will be subdivided\n"
  " * into triangles; otherwise, only concave polygons will be subdivided, and\n"
  " * convex polygons will be copied unchanged into the container.\n"
  " */";
#else
static const char *Dtool_EggCompositePrimitive_triangulate_in_place_933_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggCompositePrimitive::get_class_type(void)
 */
static PyObject *Dtool_EggCompositePrimitive_get_class_type_934(PyObject *, PyObject *) {
  // 1-static TypeHandle EggCompositePrimitive::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggCompositePrimitive::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggCompositePrimitive_get_class_type_934_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggCompositePrimitive_get_class_type_934_comment = nullptr;
#endif

/**
 * sequence length function for property EggCompositePrimitive::components
 */
static Py_ssize_t Dtool_EggCompositePrimitive_components_Len(PyObject *self) {
  EggCompositePrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggCompositePrimitive, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_components)();
}

/**
 * sequence getter for property EggCompositePrimitive::components
 */
static PyObject *Dtool_EggCompositePrimitive_components_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  EggCompositePrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggCompositePrimitive, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_components)()) {
    PyErr_SetString(PyExc_IndexError, "EggCompositePrimitive.components[] index out of range");
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 inline EggAttributes *EggCompositePrimitive::get_component(std::size_t i)
    EggAttributes *return_value = ((*local_this).get_component)(index);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggAttributes, false, false);
  }

  {
    // -2 inline EggAttributes const *EggCompositePrimitive::get_component(std::size_t i) const
    EggAttributes const *return_value = ((*(const EggCompositePrimitive*)local_this).get_component)(index);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggAttributes, false, true);
  }

  // No coercion possible: inline EggAttributes *EggCompositePrimitive::get_component(std::size_t i)
  // No coercion possible: inline EggAttributes const *EggCompositePrimitive::get_component(std::size_t i) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_component(const EggCompositePrimitive self, index)\n"
      "get_component(EggCompositePrimitive self, index)\n");
  }
}

static int Dtool_EggCompositePrimitive_components_Sequence_Setitem(PyObject *self, Py_ssize_t index, PyObject *arg) {
  EggCompositePrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggCompositePrimitive, (void **)&local_this, "EggCompositePrimitive.components")) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_components)()) {
    PyErr_SetString(PyExc_IndexError, "EggCompositePrimitive.components[] index out of range");
    return -1;
  }
  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete components[] attribute");
    return -1;
  }
  // 1-inline void EggCompositePrimitive::set_component(std::size_t i, EggAttributes const *attrib)
  EggAttributes const *arg_this = (EggAttributes *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggAttributes, 2, "EggCompositePrimitive.set_component", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_component)(index, arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_component(const EggCompositePrimitive self, index, const EggAttributes attrib)\n");
  }
  return -1;
}

static PyObject *Dtool_EggCompositePrimitive_components_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_MutableSequenceWrapper *wrap = Dtool_NewMutableSequenceWrapper(self, "EggCompositePrimitive.components");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_EggCompositePrimitive_components_Len;
    wrap->_getitem_func = &Dtool_EggCompositePrimitive_components_Sequence_Getitem;
    if (!DtoolInstance_IS_CONST(self)) {
      wrap->_setitem_func = &Dtool_EggCompositePrimitive_components_Sequence_Setitem;
    }
  }
  return (PyObject *)wrap;
}

static int Dtool_Init_EggCompositePrimitive(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_EggCompositePrimitive_get_components(PyObject *self, PyObject *) {
  EggCompositePrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggCompositePrimitive, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_components)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_EggCompositePrimitive_get_component_927(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_EggCompositePrimitive(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggCompositePrimitive) {
    printf("EggCompositePrimitive ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggCompositePrimitive *local_this = (EggCompositePrimitive *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggCompositePrimitive) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggAttributes) {
    return (EggAttributes *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggPrimitive) {
    return (EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return (EggRenderMode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggCompositePrimitive(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggCompositePrimitive) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggAttributes) {
    EggAttributes* other_this = (EggAttributes*)from_this;
    return (EggCompositePrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggCompositePrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggCompositePrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggCompositePrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_EggPrimitive) {
    EggPrimitive* other_this = (EggPrimitive*)from_this;
    return (EggCompositePrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    EggRenderMode* other_this = (EggRenderMode*)from_this;
    return (EggCompositePrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggCompositePrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggCompositePrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggCompositePrimitive*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggCompositePrimitive*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggData
 */
/**
 * Python function wrapper for:
 * inline void EggData::operator =(EggData const &copy)
 */
static PyObject *Dtool_EggData_operator_937(PyObject *self, PyObject *arg) {
  EggData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.assign")) {
    return nullptr;
  }
  // 1-inline void EggData::operator =(EggData const &copy)
  EggData const *arg_this = (EggData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggData, 1, "EggData.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggData *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggData, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggData self, const EggData copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggData_operator_937_comment =
  "C++ Interface:\n"
  "assign(const EggData self, const EggData copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggData_operator_937_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static bool EggData::resolve_egg_filename(Filename &egg_filename, DSearchPath const &searchpath = DSearchPath())
 */
static PyObject *Dtool_EggData_resolve_egg_filename_938(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static bool EggData::resolve_egg_filename(Filename &egg_filename, DSearchPath const &searchpath = DSearchPath())
  PyObject *param0;
  PyObject *param1 = nullptr;
  static const char *keyword_list[] = {"egg_filename", "searchpath", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:resolve_egg_filename", (char **)keyword_list, &param0, &param1)) {
    Filename param0_local;
    Filename *param0_this = Dtool_Coerce_Filename(param0, param0_local);
    if (!(param0_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "EggData.resolve_egg_filename", "Filename");
    }
    DSearchPath param1_local;
    DSearchPath const *param1_this;
    if (param1 != nullptr) {
      param1_this = Dtool_Coerce_DSearchPath(param1, param1_local);
    } else {
      param1_local = DSearchPath();
      param1_this = &param1_local;
    }
    if (param1 != nullptr && !(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "EggData.resolve_egg_filename", "DSearchPath");
    }
    bool return_value = (EggData::resolve_egg_filename)(*param0_this, *param1_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "resolve_egg_filename(Filename egg_filename, const DSearchPath searchpath)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggData_resolve_egg_filename_938_comment =
  "C++ Interface:\n"
  "resolve_egg_filename(Filename egg_filename, const DSearchPath searchpath)\n"
  "\n"
  "/**\n"
  " * Looks for the indicated filename, first along the indicated searchpath, and\n"
  " * then along the model_path.  If found, updates the filename to the full path\n"
  " * and returns true; otherwise, returns false.\n"
  " */";
#else
static const char *Dtool_EggData_resolve_egg_filename_938_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggData::read(Filename filename, std::string display_name = string())
 * bool EggData::read(std::istream &in)
 */
static PyObject *Dtool_EggData_read_939(PyObject *self, PyObject *args, PyObject *kwds) {
  EggData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.read")) {
    return nullptr;
  }
  {
    // -2 bool EggData::read(Filename filename, std::string display_name = string())
    PyObject *param1;
    const char *param2_str = "";
    Py_ssize_t param2_len = 0;
    static const char *keyword_list[] = {"filename", "display_name", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#:read", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
      Filename *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_Filename);
      if (param1_this != nullptr) {
        bool return_value = ((*local_this).read)(*param1_this, std::string(param2_str, param2_len));
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool EggData::read(std::istream &in)
    PyObject *param1;
    if (Dtool_ExtractArg(&param1, args, kwds, "in")) {
      std::istream *param1_this = (std::istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_istream, 1, "EggData.read", false, false);
      if (param1_this != nullptr) {
        bool return_value = ((*local_this).read)(*param1_this);
        return Dtool_Return_Bool(return_value);
      }
    }
  }

  {
    // -2 bool EggData::read(Filename filename, std::string display_name = string())
    PyObject *param1;
    const char *param2_str = "";
    Py_ssize_t param2_len = 0;
    static const char *keyword_list[] = {"filename", "display_name", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#:read", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
      Filename param1_local;
      Filename *param1_this = Dtool_Coerce_Filename(param1, param1_local);
      if ((param1_this != nullptr)) {
        bool return_value = ((*local_this).read)(*param1_this, std::string(param2_str, param2_len));
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: bool EggData::read(std::istream &in)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read(const EggData self, Filename filename, str display_name)\n"
      "read(const EggData self, istream in)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggData_read_939_comment =
  "C++ Interface:\n"
  "read(const EggData self, Filename filename, str display_name)\n"
  "read(const EggData self, istream in)\n"
  "\n"
  "/**\n"
  " * Opens the indicated filename and reads the egg data contents from it.\n"
  " * Returns true if the file was successfully opened and read, false if there\n"
  " * were some errors, in which case the data may be partially read.\n"
  " *\n"
  " * error is the output stream to which to write error messages.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Parses the egg syntax contained in the indicated input stream.  Returns\n"
  " * true if the stream was a completely valid egg file, false if there were\n"
  " * some errors, in which case the data may be partially read.\n"
  " *\n"
  " * Before you call this routine, you should probably call set_egg_filename()\n"
  " * to set the name of the egg file we're processing, if at all possible.  If\n"
  " * there is no such filename, you may set it to the empty string.\n"
  " */";
#else
static const char *Dtool_EggData_read_939_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggData::merge(EggData &other)
 */
static PyObject *Dtool_EggData_merge_940(PyObject *self, PyObject *arg) {
  EggData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.merge")) {
    return nullptr;
  }
  // 1-void EggData::merge(EggData &other)
  EggData *arg_this = (EggData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggData, 1, "EggData.merge", false, true);
  if (arg_this != nullptr) {
    ((*local_this).merge)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "merge(const EggData self, EggData other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggData_merge_940_comment =
  "C++ Interface:\n"
  "merge(const EggData self, EggData other)\n"
  "\n"
  "/**\n"
  " * Appends the other egg structure to the end of this one.  The other egg\n"
  " * structure is invalidated.\n"
  " */";
#else
static const char *Dtool_EggData_merge_940_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggData::load_externals(DSearchPath const &searchpath = DSearchPath())
 * bool EggData::load_externals(DSearchPath const &searchpath, BamCacheRecord *record)
 */
static PyObject *Dtool_EggData_load_externals_941(PyObject *self, PyObject *args, PyObject *kwds) {
  EggData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.load_externals")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-bool EggData::load_externals(DSearchPath const &searchpath)
      bool return_value = ((*local_this).load_externals)();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "searchpath")) {
        // 1-bool EggData::load_externals(DSearchPath const &searchpath)
        DSearchPath arg_local;
        DSearchPath const *arg_this = Dtool_Coerce_DSearchPath(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "EggData.load_externals", "DSearchPath");
        }
        bool return_value = ((*local_this).load_externals)(*arg_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-bool EggData::load_externals(DSearchPath const &searchpath, BamCacheRecord *record)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"searchpath", "record", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:load_externals", (char **)keyword_list, &param1, &param2)) {
        DSearchPath param1_local;
        DSearchPath const *param1_this = Dtool_Coerce_DSearchPath(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "EggData.load_externals", "DSearchPath");
        }
        BamCacheRecord *param2_this = (BamCacheRecord *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_BamCacheRecord, 2, "EggData.load_externals", false, true);
        if (param2_this != nullptr) {
          bool return_value = ((*local_this).load_externals)(*param1_this, param2_this);
          return Dtool_Return_Bool(return_value);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "load_externals() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_externals(const EggData self)\n"
      "load_externals(const EggData self, const DSearchPath searchpath)\n"
      "load_externals(const EggData self, const DSearchPath searchpath, BamCacheRecord record)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggData_load_externals_941_comment =
  "C++ Interface:\n"
  "load_externals(const EggData self)\n"
  "load_externals(const EggData self, const DSearchPath searchpath)\n"
  "load_externals(const EggData self, const DSearchPath searchpath, BamCacheRecord record)\n"
  "\n"
  "/**\n"
  " * Loads up all the egg files referenced by <File> entries within the egg\n"
  " * structure, and inserts their contents in place of the <File> entries.\n"
  " * Searches for files in the searchpath, if not found directly, and writes\n"
  " * error messages to the indicated output stream.  Returns true if all\n"
  " * externals were loaded successfully, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Loads up all the egg files referenced by <File> entries within the egg\n"
  " * structure, and inserts their contents in place of the <File> entries.\n"
  " * Searches for files in the searchpath, if not found directly, and writes\n"
  " * error messages to the indicated output stream.  Returns true if all\n"
  " * externals were loaded successfully, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggData_load_externals_941_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int EggData::collapse_equivalent_textures(void)
 */
static PyObject *Dtool_EggData_collapse_equivalent_textures_942(PyObject *self, PyObject *) {
  EggData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.collapse_equivalent_textures")) {
    return nullptr;
  }
  // 1-int EggData::collapse_equivalent_textures(void)
  int return_value = ((*local_this).collapse_equivalent_textures)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggData_collapse_equivalent_textures_942_comment =
  "C++ Interface:\n"
  "collapse_equivalent_textures(const EggData self)\n"
  "\n"
  "/**\n"
  " * Removes duplicate references to the same texture image with the same\n"
  " * properties.  Considers two texture references with identical properties,\n"
  " * but different tref names, to be equivalent, and collapses them, choosing\n"
  " * one tref name to keep arbitrarily.  Returns the number of textures removed.\n"
  " */";
#else
static const char *Dtool_EggData_collapse_equivalent_textures_942_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int EggData::collapse_equivalent_materials(void)
 */
static PyObject *Dtool_EggData_collapse_equivalent_materials_943(PyObject *self, PyObject *) {
  EggData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.collapse_equivalent_materials")) {
    return nullptr;
  }
  // 1-int EggData::collapse_equivalent_materials(void)
  int return_value = ((*local_this).collapse_equivalent_materials)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggData_collapse_equivalent_materials_943_comment =
  "C++ Interface:\n"
  "collapse_equivalent_materials(const EggData self)\n"
  "\n"
  "/**\n"
  " * Removes duplicate references to the same material with the same properties.\n"
  " * Considers two material references with identical properties, but different\n"
  " * mref names, to be equivalent, and collapses them, choosing one mref name to\n"
  " * keep arbitrarily.  Returns the number of materials removed.\n"
  " */";
#else
static const char *Dtool_EggData_collapse_equivalent_materials_943_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggData::write_egg(Filename filename)
 * bool EggData::write_egg(std::ostream &out)
 */
static PyObject *Dtool_EggData_write_egg_944(PyObject *self, PyObject *arg) {
  EggData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.write_egg")) {
    return nullptr;
  }
  {
    // -2 bool EggData::write_egg(Filename filename)
    Filename *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Filename);
    if (arg_this != nullptr) {
      bool return_value = ((*local_this).write_egg)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 bool EggData::write_egg(std::ostream &out)
    std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "EggData.write_egg", false, false);
    if (arg_this != nullptr) {
      bool return_value = ((*local_this).write_egg)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 bool EggData::write_egg(Filename filename)
    Filename arg_local;
    Filename *arg_this = Dtool_Coerce_Filename(arg, arg_local);
    if ((arg_this != nullptr)) {
      bool return_value = ((*local_this).write_egg)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  // No coercion possible: bool EggData::write_egg(std::ostream &out)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_egg(const EggData self, Filename filename)\n"
      "write_egg(const EggData self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggData_write_egg_944_comment =
  "C++ Interface:\n"
  "write_egg(const EggData self, Filename filename)\n"
  "write_egg(const EggData self, ostream out)\n"
  "\n"
  "/**\n"
  " * The main interface for writing complete egg files.\n"
  " */\n"
  "\n"
  "/**\n"
  " * The main interface for writing complete egg files.\n"
  " */";
#else
static const char *Dtool_EggData_write_egg_944_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggData::set_auto_resolve_externals(bool resolve)
 */
static PyObject *Dtool_EggData_set_auto_resolve_externals_945(PyObject *self, PyObject *arg) {
  EggData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.set_auto_resolve_externals")) {
    return nullptr;
  }
  // 1-inline void EggData::set_auto_resolve_externals(bool resolve)
  ((*local_this).set_auto_resolve_externals)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_resolve_externals(const EggData self, bool resolve)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggData_set_auto_resolve_externals_945_comment =
  "C++ Interface:\n"
  "set_auto_resolve_externals(const EggData self, bool resolve)\n"
  "\n"
  "/**\n"
  " * Indicates whether the EggData object will automatically resolve any\n"
  " * external references when read() is called.  The default is false.\n"
  " */";
#else
static const char *Dtool_EggData_set_auto_resolve_externals_945_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggData::get_auto_resolve_externals(void) const
 */
static PyObject *Dtool_EggData_get_auto_resolve_externals_946(PyObject *self, PyObject *) {
  EggData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggData)) {
    return nullptr;
  }
  // 1-inline bool EggData::get_auto_resolve_externals(void) const
  bool return_value = ((*(const EggData*)local_this).get_auto_resolve_externals)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggData_get_auto_resolve_externals_946_comment =
  "C++ Interface:\n"
  "get_auto_resolve_externals(EggData self)\n"
  "\n"
  "/**\n"
  " * Indicates whether the EggData object will automatically resolve any\n"
  " * external references when read() is called.  The default is false.\n"
  " */";
#else
static const char *Dtool_EggData_get_auto_resolve_externals_946_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggData::original_had_absolute_pathnames(void) const
 */
static PyObject *Dtool_EggData_original_had_absolute_pathnames_947(PyObject *self, PyObject *) {
  EggData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggData)) {
    return nullptr;
  }
  // 1-inline bool EggData::original_had_absolute_pathnames(void) const
  bool return_value = ((*(const EggData*)local_this).original_had_absolute_pathnames)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggData_original_had_absolute_pathnames_947_comment =
  "C++ Interface:\n"
  "original_had_absolute_pathnames(EggData self)\n"
  "\n"
  "/**\n"
  " * Returns true if the data processed in the last call to read() contained\n"
  " * absolute pathnames, or false if those pathnames were all relative.\n"
  " *\n"
  " * This method is necessary because if auto_resolve_externals() is in effect,\n"
  " * it may modify the pathnames to be absolute whether or not they were as\n"
  " * loaded from disk.  This method can be used to query the state of the\n"
  " * original egg file from disk.\n"
  " */";
#else
static const char *Dtool_EggData_original_had_absolute_pathnames_947_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggData::set_coordinate_system(CoordinateSystem coordsys)
 */
static PyObject *Dtool_EggData_set_coordinate_system_948(PyObject *self, PyObject *arg) {
  EggData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.set_coordinate_system")) {
    return nullptr;
  }
  // 1-void EggData::set_coordinate_system(CoordinateSystem coordsys)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_coordinate_system)((CoordinateSystem)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_coordinate_system(const EggData self, int coordsys)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggData_set_coordinate_system_948_comment =
  "C++ Interface:\n"
  "set_coordinate_system(const EggData self, int coordsys)\n"
  "\n"
  "/**\n"
  " * Changes the coordinate system of the EggData.  If the coordinate system was\n"
  " * previously different, this may result in a conversion of the data.\n"
  " */";
#else
static const char *Dtool_EggData_set_coordinate_system_948_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CoordinateSystem EggData::get_coordinate_system(void) const
 */
static PyObject *Dtool_EggData_get_coordinate_system_949(PyObject *self, PyObject *) {
  EggData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggData)) {
    return nullptr;
  }
  // 1-inline CoordinateSystem EggData::get_coordinate_system(void) const
  CoordinateSystem return_value = ((*(const EggData*)local_this).get_coordinate_system)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggData_get_coordinate_system_949_comment =
  "C++ Interface:\n"
  "get_coordinate_system(EggData self)\n"
  "\n"
  "/**\n"
  " * Returns the coordinate system in which the egg file is defined.\n"
  " */";
#else
static const char *Dtool_EggData_get_coordinate_system_949_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggData::set_egg_filename(Filename const &egg_filename)
 */
static PyObject *Dtool_EggData_set_egg_filename_950(PyObject *self, PyObject *arg) {
  EggData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.set_egg_filename")) {
    return nullptr;
  }
  // 1-inline void EggData::set_egg_filename(Filename const &egg_filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggData.set_egg_filename", "Filename");
  }
  ((*local_this).set_egg_filename)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_egg_filename(const EggData self, const Filename egg_filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggData_set_egg_filename_950_comment =
  "C++ Interface:\n"
  "set_egg_filename(const EggData self, const Filename egg_filename)\n"
  "\n"
  "/**\n"
  " * Sets the filename--especially the directory part--in which the egg file is\n"
  " * considered to reside.  This is also implicitly set by read().\n"
  " */";
#else
static const char *Dtool_EggData_set_egg_filename_950_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &EggData::get_egg_filename(void) const
 */
static PyObject *Dtool_EggData_get_egg_filename_951(PyObject *self, PyObject *) {
  EggData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggData)) {
    return nullptr;
  }
  // 1-inline Filename const &EggData::get_egg_filename(void) const
  Filename const *return_value = &(((*(const EggData*)local_this).get_egg_filename)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_EggData_get_egg_filename_951_comment =
  "C++ Interface:\n"
  "get_egg_filename(EggData self)\n"
  "\n"
  "/**\n"
  " * Returns the directory in which the egg file is considered to reside.\n"
  " */";
#else
static const char *Dtool_EggData_get_egg_filename_951_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggData::set_egg_timestamp(time_t egg_timestamp)
 */
static PyObject *Dtool_EggData_set_egg_timestamp_952(PyObject *self, PyObject *arg) {
  EggData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.set_egg_timestamp")) {
    return nullptr;
  }
  // 1-inline void EggData::set_egg_timestamp(time_t egg_timestamp)
  if (PyLongOrInt_Check(arg)) {
    ((*local_this).set_egg_timestamp)(PyLongOrInt_AS_LONG(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_egg_timestamp(const EggData self, int egg_timestamp)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggData_set_egg_timestamp_952_comment =
  "C++ Interface:\n"
  "set_egg_timestamp(const EggData self, int egg_timestamp)\n"
  "\n"
  "/**\n"
  " * Sets the timestamp of the egg file on disk, at the time it was opened for\n"
  " * reading.  This is also implicitly set by read().\n"
  " */";
#else
static const char *Dtool_EggData_set_egg_timestamp_952_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline time_t EggData::get_egg_timestamp(void) const
 */
static PyObject *Dtool_EggData_get_egg_timestamp_953(PyObject *self, PyObject *) {
  EggData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggData)) {
    return nullptr;
  }
  // 1-inline time_t EggData::get_egg_timestamp(void) const
  time_t return_value = ((*(const EggData*)local_this).get_egg_timestamp)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggData_get_egg_timestamp_953_comment =
  "C++ Interface:\n"
  "get_egg_timestamp(EggData self)\n"
  "\n"
  "/**\n"
  " * Returns the timestamp of the egg file on disk, at the time it was opened\n"
  " * for reading, or 0 if this information is not available.\n"
  " */";
#else
static const char *Dtool_EggData_get_egg_timestamp_953_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggData::recompute_vertex_normals(double threshold)
 */
static PyObject *Dtool_EggData_recompute_vertex_normals_961(PyObject *self, PyObject *arg) {
  EggData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.recompute_vertex_normals")) {
    return nullptr;
  }
  // 1-inline void EggData::recompute_vertex_normals(double threshold)
  if (PyNumber_Check(arg)) {
    ((*local_this).recompute_vertex_normals)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "recompute_vertex_normals(const EggData self, double threshold)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggData_recompute_vertex_normals_961_comment =
  "C++ Interface:\n"
  "recompute_vertex_normals(const EggData self, double threshold)\n"
  "\n"
  "/**\n"
  " * Recomputes all the vertex normals for polygon geometry at this group node\n"
  " * and below so that they accurately reflect the vertex positions.  A shared\n"
  " * edge between two polygons (even in different groups) is considered smooth\n"
  " * if the angle between the two edges is less than threshold degrees.\n"
  " *\n"
  " * This function also removes degenerate polygons that do not have enough\n"
  " * vertices to define a normal.  It does not affect normals for other kinds of\n"
  " * primitives like Nurbs or Points.\n"
  " *\n"
  " * This function does not remove or adjust vertices in the vertex pool; it\n"
  " * only adds new vertices with the correct normals.  Thus, it is a good idea\n"
  " * to call remove_unused_vertices() after calling this.\n"
  " */";
#else
static const char *Dtool_EggData_recompute_vertex_normals_961_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggData::recompute_polygon_normals(void)
 */
static PyObject *Dtool_EggData_recompute_polygon_normals_962(PyObject *self, PyObject *) {
  EggData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.recompute_polygon_normals")) {
    return nullptr;
  }
  // 1-inline void EggData::recompute_polygon_normals(void)
  ((*local_this).recompute_polygon_normals)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggData_recompute_polygon_normals_962_comment =
  "C++ Interface:\n"
  "recompute_polygon_normals(const EggData self)\n"
  "\n"
  "/**\n"
  " * Recomputes all the polygon normals for polygon geometry at this group node\n"
  " * and below so that they accurately reflect the vertex positions.  Normals\n"
  " * are removed from the vertices and defined only on polygons, giving the\n"
  " * geometry a faceted appearance.\n"
  " *\n"
  " * This function also removes degenerate polygons that do not have enough\n"
  " * vertices to define a normal.  It does not affect normals for other kinds of\n"
  " * primitives like Nurbs or Points.\n"
  " *\n"
  " * This function does not remove or adjust vertices in the vertex pool; it\n"
  " * only adds new vertices with the normals removed.  Thus, it is a good idea\n"
  " * to call remove_unused_vertices() after calling this.\n"
  " */";
#else
static const char *Dtool_EggData_recompute_polygon_normals_962_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggData::strip_normals(void)
 */
static PyObject *Dtool_EggData_strip_normals_963(PyObject *self, PyObject *) {
  EggData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.strip_normals")) {
    return nullptr;
  }
  // 1-inline void EggData::strip_normals(void)
  ((*local_this).strip_normals)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggData_strip_normals_963_comment =
  "C++ Interface:\n"
  "strip_normals(const EggData self)\n"
  "\n"
  "/**\n"
  " * Removes all normals from primitives, and the vertices they reference, at\n"
  " * this node and below.\n"
  " *\n"
  " * This function does not remove or adjust vertices in the vertex pool; it\n"
  " * only adds new vertices with the normal removed.  Thus, it is a good idea to\n"
  " * call remove_unused_vertices() after calling this.\n"
  " */";
#else
static const char *Dtool_EggData_strip_normals_963_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggData::get_class_type(void)
 */
static PyObject *Dtool_EggData_get_class_type_964(PyObject *, PyObject *) {
  // 1-static TypeHandle EggData::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggData::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggData_get_class_type_964_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggData_get_class_type_964_comment = nullptr;
#endif

static PyObject *Dtool_EggData_auto_resolve_externals_Getter(PyObject *self, void *) {
  const EggData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool EggData::get_auto_resolve_externals(void) const
  bool return_value = ((*(const EggData*)local_this).get_auto_resolve_externals)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggData_auto_resolve_externals_Setter(PyObject *self, PyObject *arg, void *) {
  EggData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.auto_resolve_externals")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete auto_resolve_externals attribute");
    return -1;
  }
  // 1-inline void EggData::set_auto_resolve_externals(bool resolve)
  ((*local_this).set_auto_resolve_externals)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_auto_resolve_externals(const EggData self, bool resolve)\n");
  }
  return -1;
}

static PyObject *Dtool_EggData_coordinate_system_Getter(PyObject *self, void *) {
  const EggData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline CoordinateSystem EggData::get_coordinate_system(void) const
  CoordinateSystem return_value = ((*(const EggData*)local_this).get_coordinate_system)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggData_coordinate_system_Setter(PyObject *self, PyObject *arg, void *) {
  EggData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.coordinate_system")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete coordinate_system attribute");
    return -1;
  }
  // 1-void EggData::set_coordinate_system(CoordinateSystem coordsys)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_coordinate_system)((CoordinateSystem)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_coordinate_system(const EggData self, int coordsys)\n");
  }
  return -1;
}

static PyObject *Dtool_EggData_egg_filename_Getter(PyObject *self, void *) {
  const EggData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Filename const &EggData::get_egg_filename(void) const
  Filename const *return_value = &(((*(const EggData*)local_this).get_egg_filename)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

static int Dtool_EggData_egg_filename_Setter(PyObject *self, PyObject *arg, void *) {
  EggData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.egg_filename")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete egg_filename attribute");
    return -1;
  }
  // 1-inline void EggData::set_egg_filename(Filename const &egg_filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "EggData.set_egg_filename", "Filename");
    return -1;
  }
  ((*local_this).set_egg_filename)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_egg_filename(const EggData self, const Filename egg_filename)\n");
  }
  return -1;
}

static PyObject *Dtool_EggData_egg_timestamp_Getter(PyObject *self, void *) {
  const EggData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline time_t EggData::get_egg_timestamp(void) const
  time_t return_value = ((*(const EggData*)local_this).get_egg_timestamp)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggData_egg_timestamp_Setter(PyObject *self, PyObject *arg, void *) {
  EggData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggData, (void **)&local_this, "EggData.egg_timestamp")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete egg_timestamp attribute");
    return -1;
  }
  // 1-inline void EggData::set_egg_timestamp(time_t egg_timestamp)
  if (PyLongOrInt_Check(arg)) {
    ((*local_this).set_egg_timestamp)(PyLongOrInt_AS_LONG(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_egg_timestamp(const EggData self, int egg_timestamp)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline EggData::EggData(void)
 * inline EggData::EggData(EggData const &copy)
 */
static int Dtool_Init_EggData(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline EggData::EggData(void)
      EggData *return_value = new EggData();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggData, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-inline EggData::EggData(EggData const &copy)
        EggData const *arg_this = (EggData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggData, 0, "EggData.EggData", true, true);
        if (arg_this != nullptr) {
          EggData *return_value = new EggData(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggData, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggData() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggData()\n"
      "EggData(const EggData copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggData) {
    printf("EggData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggData *local_this = (EggData *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggData) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggGroupNode) {
    return (EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggData) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggGroupNode) {
    EggGroupNode* other_this = (EggGroupNode*)from_this;
    return (EggData*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggData*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggData*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggData*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggData*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggData*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggCoordinateSystem
 */
/**
 * Python function wrapper for:
 * inline void EggCoordinateSystem::set_value(CoordinateSystem value)
 */
static PyObject *Dtool_EggCoordinateSystem_set_value_968(PyObject *self, PyObject *arg) {
  EggCoordinateSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggCoordinateSystem, (void **)&local_this, "EggCoordinateSystem.set_value")) {
    return nullptr;
  }
  // 1-inline void EggCoordinateSystem::set_value(CoordinateSystem value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_value)((CoordinateSystem)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const EggCoordinateSystem self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggCoordinateSystem_set_value_968_comment =
  "C++ Interface:\n"
  "set_value(const EggCoordinateSystem self, int value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggCoordinateSystem_set_value_968_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CoordinateSystem EggCoordinateSystem::get_value(void) const
 */
static PyObject *Dtool_EggCoordinateSystem_get_value_969(PyObject *self, PyObject *) {
  EggCoordinateSystem *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggCoordinateSystem)) {
    return nullptr;
  }
  // 1-inline CoordinateSystem EggCoordinateSystem::get_value(void) const
  CoordinateSystem return_value = ((*(const EggCoordinateSystem*)local_this).get_value)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggCoordinateSystem_get_value_969_comment =
  "C++ Interface:\n"
  "get_value(EggCoordinateSystem self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggCoordinateSystem_get_value_969_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggCoordinateSystem::get_class_type(void)
 */
static PyObject *Dtool_EggCoordinateSystem_get_class_type_970(PyObject *, PyObject *) {
  // 1-static TypeHandle EggCoordinateSystem::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggCoordinateSystem::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggCoordinateSystem_get_class_type_970_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggCoordinateSystem_get_class_type_970_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggCoordinateSystem::EggCoordinateSystem(CoordinateSystem value = ::CS_default)
 * inline EggCoordinateSystem::EggCoordinateSystem(EggCoordinateSystem const &copy)
 */
static int Dtool_Init_EggCoordinateSystem(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline EggCoordinateSystem::EggCoordinateSystem(CoordinateSystem value)
      EggCoordinateSystem *return_value = new EggCoordinateSystem();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggCoordinateSystem, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline EggCoordinateSystem::EggCoordinateSystem(EggCoordinateSystem const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          EggCoordinateSystem const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_EggCoordinateSystem);
          if (param0_this != nullptr) {
            EggCoordinateSystem *return_value = new EggCoordinateSystem(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggCoordinateSystem, true, false);
          }
        }
      }

      {
        // -2 inline EggCoordinateSystem::EggCoordinateSystem(CoordinateSystem value)
        int param0;
        static const char *keyword_list[] = {"value", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:EggCoordinateSystem", (char **)keyword_list, &param0)) {
          EggCoordinateSystem *return_value = new EggCoordinateSystem((CoordinateSystem)param0);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggCoordinateSystem, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline EggCoordinateSystem::EggCoordinateSystem(EggCoordinateSystem const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          CPT(EggCoordinateSystem) param0_this;
          if (Dtool_ConstCoerce_EggCoordinateSystem(param0, param0_this)) {
            EggCoordinateSystem *return_value = new EggCoordinateSystem(*std::move(param0_this));
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggCoordinateSystem, true, false);
          }
        }
      }

      // No coercion possible: inline EggCoordinateSystem::EggCoordinateSystem(CoordinateSystem value)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggCoordinateSystem() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggCoordinateSystem()\n"
      "EggCoordinateSystem(const EggCoordinateSystem copy)\n"
      "EggCoordinateSystem(int value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_EggCoordinateSystem(PyObject *args, CPT(EggCoordinateSystem) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_EggCoordinateSystem)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline EggCoordinateSystem::EggCoordinateSystem(CoordinateSystem value)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      EggCoordinateSystem *return_value = new EggCoordinateSystem((CoordinateSystem)arg_val);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_EggCoordinateSystem(PyObject *args, PT(EggCoordinateSystem) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_EggCoordinateSystem)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline EggCoordinateSystem::EggCoordinateSystem(CoordinateSystem value)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      EggCoordinateSystem *return_value = new EggCoordinateSystem((CoordinateSystem)arg_val);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_EggCoordinateSystem(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggCoordinateSystem) {
    printf("EggCoordinateSystem ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggCoordinateSystem *local_this = (EggCoordinateSystem *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggCoordinateSystem) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggCoordinateSystem(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggCoordinateSystem) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggCoordinateSystem*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggCoordinateSystem*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggCoordinateSystem*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggCoordinateSystem*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggCoordinateSystem*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggCoordinateSystem*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggCoordinateSystem*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggCurve
 */
/**
 * Python function wrapper for:
 * inline void EggCurve::operator =(EggCurve const &copy)
 */
static PyObject *Dtool_EggCurve_operator_973(PyObject *self, PyObject *arg) {
  EggCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggCurve, (void **)&local_this, "EggCurve.assign")) {
    return nullptr;
  }
  // 1-inline void EggCurve::operator =(EggCurve const &copy)
  EggCurve const *arg_this = (EggCurve *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggCurve, 1, "EggCurve.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggCurve *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggCurve, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggCurve self, const EggCurve copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggCurve_operator_973_comment =
  "C++ Interface:\n"
  "assign(const EggCurve self, const EggCurve copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggCurve_operator_973_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggCurve::set_subdiv(int subdiv)
 */
static PyObject *Dtool_EggCurve_set_subdiv_975(PyObject *self, PyObject *arg) {
  EggCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggCurve, (void **)&local_this, "EggCurve.set_subdiv")) {
    return nullptr;
  }
  // 1-inline void EggCurve::set_subdiv(int subdiv)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_subdiv)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdiv(const EggCurve self, int subdiv)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggCurve_set_subdiv_975_comment =
  "C++ Interface:\n"
  "set_subdiv(const EggCurve self, int subdiv)\n"
  "\n"
  "/**\n"
  " * Sets the number of subdivisions that will be requested across the curve.\n"
  " * (This doesn't necessary guarantee that this number of subdivisions will be\n"
  " * made; it's just a hint to any curve renderer or quick tesselator.)  Set the\n"
  " * number to 0 to disable the hint.\n"
  " */";
#else
static const char *Dtool_EggCurve_set_subdiv_975_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggCurve::get_subdiv(void) const
 */
static PyObject *Dtool_EggCurve_get_subdiv_976(PyObject *self, PyObject *) {
  EggCurve *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggCurve)) {
    return nullptr;
  }
  // 1-inline int EggCurve::get_subdiv(void) const
  int return_value = ((*(const EggCurve*)local_this).get_subdiv)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggCurve_get_subdiv_976_comment =
  "C++ Interface:\n"
  "get_subdiv(EggCurve self)\n"
  "\n"
  "/**\n"
  " * Returns the requested number of subdivisions, or 0 if no particular\n"
  " * subdivisions have been requested.\n"
  " */";
#else
static const char *Dtool_EggCurve_get_subdiv_976_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggCurve::set_curve_type(EggCurve::CurveType type)
 */
static PyObject *Dtool_EggCurve_set_curve_type_977(PyObject *self, PyObject *arg) {
  EggCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggCurve, (void **)&local_this, "EggCurve.set_curve_type")) {
    return nullptr;
  }
  // 1-inline void EggCurve::set_curve_type(EggCurve::CurveType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_curve_type)((EggCurve::CurveType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_curve_type(const EggCurve self, int type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggCurve_set_curve_type_977_comment =
  "C++ Interface:\n"
  "set_curve_type(const EggCurve self, int type)\n"
  "\n"
  "/**\n"
  " * Sets the type of the curve.  This is primarily used as a hint to any code\n"
  " * that may need to deal with this curve.\n"
  " */";
#else
static const char *Dtool_EggCurve_set_curve_type_977_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggCurve::CurveType EggCurve::get_curve_type(void) const
 */
static PyObject *Dtool_EggCurve_get_curve_type_978(PyObject *self, PyObject *) {
  EggCurve *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggCurve)) {
    return nullptr;
  }
  // 1-inline EggCurve::CurveType EggCurve::get_curve_type(void) const
  EggCurve::CurveType return_value = ((*(const EggCurve*)local_this).get_curve_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggCurve_get_curve_type_978_comment =
  "C++ Interface:\n"
  "get_curve_type(EggCurve self)\n"
  "\n"
  "/**\n"
  " * Returns the indicated type of the curve.\n"
  " */";
#else
static const char *Dtool_EggCurve_get_curve_type_978_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static EggCurve::CurveType EggCurve::string_curve_type(std::string const &string)
 */
static PyObject *Dtool_EggCurve_string_curve_type_979(PyObject *, PyObject *arg) {
  // 1-static EggCurve::CurveType EggCurve::string_curve_type(std::string const &string)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    EggCurve::CurveType return_value = (EggCurve::string_curve_type)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_curve_type(str string)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggCurve_string_curve_type_979_comment =
  "C++ Interface:\n"
  "string_curve_type(str string)\n"
  "\n"
  "/**\n"
  " * Returns the CurveType value associated with the given string\n"
  " * representation, or CT_invalid if the string does not match any known\n"
  " * CurveType value.\n"
  " */";
#else
static const char *Dtool_EggCurve_string_curve_type_979_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggCurve::get_class_type(void)
 */
static PyObject *Dtool_EggCurve_get_class_type_980(PyObject *, PyObject *) {
  // 1-static TypeHandle EggCurve::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggCurve::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggCurve_get_class_type_980_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggCurve_get_class_type_980_comment = nullptr;
#endif

static int Dtool_Init_EggCurve(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_EggCurve(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggCurve) {
    printf("EggCurve ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggCurve *local_this = (EggCurve *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggCurve) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggAttributes) {
    return (EggAttributes *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggPrimitive) {
    return (EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return (EggRenderMode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggCurve(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggCurve) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggAttributes) {
    EggAttributes* other_this = (EggAttributes*)from_this;
    return (EggCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_EggPrimitive) {
    EggPrimitive* other_this = (EggPrimitive*)from_this;
    return (EggCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    EggRenderMode* other_this = (EggRenderMode*)from_this;
    return (EggCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggCurve*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggExternalReference
 */
/**
 * Python function wrapper for:
 * void EggExternalReference::operator =(EggExternalReference const &copy)
 */
static PyObject *Dtool_EggExternalReference_operator_984(PyObject *self, PyObject *arg) {
  EggExternalReference *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggExternalReference, (void **)&local_this, "EggExternalReference.assign")) {
    return nullptr;
  }
  // 1-void EggExternalReference::operator =(EggExternalReference const &copy)
  EggExternalReference const *arg_this = (EggExternalReference *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggExternalReference, 1, "EggExternalReference.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggExternalReference *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggExternalReference, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggExternalReference self, const EggExternalReference copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggExternalReference_operator_984_comment =
  "C++ Interface:\n"
  "assign(const EggExternalReference self, const EggExternalReference copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggExternalReference_operator_984_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggExternalReference::get_class_type(void)
 */
static PyObject *Dtool_EggExternalReference_get_class_type_985(PyObject *, PyObject *) {
  // 1-static TypeHandle EggExternalReference::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggExternalReference::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggExternalReference_get_class_type_985_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggExternalReference_get_class_type_985_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggExternalReference::EggExternalReference(EggExternalReference const &copy)
 * explicit EggExternalReference::EggExternalReference(std::string const &node_name, std::string const &filename)
 */
static int Dtool_Init_EggExternalReference(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-EggExternalReference::EggExternalReference(EggExternalReference const &copy)
        EggExternalReference const *arg_this = (EggExternalReference *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggExternalReference, 0, "EggExternalReference.EggExternalReference", true, true);
        if (arg_this != nullptr) {
          EggExternalReference *return_value = new EggExternalReference(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggExternalReference, true, false);
        }
      }
    }
    break;
  case 2:
    {
      // 1-explicit EggExternalReference::EggExternalReference(std::string const &node_name, std::string const &filename)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      static const char *keyword_list[] = {"node_name", "filename", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:EggExternalReference", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len)) {
        EggExternalReference *return_value = new EggExternalReference(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggExternalReference, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggExternalReference() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggExternalReference(const EggExternalReference copy)\n"
      "EggExternalReference(str node_name, str filename)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggExternalReference(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggExternalReference) {
    printf("EggExternalReference ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggExternalReference *local_this = (EggExternalReference *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggExternalReference) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggFilenameNode) {
    return (EggFilenameNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggFilenameNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggFilenameNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggFilenameNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggFilenameNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggFilenameNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggFilenameNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggFilenameNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggExternalReference(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggExternalReference) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggFilenameNode) {
    EggFilenameNode* other_this = (EggFilenameNode*)from_this;
    return (EggExternalReference*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggExternalReference*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggExternalReference*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggExternalReference*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggExternalReference*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggExternalReference*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggExternalReference*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggExternalReference*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggNameUniquifier
 */
/**
 * Python function wrapper for:
 * void EggNameUniquifier::clear(void)
 */
static PyObject *Dtool_EggNameUniquifier_clear_988(PyObject *self, PyObject *) {
  EggNameUniquifier *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNameUniquifier, (void **)&local_this, "EggNameUniquifier.clear")) {
    return nullptr;
  }
  // 1-void EggNameUniquifier::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggNameUniquifier_clear_988_comment =
  "C++ Interface:\n"
  "clear(const EggNameUniquifier self)\n"
  "\n"
  "/**\n"
  " * Empties the table of used named and prepares the Uniquifier for a new tree.\n"
  " */";
#else
static const char *Dtool_EggNameUniquifier_clear_988_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggNameUniquifier::uniquify(EggNode *node)
 */
static PyObject *Dtool_EggNameUniquifier_uniquify_989(PyObject *self, PyObject *arg) {
  EggNameUniquifier *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNameUniquifier, (void **)&local_this, "EggNameUniquifier.uniquify")) {
    return nullptr;
  }
  // 1-void EggNameUniquifier::uniquify(EggNode *node)
  EggNode *arg_this = (EggNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggNode, 1, "EggNameUniquifier.uniquify", false, true);
  if (arg_this != nullptr) {
    ((*local_this).uniquify)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "uniquify(const EggNameUniquifier self, EggNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNameUniquifier_uniquify_989_comment =
  "C++ Interface:\n"
  "uniquify(const EggNameUniquifier self, EggNode node)\n"
  "\n"
  "/**\n"
  " * Begins the traversal from the indicated node.\n"
  " */";
#else
static const char *Dtool_EggNameUniquifier_uniquify_989_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggNode *EggNameUniquifier::get_node(std::string const &category, std::string const &name) const
 */
static PyObject *Dtool_EggNameUniquifier_get_node_990(PyObject *self, PyObject *args, PyObject *kwds) {
  EggNameUniquifier *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNameUniquifier)) {
    return nullptr;
  }
  // 1-EggNode *EggNameUniquifier::get_node(std::string const &category, std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"category", "name", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:get_node", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
    EggNode *return_value = ((*(const EggNameUniquifier*)local_this).get_node)(std::string(param1_str, param1_len), std::string(param2_str, param2_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggNode, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_node(EggNameUniquifier self, str category, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNameUniquifier_get_node_990_comment =
  "C++ Interface:\n"
  "get_node(EggNameUniquifier self, str category, str name)\n"
  "\n"
  "/**\n"
  " * Returns the node associated with the given category and name, or NULL if\n"
  " * the name has not been used.\n"
  " */";
#else
static const char *Dtool_EggNameUniquifier_get_node_990_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggNameUniquifier::has_name(std::string const &category, std::string const &name) const
 */
static PyObject *Dtool_EggNameUniquifier_has_name_991(PyObject *self, PyObject *args, PyObject *kwds) {
  EggNameUniquifier *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNameUniquifier)) {
    return nullptr;
  }
  // 1-bool EggNameUniquifier::has_name(std::string const &category, std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"category", "name", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:has_name", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
    bool return_value = ((*(const EggNameUniquifier*)local_this).has_name)(std::string(param1_str, param1_len), std::string(param2_str, param2_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_name(EggNameUniquifier self, str category, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNameUniquifier_has_name_991_comment =
  "C++ Interface:\n"
  "has_name(EggNameUniquifier self, str category, str name)\n"
  "\n"
  "/**\n"
  " * Returns true if the name has been used for the indicated category already,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_EggNameUniquifier_has_name_991_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggNameUniquifier::add_name(std::string const &category, std::string const &name, EggNode *node = nullptr)
 */
static PyObject *Dtool_EggNameUniquifier_add_name_992(PyObject *self, PyObject *args, PyObject *kwds) {
  EggNameUniquifier *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNameUniquifier, (void **)&local_this, "EggNameUniquifier.add_name")) {
    return nullptr;
  }
  // 1-bool EggNameUniquifier::add_name(std::string const &category, std::string const &name, EggNode *node = nullptr)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  PyObject *param3 = nullptr;
  static const char *keyword_list[] = {"category", "name", "node", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#|O:add_name", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
    EggNode *param3_this = nullptr;
    if (param3 != nullptr && param3 != Py_None) {
      param3_this = (EggNode *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_EggNode, 3, "EggNameUniquifier.add_name", false, true);
    }
    if ((param3 == nullptr || param3 == Py_None || param3_this != nullptr)) {
      bool return_value = ((*local_this).add_name)(std::string(param1_str, param1_len), std::string(param2_str, param2_len), param3_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_name(const EggNameUniquifier self, str category, str name, EggNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNameUniquifier_add_name_992_comment =
  "C++ Interface:\n"
  "add_name(const EggNameUniquifier self, str category, str name, EggNode node)\n"
  "\n"
  "/**\n"
  " * Adds the name to the indicated category.  This name will not be used for\n"
  " * any other egg node within this category.  Returns true if the name was\n"
  " * added, or false if it was already in use for the category.\n"
  " */";
#else
static const char *Dtool_EggNameUniquifier_add_name_992_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual std::string EggNameUniquifier::get_category(EggNode *node) = 0
 */
static PyObject *Dtool_EggNameUniquifier_get_category_993(PyObject *self, PyObject *arg) {
  EggNameUniquifier *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNameUniquifier, (void **)&local_this, "EggNameUniquifier.get_category")) {
    return nullptr;
  }
  // 1-virtual std::string EggNameUniquifier::get_category(EggNode *node) = 0
  EggNode *arg_this = (EggNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggNode, 1, "EggNameUniquifier.get_category", false, true);
  if (arg_this != nullptr) {
    std::string return_value = ((*local_this).get_category)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_category(const EggNameUniquifier self, EggNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNameUniquifier_get_category_993_comment =
  "C++ Interface:\n"
  "get_category(const EggNameUniquifier self, EggNode node)\n";
#else
static const char *Dtool_EggNameUniquifier_get_category_993_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual std::string EggNameUniquifier::filter_name(EggNode *node)
 */
static PyObject *Dtool_EggNameUniquifier_filter_name_994(PyObject *self, PyObject *arg) {
  EggNameUniquifier *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNameUniquifier, (void **)&local_this, "EggNameUniquifier.filter_name")) {
    return nullptr;
  }
  // 1-virtual std::string EggNameUniquifier::filter_name(EggNode *node)
  EggNode *arg_this = (EggNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggNode, 1, "EggNameUniquifier.filter_name", false, true);
  if (arg_this != nullptr) {
    std::string return_value = ((*local_this).filter_name)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "filter_name(const EggNameUniquifier self, EggNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNameUniquifier_filter_name_994_comment =
  "C++ Interface:\n"
  "filter_name(const EggNameUniquifier self, EggNode node)\n"
  "\n"
  "/**\n"
  " * Returns the name of the given node, or at least the name it should be.\n"
  " * This provides a hook to adjust the name before attempting to uniquify it,\n"
  " * if desired, for instance to remove invalid characters.\n"
  " */";
#else
static const char *Dtool_EggNameUniquifier_filter_name_994_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual std::string EggNameUniquifier::generate_name(EggNode *node, std::string const &category, int index)
 */
static PyObject *Dtool_EggNameUniquifier_generate_name_995(PyObject *self, PyObject *args, PyObject *kwds) {
  EggNameUniquifier *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNameUniquifier, (void **)&local_this, "EggNameUniquifier.generate_name")) {
    return nullptr;
  }
  // 1-virtual std::string EggNameUniquifier::generate_name(EggNode *node, std::string const &category, int index)
  PyObject *param1;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  int param3;
  static const char *keyword_list[] = {"node", "category", "index", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#i:generate_name", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3)) {
    EggNode *param1_this = (EggNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_EggNode, 1, "EggNameUniquifier.generate_name", false, true);
    if (param1_this != nullptr) {
      std::string return_value = ((*local_this).generate_name)(param1_this, std::string(param2_str, param2_len), (int)param3);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "generate_name(const EggNameUniquifier self, EggNode node, str category, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNameUniquifier_generate_name_995_comment =
  "C++ Interface:\n"
  "generate_name(const EggNameUniquifier self, EggNode node, str category, int index)\n"
  "\n"
  "/**\n"
  " * Generates a new name for the given node when its existing name clashes with\n"
  " * some other node.  This function will be called repeatedly, if necessary,\n"
  " * until it returns a name that actually is unique.\n"
  " *\n"
  " * The category is the string returned by get_category(), and index is a\n"
  " * uniquely-generated number that may be useful for synthesizing the name.\n"
  " */";
#else
static const char *Dtool_EggNameUniquifier_generate_name_995_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggNameUniquifier::get_class_type(void)
 */
static PyObject *Dtool_EggNameUniquifier_get_class_type_996(PyObject *, PyObject *) {
  // 1-static TypeHandle EggNameUniquifier::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggNameUniquifier::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggNameUniquifier_get_class_type_996_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggNameUniquifier_get_class_type_996_comment = nullptr;
#endif

static int Dtool_Init_EggNameUniquifier(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_EggNameUniquifier(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggNameUniquifier) {
    printf("EggNameUniquifier ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggNameUniquifier *local_this = (EggNameUniquifier *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggNameUniquifier) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggNameUniquifier(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggNameUniquifier) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggNameUniquifier*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggNameUniquifier*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggNameUniquifier*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggNameUniquifier*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggGroupUniquifier
 */
/**
 * Python function wrapper for:
 * static TypeHandle EggGroupUniquifier::get_class_type(void)
 */
static PyObject *Dtool_EggGroupUniquifier_get_class_type_999(PyObject *, PyObject *) {
  // 1-static TypeHandle EggGroupUniquifier::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggGroupUniquifier::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggGroupUniquifier_get_class_type_999_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggGroupUniquifier_get_class_type_999_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit EggGroupUniquifier::EggGroupUniquifier(bool filter_names = true)
 */
static int Dtool_Init_EggGroupUniquifier(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-explicit EggGroupUniquifier::EggGroupUniquifier(bool filter_names = true)
  PyObject *param0 = Py_True;
  if (Dtool_ExtractOptionalArg(&param0, args, kwds, "filter_names")) {
    EggGroupUniquifier *return_value = new EggGroupUniquifier((PyObject_IsTrue(param0) != 0));
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggGroupUniquifier, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggGroupUniquifier(bool filter_names)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggGroupUniquifier(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggGroupUniquifier) {
    printf("EggGroupUniquifier ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggGroupUniquifier *local_this = (EggGroupUniquifier *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggGroupUniquifier) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggNameUniquifier) {
    return (EggNameUniquifier *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNameUniquifier *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNameUniquifier *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNameUniquifier *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNameUniquifier *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggGroupUniquifier(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggGroupUniquifier) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggNameUniquifier) {
    EggNameUniquifier* other_this = (EggNameUniquifier*)from_this;
    return (EggGroupUniquifier*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggGroupUniquifier*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggGroupUniquifier*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggGroupUniquifier*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggGroupUniquifier*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggLine
 */
/**
 * Python function wrapper for:
 * inline void EggLine::operator =(EggLine const &copy)
 */
static PyObject *Dtool_EggLine_operator_1003(PyObject *self, PyObject *arg) {
  EggLine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggLine, (void **)&local_this, "EggLine.assign")) {
    return nullptr;
  }
  // 1-inline void EggLine::operator =(EggLine const &copy)
  EggLine const *arg_this = (EggLine *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggLine, 1, "EggLine.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggLine *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggLine, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggLine self, const EggLine copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggLine_operator_1003_comment =
  "C++ Interface:\n"
  "assign(const EggLine self, const EggLine copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggLine_operator_1003_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggLine::has_thick(void) const
 */
static PyObject *Dtool_EggLine_has_thick_1004(PyObject *self, PyObject *) {
  EggLine *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggLine)) {
    return nullptr;
  }
  // 1-inline bool EggLine::has_thick(void) const
  bool return_value = ((*(const EggLine*)local_this).has_thick)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggLine_has_thick_1004_comment =
  "C++ Interface:\n"
  "has_thick(EggLine self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggLine_has_thick_1004_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double EggLine::get_thick(void) const
 */
static PyObject *Dtool_EggLine_get_thick_1005(PyObject *self, PyObject *) {
  EggLine *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggLine)) {
    return nullptr;
  }
  // 1-inline double EggLine::get_thick(void) const
  double return_value = ((*(const EggLine*)local_this).get_thick)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggLine_get_thick_1005_comment =
  "C++ Interface:\n"
  "get_thick(EggLine self)\n"
  "\n"
  "/**\n"
  " * Returns the thickness set on this particular line.  If there is no\n"
  " * thickness set, returns 1.0.\n"
  " */";
#else
static const char *Dtool_EggLine_get_thick_1005_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggLine::set_thick(double thick)
 */
static PyObject *Dtool_EggLine_set_thick_1006(PyObject *self, PyObject *arg) {
  EggLine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggLine, (void **)&local_this, "EggLine.set_thick")) {
    return nullptr;
  }
  // 1-inline void EggLine::set_thick(double thick)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_thick)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_thick(const EggLine self, double thick)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggLine_set_thick_1006_comment =
  "C++ Interface:\n"
  "set_thick(const EggLine self, double thick)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggLine_set_thick_1006_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggLine::clear_thick(void)
 */
static PyObject *Dtool_EggLine_clear_thick_1007(PyObject *self, PyObject *) {
  EggLine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggLine, (void **)&local_this, "EggLine.clear_thick")) {
    return nullptr;
  }
  // 1-inline void EggLine::clear_thick(void)
  ((*local_this).clear_thick)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggLine_clear_thick_1007_comment =
  "C++ Interface:\n"
  "clear_thick(const EggLine self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggLine_clear_thick_1007_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggLine::get_class_type(void)
 */
static PyObject *Dtool_EggLine_get_class_type_1008(PyObject *, PyObject *) {
  // 1-static TypeHandle EggLine::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggLine::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggLine_get_class_type_1008_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggLine_get_class_type_1008_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggLine::EggLine(EggLine const &copy)
 * inline explicit EggLine::EggLine(std::string const &name = "")
 */
static int Dtool_Init_EggLine(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline explicit EggLine::EggLine(std::string const &name)
      EggLine *return_value = new EggLine();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggLine, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline EggLine::EggLine(EggLine const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          EggLine const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_EggLine);
          if (param0_this != nullptr) {
            EggLine *return_value = new EggLine(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggLine, true, false);
          }
        }
      }

      {
        // -2 inline explicit EggLine::EggLine(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:EggLine", (char **)keyword_list, &param0_str, &param0_len)) {
          EggLine *return_value = new EggLine(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggLine, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline EggLine::EggLine(EggLine const &copy)
      // No coercion possible: inline explicit EggLine::EggLine(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggLine() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggLine()\n"
      "EggLine(const EggLine copy)\n"
      "EggLine(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggLine(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggLine) {
    printf("EggLine ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggLine *local_this = (EggLine *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggLine) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggAttributes) {
    return (EggAttributes *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggCompositePrimitive) {
    return (EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggPrimitive) {
    return (EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return (EggRenderMode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggLine(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggLine) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggAttributes) {
    EggAttributes* other_this = (EggAttributes*)from_this;
    return (EggLine*)other_this;
  }
  if (from_type == Dtool_Ptr_EggCompositePrimitive) {
    EggCompositePrimitive* other_this = (EggCompositePrimitive*)from_this;
    return (EggLine*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggLine*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggLine*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggLine*)other_this;
  }
  if (from_type == Dtool_Ptr_EggPrimitive) {
    EggPrimitive* other_this = (EggPrimitive*)from_this;
    return (EggLine*)other_this;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    EggRenderMode* other_this = (EggRenderMode*)from_this;
    return (EggLine*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggLine*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggLine*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggLine*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggLine*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggMaterialCollection
 */
/**
 * Python function wrapper for:
 * void EggMaterialCollection::operator =(EggMaterialCollection const &copy)
 */
static PyObject *Dtool_EggMaterialCollection_operator_1011(PyObject *self, PyObject *arg) {
  EggMaterialCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterialCollection, (void **)&local_this, "EggMaterialCollection.assign")) {
    return nullptr;
  }
  // 1-void EggMaterialCollection::operator =(EggMaterialCollection const &copy)
  EggMaterialCollection const *arg_this = (EggMaterialCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggMaterialCollection, 1, "EggMaterialCollection.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggMaterialCollection *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggMaterialCollection, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggMaterialCollection self, const EggMaterialCollection copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterialCollection_operator_1011_comment =
  "C++ Interface:\n"
  "assign(const EggMaterialCollection self, const EggMaterialCollection copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggMaterialCollection_operator_1011_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggMaterialCollection::clear(void)
 */
static PyObject *Dtool_EggMaterialCollection_clear_1013(PyObject *self, PyObject *) {
  EggMaterialCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterialCollection, (void **)&local_this, "EggMaterialCollection.clear")) {
    return nullptr;
  }
  // 1-void EggMaterialCollection::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggMaterialCollection_clear_1013_comment =
  "C++ Interface:\n"
  "clear(const EggMaterialCollection self)\n"
  "\n"
  "/**\n"
  " * Removes all materials from the collection.\n"
  " */";
#else
static const char *Dtool_EggMaterialCollection_clear_1013_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int EggMaterialCollection::extract_materials(EggGroupNode *node)
 */
static PyObject *Dtool_EggMaterialCollection_extract_materials_1014(PyObject *self, PyObject *arg) {
  EggMaterialCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterialCollection, (void **)&local_this, "EggMaterialCollection.extract_materials")) {
    return nullptr;
  }
  // 1-int EggMaterialCollection::extract_materials(EggGroupNode *node)
  EggGroupNode *arg_this = (EggGroupNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggGroupNode, 1, "EggMaterialCollection.extract_materials", false, true);
  if (arg_this != nullptr) {
    int return_value = ((*local_this).extract_materials)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extract_materials(const EggMaterialCollection self, EggGroupNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterialCollection_extract_materials_1014_comment =
  "C++ Interface:\n"
  "extract_materials(const EggMaterialCollection self, EggGroupNode node)\n"
  "\n"
  "/**\n"
  " * Walks the egg hierarchy beginning at the indicated node, and removes any\n"
  " * EggMaterials encountered in the hierarchy, adding them to the collection.\n"
  " * Returns the number of EggMaterials encountered.\n"
  " */";
#else
static const char *Dtool_EggMaterialCollection_extract_materials_1014_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int EggMaterialCollection::find_used_materials(EggNode *node)
 */
static PyObject *Dtool_EggMaterialCollection_find_used_materials_1015(PyObject *self, PyObject *arg) {
  EggMaterialCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterialCollection, (void **)&local_this, "EggMaterialCollection.find_used_materials")) {
    return nullptr;
  }
  // 1-int EggMaterialCollection::find_used_materials(EggNode *node)
  EggNode *arg_this = (EggNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggNode, 1, "EggMaterialCollection.find_used_materials", false, true);
  if (arg_this != nullptr) {
    int return_value = ((*local_this).find_used_materials)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_used_materials(const EggMaterialCollection self, EggNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterialCollection_find_used_materials_1015_comment =
  "C++ Interface:\n"
  "find_used_materials(const EggMaterialCollection self, EggNode node)\n"
  "\n"
  "/**\n"
  " * Walks the egg hierarchy beginning at the indicated node, looking for\n"
  " * materials that are referenced by primitives but are not already members of\n"
  " * the collection, adding them to the collection.\n"
  " *\n"
  " * If this is called following extract_materials(), it can be used to pick up\n"
  " * any additional material references that appeared in the egg hierarchy (but\n"
  " * whose EggMaterial node was not actually part of the hierarchy).\n"
  " *\n"
  " * If this is called in lieu of extract_materials(), it will fill up the\n"
  " * collection with all of the referenced materials (and only the referenced\n"
  " * materials), without destructively removing the EggMaterials from the\n"
  " * hierarchy.\n"
  " *\n"
  " * This also has the side effect of incrementing the internal usage count for\n"
  " * a material in the collection each time a material reference is encountered.\n"
  " * This side effect is taken advantage of by remove_unused_materials().\n"
  " */";
#else
static const char *Dtool_EggMaterialCollection_find_used_materials_1015_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggMaterialCollection::remove_unused_materials(EggNode *node)
 */
static PyObject *Dtool_EggMaterialCollection_remove_unused_materials_1016(PyObject *self, PyObject *arg) {
  EggMaterialCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterialCollection, (void **)&local_this, "EggMaterialCollection.remove_unused_materials")) {
    return nullptr;
  }
  // 1-void EggMaterialCollection::remove_unused_materials(EggNode *node)
  EggNode *arg_this = (EggNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggNode, 1, "EggMaterialCollection.remove_unused_materials", false, true);
  if (arg_this != nullptr) {
    ((*local_this).remove_unused_materials)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_unused_materials(const EggMaterialCollection self, EggNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterialCollection_remove_unused_materials_1016_comment =
  "C++ Interface:\n"
  "remove_unused_materials(const EggMaterialCollection self, EggNode node)\n"
  "\n"
  "/**\n"
  " * Removes any materials from the collection that aren't referenced by any\n"
  " * primitives in the indicated egg hierarchy.  This also, incidentally, adds\n"
  " * materials to the collection that had been referenced by primitives but had\n"
  " * not previously appeared in the collection.\n"
  " */";
#else
static const char *Dtool_EggMaterialCollection_remove_unused_materials_1016_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int EggMaterialCollection::collapse_equivalent_materials(int eq, EggGroupNode *node)
 * Rejected Remap [int EggMaterialCollection::collapse_equivalent_materials(int eq, EggMaterialCollection::MaterialReplacement &removed)]
 */
static PyObject *Dtool_EggMaterialCollection_collapse_equivalent_materials_1017(PyObject *self, PyObject *args, PyObject *kwds) {
  EggMaterialCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterialCollection, (void **)&local_this, "EggMaterialCollection.collapse_equivalent_materials")) {
    return nullptr;
  }
  // 1-int EggMaterialCollection::collapse_equivalent_materials(int eq, EggGroupNode *node)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"eq", "node", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:collapse_equivalent_materials", (char **)keyword_list, &param1, &param2)) {
    EggGroupNode *param2_this = (EggGroupNode *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_EggGroupNode, 2, "EggMaterialCollection.collapse_equivalent_materials", false, true);
    if (param2_this != nullptr) {
      int return_value = ((*local_this).collapse_equivalent_materials)((int)param1, param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "collapse_equivalent_materials(const EggMaterialCollection self, int eq, EggGroupNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterialCollection_collapse_equivalent_materials_1017_comment =
  "C++ Interface:\n"
  "collapse_equivalent_materials(const EggMaterialCollection self, int eq, EggGroupNode node)\n"
  "\n"
  "/**\n"
  " * Walks through the collection and collapses together any separate materials\n"
  " * that are equivalent according to the indicated equivalence factor, eq (see\n"
  " * EggMaterial::is_equivalent_to()).  The return value is the number of\n"
  " * materials removed.\n"
  " *\n"
  " * This flavor of collapse_equivalent_materials() automatically adjusts all\n"
  " * the primitives in the egg hierarchy to refer to the new material pointers.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Walks through the collection and collapses together any separate materials\n"
  " * that are equivalent according to the indicated equivalence factor, eq (see\n"
  " * EggMaterial::is_equivalent_to()).  The return value is the number of\n"
  " * materials removed.\n"
  " *\n"
  " * This flavor of collapse_equivalent_materials() does not adjust any\n"
  " * primitives in the egg hierarchy; instead, it fills up the 'removed' map\n"
  " * with an entry for each removed material, mapping it back to the equivalent\n"
  " * retained material.  It's up to the user to then call replace_materials()\n"
  " * with this map, if desired, to apply these changes to the egg hierarchy.\n"
  " */";
#else
static const char *Dtool_EggMaterialCollection_collapse_equivalent_materials_1017_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggMaterialCollection::uniquify_mrefs(void)
 */
static PyObject *Dtool_EggMaterialCollection_uniquify_mrefs_1019(PyObject *self, PyObject *) {
  EggMaterialCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterialCollection, (void **)&local_this, "EggMaterialCollection.uniquify_mrefs")) {
    return nullptr;
  }
  // 1-void EggMaterialCollection::uniquify_mrefs(void)
  ((*local_this).uniquify_mrefs)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggMaterialCollection_uniquify_mrefs_1019_comment =
  "C++ Interface:\n"
  "uniquify_mrefs(const EggMaterialCollection self)\n"
  "\n"
  "/**\n"
  " * Guarantees that each material in the collection has a unique MRef name.\n"
  " * This is essential before writing an egg file.\n"
  " */";
#else
static const char *Dtool_EggMaterialCollection_uniquify_mrefs_1019_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggMaterialCollection::sort_by_mref(void)
 */
static PyObject *Dtool_EggMaterialCollection_sort_by_mref_1020(PyObject *self, PyObject *) {
  EggMaterialCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterialCollection, (void **)&local_this, "EggMaterialCollection.sort_by_mref")) {
    return nullptr;
  }
  // 1-void EggMaterialCollection::sort_by_mref(void)
  ((*local_this).sort_by_mref)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggMaterialCollection_sort_by_mref_1020_comment =
  "C++ Interface:\n"
  "sort_by_mref(const EggMaterialCollection self)\n"
  "\n"
  "/**\n"
  " * Sorts all the materials into alphabetical order by MRef name.  Subsequent\n"
  " * operations using begin()/end() will traverse in this sorted order.\n"
  " */";
#else
static const char *Dtool_EggMaterialCollection_sort_by_mref_1020_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggMaterialCollection::add_material(EggMaterial *material)
 */
static PyObject *Dtool_EggMaterialCollection_add_material_1021(PyObject *self, PyObject *arg) {
  EggMaterialCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterialCollection, (void **)&local_this, "EggMaterialCollection.add_material")) {
    return nullptr;
  }
  // 1-bool EggMaterialCollection::add_material(EggMaterial *material)
  EggMaterial *arg_this = (EggMaterial *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggMaterial, 1, "EggMaterialCollection.add_material", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).add_material)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_material(const EggMaterialCollection self, EggMaterial material)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterialCollection_add_material_1021_comment =
  "C++ Interface:\n"
  "add_material(const EggMaterialCollection self, EggMaterial material)\n"
  "\n"
  "/**\n"
  " * Explicitly adds a new material to the collection.  Returns true if the\n"
  " * material was added, false if it was already there or if there was some\n"
  " * error.\n"
  " */";
#else
static const char *Dtool_EggMaterialCollection_add_material_1021_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggMaterialCollection::remove_material(EggMaterial *material)
 */
static PyObject *Dtool_EggMaterialCollection_remove_material_1022(PyObject *self, PyObject *arg) {
  EggMaterialCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterialCollection, (void **)&local_this, "EggMaterialCollection.remove_material")) {
    return nullptr;
  }
  // 1-bool EggMaterialCollection::remove_material(EggMaterial *material)
  EggMaterial *arg_this = (EggMaterial *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggMaterial, 1, "EggMaterialCollection.remove_material", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).remove_material)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_material(const EggMaterialCollection self, EggMaterial material)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterialCollection_remove_material_1022_comment =
  "C++ Interface:\n"
  "remove_material(const EggMaterialCollection self, EggMaterial material)\n"
  "\n"
  "/**\n"
  " * Explicitly removes a material from the collection.  Returns true if the\n"
  " * material was removed, false if it wasn't there or if there was some error.\n"
  " */";
#else
static const char *Dtool_EggMaterialCollection_remove_material_1022_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggMaterial *EggMaterialCollection::create_unique_material(EggMaterial const &copy, int eq)
 */
static PyObject *Dtool_EggMaterialCollection_create_unique_material_1023(PyObject *self, PyObject *args, PyObject *kwds) {
  EggMaterialCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggMaterialCollection, (void **)&local_this, "EggMaterialCollection.create_unique_material")) {
    return nullptr;
  }
  // 1-EggMaterial *EggMaterialCollection::create_unique_material(EggMaterial const &copy, int eq)
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"copy", "eq", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:create_unique_material", (char **)keyword_list, &param1, &param2)) {
    EggMaterial const *param1_this = (EggMaterial *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_EggMaterial, 1, "EggMaterialCollection.create_unique_material", true, true);
    if (param1_this != nullptr) {
      EggMaterial *return_value = ((*local_this).create_unique_material)(*param1_this, (int)param2);
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggMaterial, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "create_unique_material(const EggMaterialCollection self, const EggMaterial copy, int eq)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterialCollection_create_unique_material_1023_comment =
  "C++ Interface:\n"
  "create_unique_material(const EggMaterialCollection self, const EggMaterial copy, int eq)\n"
  "\n"
  "// create_unique_material() creates a new material if there is not already\n"
  "// one equivalent (according to eq, see EggMaterial::is_equivalent_to()) to\n"
  "// the indicated material, or returns the existing one if there is.\n"
  "\n"
  "/**\n"
  " * Creates a new material if there is not already one equivalent (according to\n"
  " * eq, see EggMaterial::is_equivalent_to()) to the indicated material, or\n"
  " * returns the existing one if there is.\n"
  " */";
#else
static const char *Dtool_EggMaterialCollection_create_unique_material_1023_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggMaterial *EggMaterialCollection::find_mref(std::string const &mref_name) const
 */
static PyObject *Dtool_EggMaterialCollection_find_mref_1024(PyObject *self, PyObject *arg) {
  EggMaterialCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggMaterialCollection)) {
    return nullptr;
  }
  // 1-EggMaterial *EggMaterialCollection::find_mref(std::string const &mref_name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    EggMaterial *return_value = ((*(const EggMaterialCollection*)local_this).find_mref)(std::string(param1_str, param1_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggMaterial, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_mref(EggMaterialCollection self, str mref_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggMaterialCollection_find_mref_1024_comment =
  "C++ Interface:\n"
  "find_mref(EggMaterialCollection self, str mref_name)\n"
  "\n"
  "// Find a material with a particular MRef name.\n"
  "\n"
  "/**\n"
  " * Returns the material with the indicated MRef name, or NULL if no material\n"
  " * matches.\n"
  " */";
#else
static const char *Dtool_EggMaterialCollection_find_mref_1024_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggMaterialCollection::EggMaterialCollection(void)
 * EggMaterialCollection::EggMaterialCollection(EggMaterialCollection const &copy)
 */
static int Dtool_Init_EggMaterialCollection(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-EggMaterialCollection::EggMaterialCollection(void)
      EggMaterialCollection *return_value = new EggMaterialCollection();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggMaterialCollection, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-EggMaterialCollection::EggMaterialCollection(EggMaterialCollection const &copy)
        EggMaterialCollection const *arg_this = (EggMaterialCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggMaterialCollection, 0, "EggMaterialCollection.EggMaterialCollection", true, true);
        if (arg_this != nullptr) {
          EggMaterialCollection *return_value = new EggMaterialCollection(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggMaterialCollection, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggMaterialCollection() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggMaterialCollection()\n"
      "EggMaterialCollection(const EggMaterialCollection copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggMaterialCollection(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggMaterialCollection) {
    printf("EggMaterialCollection ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggMaterialCollection *local_this = (EggMaterialCollection *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggMaterialCollection) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggMaterialCollection(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggMaterialCollection) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggPolygon
 */
/**
 * Python function wrapper for:
 * inline void EggPolygon::operator =(EggPolygon const &copy)
 */
static PyObject *Dtool_EggPolygon_operator_1027(PyObject *self, PyObject *arg) {
  EggPolygon *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPolygon, (void **)&local_this, "EggPolygon.assign")) {
    return nullptr;
  }
  // 1-inline void EggPolygon::operator =(EggPolygon const &copy)
  EggPolygon const *arg_this = (EggPolygon *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggPolygon, 1, "EggPolygon.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggPolygon *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggPolygon, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggPolygon self, const EggPolygon copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggPolygon_operator_1027_comment =
  "C++ Interface:\n"
  "assign(const EggPolygon self, const EggPolygon copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggPolygon_operator_1027_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggPolygon::calculate_normal(LNormald &result, CoordinateSystem cs = ::CS_default) const
 */
static PyObject *Dtool_EggPolygon_calculate_normal_1028(PyObject *self, PyObject *args, PyObject *kwds) {
  EggPolygon *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggPolygon)) {
    return nullptr;
  }
  // 1-bool EggPolygon::calculate_normal(LNormald &result, CoordinateSystem cs = ::CS_default) const
  PyObject *param1;
  int param2 = ::CS_default;
  static const char *keyword_list[] = {"result", "cs", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:calculate_normal", (char **)keyword_list, &param1, &param2)) {
    LVector3d param1_local;
    LNormald *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "EggPolygon.calculate_normal", "LVector3d");
    }
    bool return_value = ((*(const EggPolygon*)local_this).calculate_normal)(*param1_this, (CoordinateSystem)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calculate_normal(EggPolygon self, LVector3d result, int cs)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggPolygon_calculate_normal_1028_comment =
  "C++ Interface:\n"
  "calculate_normal(EggPolygon self, LVector3d result, int cs)\n"
  "\n"
  "/**\n"
  " * Calculates the true polygon normal--the vector pointing out of the front of\n"
  " * the polygon--based on the vertices.  This does not return or change the\n"
  " * polygon's normal as set via set_normal().\n"
  " *\n"
  " * The return value is true if the normal is computed correctly, or false if\n"
  " * the polygon is degenerate and does not have at least three noncollinear\n"
  " * vertices.\n"
  " */";
#else
static const char *Dtool_EggPolygon_calculate_normal_1028_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggPolygon::is_planar(void) const
 */
static PyObject *Dtool_EggPolygon_is_planar_1029(PyObject *self, PyObject *) {
  EggPolygon *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggPolygon)) {
    return nullptr;
  }
  // 1-bool EggPolygon::is_planar(void) const
  bool return_value = ((*(const EggPolygon*)local_this).is_planar)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPolygon_is_planar_1029_comment =
  "C++ Interface:\n"
  "is_planar(EggPolygon self)\n"
  "\n"
  "/**\n"
  " * Returns true if all of the polygon's vertices lie within the same plane,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_EggPolygon_is_planar_1029_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggPolygon::recompute_polygon_normal(CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_EggPolygon_recompute_polygon_normal_1030(PyObject *self, PyObject *args, PyObject *kwds) {
  EggPolygon *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPolygon, (void **)&local_this, "EggPolygon.recompute_polygon_normal")) {
    return nullptr;
  }
  // 1-inline bool EggPolygon::recompute_polygon_normal(CoordinateSystem cs = ::CS_default)
  int param1 = ::CS_default;
  static const char *keyword_list[] = {"cs", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:recompute_polygon_normal", (char **)keyword_list, &param1)) {
    bool return_value = ((*local_this).recompute_polygon_normal)((CoordinateSystem)param1);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "recompute_polygon_normal(const EggPolygon self, int cs)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggPolygon_recompute_polygon_normal_1030_comment =
  "C++ Interface:\n"
  "recompute_polygon_normal(const EggPolygon self, int cs)\n"
  "\n"
  "/**\n"
  " * Recalculates the normal according to the order of the vertices, and sets\n"
  " * it.  Returns true if the normal is computed correctly, or false if the\n"
  " * polygon is degenerate and does not have a normal.\n"
  " */";
#else
static const char *Dtool_EggPolygon_recompute_polygon_normal_1030_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggPolygon::triangulate_into(EggGroupNode *container, bool convex_also) const
 */
static PyObject *Dtool_EggPolygon_triangulate_into_1031(PyObject *self, PyObject *args, PyObject *kwds) {
  EggPolygon *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggPolygon)) {
    return nullptr;
  }
  // 1-inline bool EggPolygon::triangulate_into(EggGroupNode *container, bool convex_also) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"container", "convex_also", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:triangulate_into", (char **)keyword_list, &param1, &param2)) {
    EggGroupNode *param1_this = (EggGroupNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_EggGroupNode, 1, "EggPolygon.triangulate_into", false, true);
    if (param1_this != nullptr) {
      bool return_value = ((*(const EggPolygon*)local_this).triangulate_into)(param1_this, (PyObject_IsTrue(param2) != 0));
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "triangulate_into(EggPolygon self, EggGroupNode container, bool convex_also)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggPolygon_triangulate_into_1031_comment =
  "C++ Interface:\n"
  "triangulate_into(EggPolygon self, EggGroupNode container, bool convex_also)\n"
  "\n"
  "/**\n"
  " * Subdivides the polygon into triangles and adds each one to the indicated\n"
  " * container.  If the polygon is already a triangle, adds an exact copy of the\n"
  " * polygon to the container.  Does not remove the polygon from its existing\n"
  " * parent or modify it in any way.\n"
  " *\n"
  " * Returns true if the triangulation is successful, or false if there was some\n"
  " * error (in which case the container may contain some partial triangulation).\n"
  " *\n"
  " * If convex_also is true, both concave and convex polygons will be subdivided\n"
  " * into triangles; otherwise, only concave polygons will be subdivided, and\n"
  " * convex polygons will be copied unchanged into the container.\n"
  " */";
#else
static const char *Dtool_EggPolygon_triangulate_into_1031_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< EggPolygon > EggPolygon::triangulate_in_place(bool convex_also)
 */
static PyObject *Dtool_EggPolygon_triangulate_in_place_1032(PyObject *self, PyObject *arg) {
  EggPolygon *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPolygon, (void **)&local_this, "EggPolygon.triangulate_in_place")) {
    return nullptr;
  }
  // 1-PointerTo< EggPolygon > EggPolygon::triangulate_in_place(bool convex_also)
  PointerTo< EggPolygon > return_value = ((*local_this).triangulate_in_place)((PyObject_IsTrue(arg) != 0));
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  EggPolygon *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_EggPolygon, true, false, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "triangulate_in_place(const EggPolygon self, bool convex_also)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggPolygon_triangulate_in_place_1032_comment =
  "C++ Interface:\n"
  "triangulate_in_place(const EggPolygon self, bool convex_also)\n"
  "\n"
  "/**\n"
  " * Subdivides the polygon into triangles and adds those triangles to the\n"
  " * parent group node in place of the original polygon.  Returns a pointer to\n"
  " * the original polygon, which is likely about to be destructed.\n"
  " *\n"
  " * If convex_also is true, both concave and convex polygons will be subdivided\n"
  " * into triangles; otherwise, only concave polygons will be subdivided, and\n"
  " * convex polygons will be copied unchanged into the container.\n"
  " */";
#else
static const char *Dtool_EggPolygon_triangulate_in_place_1032_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggPolygon::get_class_type(void)
 */
static PyObject *Dtool_EggPolygon_get_class_type_1033(PyObject *, PyObject *) {
  // 1-static TypeHandle EggPolygon::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggPolygon::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggPolygon_get_class_type_1033_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggPolygon_get_class_type_1033_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggPolygon::EggPolygon(EggPolygon const &copy)
 * inline explicit EggPolygon::EggPolygon(std::string const &name = "")
 */
static int Dtool_Init_EggPolygon(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline explicit EggPolygon::EggPolygon(std::string const &name)
      EggPolygon *return_value = new EggPolygon();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggPolygon, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline EggPolygon::EggPolygon(EggPolygon const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          EggPolygon const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_EggPolygon);
          if (param0_this != nullptr) {
            EggPolygon *return_value = new EggPolygon(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggPolygon, true, false);
          }
        }
      }

      {
        // -2 inline explicit EggPolygon::EggPolygon(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:EggPolygon", (char **)keyword_list, &param0_str, &param0_len)) {
          EggPolygon *return_value = new EggPolygon(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggPolygon, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline EggPolygon::EggPolygon(EggPolygon const &copy)
      // No coercion possible: inline explicit EggPolygon::EggPolygon(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggPolygon() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggPolygon()\n"
      "EggPolygon(const EggPolygon copy)\n"
      "EggPolygon(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggPolygon(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggPolygon) {
    printf("EggPolygon ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggPolygon *local_this = (EggPolygon *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggPolygon) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggAttributes) {
    return (EggAttributes *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggPrimitive) {
    return (EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return (EggRenderMode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggPolygon(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggPolygon) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggAttributes) {
    EggAttributes* other_this = (EggAttributes*)from_this;
    return (EggPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_EggPrimitive) {
    EggPrimitive* other_this = (EggPrimitive*)from_this;
    return (EggPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    EggRenderMode* other_this = (EggRenderMode*)from_this;
    return (EggPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggPolygon*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggNurbsCurve
 */
/**
 * Python function wrapper for:
 * inline void EggNurbsCurve::operator =(EggNurbsCurve const &copy)
 */
static PyObject *Dtool_EggNurbsCurve_operator_1037(PyObject *self, PyObject *arg) {
  EggNurbsCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsCurve, (void **)&local_this, "EggNurbsCurve.assign")) {
    return nullptr;
  }
  // 1-inline void EggNurbsCurve::operator =(EggNurbsCurve const &copy)
  EggNurbsCurve const *arg_this = (EggNurbsCurve *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggNurbsCurve, 1, "EggNurbsCurve.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggNurbsCurve *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggNurbsCurve, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggNurbsCurve self, const EggNurbsCurve copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsCurve_operator_1037_comment =
  "C++ Interface:\n"
  "assign(const EggNurbsCurve self, const EggNurbsCurve copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggNurbsCurve_operator_1037_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggNurbsCurve::setup(int order, int num_knots)
 */
static PyObject *Dtool_EggNurbsCurve_setup_1038(PyObject *self, PyObject *args, PyObject *kwds) {
  EggNurbsCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsCurve, (void **)&local_this, "EggNurbsCurve.setup")) {
    return nullptr;
  }
  // 1-void EggNurbsCurve::setup(int order, int num_knots)
  int param1;
  int param2;
  static const char *keyword_list[] = {"order", "num_knots", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:setup", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).setup)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup(const EggNurbsCurve self, int order, int num_knots)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsCurve_setup_1038_comment =
  "C++ Interface:\n"
  "setup(const EggNurbsCurve self, int order, int num_knots)\n"
  "\n"
  "/**\n"
  " * Prepares a new curve definition with the indicated order and number of\n"
  " * knots.  This also implies a particular number of vertices as well (the\n"
  " * number of knots minus the order), but it is up to the user to add the\n"
  " * correct number of vertices to the curve by repeatedly calling push_back().\n"
  " */";
#else
static const char *Dtool_EggNurbsCurve_setup_1038_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggNurbsCurve::set_order(int order)
 */
static PyObject *Dtool_EggNurbsCurve_set_order_1039(PyObject *self, PyObject *arg) {
  EggNurbsCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsCurve, (void **)&local_this, "EggNurbsCurve.set_order")) {
    return nullptr;
  }
  // 1-inline void EggNurbsCurve::set_order(int order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_order)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_order(const EggNurbsCurve self, int order)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsCurve_set_order_1039_comment =
  "C++ Interface:\n"
  "set_order(const EggNurbsCurve self, int order)\n"
  "\n"
  "/**\n"
  " * Directly changes the order to the indicated value (which must be an integer\n"
  " * in the range 1 <= order <= 4).  If possible, it is preferable to use the\n"
  " * setup() method instead of this method, since changing the order directly\n"
  " * may result in an invalid curve.\n"
  " */";
#else
static const char *Dtool_EggNurbsCurve_set_order_1039_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggNurbsCurve::set_num_knots(int num)
 */
static PyObject *Dtool_EggNurbsCurve_set_num_knots_1040(PyObject *self, PyObject *arg) {
  EggNurbsCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsCurve, (void **)&local_this, "EggNurbsCurve.set_num_knots")) {
    return nullptr;
  }
  // 1-void EggNurbsCurve::set_num_knots(int num)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_num_knots)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_knots(const EggNurbsCurve self, int num)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsCurve_set_num_knots_1040_comment =
  "C++ Interface:\n"
  "set_num_knots(const EggNurbsCurve self, int num)\n"
  "\n"
  "/**\n"
  " * Directly changes the number of knots.  This will either add zero-valued\n"
  " * knots onto the end, or truncate knot values from the end, depending on\n"
  " * whether the list is being increased or decreased.  If possible, it is\n"
  " * preferable to use the setup() method instead of directly setting the number\n"
  " * of knots, as this may result in an invalid curve.\n"
  " */";
#else
static const char *Dtool_EggNurbsCurve_set_num_knots_1040_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggNurbsCurve::set_knot(int k, double value)
 */
static PyObject *Dtool_EggNurbsCurve_set_knot_1041(PyObject *self, PyObject *args, PyObject *kwds) {
  EggNurbsCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsCurve, (void **)&local_this, "EggNurbsCurve.set_knot")) {
    return nullptr;
  }
  // 1-inline void EggNurbsCurve::set_knot(int k, double value)
  int param1;
  double param2;
  static const char *keyword_list[] = {"k", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "id:set_knot", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_knot)((int)param1, (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_knot(const EggNurbsCurve self, int k, double value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsCurve_set_knot_1041_comment =
  "C++ Interface:\n"
  "set_knot(const EggNurbsCurve self, int k, double value)\n"
  "\n"
  "/**\n"
  " * Resets the value of the indicated knot as indicated.  k must be in the\n"
  " * range 0 <= k < get_num_knots(), and the value must be in the range\n"
  " * get_knot(k - 1) <= value <= get_knot(k + 1).\n"
  " */";
#else
static const char *Dtool_EggNurbsCurve_set_knot_1041_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggNurbsCurve::is_valid(void) const
 */
static PyObject *Dtool_EggNurbsCurve_is_valid_1042(PyObject *self, PyObject *) {
  EggNurbsCurve *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNurbsCurve)) {
    return nullptr;
  }
  // 1-bool EggNurbsCurve::is_valid(void) const
  bool return_value = ((*(const EggNurbsCurve*)local_this).is_valid)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsCurve_is_valid_1042_comment =
  "C++ Interface:\n"
  "is_valid(EggNurbsCurve self)\n"
  "\n"
  "/**\n"
  " * Returns true if the NURBS parameters are all internally consistent (e.g.\n"
  " * it has the right number of vertices to match its number of knots and order\n"
  " * in each dimension), or false otherwise.\n"
  " */";
#else
static const char *Dtool_EggNurbsCurve_is_valid_1042_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsCurve::get_order(void) const
 */
static PyObject *Dtool_EggNurbsCurve_get_order_1043(PyObject *self, PyObject *) {
  EggNurbsCurve *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNurbsCurve)) {
    return nullptr;
  }
  // 1-inline int EggNurbsCurve::get_order(void) const
  int return_value = ((*(const EggNurbsCurve*)local_this).get_order)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsCurve_get_order_1043_comment =
  "C++ Interface:\n"
  "get_order(EggNurbsCurve self)\n"
  "\n"
  "/**\n"
  " * Returns the order of the curve.  The order is the degree of the NURBS\n"
  " * equation plus 1; for a typical NURBS, the order is 4.  With this\n"
  " * implementation of NURBS, the order must be in the range [1, 4].\n"
  " */";
#else
static const char *Dtool_EggNurbsCurve_get_order_1043_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsCurve::get_degree(void) const
 */
static PyObject *Dtool_EggNurbsCurve_get_degree_1044(PyObject *self, PyObject *) {
  EggNurbsCurve *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNurbsCurve)) {
    return nullptr;
  }
  // 1-inline int EggNurbsCurve::get_degree(void) const
  int return_value = ((*(const EggNurbsCurve*)local_this).get_degree)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsCurve_get_degree_1044_comment =
  "C++ Interface:\n"
  "get_degree(EggNurbsCurve self)\n"
  "\n"
  "/**\n"
  " * Returns the degree of the curve.  For a typical NURBS, the degree is 3.\n"
  " */";
#else
static const char *Dtool_EggNurbsCurve_get_degree_1044_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsCurve::get_num_knots(void) const
 */
static PyObject *Dtool_EggNurbsCurve_get_num_knots_1045(PyObject *self, PyObject *) {
  EggNurbsCurve *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNurbsCurve)) {
    return nullptr;
  }
  // 1-inline int EggNurbsCurve::get_num_knots(void) const
  int return_value = ((*(const EggNurbsCurve*)local_this).get_num_knots)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsCurve_get_num_knots_1045_comment =
  "C++ Interface:\n"
  "get_num_knots(EggNurbsCurve self)\n"
  "\n"
  "/**\n"
  " * Returns the number of knots.\n"
  " */";
#else
static const char *Dtool_EggNurbsCurve_get_num_knots_1045_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsCurve::get_num_cvs(void) const
 */
static PyObject *Dtool_EggNurbsCurve_get_num_cvs_1046(PyObject *self, PyObject *) {
  EggNurbsCurve *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNurbsCurve)) {
    return nullptr;
  }
  // 1-inline int EggNurbsCurve::get_num_cvs(void) const
  int return_value = ((*(const EggNurbsCurve*)local_this).get_num_cvs)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsCurve_get_num_cvs_1046_comment =
  "C++ Interface:\n"
  "get_num_cvs(EggNurbsCurve self)\n"
  "\n"
  "/**\n"
  " * Returns the total number of control vertices that *should* be defined for\n"
  " * the curve.  This is determined by the number of knots and the order, in\n"
  " * each direction; it does not necessarily reflect the number of vertices that\n"
  " * have actually been added to the curve.  (However, if the number of vertices\n"
  " * in the curve are wrong, the curve is invalid.)\n"
  " */";
#else
static const char *Dtool_EggNurbsCurve_get_num_cvs_1046_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggNurbsCurve::is_closed(void) const
 */
static PyObject *Dtool_EggNurbsCurve_is_closed_1047(PyObject *self, PyObject *) {
  EggNurbsCurve *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNurbsCurve)) {
    return nullptr;
  }
  // 1-bool EggNurbsCurve::is_closed(void) const
  bool return_value = ((*(const EggNurbsCurve*)local_this).is_closed)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsCurve_is_closed_1047_comment =
  "C++ Interface:\n"
  "is_closed(EggNurbsCurve self)\n"
  "\n"
  "/**\n"
  " * Returns true if the curve appears to be closed.  Since the Egg syntax does\n"
  " * not provide a means for explicit indication of closure, this has to be\n"
  " * guessed at by examining the curve itself.\n"
  " */";
#else
static const char *Dtool_EggNurbsCurve_is_closed_1047_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double EggNurbsCurve::get_knot(int k) const
 */
static PyObject *Dtool_EggNurbsCurve_get_knot_1048(PyObject *self, PyObject *arg) {
  EggNurbsCurve *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNurbsCurve)) {
    return nullptr;
  }
  // 1-inline double EggNurbsCurve::get_knot(int k) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    double return_value = ((*(const EggNurbsCurve*)local_this).get_knot)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_knot(EggNurbsCurve self, int k)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsCurve_get_knot_1048_comment =
  "C++ Interface:\n"
  "get_knot(EggNurbsCurve self, int k)\n"
  "\n"
  "/**\n"
  " * Returns the nth knot value defined.\n"
  " */";
#else
static const char *Dtool_EggNurbsCurve_get_knot_1048_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggNurbsCurve::get_class_type(void)
 */
static PyObject *Dtool_EggNurbsCurve_get_class_type_1054(PyObject *, PyObject *) {
  // 1-static TypeHandle EggNurbsCurve::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggNurbsCurve::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsCurve_get_class_type_1054_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggNurbsCurve_get_class_type_1054_comment = nullptr;
#endif

static PyObject *Dtool_EggNurbsCurve_order_Getter(PyObject *self, void *) {
  const EggNurbsCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsCurve, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int EggNurbsCurve::get_order(void) const
  int return_value = ((*(const EggNurbsCurve*)local_this).get_order)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_EggNurbsCurve_order_Setter(PyObject *self, PyObject *arg, void *) {
  EggNurbsCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsCurve, (void **)&local_this, "EggNurbsCurve.order")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete order attribute");
    return -1;
  }
  // 1-inline void EggNurbsCurve::set_order(int order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_order)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_order(const EggNurbsCurve self, int order)\n");
  }
  return -1;
}

static PyObject *Dtool_EggNurbsCurve_degree_Getter(PyObject *self, void *) {
  const EggNurbsCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsCurve, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int EggNurbsCurve::get_degree(void) const
  int return_value = ((*(const EggNurbsCurve*)local_this).get_degree)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_EggNurbsCurve_closed_Getter(PyObject *self, void *) {
  const EggNurbsCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsCurve, (void **)&local_this)) {
    return nullptr;
  }

  // 1-bool EggNurbsCurve::is_closed(void) const
  bool return_value = ((*(const EggNurbsCurve*)local_this).is_closed)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * sequence length function for property EggNurbsCurve::knots
 */
static Py_ssize_t Dtool_EggNurbsCurve_knots_Len(PyObject *self) {
  EggNurbsCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsCurve, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_knots)();
}

/**
 * sequence getter for property EggNurbsCurve::knots
 */
static PyObject *Dtool_EggNurbsCurve_knots_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  EggNurbsCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsCurve, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_knots)()) {
    PyErr_SetString(PyExc_IndexError, "EggNurbsCurve.knots[] index out of range");
    return nullptr;
  }
  // 1-inline double EggNurbsCurve::get_knot(int k) const
  double return_value = ((*(const EggNurbsCurve*)local_this).get_knot)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_knot(EggNurbsCurve self, index)\n");
  }
}

static int Dtool_EggNurbsCurve_knots_Sequence_Setitem(PyObject *self, Py_ssize_t index, PyObject *arg) {
  EggNurbsCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsCurve, (void **)&local_this, "EggNurbsCurve.knots")) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_knots)()) {
    PyErr_SetString(PyExc_IndexError, "EggNurbsCurve.knots[] index out of range");
    return -1;
  }
  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete knots[] attribute");
    return -1;
  }
  // 1-inline void EggNurbsCurve::set_knot(int k, double value)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_knot)(index, PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_knot(const EggNurbsCurve self, index, double value)\n");
  }
  return -1;
}

static PyObject *Dtool_EggNurbsCurve_knots_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_MutableSequenceWrapper *wrap = Dtool_NewMutableSequenceWrapper(self, "EggNurbsCurve.knots");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_EggNurbsCurve_knots_Len;
    wrap->_getitem_func = &Dtool_EggNurbsCurve_knots_Sequence_Getitem;
    if (!DtoolInstance_IS_CONST(self)) {
      wrap->_setitem_func = &Dtool_EggNurbsCurve_knots_Sequence_Setitem;
    }
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * inline EggNurbsCurve::EggNurbsCurve(EggNurbsCurve const &copy)
 * inline explicit EggNurbsCurve::EggNurbsCurve(std::string const &name = "")
 */
static int Dtool_Init_EggNurbsCurve(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline explicit EggNurbsCurve::EggNurbsCurve(std::string const &name)
      EggNurbsCurve *return_value = new EggNurbsCurve();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggNurbsCurve, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline EggNurbsCurve::EggNurbsCurve(EggNurbsCurve const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          EggNurbsCurve const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_EggNurbsCurve);
          if (param0_this != nullptr) {
            EggNurbsCurve *return_value = new EggNurbsCurve(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggNurbsCurve, true, false);
          }
        }
      }

      {
        // -2 inline explicit EggNurbsCurve::EggNurbsCurve(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:EggNurbsCurve", (char **)keyword_list, &param0_str, &param0_len)) {
          EggNurbsCurve *return_value = new EggNurbsCurve(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggNurbsCurve, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline EggNurbsCurve::EggNurbsCurve(EggNurbsCurve const &copy)
      // No coercion possible: inline explicit EggNurbsCurve::EggNurbsCurve(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggNurbsCurve() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggNurbsCurve()\n"
      "EggNurbsCurve(const EggNurbsCurve copy)\n"
      "EggNurbsCurve(str name)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_EggNurbsCurve_get_knots(PyObject *self, PyObject *) {
  EggNurbsCurve *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsCurve, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_knots)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_EggNurbsCurve_get_knot_1048(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_EggNurbsCurve(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggNurbsCurve) {
    printf("EggNurbsCurve ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggNurbsCurve *local_this = (EggNurbsCurve *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggNurbsCurve) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggAttributes) {
    return (EggAttributes *)(EggPrimitive *)(EggCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggCurve) {
    return (EggCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggPrimitive *)(EggCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggPrimitive) {
    return (EggPrimitive *)(EggCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return (EggRenderMode *)(EggPrimitive *)(EggCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCurve *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCurve *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggNurbsCurve(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggNurbsCurve) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggAttributes) {
    EggAttributes* other_this = (EggAttributes*)from_this;
    return (EggNurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_EggCurve) {
    EggCurve* other_this = (EggCurve*)from_this;
    return (EggNurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggNurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggNurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggNurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_EggPrimitive) {
    EggPrimitive* other_this = (EggPrimitive*)from_this;
    return (EggNurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    EggRenderMode* other_this = (EggRenderMode*)from_this;
    return (EggNurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggNurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggNurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggNurbsCurve*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggNurbsCurve*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggSurface
 */
/**
 * Python function wrapper for:
 * inline void EggSurface::operator =(EggSurface const &copy)
 */
static PyObject *Dtool_EggSurface_operator_1057(PyObject *self, PyObject *arg) {
  EggSurface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggSurface, (void **)&local_this, "EggSurface.assign")) {
    return nullptr;
  }
  // 1-inline void EggSurface::operator =(EggSurface const &copy)
  EggSurface const *arg_this = (EggSurface *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggSurface, 1, "EggSurface.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggSurface *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggSurface, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggSurface self, const EggSurface copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggSurface_operator_1057_comment =
  "C++ Interface:\n"
  "assign(const EggSurface self, const EggSurface copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggSurface_operator_1057_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggSurface::set_u_subdiv(int subdiv)
 */
static PyObject *Dtool_EggSurface_set_u_subdiv_1058(PyObject *self, PyObject *arg) {
  EggSurface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggSurface, (void **)&local_this, "EggSurface.set_u_subdiv")) {
    return nullptr;
  }
  // 1-inline void EggSurface::set_u_subdiv(int subdiv)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_u_subdiv)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_u_subdiv(const EggSurface self, int subdiv)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggSurface_set_u_subdiv_1058_comment =
  "C++ Interface:\n"
  "set_u_subdiv(const EggSurface self, int subdiv)\n"
  "\n"
  "/**\n"
  " * Sets the number of subdivisions in the U direction that will be requested\n"
  " * across the surface.  (This doesn't necessary guarantee that this number of\n"
  " * subdivisions will be made; it's just a hint to any surface renderer or\n"
  " * quick tesselator.)  Set the number to 0 to disable the hint.\n"
  " */";
#else
static const char *Dtool_EggSurface_set_u_subdiv_1058_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggSurface::get_u_subdiv(void) const
 */
static PyObject *Dtool_EggSurface_get_u_subdiv_1059(PyObject *self, PyObject *) {
  EggSurface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggSurface)) {
    return nullptr;
  }
  // 1-inline int EggSurface::get_u_subdiv(void) const
  int return_value = ((*(const EggSurface*)local_this).get_u_subdiv)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggSurface_get_u_subdiv_1059_comment =
  "C++ Interface:\n"
  "get_u_subdiv(EggSurface self)\n"
  "\n"
  "/**\n"
  " * Returns the requested number of subdivisions in the U direction, or 0 if no\n"
  " * particular subdivisions have been requested.\n"
  " */";
#else
static const char *Dtool_EggSurface_get_u_subdiv_1059_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggSurface::set_v_subdiv(int subdiv)
 */
static PyObject *Dtool_EggSurface_set_v_subdiv_1060(PyObject *self, PyObject *arg) {
  EggSurface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggSurface, (void **)&local_this, "EggSurface.set_v_subdiv")) {
    return nullptr;
  }
  // 1-inline void EggSurface::set_v_subdiv(int subdiv)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_v_subdiv)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_v_subdiv(const EggSurface self, int subdiv)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggSurface_set_v_subdiv_1060_comment =
  "C++ Interface:\n"
  "set_v_subdiv(const EggSurface self, int subdiv)\n"
  "\n"
  "/**\n"
  " * Sets the number of subdivisions in the U direction that will be requested\n"
  " * across the surface.  (This doesn't necessary guarantee that this number of\n"
  " * subdivisions will be made; it's just a hint to any surface renderer or\n"
  " * quick tesselator.)  Set the number to 0 to disable the hint.\n"
  " */";
#else
static const char *Dtool_EggSurface_set_v_subdiv_1060_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggSurface::get_v_subdiv(void) const
 */
static PyObject *Dtool_EggSurface_get_v_subdiv_1061(PyObject *self, PyObject *) {
  EggSurface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggSurface)) {
    return nullptr;
  }
  // 1-inline int EggSurface::get_v_subdiv(void) const
  int return_value = ((*(const EggSurface*)local_this).get_v_subdiv)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggSurface_get_v_subdiv_1061_comment =
  "C++ Interface:\n"
  "get_v_subdiv(EggSurface self)\n"
  "\n"
  "/**\n"
  " * Returns the requested number of subdivisions in the U direction, or 0 if no\n"
  " * particular subdivisions have been requested.\n"
  " */";
#else
static const char *Dtool_EggSurface_get_v_subdiv_1061_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggSurface::get_class_type(void)
 */
static PyObject *Dtool_EggSurface_get_class_type_1062(PyObject *, PyObject *) {
  // 1-static TypeHandle EggSurface::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggSurface::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggSurface_get_class_type_1062_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggSurface_get_class_type_1062_comment = nullptr;
#endif

static int Dtool_Init_EggSurface(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_EggSurface(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggSurface) {
    printf("EggSurface ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggSurface *local_this = (EggSurface *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggSurface) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggAttributes) {
    return (EggAttributes *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggPrimitive) {
    return (EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return (EggRenderMode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggSurface(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggSurface) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggAttributes) {
    EggAttributes* other_this = (EggAttributes*)from_this;
    return (EggSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_EggPrimitive) {
    EggPrimitive* other_this = (EggPrimitive*)from_this;
    return (EggSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    EggRenderMode* other_this = (EggRenderMode*)from_this;
    return (EggSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggSurface*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggNurbsSurface
 */
/**
 * Python function wrapper for:
 * inline void EggNurbsSurface::operator =(EggNurbsSurface const &copy)
 */
static PyObject *Dtool_EggNurbsSurface_operator_1074(PyObject *self, PyObject *arg) {
  EggNurbsSurface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsSurface, (void **)&local_this, "EggNurbsSurface.assign")) {
    return nullptr;
  }
  // 1-inline void EggNurbsSurface::operator =(EggNurbsSurface const &copy)
  EggNurbsSurface const *arg_this = (EggNurbsSurface *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggNurbsSurface, 1, "EggNurbsSurface.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggNurbsSurface *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggNurbsSurface, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggNurbsSurface self, const EggNurbsSurface copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_operator_1074_comment =
  "C++ Interface:\n"
  "assign(const EggNurbsSurface self, const EggNurbsSurface copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_operator_1074_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggNurbsSurface::setup(int u_order, int v_order, int num_u_knots, int num_v_knots)
 */
static PyObject *Dtool_EggNurbsSurface_setup_1075(PyObject *self, PyObject *args, PyObject *kwds) {
  EggNurbsSurface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsSurface, (void **)&local_this, "EggNurbsSurface.setup")) {
    return nullptr;
  }
  // 1-void EggNurbsSurface::setup(int u_order, int v_order, int num_u_knots, int num_v_knots)
  int param1;
  int param2;
  int param3;
  int param4;
  static const char *keyword_list[] = {"u_order", "v_order", "num_u_knots", "num_v_knots", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiii:setup", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    ((*local_this).setup)((int)param1, (int)param2, (int)param3, (int)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup(const EggNurbsSurface self, int u_order, int v_order, int num_u_knots, int num_v_knots)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_setup_1075_comment =
  "C++ Interface:\n"
  "setup(const EggNurbsSurface self, int u_order, int v_order, int num_u_knots, int num_v_knots)\n"
  "\n"
  "/**\n"
  " * Prepares a new surface definition with the indicated order and number of\n"
  " * knots in each dimension.  This also implies a particular number of vertices\n"
  " * in each dimension as well (the number of knots minus the order), but it is\n"
  " * up to the user to add the correct number of vertices to the surface by\n"
  " * repeatedly calling push_back().\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_setup_1075_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggNurbsSurface::set_u_order(int u_order)
 */
static PyObject *Dtool_EggNurbsSurface_set_u_order_1076(PyObject *self, PyObject *arg) {
  EggNurbsSurface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsSurface, (void **)&local_this, "EggNurbsSurface.set_u_order")) {
    return nullptr;
  }
  // 1-inline void EggNurbsSurface::set_u_order(int u_order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_u_order)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_u_order(const EggNurbsSurface self, int u_order)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_set_u_order_1076_comment =
  "C++ Interface:\n"
  "set_u_order(const EggNurbsSurface self, int u_order)\n"
  "\n"
  "/**\n"
  " * Directly changes the order in the U direction to the indicated value (which\n"
  " * must be an integer in the range 1 <= u_order <= 4).  If possible, it is\n"
  " * preferable to use the setup() method instead of this method, since changing\n"
  " * the order directly may result in an invalid surface.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_set_u_order_1076_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggNurbsSurface::set_v_order(int v_order)
 */
static PyObject *Dtool_EggNurbsSurface_set_v_order_1077(PyObject *self, PyObject *arg) {
  EggNurbsSurface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsSurface, (void **)&local_this, "EggNurbsSurface.set_v_order")) {
    return nullptr;
  }
  // 1-inline void EggNurbsSurface::set_v_order(int v_order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_v_order)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_v_order(const EggNurbsSurface self, int v_order)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_set_v_order_1077_comment =
  "C++ Interface:\n"
  "set_v_order(const EggNurbsSurface self, int v_order)\n"
  "\n"
  "/**\n"
  " * Directly changes the order in the V direction to the indicated value (which\n"
  " * must be an integer in the range 1 <= v_order <= 4).  If possible, it is\n"
  " * preferable to use the setup() method instead of this method, since changing\n"
  " * the order directly may result in an invalid surface.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_set_v_order_1077_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggNurbsSurface::set_num_u_knots(int num)
 */
static PyObject *Dtool_EggNurbsSurface_set_num_u_knots_1078(PyObject *self, PyObject *arg) {
  EggNurbsSurface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsSurface, (void **)&local_this, "EggNurbsSurface.set_num_u_knots")) {
    return nullptr;
  }
  // 1-void EggNurbsSurface::set_num_u_knots(int num)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_num_u_knots)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_u_knots(const EggNurbsSurface self, int num)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_set_num_u_knots_1078_comment =
  "C++ Interface:\n"
  "set_num_u_knots(const EggNurbsSurface self, int num)\n"
  "\n"
  "/**\n"
  " * Directly changes the number of knots in the U direction.  This will either\n"
  " * add zero-valued knots onto the end, or truncate knot values from the end,\n"
  " * depending on whether the list is being increased or decreased.  If\n"
  " * possible, it is preferable to use the setup() method instead of directly\n"
  " * setting the number of knots, as this may result in an invalid surface.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_set_num_u_knots_1078_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggNurbsSurface::set_num_v_knots(int num)
 */
static PyObject *Dtool_EggNurbsSurface_set_num_v_knots_1079(PyObject *self, PyObject *arg) {
  EggNurbsSurface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsSurface, (void **)&local_this, "EggNurbsSurface.set_num_v_knots")) {
    return nullptr;
  }
  // 1-void EggNurbsSurface::set_num_v_knots(int num)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_num_v_knots)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_v_knots(const EggNurbsSurface self, int num)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_set_num_v_knots_1079_comment =
  "C++ Interface:\n"
  "set_num_v_knots(const EggNurbsSurface self, int num)\n"
  "\n"
  "/**\n"
  " * Directly changes the number of knots in the V direction.  This will either\n"
  " * add zero-valued knots onto the end, or truncate knot values from the end,\n"
  " * depending on whether the list is being increased or decreased.  If\n"
  " * possible, it is preferable to use the setup() method instead of directly\n"
  " * setting the number of knots, as this may result in an invalid surface.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_set_num_v_knots_1079_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggNurbsSurface::set_u_knot(int k, double value)
 */
static PyObject *Dtool_EggNurbsSurface_set_u_knot_1080(PyObject *self, PyObject *args, PyObject *kwds) {
  EggNurbsSurface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsSurface, (void **)&local_this, "EggNurbsSurface.set_u_knot")) {
    return nullptr;
  }
  // 1-inline void EggNurbsSurface::set_u_knot(int k, double value)
  int param1;
  double param2;
  static const char *keyword_list[] = {"k", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "id:set_u_knot", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_u_knot)((int)param1, (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_u_knot(const EggNurbsSurface self, int k, double value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_set_u_knot_1080_comment =
  "C++ Interface:\n"
  "set_u_knot(const EggNurbsSurface self, int k, double value)\n"
  "\n"
  "/**\n"
  " * Resets the value of the indicated knot as indicated.  k must be in the\n"
  " * range 0 <= k < get_num_u_knots(), and the value must be in the range\n"
  " * get_u_knot(k - 1) <= value <= get_u_knot(k + 1).\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_set_u_knot_1080_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggNurbsSurface::set_v_knot(int k, double value)
 */
static PyObject *Dtool_EggNurbsSurface_set_v_knot_1081(PyObject *self, PyObject *args, PyObject *kwds) {
  EggNurbsSurface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsSurface, (void **)&local_this, "EggNurbsSurface.set_v_knot")) {
    return nullptr;
  }
  // 1-inline void EggNurbsSurface::set_v_knot(int k, double value)
  int param1;
  double param2;
  static const char *keyword_list[] = {"k", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "id:set_v_knot", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_v_knot)((int)param1, (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_v_knot(const EggNurbsSurface self, int k, double value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_set_v_knot_1081_comment =
  "C++ Interface:\n"
  "set_v_knot(const EggNurbsSurface self, int k, double value)\n"
  "\n"
  "/**\n"
  " * Resets the value of the indicated knot as indicated.  k must be in the\n"
  " * range 0 <= k < get_num_v_knots(), and the value must be in the range\n"
  " * get_v_knot(k - 1) <= value <= get_v_knot(k + 1).\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_set_v_knot_1081_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggNurbsSurface::set_cv(int ui, int vi, EggVertex *vertex)
 */
static PyObject *Dtool_EggNurbsSurface_set_cv_1082(PyObject *self, PyObject *args, PyObject *kwds) {
  EggNurbsSurface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggNurbsSurface, (void **)&local_this, "EggNurbsSurface.set_cv")) {
    return nullptr;
  }
  // 1-inline void EggNurbsSurface::set_cv(int ui, int vi, EggVertex *vertex)
  int param1;
  int param2;
  PyObject *param3;
  static const char *keyword_list[] = {"ui", "vi", "vertex", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_cv", (char **)keyword_list, &param1, &param2, &param3)) {
    EggVertex *param3_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_EggVertex, 3, "EggNurbsSurface.set_cv", false, true);
    if (param3_this != nullptr) {
      ((*local_this).set_cv)((int)param1, (int)param2, param3_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cv(const EggNurbsSurface self, int ui, int vi, EggVertex vertex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_set_cv_1082_comment =
  "C++ Interface:\n"
  "set_cv(const EggNurbsSurface self, int ui, int vi, EggVertex vertex)\n"
  "\n"
  "/**\n"
  " * Redefines the control vertex associated with a particular u, v coordinate\n"
  " * pair.  This is just a shorthand to access the EggPrimitive's normal vertex\n"
  " * assignment for a 2-d control vertex.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_set_cv_1082_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggNurbsSurface::is_valid(void) const
 */
static PyObject *Dtool_EggNurbsSurface_is_valid_1083(PyObject *self, PyObject *) {
  EggNurbsSurface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNurbsSurface)) {
    return nullptr;
  }
  // 1-bool EggNurbsSurface::is_valid(void) const
  bool return_value = ((*(const EggNurbsSurface*)local_this).is_valid)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_is_valid_1083_comment =
  "C++ Interface:\n"
  "is_valid(EggNurbsSurface self)\n"
  "\n"
  "/**\n"
  " * Returns true if the NURBS parameters are all internally consistent (e.g.\n"
  " * it has the right number of vertices to match its number of knots and order\n"
  " * in each dimension), or false otherwise.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_is_valid_1083_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsSurface::get_u_order(void) const
 */
static PyObject *Dtool_EggNurbsSurface_get_u_order_1084(PyObject *self, PyObject *) {
  EggNurbsSurface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNurbsSurface)) {
    return nullptr;
  }
  // 1-inline int EggNurbsSurface::get_u_order(void) const
  int return_value = ((*(const EggNurbsSurface*)local_this).get_u_order)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_u_order_1084_comment =
  "C++ Interface:\n"
  "get_u_order(EggNurbsSurface self)\n"
  "\n"
  "/**\n"
  " * Returns the order of the surface in the U direction.  The order is the\n"
  " * degree of the NURBS equation plus 1; for a typical NURBS, the order is 4.\n"
  " * With this implementation of NURBS, the order must be in the range [1, 4].\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_get_u_order_1084_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsSurface::get_v_order(void) const
 */
static PyObject *Dtool_EggNurbsSurface_get_v_order_1085(PyObject *self, PyObject *) {
  EggNurbsSurface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNurbsSurface)) {
    return nullptr;
  }
  // 1-inline int EggNurbsSurface::get_v_order(void) const
  int return_value = ((*(const EggNurbsSurface*)local_this).get_v_order)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_v_order_1085_comment =
  "C++ Interface:\n"
  "get_v_order(EggNurbsSurface self)\n"
  "\n"
  "/**\n"
  " * Returns the order of the surface in the V direction.  The order is the\n"
  " * degree of the NURBS equation plus 1; for a typical NURBS, the order is 4.\n"
  " * With this implementation of NURBS, the order must be in the range [1, 4].\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_get_v_order_1085_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsSurface::get_u_degree(void) const
 */
static PyObject *Dtool_EggNurbsSurface_get_u_degree_1086(PyObject *self, PyObject *) {
  EggNurbsSurface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNurbsSurface)) {
    return nullptr;
  }
  // 1-inline int EggNurbsSurface::get_u_degree(void) const
  int return_value = ((*(const EggNurbsSurface*)local_this).get_u_degree)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_u_degree_1086_comment =
  "C++ Interface:\n"
  "get_u_degree(EggNurbsSurface self)\n"
  "\n"
  "/**\n"
  " * Returns the degree of the surface in the U direction.  For a typical NURBS,\n"
  " * the degree is 3.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_get_u_degree_1086_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsSurface::get_v_degree(void) const
 */
static PyObject *Dtool_EggNurbsSurface_get_v_degree_1087(PyObject *self, PyObject *) {
  EggNurbsSurface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNurbsSurface)) {
    return nullptr;
  }
  // 1-inline int EggNurbsSurface::get_v_degree(void) const
  int return_value = ((*(const EggNurbsSurface*)local_this).get_v_degree)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_v_degree_1087_comment =
  "C++ Interface:\n"
  "get_v_degree(EggNurbsSurface self)\n"
  "\n"
  "/**\n"
  " * Returns the degree of the surface in the V direction.  for a typical NURBS,\n"
  " * the degree is 3.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_get_v_degree_1087_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsSurface::get_num_u_knots(void) const
 */
static PyObject *Dtool_EggNurbsSurface_get_num_u_knots_1088(PyObject *self, PyObject *) {
  EggNurbsSurface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNurbsSurface)) {
    return nullptr;
  }
  // 1-inline int EggNurbsSurface::get_num_u_knots(void) const
  int return_value = ((*(const EggNurbsSurface*)local_this).get_num_u_knots)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_num_u_knots_1088_comment =
  "C++ Interface:\n"
  "get_num_u_knots(EggNurbsSurface self)\n"
  "\n"
  "/**\n"
  " * Returns the number of knots in the U direction.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_get_num_u_knots_1088_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsSurface::get_num_v_knots(void) const
 */
static PyObject *Dtool_EggNurbsSurface_get_num_v_knots_1089(PyObject *self, PyObject *) {
  EggNurbsSurface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNurbsSurface)) {
    return nullptr;
  }
  // 1-inline int EggNurbsSurface::get_num_v_knots(void) const
  int return_value = ((*(const EggNurbsSurface*)local_this).get_num_v_knots)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_num_v_knots_1089_comment =
  "C++ Interface:\n"
  "get_num_v_knots(EggNurbsSurface self)\n"
  "\n"
  "/**\n"
  " * Returns the number of knots in the V direction.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_get_num_v_knots_1089_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsSurface::get_num_u_cvs(void) const
 */
static PyObject *Dtool_EggNurbsSurface_get_num_u_cvs_1090(PyObject *self, PyObject *) {
  EggNurbsSurface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNurbsSurface)) {
    return nullptr;
  }
  // 1-inline int EggNurbsSurface::get_num_u_cvs(void) const
  int return_value = ((*(const EggNurbsSurface*)local_this).get_num_u_cvs)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_num_u_cvs_1090_comment =
  "C++ Interface:\n"
  "get_num_u_cvs(EggNurbsSurface self)\n"
  "\n"
  "/**\n"
  " * Returns the number of control vertices that should be present in the U\n"
  " * direction.  This is determined by the number of knots and the order; it\n"
  " * does not necessarily reflect the number of vertices that have actually been\n"
  " * added to the surface.  (However, if the number of vertices in the surface\n"
  " * are wrong, the surface is invalid.)\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_get_num_u_cvs_1090_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsSurface::get_num_v_cvs(void) const
 */
static PyObject *Dtool_EggNurbsSurface_get_num_v_cvs_1091(PyObject *self, PyObject *) {
  EggNurbsSurface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNurbsSurface)) {
    return nullptr;
  }
  // 1-inline int EggNurbsSurface::get_num_v_cvs(void) const
  int return_value = ((*(const EggNurbsSurface*)local_this).get_num_v_cvs)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_num_v_cvs_1091_comment =
  "C++ Interface:\n"
  "get_num_v_cvs(EggNurbsSurface self)\n"
  "\n"
  "/**\n"
  " * Returns the number of control vertices that should be present in the V\n"
  " * direction.  This is determined by the number of knots and the order; it\n"
  " * does not necessarily reflect the number of vertices that have actually been\n"
  " * added to the surface.  (However, if the number of vertices in the surface\n"
  " * are wrong, the surface is invalid.)\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_get_num_v_cvs_1091_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsSurface::get_num_cvs(void) const
 */
static PyObject *Dtool_EggNurbsSurface_get_num_cvs_1092(PyObject *self, PyObject *) {
  EggNurbsSurface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNurbsSurface)) {
    return nullptr;
  }
  // 1-inline int EggNurbsSurface::get_num_cvs(void) const
  int return_value = ((*(const EggNurbsSurface*)local_this).get_num_cvs)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_num_cvs_1092_comment =
  "C++ Interface:\n"
  "get_num_cvs(EggNurbsSurface self)\n"
  "\n"
  "/**\n"
  " * Returns the total number of control vertices that *should* be defined for\n"
  " * the surface.  This is determined by the number of knots and the order, in\n"
  " * each direction; it does not necessarily reflect the number of vertices that\n"
  " * have actually been added to the surface.  (However, if the number of\n"
  " * vertices in the surface are wrong, the surface is invalid.)\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_get_num_cvs_1092_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsSurface::get_u_index(int vertex_index) const
 */
static PyObject *Dtool_EggNurbsSurface_get_u_index_1093(PyObject *self, PyObject *arg) {
  EggNurbsSurface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNurbsSurface)) {
    return nullptr;
  }
  // 1-inline int EggNurbsSurface::get_u_index(int vertex_index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const EggNurbsSurface*)local_this).get_u_index)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_u_index(EggNurbsSurface self, int vertex_index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_u_index_1093_comment =
  "C++ Interface:\n"
  "get_u_index(EggNurbsSurface self, int vertex_index)\n"
  "\n"
  "/**\n"
  " * Returns the U index number of the given vertex within the EggPrimitive's\n"
  " * linear list of vertices.  An EggNurbsSurface maps a linear list of vertices\n"
  " * to its 2-d mesh; this returns the U index number that corresponds to the\n"
  " * nth vertex in the list.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_get_u_index_1093_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsSurface::get_v_index(int vertex_index) const
 */
static PyObject *Dtool_EggNurbsSurface_get_v_index_1094(PyObject *self, PyObject *arg) {
  EggNurbsSurface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNurbsSurface)) {
    return nullptr;
  }
  // 1-inline int EggNurbsSurface::get_v_index(int vertex_index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const EggNurbsSurface*)local_this).get_v_index)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_v_index(EggNurbsSurface self, int vertex_index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_v_index_1094_comment =
  "C++ Interface:\n"
  "get_v_index(EggNurbsSurface self, int vertex_index)\n"
  "\n"
  "/**\n"
  " * Returns the V index number of the given vertex within the EggPrimitive's\n"
  " * linear list of vertices.  An EggNurbsSurface maps a linear list of vertices\n"
  " * to its 2-d mesh; this returns the V index number that corresponds to the\n"
  " * nth vertex in the list.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_get_v_index_1094_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggNurbsSurface::get_vertex_index(int ui, int vi) const
 */
static PyObject *Dtool_EggNurbsSurface_get_vertex_index_1095(PyObject *self, PyObject *args, PyObject *kwds) {
  EggNurbsSurface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNurbsSurface)) {
    return nullptr;
  }
  // 1-inline int EggNurbsSurface::get_vertex_index(int ui, int vi) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"ui", "vi", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_vertex_index", (char **)keyword_list, &param1, &param2)) {
    int return_value = ((*(const EggNurbsSurface*)local_this).get_vertex_index)((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex_index(EggNurbsSurface self, int ui, int vi)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_vertex_index_1095_comment =
  "C++ Interface:\n"
  "get_vertex_index(EggNurbsSurface self, int ui, int vi)\n"
  "\n"
  "/**\n"
  " * Returns the index number within the EggPrimitive's list of the control\n"
  " * vertex at position ui, vi.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_get_vertex_index_1095_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggNurbsSurface::is_closed_u(void) const
 */
static PyObject *Dtool_EggNurbsSurface_is_closed_u_1096(PyObject *self, PyObject *) {
  EggNurbsSurface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNurbsSurface)) {
    return nullptr;
  }
  // 1-bool EggNurbsSurface::is_closed_u(void) const
  bool return_value = ((*(const EggNurbsSurface*)local_this).is_closed_u)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_is_closed_u_1096_comment =
  "C++ Interface:\n"
  "is_closed_u(EggNurbsSurface self)\n"
  "\n"
  "/**\n"
  " * Returns true if the surface appears to be closed in the U direction.  Since\n"
  " * the Egg syntax does not provide a means for explicit indication of closure,\n"
  " * this has to be guessed at by examining the surface itself.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_is_closed_u_1096_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggNurbsSurface::is_closed_v(void) const
 */
static PyObject *Dtool_EggNurbsSurface_is_closed_v_1097(PyObject *self, PyObject *) {
  EggNurbsSurface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNurbsSurface)) {
    return nullptr;
  }
  // 1-bool EggNurbsSurface::is_closed_v(void) const
  bool return_value = ((*(const EggNurbsSurface*)local_this).is_closed_v)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_is_closed_v_1097_comment =
  "C++ Interface:\n"
  "is_closed_v(EggNurbsSurface self)\n"
  "\n"
  "/**\n"
  " * Returns true if the surface appears to be closed in the V direction.  Since\n"
  " * the Egg syntax does not provide a means for explicit indication of closure,\n"
  " * this has to be guessed at by examining the surface itself.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_is_closed_v_1097_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double EggNurbsSurface::get_u_knot(int k) const
 */
static PyObject *Dtool_EggNurbsSurface_get_u_knot_1098(PyObject *self, PyObject *arg) {
  EggNurbsSurface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNurbsSurface)) {
    return nullptr;
  }
  // 1-inline double EggNurbsSurface::get_u_knot(int k) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    double return_value = ((*(const EggNurbsSurface*)local_this).get_u_knot)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_u_knot(EggNurbsSurface self, int k)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_u_knot_1098_comment =
  "C++ Interface:\n"
  "get_u_knot(EggNurbsSurface self, int k)\n"
  "\n"
  "/**\n"
  " * Returns the nth knot value defined in the U direction.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_get_u_knot_1098_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double EggNurbsSurface::get_v_knot(int k) const
 */
static PyObject *Dtool_EggNurbsSurface_get_v_knot_1100(PyObject *self, PyObject *arg) {
  EggNurbsSurface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNurbsSurface)) {
    return nullptr;
  }
  // 1-inline double EggNurbsSurface::get_v_knot(int k) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    double return_value = ((*(const EggNurbsSurface*)local_this).get_v_knot)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_v_knot(EggNurbsSurface self, int k)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_v_knot_1100_comment =
  "C++ Interface:\n"
  "get_v_knot(EggNurbsSurface self, int k)\n"
  "\n"
  "/**\n"
  " * Returns the nth knot value defined in the V direction.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_get_v_knot_1100_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggVertex *EggNurbsSurface::get_cv(int ui, int vi) const
 */
static PyObject *Dtool_EggNurbsSurface_get_cv_1102(PyObject *self, PyObject *args, PyObject *kwds) {
  EggNurbsSurface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggNurbsSurface)) {
    return nullptr;
  }
  // 1-inline EggVertex *EggNurbsSurface::get_cv(int ui, int vi) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"ui", "vi", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_cv", (char **)keyword_list, &param1, &param2)) {
    EggVertex *return_value = ((*(const EggNurbsSurface*)local_this).get_cv)((int)param1, (int)param2);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cv(EggNurbsSurface self, int ui, int vi)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_cv_1102_comment =
  "C++ Interface:\n"
  "get_cv(EggNurbsSurface self, int ui, int vi)\n"
  "\n"
  "/**\n"
  " * Returns the control vertex at the indicate U, V position.\n"
  " */";
#else
static const char *Dtool_EggNurbsSurface_get_cv_1102_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggNurbsSurface::get_class_type(void)
 */
static PyObject *Dtool_EggNurbsSurface_get_class_type_1103(PyObject *, PyObject *) {
  // 1-static TypeHandle EggNurbsSurface::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggNurbsSurface::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggNurbsSurface_get_class_type_1103_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggNurbsSurface_get_class_type_1103_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggNurbsSurface::EggNurbsSurface(EggNurbsSurface const &copy)
 * inline explicit EggNurbsSurface::EggNurbsSurface(std::string const &name = "")
 */
static int Dtool_Init_EggNurbsSurface(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline explicit EggNurbsSurface::EggNurbsSurface(std::string const &name)
      EggNurbsSurface *return_value = new EggNurbsSurface();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggNurbsSurface, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline EggNurbsSurface::EggNurbsSurface(EggNurbsSurface const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          EggNurbsSurface const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_EggNurbsSurface);
          if (param0_this != nullptr) {
            EggNurbsSurface *return_value = new EggNurbsSurface(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggNurbsSurface, true, false);
          }
        }
      }

      {
        // -2 inline explicit EggNurbsSurface::EggNurbsSurface(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:EggNurbsSurface", (char **)keyword_list, &param0_str, &param0_len)) {
          EggNurbsSurface *return_value = new EggNurbsSurface(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggNurbsSurface, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline EggNurbsSurface::EggNurbsSurface(EggNurbsSurface const &copy)
      // No coercion possible: inline explicit EggNurbsSurface::EggNurbsSurface(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggNurbsSurface() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggNurbsSurface()\n"
      "EggNurbsSurface(const EggNurbsSurface copy)\n"
      "EggNurbsSurface(str name)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_EggNurbsSurface_get_u_knots(PyObject *self, PyObject *) {
  EggNurbsSurface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsSurface, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_u_knots)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_EggNurbsSurface_get_u_knot_1098(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_EggNurbsSurface_get_v_knots(PyObject *self, PyObject *) {
  EggNurbsSurface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNurbsSurface, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_v_knots)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_EggNurbsSurface_get_v_knot_1100(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_EggNurbsSurface(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggNurbsSurface) {
    printf("EggNurbsSurface ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggNurbsSurface *local_this = (EggNurbsSurface *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggNurbsSurface) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggAttributes) {
    return (EggAttributes *)(EggPrimitive *)(EggSurface *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggPrimitive *)(EggSurface *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggPrimitive *)(EggSurface *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggSurface *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggPrimitive) {
    return (EggPrimitive *)(EggSurface *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return (EggRenderMode *)(EggPrimitive *)(EggSurface *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggSurface) {
    return (EggSurface *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggSurface *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggSurface *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggSurface *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggSurface *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggNurbsSurface(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggNurbsSurface) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggAttributes) {
    EggAttributes* other_this = (EggAttributes*)from_this;
    return (EggNurbsSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggNurbsSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggNurbsSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggNurbsSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_EggPrimitive) {
    EggPrimitive* other_this = (EggPrimitive*)from_this;
    return (EggNurbsSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    EggRenderMode* other_this = (EggRenderMode*)from_this;
    return (EggNurbsSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_EggSurface) {
    EggSurface* other_this = (EggSurface*)from_this;
    return (EggNurbsSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggNurbsSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggNurbsSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggNurbsSurface*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggNurbsSurface*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggPatch
 */
/**
 * Python function wrapper for:
 * inline void EggPatch::operator =(EggPatch const &copy)
 */
static PyObject *Dtool_EggPatch_operator_1107(PyObject *self, PyObject *arg) {
  EggPatch *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPatch, (void **)&local_this, "EggPatch.assign")) {
    return nullptr;
  }
  // 1-inline void EggPatch::operator =(EggPatch const &copy)
  EggPatch const *arg_this = (EggPatch *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggPatch, 1, "EggPatch.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggPatch *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggPatch, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggPatch self, const EggPatch copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggPatch_operator_1107_comment =
  "C++ Interface:\n"
  "assign(const EggPatch self, const EggPatch copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggPatch_operator_1107_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggPatch::get_class_type(void)
 */
static PyObject *Dtool_EggPatch_get_class_type_1108(PyObject *, PyObject *) {
  // 1-static TypeHandle EggPatch::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggPatch::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggPatch_get_class_type_1108_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggPatch_get_class_type_1108_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggPatch::EggPatch(EggPatch const &copy)
 * inline explicit EggPatch::EggPatch(std::string const &name = "")
 */
static int Dtool_Init_EggPatch(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline explicit EggPatch::EggPatch(std::string const &name)
      EggPatch *return_value = new EggPatch();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggPatch, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline EggPatch::EggPatch(EggPatch const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          EggPatch const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_EggPatch);
          if (param0_this != nullptr) {
            EggPatch *return_value = new EggPatch(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggPatch, true, false);
          }
        }
      }

      {
        // -2 inline explicit EggPatch::EggPatch(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:EggPatch", (char **)keyword_list, &param0_str, &param0_len)) {
          EggPatch *return_value = new EggPatch(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggPatch, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline EggPatch::EggPatch(EggPatch const &copy)
      // No coercion possible: inline explicit EggPatch::EggPatch(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggPatch() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggPatch()\n"
      "EggPatch(const EggPatch copy)\n"
      "EggPatch(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggPatch(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggPatch) {
    printf("EggPatch ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggPatch *local_this = (EggPatch *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggPatch) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggAttributes) {
    return (EggAttributes *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggPrimitive) {
    return (EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return (EggRenderMode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggPatch(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggPatch) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggAttributes) {
    EggAttributes* other_this = (EggAttributes*)from_this;
    return (EggPatch*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggPatch*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggPatch*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggPatch*)other_this;
  }
  if (from_type == Dtool_Ptr_EggPrimitive) {
    EggPrimitive* other_this = (EggPrimitive*)from_this;
    return (EggPatch*)other_this;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    EggRenderMode* other_this = (EggRenderMode*)from_this;
    return (EggPatch*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggPatch*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggPatch*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggPatch*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggPatch*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggPoint
 */
/**
 * Python function wrapper for:
 * inline void EggPoint::operator =(EggPoint const &copy)
 */
static PyObject *Dtool_EggPoint_operator_1112(PyObject *self, PyObject *arg) {
  EggPoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPoint, (void **)&local_this, "EggPoint.assign")) {
    return nullptr;
  }
  // 1-inline void EggPoint::operator =(EggPoint const &copy)
  EggPoint const *arg_this = (EggPoint *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggPoint, 1, "EggPoint.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggPoint *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggPoint, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggPoint self, const EggPoint copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggPoint_operator_1112_comment =
  "C++ Interface:\n"
  "assign(const EggPoint self, const EggPoint copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggPoint_operator_1112_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggPoint::has_thick(void) const
 */
static PyObject *Dtool_EggPoint_has_thick_1113(PyObject *self, PyObject *) {
  EggPoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggPoint)) {
    return nullptr;
  }
  // 1-inline bool EggPoint::has_thick(void) const
  bool return_value = ((*(const EggPoint*)local_this).has_thick)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPoint_has_thick_1113_comment =
  "C++ Interface:\n"
  "has_thick(EggPoint self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggPoint_has_thick_1113_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double EggPoint::get_thick(void) const
 */
static PyObject *Dtool_EggPoint_get_thick_1114(PyObject *self, PyObject *) {
  EggPoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggPoint)) {
    return nullptr;
  }
  // 1-inline double EggPoint::get_thick(void) const
  double return_value = ((*(const EggPoint*)local_this).get_thick)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPoint_get_thick_1114_comment =
  "C++ Interface:\n"
  "get_thick(EggPoint self)\n"
  "\n"
  "/**\n"
  " * Returns the thickness set on this particular point.  If there is no\n"
  " * thickness set, returns 1.0.\n"
  " */";
#else
static const char *Dtool_EggPoint_get_thick_1114_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggPoint::set_thick(double thick)
 */
static PyObject *Dtool_EggPoint_set_thick_1115(PyObject *self, PyObject *arg) {
  EggPoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPoint, (void **)&local_this, "EggPoint.set_thick")) {
    return nullptr;
  }
  // 1-inline void EggPoint::set_thick(double thick)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_thick)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_thick(const EggPoint self, double thick)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggPoint_set_thick_1115_comment =
  "C++ Interface:\n"
  "set_thick(const EggPoint self, double thick)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggPoint_set_thick_1115_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggPoint::clear_thick(void)
 */
static PyObject *Dtool_EggPoint_clear_thick_1116(PyObject *self, PyObject *) {
  EggPoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPoint, (void **)&local_this, "EggPoint.clear_thick")) {
    return nullptr;
  }
  // 1-inline void EggPoint::clear_thick(void)
  ((*local_this).clear_thick)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggPoint_clear_thick_1116_comment =
  "C++ Interface:\n"
  "clear_thick(const EggPoint self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggPoint_clear_thick_1116_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggPoint::has_perspective(void) const
 */
static PyObject *Dtool_EggPoint_has_perspective_1117(PyObject *self, PyObject *) {
  EggPoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggPoint)) {
    return nullptr;
  }
  // 1-inline bool EggPoint::has_perspective(void) const
  bool return_value = ((*(const EggPoint*)local_this).has_perspective)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPoint_has_perspective_1117_comment =
  "C++ Interface:\n"
  "has_perspective(EggPoint self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggPoint_has_perspective_1117_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggPoint::get_perspective(void) const
 */
static PyObject *Dtool_EggPoint_get_perspective_1118(PyObject *self, PyObject *) {
  EggPoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggPoint)) {
    return nullptr;
  }
  // 1-inline bool EggPoint::get_perspective(void) const
  bool return_value = ((*(const EggPoint*)local_this).get_perspective)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggPoint_get_perspective_1118_comment =
  "C++ Interface:\n"
  "get_perspective(EggPoint self)\n"
  "\n"
  "/**\n"
  " * Returns the perspective flag set on this particular point.  If there is no\n"
  " * perspective flag set, returns false.\n"
  " */";
#else
static const char *Dtool_EggPoint_get_perspective_1118_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggPoint::set_perspective(bool perspective)
 */
static PyObject *Dtool_EggPoint_set_perspective_1119(PyObject *self, PyObject *arg) {
  EggPoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPoint, (void **)&local_this, "EggPoint.set_perspective")) {
    return nullptr;
  }
  // 1-inline void EggPoint::set_perspective(bool perspective)
  ((*local_this).set_perspective)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_perspective(const EggPoint self, bool perspective)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggPoint_set_perspective_1119_comment =
  "C++ Interface:\n"
  "set_perspective(const EggPoint self, bool perspective)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggPoint_set_perspective_1119_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggPoint::clear_perspective(void)
 */
static PyObject *Dtool_EggPoint_clear_perspective_1120(PyObject *self, PyObject *) {
  EggPoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPoint, (void **)&local_this, "EggPoint.clear_perspective")) {
    return nullptr;
  }
  // 1-inline void EggPoint::clear_perspective(void)
  ((*local_this).clear_perspective)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggPoint_clear_perspective_1120_comment =
  "C++ Interface:\n"
  "clear_perspective(const EggPoint self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggPoint_clear_perspective_1120_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggPoint::get_class_type(void)
 */
static PyObject *Dtool_EggPoint_get_class_type_1121(PyObject *, PyObject *) {
  // 1-static TypeHandle EggPoint::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggPoint::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggPoint_get_class_type_1121_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggPoint_get_class_type_1121_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggPoint::EggPoint(EggPoint const &copy)
 * inline explicit EggPoint::EggPoint(std::string const &name = "")
 */
static int Dtool_Init_EggPoint(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline explicit EggPoint::EggPoint(std::string const &name)
      EggPoint *return_value = new EggPoint();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggPoint, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline EggPoint::EggPoint(EggPoint const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          EggPoint const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_EggPoint);
          if (param0_this != nullptr) {
            EggPoint *return_value = new EggPoint(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggPoint, true, false);
          }
        }
      }

      {
        // -2 inline explicit EggPoint::EggPoint(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:EggPoint", (char **)keyword_list, &param0_str, &param0_len)) {
          EggPoint *return_value = new EggPoint(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggPoint, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline EggPoint::EggPoint(EggPoint const &copy)
      // No coercion possible: inline explicit EggPoint::EggPoint(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggPoint() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggPoint()\n"
      "EggPoint(const EggPoint copy)\n"
      "EggPoint(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggPoint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggPoint) {
    printf("EggPoint ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggPoint *local_this = (EggPoint *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggPoint) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggAttributes) {
    return (EggAttributes *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggPrimitive) {
    return (EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return (EggRenderMode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggPoint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggPoint) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggAttributes) {
    EggAttributes* other_this = (EggAttributes*)from_this;
    return (EggPoint*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggPoint*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggPoint*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggPoint*)other_this;
  }
  if (from_type == Dtool_Ptr_EggPrimitive) {
    EggPrimitive* other_this = (EggPrimitive*)from_this;
    return (EggPoint*)other_this;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    EggRenderMode* other_this = (EggRenderMode*)from_this;
    return (EggPoint*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggPoint*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggPoint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggPoint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggPoint*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggPolysetMaker
 */
/**
 * Python function wrapper for:
 * void EggPolysetMaker::set_properties(int properties)
 */
static PyObject *Dtool_EggPolysetMaker_set_properties_1127(PyObject *self, PyObject *arg) {
  EggPolysetMaker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggPolysetMaker, (void **)&local_this, "EggPolysetMaker.set_properties")) {
    return nullptr;
  }
  // 1-void EggPolysetMaker::set_properties(int properties)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_properties)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_properties(const EggPolysetMaker self, int properties)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggPolysetMaker_set_properties_1127_comment =
  "C++ Interface:\n"
  "set_properties(const EggPolysetMaker self, int properties)\n"
  "\n"
  "/**\n"
  " * Sets the set of properties that determines which polygons are allowed to be\n"
  " * grouped together into a single polyset.  This is the bitwise 'or' of all\n"
  " * the properties that matter.  If this is 0, all polygons (within a given\n"
  " * group) will be lumped into a common polyset regardless of their properties.\n"
  " */";
#else
static const char *Dtool_EggPolysetMaker_set_properties_1127_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggPolysetMaker::get_class_type(void)
 */
static PyObject *Dtool_EggPolysetMaker_get_class_type_1128(PyObject *, PyObject *) {
  // 1-static TypeHandle EggPolysetMaker::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggPolysetMaker::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggPolysetMaker_get_class_type_1128_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggPolysetMaker_get_class_type_1128_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggPolysetMaker::EggPolysetMaker(void)
 */
static int Dtool_Init_EggPolysetMaker(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("EggPolysetMaker() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "EggPolysetMaker() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-EggPolysetMaker::EggPolysetMaker(void)
  EggPolysetMaker *return_value = new EggPolysetMaker();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggPolysetMaker, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggPolysetMaker()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggPolysetMaker(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggPolysetMaker) {
    printf("EggPolysetMaker ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggPolysetMaker *local_this = (EggPolysetMaker *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggPolysetMaker) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggBinMaker) {
    return (EggBinMaker *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggBinMaker *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggBinMaker *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggBinMaker *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggBinMaker *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggPolysetMaker(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggPolysetMaker) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggBinMaker) {
    EggBinMaker* other_this = (EggBinMaker*)from_this;
    return (EggPolysetMaker*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggPolysetMaker*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggPolysetMaker*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggPolysetMaker*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggPolysetMaker*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggPoolUniquifier
 */
/**
 * Python function wrapper for:
 * static TypeHandle EggPoolUniquifier::get_class_type(void)
 */
static PyObject *Dtool_EggPoolUniquifier_get_class_type_1132(PyObject *, PyObject *) {
  // 1-static TypeHandle EggPoolUniquifier::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggPoolUniquifier::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggPoolUniquifier_get_class_type_1132_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggPoolUniquifier_get_class_type_1132_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggPoolUniquifier::EggPoolUniquifier(void)
 */
static int Dtool_Init_EggPoolUniquifier(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("EggPoolUniquifier() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "EggPoolUniquifier() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-EggPoolUniquifier::EggPoolUniquifier(void)
  EggPoolUniquifier *return_value = new EggPoolUniquifier();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggPoolUniquifier, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggPoolUniquifier()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggPoolUniquifier(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggPoolUniquifier) {
    printf("EggPoolUniquifier ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggPoolUniquifier *local_this = (EggPoolUniquifier *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggPoolUniquifier) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggNameUniquifier) {
    return (EggNameUniquifier *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNameUniquifier *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNameUniquifier *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNameUniquifier *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNameUniquifier *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggPoolUniquifier(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggPoolUniquifier) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggNameUniquifier) {
    EggNameUniquifier* other_this = (EggNameUniquifier*)from_this;
    return (EggPoolUniquifier*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggPoolUniquifier*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggPoolUniquifier*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggPoolUniquifier*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggPoolUniquifier*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggSAnimData
 */
/**
 * Python function wrapper for:
 * inline void EggSAnimData::operator =(EggSAnimData const &copy)
 */
static PyObject *Dtool_EggSAnimData_operator_1136(PyObject *self, PyObject *arg) {
  EggSAnimData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggSAnimData, (void **)&local_this, "EggSAnimData.assign")) {
    return nullptr;
  }
  // 1-inline void EggSAnimData::operator =(EggSAnimData const &copy)
  EggSAnimData const *arg_this = (EggSAnimData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggSAnimData, 1, "EggSAnimData.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggSAnimData *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggSAnimData, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggSAnimData self, const EggSAnimData copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggSAnimData_operator_1136_comment =
  "C++ Interface:\n"
  "assign(const EggSAnimData self, const EggSAnimData copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggSAnimData_operator_1136_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggSAnimData::get_num_rows(void) const
 */
static PyObject *Dtool_EggSAnimData_get_num_rows_1137(PyObject *self, PyObject *) {
  EggSAnimData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggSAnimData)) {
    return nullptr;
  }
  // 1-inline int EggSAnimData::get_num_rows(void) const
  int return_value = ((*(const EggSAnimData*)local_this).get_num_rows)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggSAnimData_get_num_rows_1137_comment =
  "C++ Interface:\n"
  "get_num_rows(EggSAnimData self)\n"
  "\n"
  "/**\n"
  " * Returns the number of rows in the table.  For an SAnim table, each row has\n"
  " * one column.\n"
  " */";
#else
static const char *Dtool_EggSAnimData_get_num_rows_1137_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double EggSAnimData::get_value(int row) const
 */
static PyObject *Dtool_EggSAnimData_get_value_1138(PyObject *self, PyObject *arg) {
  EggSAnimData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggSAnimData)) {
    return nullptr;
  }
  // 1-inline double EggSAnimData::get_value(int row) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    double return_value = ((*(const EggSAnimData*)local_this).get_value)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_value(EggSAnimData self, int row)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggSAnimData_get_value_1138_comment =
  "C++ Interface:\n"
  "get_value(EggSAnimData self, int row)\n"
  "\n"
  "/**\n"
  " * Returns the value at the indicated row.  Row must be in the range 0 <= row\n"
  " * < get_num_rows().\n"
  " */";
#else
static const char *Dtool_EggSAnimData_get_value_1138_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggSAnimData::set_value(int row, double value)
 */
static PyObject *Dtool_EggSAnimData_set_value_1139(PyObject *self, PyObject *args, PyObject *kwds) {
  EggSAnimData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggSAnimData, (void **)&local_this, "EggSAnimData.set_value")) {
    return nullptr;
  }
  // 1-inline void EggSAnimData::set_value(int row, double value)
  int param1;
  double param2;
  static const char *keyword_list[] = {"row", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "id:set_value", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_value)((int)param1, (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const EggSAnimData self, int row, double value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggSAnimData_set_value_1139_comment =
  "C++ Interface:\n"
  "set_value(const EggSAnimData self, int row, double value)\n"
  "\n"
  "/**\n"
  " * Changes the value at the indicated row.  Row must be in the range 0 <= row\n"
  " * < get_num_rows().\n"
  " */";
#else
static const char *Dtool_EggSAnimData_set_value_1139_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggSAnimData::optimize(void)
 */
static PyObject *Dtool_EggSAnimData_optimize_1140(PyObject *self, PyObject *) {
  EggSAnimData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggSAnimData, (void **)&local_this, "EggSAnimData.optimize")) {
    return nullptr;
  }
  // 1-void EggSAnimData::optimize(void)
  ((*local_this).optimize)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggSAnimData_optimize_1140_comment =
  "C++ Interface:\n"
  "optimize(const EggSAnimData self)\n"
  "\n"
  "/**\n"
  " * Optimizes the data by collapsing a long table of duplicate values into a\n"
  " * single value.\n"
  " */";
#else
static const char *Dtool_EggSAnimData_optimize_1140_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggSAnimData::get_class_type(void)
 */
static PyObject *Dtool_EggSAnimData_get_class_type_1141(PyObject *, PyObject *) {
  // 1-static TypeHandle EggSAnimData::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggSAnimData::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggSAnimData_get_class_type_1141_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggSAnimData_get_class_type_1141_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggSAnimData::EggSAnimData(EggSAnimData const &copy)
 * inline explicit EggSAnimData::EggSAnimData(std::string const &name = "")
 */
static int Dtool_Init_EggSAnimData(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline explicit EggSAnimData::EggSAnimData(std::string const &name)
      EggSAnimData *return_value = new EggSAnimData();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggSAnimData, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline EggSAnimData::EggSAnimData(EggSAnimData const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          EggSAnimData const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_EggSAnimData);
          if (param0_this != nullptr) {
            EggSAnimData *return_value = new EggSAnimData(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggSAnimData, true, false);
          }
        }
      }

      {
        // -2 inline explicit EggSAnimData::EggSAnimData(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:EggSAnimData", (char **)keyword_list, &param0_str, &param0_len)) {
          EggSAnimData *return_value = new EggSAnimData(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggSAnimData, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline EggSAnimData::EggSAnimData(EggSAnimData const &copy)
      // No coercion possible: inline explicit EggSAnimData::EggSAnimData(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggSAnimData() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggSAnimData()\n"
      "EggSAnimData(const EggSAnimData copy)\n"
      "EggSAnimData(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggSAnimData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggSAnimData) {
    printf("EggSAnimData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggSAnimData *local_this = (EggSAnimData *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggSAnimData) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggAnimData) {
    return (EggAnimData *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggAnimData *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggAnimData *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggAnimData *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggAnimData *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggAnimData *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggAnimData *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggAnimData *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggSAnimData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggSAnimData) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggAnimData) {
    EggAnimData* other_this = (EggAnimData*)from_this;
    return (EggSAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggSAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggSAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggSAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggSAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggSAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggSAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggSAnimData*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggTable
 */
/**
 * Python function wrapper for:
 * inline void EggTable::operator =(EggTable const &copy)
 */
static PyObject *Dtool_EggTable_operator_1146(PyObject *self, PyObject *arg) {
  EggTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTable, (void **)&local_this, "EggTable.assign")) {
    return nullptr;
  }
  // 1-inline void EggTable::operator =(EggTable const &copy)
  EggTable const *arg_this = (EggTable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggTable, 1, "EggTable.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggTable *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggTable, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggTable self, const EggTable copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTable_operator_1146_comment =
  "C++ Interface:\n"
  "assign(const EggTable self, const EggTable copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTable_operator_1146_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggTable::set_table_type(EggTable::TableType type)
 */
static PyObject *Dtool_EggTable_set_table_type_1147(PyObject *self, PyObject *arg) {
  EggTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTable, (void **)&local_this, "EggTable.set_table_type")) {
    return nullptr;
  }
  // 1-inline void EggTable::set_table_type(EggTable::TableType type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_table_type)((EggTable::TableType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_table_type(const EggTable self, int type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTable_set_table_type_1147_comment =
  "C++ Interface:\n"
  "set_table_type(const EggTable self, int type)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTable_set_table_type_1147_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggTable::TableType EggTable::get_table_type(void) const
 */
static PyObject *Dtool_EggTable_get_table_type_1148(PyObject *self, PyObject *) {
  EggTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTable)) {
    return nullptr;
  }
  // 1-inline EggTable::TableType EggTable::get_table_type(void) const
  EggTable::TableType return_value = ((*(const EggTable*)local_this).get_table_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTable_get_table_type_1148_comment =
  "C++ Interface:\n"
  "get_table_type(EggTable self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTable_get_table_type_1148_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggTable::has_transform(void) const
 */
static PyObject *Dtool_EggTable_has_transform_1149(PyObject *self, PyObject *) {
  EggTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTable)) {
    return nullptr;
  }
  // 1-bool EggTable::has_transform(void) const
  bool return_value = ((*(const EggTable*)local_this).has_transform)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTable_has_transform_1149_comment =
  "C++ Interface:\n"
  "has_transform(EggTable self)\n"
  "\n"
  "/**\n"
  " * Returns true if the table contains a transform description, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_EggTable_has_transform_1149_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static EggTable::TableType EggTable::string_table_type(std::string const &string)
 */
static PyObject *Dtool_EggTable_string_table_type_1150(PyObject *, PyObject *arg) {
  // 1-static EggTable::TableType EggTable::string_table_type(std::string const &string)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    EggTable::TableType return_value = (EggTable::string_table_type)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_table_type(str string)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTable_string_table_type_1150_comment =
  "C++ Interface:\n"
  "string_table_type(str string)\n"
  "\n"
  "/**\n"
  " * Returns the TableType value associated with the given string\n"
  " * representation, or TT_invalid if the string does not match any known\n"
  " * TableType value.\n"
  " */";
#else
static const char *Dtool_EggTable_string_table_type_1150_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggTable::get_class_type(void)
 */
static PyObject *Dtool_EggTable_get_class_type_1151(PyObject *, PyObject *) {
  // 1-static TypeHandle EggTable::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggTable::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggTable_get_class_type_1151_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggTable_get_class_type_1151_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggTable::EggTable(EggTable const &copy)
 * inline explicit EggTable::EggTable(std::string const &name = "")
 */
static int Dtool_Init_EggTable(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline explicit EggTable::EggTable(std::string const &name)
      EggTable *return_value = new EggTable();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggTable, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline EggTable::EggTable(EggTable const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          EggTable const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_EggTable);
          if (param0_this != nullptr) {
            EggTable *return_value = new EggTable(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggTable, true, false);
          }
        }
      }

      {
        // -2 inline explicit EggTable::EggTable(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:EggTable", (char **)keyword_list, &param0_str, &param0_len)) {
          EggTable *return_value = new EggTable(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggTable, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline EggTable::EggTable(EggTable const &copy)
      // No coercion possible: inline explicit EggTable::EggTable(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggTable() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggTable()\n"
      "EggTable(const EggTable copy)\n"
      "EggTable(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggTable(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggTable) {
    printf("EggTable ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggTable *local_this = (EggTable *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggTable) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggGroupNode) {
    return (EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggTable(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggTable) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggGroupNode) {
    EggGroupNode* other_this = (EggGroupNode*)from_this;
    return (EggTable*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggTable*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggTable*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggTable*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggTable*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggTable*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggTextureCollection
 */
/**
 * Python function wrapper for:
 * void EggTextureCollection::operator =(EggTextureCollection const &copy)
 */
static PyObject *Dtool_EggTextureCollection_operator_1155(PyObject *self, PyObject *arg) {
  EggTextureCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTextureCollection, (void **)&local_this, "EggTextureCollection.assign")) {
    return nullptr;
  }
  // 1-void EggTextureCollection::operator =(EggTextureCollection const &copy)
  EggTextureCollection const *arg_this = (EggTextureCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggTextureCollection, 1, "EggTextureCollection.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggTextureCollection *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EggTextureCollection, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggTextureCollection self, const EggTextureCollection copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_operator_1155_comment =
  "C++ Interface:\n"
  "assign(const EggTextureCollection self, const EggTextureCollection copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_operator_1155_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggTextureCollection::clear(void)
 */
static PyObject *Dtool_EggTextureCollection_clear_1157(PyObject *self, PyObject *) {
  EggTextureCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTextureCollection, (void **)&local_this, "EggTextureCollection.clear")) {
    return nullptr;
  }
  // 1-void EggTextureCollection::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_clear_1157_comment =
  "C++ Interface:\n"
  "clear(const EggTextureCollection self)\n"
  "\n"
  "/**\n"
  " * Removes all textures from the collection.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_clear_1157_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int EggTextureCollection::extract_textures(EggGroupNode *node)
 */
static PyObject *Dtool_EggTextureCollection_extract_textures_1158(PyObject *self, PyObject *arg) {
  EggTextureCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTextureCollection, (void **)&local_this, "EggTextureCollection.extract_textures")) {
    return nullptr;
  }
  // 1-int EggTextureCollection::extract_textures(EggGroupNode *node)
  EggGroupNode *arg_this = (EggGroupNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggGroupNode, 1, "EggTextureCollection.extract_textures", false, true);
  if (arg_this != nullptr) {
    int return_value = ((*local_this).extract_textures)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extract_textures(const EggTextureCollection self, EggGroupNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_extract_textures_1158_comment =
  "C++ Interface:\n"
  "extract_textures(const EggTextureCollection self, EggGroupNode node)\n"
  "\n"
  "/**\n"
  " * Walks the egg hierarchy beginning at the indicated node, and removes any\n"
  " * EggTextures encountered in the hierarchy, adding them to the collection.\n"
  " * Returns the number of EggTextures encountered.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_extract_textures_1158_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggTextureCollection::is_empty(void) const
 */
static PyObject *Dtool_EggTextureCollection_is_empty_1159(PyObject *self, PyObject *) {
  EggTextureCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTextureCollection)) {
    return nullptr;
  }
  // 1-bool EggTextureCollection::is_empty(void) const
  bool return_value = ((*(const EggTextureCollection*)local_this).is_empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_is_empty_1159_comment =
  "C++ Interface:\n"
  "is_empty(EggTextureCollection self)\n"
  "\n"
  "/**\n"
  " * Returns true if there are no EggTexures in the collection, false otherwise.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_is_empty_1159_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int EggTextureCollection::get_num_textures(void) const
 */
static PyObject *Dtool_EggTextureCollection_get_num_textures_1160(PyObject *self, PyObject *) {
  EggTextureCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTextureCollection)) {
    return nullptr;
  }
  // 1-int EggTextureCollection::get_num_textures(void) const
  int return_value = ((*(const EggTextureCollection*)local_this).get_num_textures)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_get_num_textures_1160_comment =
  "C++ Interface:\n"
  "get_num_textures(EggTextureCollection self)\n"
  "\n"
  "/**\n"
  " * Returns the number of EggTextures in the collection.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_get_num_textures_1160_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggTexture *EggTextureCollection::get_texture(int index) const
 */
static PyObject *Dtool_EggTextureCollection_get_texture_1161(PyObject *self, PyObject *arg) {
  EggTextureCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTextureCollection)) {
    return nullptr;
  }
  // 1-EggTexture *EggTextureCollection::get_texture(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    EggTexture *return_value = ((*(const EggTextureCollection*)local_this).get_texture)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggTexture, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_texture(EggTextureCollection self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_get_texture_1161_comment =
  "C++ Interface:\n"
  "get_texture(EggTextureCollection self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the nth EggTexture in the collection.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_get_texture_1161_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int EggTextureCollection::find_used_textures(EggNode *node)
 */
static PyObject *Dtool_EggTextureCollection_find_used_textures_1163(PyObject *self, PyObject *arg) {
  EggTextureCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTextureCollection, (void **)&local_this, "EggTextureCollection.find_used_textures")) {
    return nullptr;
  }
  // 1-int EggTextureCollection::find_used_textures(EggNode *node)
  EggNode *arg_this = (EggNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggNode, 1, "EggTextureCollection.find_used_textures", false, true);
  if (arg_this != nullptr) {
    int return_value = ((*local_this).find_used_textures)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_used_textures(const EggTextureCollection self, EggNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_find_used_textures_1163_comment =
  "C++ Interface:\n"
  "find_used_textures(const EggTextureCollection self, EggNode node)\n"
  "\n"
  "/**\n"
  " * Walks the egg hierarchy beginning at the indicated node, looking for\n"
  " * textures that are referenced by primitives but are not already members of\n"
  " * the collection, adding them to the collection.\n"
  " *\n"
  " * If this is called following extract_textures(), it can be used to pick up\n"
  " * any additional texture references that appeared in the egg hierarchy (but\n"
  " * whose EggTexture node was not actually part of the hierarchy).\n"
  " *\n"
  " * If this is called in lieu of extract_textures(), it will fill up the\n"
  " * collection with all of the referenced textures (and only the referenced\n"
  " * textures), without destructively removing the EggTextures from the\n"
  " * hierarchy.\n"
  " *\n"
  " * This also has the side effect of incrementing the internal usage count for\n"
  " * a texture in the collection each time a texture reference is encountered.\n"
  " * This side effect is taken advantage of by remove_unused_textures().\n"
  " *\n"
  " * And one more side effect: this function identifies the presence of\n"
  " * multitexturing in the egg file, and calls multitexture_over() on each\n"
  " * texture appropriately so that, after this call, you may expect\n"
  " * get_multitexture_sort() to return a reasonable value for each texture.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_find_used_textures_1163_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggTextureCollection::remove_unused_textures(EggNode *node)
 */
static PyObject *Dtool_EggTextureCollection_remove_unused_textures_1164(PyObject *self, PyObject *arg) {
  EggTextureCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTextureCollection, (void **)&local_this, "EggTextureCollection.remove_unused_textures")) {
    return nullptr;
  }
  // 1-void EggTextureCollection::remove_unused_textures(EggNode *node)
  EggNode *arg_this = (EggNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggNode, 1, "EggTextureCollection.remove_unused_textures", false, true);
  if (arg_this != nullptr) {
    ((*local_this).remove_unused_textures)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_unused_textures(const EggTextureCollection self, EggNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_remove_unused_textures_1164_comment =
  "C++ Interface:\n"
  "remove_unused_textures(const EggTextureCollection self, EggNode node)\n"
  "\n"
  "/**\n"
  " * Removes any textures from the collection that aren't referenced by any\n"
  " * primitives in the indicated egg hierarchy.  This also, incidentally, adds\n"
  " * textures to the collection that had been referenced by primitives but had\n"
  " * not previously appeared in the collection.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_remove_unused_textures_1164_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int EggTextureCollection::collapse_equivalent_textures(int eq, EggGroupNode *node)
 * Rejected Remap [int EggTextureCollection::collapse_equivalent_textures(int eq, EggTextureCollection::TextureReplacement &removed)]
 */
static PyObject *Dtool_EggTextureCollection_collapse_equivalent_textures_1165(PyObject *self, PyObject *args, PyObject *kwds) {
  EggTextureCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTextureCollection, (void **)&local_this, "EggTextureCollection.collapse_equivalent_textures")) {
    return nullptr;
  }
  // 1-int EggTextureCollection::collapse_equivalent_textures(int eq, EggGroupNode *node)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"eq", "node", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:collapse_equivalent_textures", (char **)keyword_list, &param1, &param2)) {
    EggGroupNode *param2_this = (EggGroupNode *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_EggGroupNode, 2, "EggTextureCollection.collapse_equivalent_textures", false, true);
    if (param2_this != nullptr) {
      int return_value = ((*local_this).collapse_equivalent_textures)((int)param1, param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "collapse_equivalent_textures(const EggTextureCollection self, int eq, EggGroupNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_collapse_equivalent_textures_1165_comment =
  "C++ Interface:\n"
  "collapse_equivalent_textures(const EggTextureCollection self, int eq, EggGroupNode node)\n"
  "\n"
  "/**\n"
  " * Walks through the collection and collapses together any separate textures\n"
  " * that are equivalent according to the indicated equivalence factor, eq (see\n"
  " * EggTexture::is_equivalent_to()).  The return value is the number of\n"
  " * textures removed.\n"
  " *\n"
  " * This flavor of collapse_equivalent_textures() automatically adjusts all the\n"
  " * primitives in the egg hierarchy to refer to the new texture pointers.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Walks through the collection and collapses together any separate textures\n"
  " * that are equivalent according to the indicated equivalence factor, eq (see\n"
  " * EggTexture::is_equivalent_to()).  The return value is the number of\n"
  " * textures removed.\n"
  " *\n"
  " * This flavor of collapse_equivalent_textures() does not adjust any\n"
  " * primitives in the egg hierarchy; instead, it fills up the 'removed' map\n"
  " * with an entry for each removed texture, mapping it back to the equivalent\n"
  " * retained texture.  It's up to the user to then call replace_textures() with\n"
  " * this map, if desired, to apply these changes to the egg hierarchy.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_collapse_equivalent_textures_1165_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggTextureCollection::uniquify_trefs(void)
 */
static PyObject *Dtool_EggTextureCollection_uniquify_trefs_1167(PyObject *self, PyObject *) {
  EggTextureCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTextureCollection, (void **)&local_this, "EggTextureCollection.uniquify_trefs")) {
    return nullptr;
  }
  // 1-void EggTextureCollection::uniquify_trefs(void)
  ((*local_this).uniquify_trefs)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_uniquify_trefs_1167_comment =
  "C++ Interface:\n"
  "uniquify_trefs(const EggTextureCollection self)\n"
  "\n"
  "/**\n"
  " * Guarantees that each texture in the collection has a unique TRef name.\n"
  " * This is essential before writing an egg file.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_uniquify_trefs_1167_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggTextureCollection::sort_by_tref(void)
 */
static PyObject *Dtool_EggTextureCollection_sort_by_tref_1168(PyObject *self, PyObject *) {
  EggTextureCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTextureCollection, (void **)&local_this, "EggTextureCollection.sort_by_tref")) {
    return nullptr;
  }
  // 1-void EggTextureCollection::sort_by_tref(void)
  ((*local_this).sort_by_tref)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_sort_by_tref_1168_comment =
  "C++ Interface:\n"
  "sort_by_tref(const EggTextureCollection self)\n"
  "\n"
  "/**\n"
  " * Sorts all the textures into alphabetical order by TRef name.  Subsequent\n"
  " * operations using begin()/end() will traverse in this sorted order.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_sort_by_tref_1168_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggTextureCollection::sort_by_basename(void)
 */
static PyObject *Dtool_EggTextureCollection_sort_by_basename_1169(PyObject *self, PyObject *) {
  EggTextureCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTextureCollection, (void **)&local_this, "EggTextureCollection.sort_by_basename")) {
    return nullptr;
  }
  // 1-void EggTextureCollection::sort_by_basename(void)
  ((*local_this).sort_by_basename)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_sort_by_basename_1169_comment =
  "C++ Interface:\n"
  "sort_by_basename(const EggTextureCollection self)\n"
  "\n"
  "/**\n"
  " * Sorts all the textures into alphabetical order by the basename part\n"
  " * (including extension) of the filename.  Subsequent operations using\n"
  " * begin()/end() will traverse in this sorted order.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_sort_by_basename_1169_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggTextureCollection::add_texture(EggTexture *texture)
 */
static PyObject *Dtool_EggTextureCollection_add_texture_1172(PyObject *self, PyObject *arg) {
  EggTextureCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTextureCollection, (void **)&local_this, "EggTextureCollection.add_texture")) {
    return nullptr;
  }
  // 1-bool EggTextureCollection::add_texture(EggTexture *texture)
  EggTexture *arg_this = (EggTexture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggTexture, 1, "EggTextureCollection.add_texture", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).add_texture)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_texture(const EggTextureCollection self, EggTexture texture)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_add_texture_1172_comment =
  "C++ Interface:\n"
  "add_texture(const EggTextureCollection self, EggTexture texture)\n"
  "\n"
  "/**\n"
  " * Explicitly adds a new texture to the collection.  Returns true if the\n"
  " * texture was added, false if it was already there or if there was some\n"
  " * error.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_add_texture_1172_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggTextureCollection::remove_texture(EggTexture *texture)
 */
static PyObject *Dtool_EggTextureCollection_remove_texture_1173(PyObject *self, PyObject *arg) {
  EggTextureCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTextureCollection, (void **)&local_this, "EggTextureCollection.remove_texture")) {
    return nullptr;
  }
  // 1-bool EggTextureCollection::remove_texture(EggTexture *texture)
  EggTexture *arg_this = (EggTexture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggTexture, 1, "EggTextureCollection.remove_texture", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).remove_texture)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_texture(const EggTextureCollection self, EggTexture texture)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_remove_texture_1173_comment =
  "C++ Interface:\n"
  "remove_texture(const EggTextureCollection self, EggTexture texture)\n"
  "\n"
  "/**\n"
  " * Explicitly removes a texture from the collection.  Returns true if the\n"
  " * texture was removed, false if it wasn't there or if there was some error.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_remove_texture_1173_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggTexture *EggTextureCollection::create_unique_texture(EggTexture const &copy, int eq)
 */
static PyObject *Dtool_EggTextureCollection_create_unique_texture_1174(PyObject *self, PyObject *args, PyObject *kwds) {
  EggTextureCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTextureCollection, (void **)&local_this, "EggTextureCollection.create_unique_texture")) {
    return nullptr;
  }
  // 1-EggTexture *EggTextureCollection::create_unique_texture(EggTexture const &copy, int eq)
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"copy", "eq", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:create_unique_texture", (char **)keyword_list, &param1, &param2)) {
    EggTexture const *param1_this = (EggTexture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_EggTexture, 1, "EggTextureCollection.create_unique_texture", true, true);
    if (param1_this != nullptr) {
      EggTexture *return_value = ((*local_this).create_unique_texture)(*param1_this, (int)param2);
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggTexture, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "create_unique_texture(const EggTextureCollection self, const EggTexture copy, int eq)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_create_unique_texture_1174_comment =
  "C++ Interface:\n"
  "create_unique_texture(const EggTextureCollection self, const EggTexture copy, int eq)\n"
  "\n"
  "// create_unique_texture() creates a new texture if there is not already one\n"
  "// equivalent (according to eq, see EggTexture::is_equivalent_to()) to the\n"
  "// indicated texture, or returns the existing one if there is.\n"
  "\n"
  "/**\n"
  " * Creates a new texture if there is not already one equivalent (according to\n"
  " * eq, see EggTexture::is_equivalent_to()) to the indicated texture, or\n"
  " * returns the existing one if there is.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_create_unique_texture_1174_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggTexture *EggTextureCollection::find_tref(std::string const &tref_name) const
 */
static PyObject *Dtool_EggTextureCollection_find_tref_1175(PyObject *self, PyObject *arg) {
  EggTextureCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTextureCollection)) {
    return nullptr;
  }
  // 1-EggTexture *EggTextureCollection::find_tref(std::string const &tref_name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    EggTexture *return_value = ((*(const EggTextureCollection*)local_this).find_tref)(std::string(param1_str, param1_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggTexture, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_tref(EggTextureCollection self, str tref_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_find_tref_1175_comment =
  "C++ Interface:\n"
  "find_tref(EggTextureCollection self, str tref_name)\n"
  "\n"
  "// Find a texture with a particular TRef name.\n"
  "\n"
  "/**\n"
  " * Returns the texture with the indicated TRef name, or NULL if no texture\n"
  " * matches.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_find_tref_1175_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggTexture *EggTextureCollection::find_filename(Filename const &filename) const
 */
static PyObject *Dtool_EggTextureCollection_find_filename_1176(PyObject *self, PyObject *arg) {
  EggTextureCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggTextureCollection)) {
    return nullptr;
  }
  // 1-EggTexture *EggTextureCollection::find_filename(Filename const &filename) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggTextureCollection.find_filename", "Filename");
  }
  EggTexture *return_value = ((*(const EggTextureCollection*)local_this).find_filename)(*arg_this);
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggTexture, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_filename(EggTextureCollection self, const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTextureCollection_find_filename_1176_comment =
  "C++ Interface:\n"
  "find_filename(EggTextureCollection self, const Filename filename)\n"
  "\n"
  "// Find a texture with a particular filename.\n"
  "\n"
  "/**\n"
  " * Returns the texture with the indicated filename, or NULL if no texture\n"
  " * matches.\n"
  " */";
#else
static const char *Dtool_EggTextureCollection_find_filename_1176_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggTextureCollection::EggTextureCollection(void)
 * EggTextureCollection::EggTextureCollection(EggTextureCollection const &copy)
 */
static int Dtool_Init_EggTextureCollection(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-EggTextureCollection::EggTextureCollection(void)
      EggTextureCollection *return_value = new EggTextureCollection();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggTextureCollection, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-EggTextureCollection::EggTextureCollection(EggTextureCollection const &copy)
        EggTextureCollection const *arg_this = (EggTextureCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggTextureCollection, 0, "EggTextureCollection.EggTextureCollection", true, true);
        if (arg_this != nullptr) {
          EggTextureCollection *return_value = new EggTextureCollection(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggTextureCollection, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggTextureCollection() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggTextureCollection()\n"
      "EggTextureCollection(const EggTextureCollection copy)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_EggTextureCollection_get_textures(PyObject *self, PyObject *) {
  EggTextureCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTextureCollection, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_textures)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_EggTextureCollection_get_texture_1161(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_EggTextureCollection(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggTextureCollection) {
    printf("EggTextureCollection ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggTextureCollection *local_this = (EggTextureCollection *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggTextureCollection) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggTextureCollection(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggTextureCollection) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggTriangleFan
 */
/**
 * Python function wrapper for:
 * inline void EggTriangleFan::operator =(EggTriangleFan const &copy)
 */
static PyObject *Dtool_EggTriangleFan_operator_1179(PyObject *self, PyObject *arg) {
  EggTriangleFan *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTriangleFan, (void **)&local_this, "EggTriangleFan.assign")) {
    return nullptr;
  }
  // 1-inline void EggTriangleFan::operator =(EggTriangleFan const &copy)
  EggTriangleFan const *arg_this = (EggTriangleFan *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggTriangleFan, 1, "EggTriangleFan.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggTriangleFan *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggTriangleFan, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggTriangleFan self, const EggTriangleFan copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTriangleFan_operator_1179_comment =
  "C++ Interface:\n"
  "assign(const EggTriangleFan self, const EggTriangleFan copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTriangleFan_operator_1179_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggTriangleFan::get_class_type(void)
 */
static PyObject *Dtool_EggTriangleFan_get_class_type_1180(PyObject *, PyObject *) {
  // 1-static TypeHandle EggTriangleFan::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggTriangleFan::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggTriangleFan_get_class_type_1180_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggTriangleFan_get_class_type_1180_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggTriangleFan::EggTriangleFan(EggTriangleFan const &copy)
 * inline explicit EggTriangleFan::EggTriangleFan(std::string const &name = "")
 */
static int Dtool_Init_EggTriangleFan(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline explicit EggTriangleFan::EggTriangleFan(std::string const &name)
      EggTriangleFan *return_value = new EggTriangleFan();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggTriangleFan, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline EggTriangleFan::EggTriangleFan(EggTriangleFan const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          EggTriangleFan const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_EggTriangleFan);
          if (param0_this != nullptr) {
            EggTriangleFan *return_value = new EggTriangleFan(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggTriangleFan, true, false);
          }
        }
      }

      {
        // -2 inline explicit EggTriangleFan::EggTriangleFan(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:EggTriangleFan", (char **)keyword_list, &param0_str, &param0_len)) {
          EggTriangleFan *return_value = new EggTriangleFan(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggTriangleFan, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline EggTriangleFan::EggTriangleFan(EggTriangleFan const &copy)
      // No coercion possible: inline explicit EggTriangleFan::EggTriangleFan(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggTriangleFan() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggTriangleFan()\n"
      "EggTriangleFan(const EggTriangleFan copy)\n"
      "EggTriangleFan(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggTriangleFan(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggTriangleFan) {
    printf("EggTriangleFan ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggTriangleFan *local_this = (EggTriangleFan *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggTriangleFan) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggAttributes) {
    return (EggAttributes *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggCompositePrimitive) {
    return (EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggPrimitive) {
    return (EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return (EggRenderMode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggTriangleFan(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggTriangleFan) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggAttributes) {
    EggAttributes* other_this = (EggAttributes*)from_this;
    return (EggTriangleFan*)other_this;
  }
  if (from_type == Dtool_Ptr_EggCompositePrimitive) {
    EggCompositePrimitive* other_this = (EggCompositePrimitive*)from_this;
    return (EggTriangleFan*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggTriangleFan*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggTriangleFan*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggTriangleFan*)other_this;
  }
  if (from_type == Dtool_Ptr_EggPrimitive) {
    EggPrimitive* other_this = (EggPrimitive*)from_this;
    return (EggTriangleFan*)other_this;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    EggRenderMode* other_this = (EggRenderMode*)from_this;
    return (EggTriangleFan*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggTriangleFan*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggTriangleFan*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggTriangleFan*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggTriangleFan*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggTriangleStrip
 */
/**
 * Python function wrapper for:
 * inline void EggTriangleStrip::operator =(EggTriangleStrip const &copy)
 */
static PyObject *Dtool_EggTriangleStrip_operator_1183(PyObject *self, PyObject *arg) {
  EggTriangleStrip *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggTriangleStrip, (void **)&local_this, "EggTriangleStrip.assign")) {
    return nullptr;
  }
  // 1-inline void EggTriangleStrip::operator =(EggTriangleStrip const &copy)
  EggTriangleStrip const *arg_this = (EggTriangleStrip *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggTriangleStrip, 1, "EggTriangleStrip.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    EggTriangleStrip *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggTriangleStrip, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggTriangleStrip self, const EggTriangleStrip copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggTriangleStrip_operator_1183_comment =
  "C++ Interface:\n"
  "assign(const EggTriangleStrip self, const EggTriangleStrip copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggTriangleStrip_operator_1183_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggTriangleStrip::get_class_type(void)
 */
static PyObject *Dtool_EggTriangleStrip_get_class_type_1184(PyObject *, PyObject *) {
  // 1-static TypeHandle EggTriangleStrip::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggTriangleStrip::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggTriangleStrip_get_class_type_1184_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggTriangleStrip_get_class_type_1184_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggTriangleStrip::EggTriangleStrip(EggTriangleStrip const &copy)
 * inline explicit EggTriangleStrip::EggTriangleStrip(std::string const &name = "")
 */
static int Dtool_Init_EggTriangleStrip(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline explicit EggTriangleStrip::EggTriangleStrip(std::string const &name)
      EggTriangleStrip *return_value = new EggTriangleStrip();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggTriangleStrip, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline EggTriangleStrip::EggTriangleStrip(EggTriangleStrip const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          EggTriangleStrip const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_EggTriangleStrip);
          if (param0_this != nullptr) {
            EggTriangleStrip *return_value = new EggTriangleStrip(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggTriangleStrip, true, false);
          }
        }
      }

      {
        // -2 inline explicit EggTriangleStrip::EggTriangleStrip(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:EggTriangleStrip", (char **)keyword_list, &param0_str, &param0_len)) {
          EggTriangleStrip *return_value = new EggTriangleStrip(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggTriangleStrip, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline EggTriangleStrip::EggTriangleStrip(EggTriangleStrip const &copy)
      // No coercion possible: inline explicit EggTriangleStrip::EggTriangleStrip(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggTriangleStrip() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggTriangleStrip()\n"
      "EggTriangleStrip(const EggTriangleStrip copy)\n"
      "EggTriangleStrip(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EggTriangleStrip(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggTriangleStrip) {
    printf("EggTriangleStrip ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggTriangleStrip *local_this = (EggTriangleStrip *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggTriangleStrip) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggAttributes) {
    return (EggAttributes *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggCompositePrimitive) {
    return (EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggPrimitive) {
    return (EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggRenderMode) {
    return (EggRenderMode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggPrimitive *)(EggCompositePrimitive *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggTriangleStrip(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggTriangleStrip) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggAttributes) {
    EggAttributes* other_this = (EggAttributes*)from_this;
    return (EggTriangleStrip*)other_this;
  }
  if (from_type == Dtool_Ptr_EggCompositePrimitive) {
    EggCompositePrimitive* other_this = (EggCompositePrimitive*)from_this;
    return (EggTriangleStrip*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggTriangleStrip*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggTriangleStrip*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggTriangleStrip*)other_this;
  }
  if (from_type == Dtool_Ptr_EggPrimitive) {
    EggPrimitive* other_this = (EggPrimitive*)from_this;
    return (EggTriangleStrip*)other_this;
  }
  if (from_type == Dtool_Ptr_EggRenderMode) {
    EggRenderMode* other_this = (EggRenderMode*)from_this;
    return (EggTriangleStrip*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggTriangleStrip*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggTriangleStrip*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggTriangleStrip*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggTriangleStrip*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggXfmSAnim
 */
/**
 * Python function wrapper for:
 * inline void EggXfmSAnim::operator =(EggXfmSAnim const &copy)
 */
static PyObject *Dtool_EggXfmSAnim_operator_1187(PyObject *self, PyObject *arg) {
  EggXfmSAnim *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmSAnim, (void **)&local_this, "EggXfmSAnim.assign")) {
    return nullptr;
  }
  // 1-inline void EggXfmSAnim::operator =(EggXfmSAnim const &copy)
  CPT(EggXfmSAnim) arg_this;
  if (!Dtool_ConstCoerce_EggXfmSAnim(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggXfmSAnim.assign", "EggXfmSAnim");
  }
  ((*local_this).operator =)(*std::move(arg_this));
  EggXfmSAnim *return_value = local_this;
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggXfmSAnim, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggXfmSAnim self, const EggXfmSAnim copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_operator_1187_comment =
  "C++ Interface:\n"
  "assign(const EggXfmSAnim self, const EggXfmSAnim copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_operator_1187_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggXfmSAnim::set_fps(double fps)
 */
static PyObject *Dtool_EggXfmSAnim_set_fps_1188(PyObject *self, PyObject *arg) {
  EggXfmSAnim *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmSAnim, (void **)&local_this, "EggXfmSAnim.set_fps")) {
    return nullptr;
  }
  // 1-inline void EggXfmSAnim::set_fps(double fps)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_fps)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fps(const EggXfmSAnim self, double fps)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_set_fps_1188_comment =
  "C++ Interface:\n"
  "set_fps(const EggXfmSAnim self, double fps)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_set_fps_1188_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggXfmSAnim::clear_fps(void)
 */
static PyObject *Dtool_EggXfmSAnim_clear_fps_1189(PyObject *self, PyObject *) {
  EggXfmSAnim *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmSAnim, (void **)&local_this, "EggXfmSAnim.clear_fps")) {
    return nullptr;
  }
  // 1-inline void EggXfmSAnim::clear_fps(void)
  ((*local_this).clear_fps)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_clear_fps_1189_comment =
  "C++ Interface:\n"
  "clear_fps(const EggXfmSAnim self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_clear_fps_1189_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggXfmSAnim::has_fps(void) const
 */
static PyObject *Dtool_EggXfmSAnim_has_fps_1190(PyObject *self, PyObject *) {
  EggXfmSAnim *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggXfmSAnim)) {
    return nullptr;
  }
  // 1-inline bool EggXfmSAnim::has_fps(void) const
  bool return_value = ((*(const EggXfmSAnim*)local_this).has_fps)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_has_fps_1190_comment =
  "C++ Interface:\n"
  "has_fps(EggXfmSAnim self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_has_fps_1190_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double EggXfmSAnim::get_fps(void) const
 */
static PyObject *Dtool_EggXfmSAnim_get_fps_1191(PyObject *self, PyObject *) {
  EggXfmSAnim *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggXfmSAnim)) {
    return nullptr;
  }
  // 1-inline double EggXfmSAnim::get_fps(void) const
  double return_value = ((*(const EggXfmSAnim*)local_this).get_fps)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_get_fps_1191_comment =
  "C++ Interface:\n"
  "get_fps(EggXfmSAnim self)\n"
  "\n"
  "/**\n"
  " * This is only valid if has_fps() returns true.\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_get_fps_1191_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggXfmSAnim::set_order(std::string const &order)
 */
static PyObject *Dtool_EggXfmSAnim_set_order_1192(PyObject *self, PyObject *arg) {
  EggXfmSAnim *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmSAnim, (void **)&local_this, "EggXfmSAnim.set_order")) {
    return nullptr;
  }
  // 1-inline void EggXfmSAnim::set_order(std::string const &order)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_order)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_order(const EggXfmSAnim self, str order)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_set_order_1192_comment =
  "C++ Interface:\n"
  "set_order(const EggXfmSAnim self, str order)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_set_order_1192_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggXfmSAnim::clear_order(void)
 */
static PyObject *Dtool_EggXfmSAnim_clear_order_1193(PyObject *self, PyObject *) {
  EggXfmSAnim *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmSAnim, (void **)&local_this, "EggXfmSAnim.clear_order")) {
    return nullptr;
  }
  // 1-inline void EggXfmSAnim::clear_order(void)
  ((*local_this).clear_order)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_clear_order_1193_comment =
  "C++ Interface:\n"
  "clear_order(const EggXfmSAnim self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_clear_order_1193_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggXfmSAnim::has_order(void) const
 */
static PyObject *Dtool_EggXfmSAnim_has_order_1194(PyObject *self, PyObject *) {
  EggXfmSAnim *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggXfmSAnim)) {
    return nullptr;
  }
  // 1-inline bool EggXfmSAnim::has_order(void) const
  bool return_value = ((*(const EggXfmSAnim*)local_this).has_order)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_has_order_1194_comment =
  "C++ Interface:\n"
  "has_order(EggXfmSAnim self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_has_order_1194_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &EggXfmSAnim::get_order(void) const
 */
static PyObject *Dtool_EggXfmSAnim_get_order_1195(PyObject *self, PyObject *) {
  EggXfmSAnim *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggXfmSAnim)) {
    return nullptr;
  }
  // 1-inline std::string const &EggXfmSAnim::get_order(void) const
  std::string const &return_value = ((*(const EggXfmSAnim*)local_this).get_order)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_get_order_1195_comment =
  "C++ Interface:\n"
  "get_order(EggXfmSAnim self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_get_order_1195_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline std::string const &EggXfmSAnim::get_standard_order(void)
 */
static PyObject *Dtool_EggXfmSAnim_get_standard_order_1196(PyObject *, PyObject *) {
  // 1-static inline std::string const &EggXfmSAnim::get_standard_order(void)
  std::string const &return_value = (EggXfmSAnim::get_standard_order)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_get_standard_order_1196_comment =
  "C++ Interface:\n"
  "get_standard_order()\n"
  "\n"
  "/**\n"
  " * Returns the standard order of matrix component composition.  This is what\n"
  " * the order string must be set to in order to use set_value() or add_data()\n"
  " * successfully.\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_get_standard_order_1196_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CoordinateSystem EggXfmSAnim::get_coordinate_system(void) const
 */
static PyObject *Dtool_EggXfmSAnim_get_coordinate_system_1197(PyObject *self, PyObject *) {
  EggXfmSAnim *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggXfmSAnim)) {
    return nullptr;
  }
  // 1-inline CoordinateSystem EggXfmSAnim::get_coordinate_system(void) const
  CoordinateSystem return_value = ((*(const EggXfmSAnim*)local_this).get_coordinate_system)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_get_coordinate_system_1197_comment =
  "C++ Interface:\n"
  "get_coordinate_system(EggXfmSAnim self)\n"
  "\n"
  "/**\n"
  " * Returns the coordinate system this table believes it is defined within.\n"
  " * This should always match the coordinate system of the EggData structure\n"
  " * that owns it.  It is necessary to store it here because the meaning of the\n"
  " * h, p, and r columns depends on the coordinate system.\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_get_coordinate_system_1197_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggXfmSAnim::optimize(void)
 */
static PyObject *Dtool_EggXfmSAnim_optimize_1198(PyObject *self, PyObject *) {
  EggXfmSAnim *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmSAnim, (void **)&local_this, "EggXfmSAnim.optimize")) {
    return nullptr;
  }
  // 1-void EggXfmSAnim::optimize(void)
  ((*local_this).optimize)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_optimize_1198_comment =
  "C++ Interface:\n"
  "optimize(const EggXfmSAnim self)\n"
  "\n"
  "/**\n"
  " * Optimizes the table by collapsing redundant sub-tables.\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_optimize_1198_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggXfmSAnim::optimize_to_standard_order(void)
 */
static PyObject *Dtool_EggXfmSAnim_optimize_to_standard_order_1199(PyObject *self, PyObject *) {
  EggXfmSAnim *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmSAnim, (void **)&local_this, "EggXfmSAnim.optimize_to_standard_order")) {
    return nullptr;
  }
  // 1-void EggXfmSAnim::optimize_to_standard_order(void)
  ((*local_this).optimize_to_standard_order)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_optimize_to_standard_order_1199_comment =
  "C++ Interface:\n"
  "optimize_to_standard_order(const EggXfmSAnim self)\n"
  "\n"
  "/**\n"
  " * Optimizes the table by collapsing redundant sub-tables, and simultaneously\n"
  " * ensures that the order string is the standard order (which is the same as\n"
  " * that supported by compose_matrix() and decompose_matrix()).\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_optimize_to_standard_order_1199_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggXfmSAnim::normalize(void)
 */
static PyObject *Dtool_EggXfmSAnim_normalize_1200(PyObject *self, PyObject *) {
  EggXfmSAnim *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmSAnim, (void **)&local_this, "EggXfmSAnim.normalize")) {
    return nullptr;
  }
  // 1-void EggXfmSAnim::normalize(void)
  ((*local_this).normalize)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_normalize_1200_comment =
  "C++ Interface:\n"
  "normalize(const EggXfmSAnim self)\n"
  "\n"
  "/**\n"
  " * The inverse operation of optimize(), this ensures that all the sub-tables\n"
  " * have the same length by duplicating rows as necessary.  This is needed\n"
  " * before doing operations like add_data() or set_value() on an existing\n"
  " * table.\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_normalize_1200_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int EggXfmSAnim::get_num_rows(void) const
 */
static PyObject *Dtool_EggXfmSAnim_get_num_rows_1201(PyObject *self, PyObject *) {
  EggXfmSAnim *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggXfmSAnim)) {
    return nullptr;
  }
  // 1-int EggXfmSAnim::get_num_rows(void) const
  int return_value = ((*(const EggXfmSAnim*)local_this).get_num_rows)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_get_num_rows_1201_comment =
  "C++ Interface:\n"
  "get_num_rows(EggXfmSAnim self)\n"
  "\n"
  "/**\n"
  " * Returns the effective number of rows in the table.  This is actually the\n"
  " * number of rows of the smallest subtable larger than one row.  This is a\n"
  " * convenience function that treats the table of tables as if it were a single\n"
  " * table of matrices.\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_get_num_rows_1201_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggXfmSAnim::get_value(int row, LMatrix4d &mat) const
 */
static PyObject *Dtool_EggXfmSAnim_get_value_1202(PyObject *self, PyObject *args, PyObject *kwds) {
  EggXfmSAnim *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggXfmSAnim)) {
    return nullptr;
  }
  // 1-void EggXfmSAnim::get_value(int row, LMatrix4d &mat) const
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"row", "mat", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_value", (char **)keyword_list, &param1, &param2)) {
    LMatrix4d param2_local;
    LMatrix4d *param2_this = Dtool_Coerce_LMatrix4d(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "EggXfmSAnim.get_value", "LMatrix4d");
    }
    ((*(const EggXfmSAnim*)local_this).get_value)((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_value(EggXfmSAnim self, int row, LMatrix4d mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_get_value_1202_comment =
  "C++ Interface:\n"
  "get_value(EggXfmSAnim self, int row, LMatrix4d mat)\n"
  "\n"
  "/**\n"
  " * Returns the value of the aggregate row of the table as a matrix.  This is a\n"
  " * convenience function that treats the table of tables as if it were a single\n"
  " * table of matrices.  It is an error to call this if any SAnimData children\n"
  " * of this node have an improper name (e.g.  not a single letter, or not one\n"
  " * of \"ijkabchprxyz\").\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_get_value_1202_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggXfmSAnim::set_value(int row, LMatrix4d const &mat)
 */
static PyObject *Dtool_EggXfmSAnim_set_value_1203(PyObject *self, PyObject *args, PyObject *kwds) {
  EggXfmSAnim *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmSAnim, (void **)&local_this, "EggXfmSAnim.set_value")) {
    return nullptr;
  }
  // 1-bool EggXfmSAnim::set_value(int row, LMatrix4d const &mat)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"row", "mat", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_value", (char **)keyword_list, &param1, &param2)) {
    LMatrix4d param2_local;
    LMatrix4d const *param2_this = Dtool_Coerce_LMatrix4d(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "EggXfmSAnim.set_value", "LMatrix4d");
    }
    bool return_value = ((*local_this).set_value)((int)param1, *param2_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const EggXfmSAnim self, int row, const LMatrix4d mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_set_value_1203_comment =
  "C++ Interface:\n"
  "set_value(const EggXfmSAnim self, int row, const LMatrix4d mat)\n"
  "\n"
  "/**\n"
  " * Replaces the indicated row of the table with the given matrix.\n"
  " *\n"
  " * This function can only be called if all the constraints of add_data(),\n"
  " * below, are met.  Call normalize() first if you are not sure.\n"
  " *\n"
  " * The return value is true if the matrix can be decomposed and stored as\n"
  " * scale, shear, rotate, and translate, or false otherwise.  The data is set\n"
  " * in either case.\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_set_value_1203_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggXfmSAnim::clear_data(void)
 */
static PyObject *Dtool_EggXfmSAnim_clear_data_1204(PyObject *self, PyObject *) {
  EggXfmSAnim *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmSAnim, (void **)&local_this, "EggXfmSAnim.clear_data")) {
    return nullptr;
  }
  // 1-inline void EggXfmSAnim::clear_data(void)
  ((*local_this).clear_data)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_clear_data_1204_comment =
  "C++ Interface:\n"
  "clear_data(const EggXfmSAnim self)\n"
  "\n"
  "/**\n"
  " * Removes all data from the table.  It does this by removing all of its\n"
  " * children.\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_clear_data_1204_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EggXfmSAnim::add_data(LMatrix4d const &mat)
 */
static PyObject *Dtool_EggXfmSAnim_add_data_1205(PyObject *self, PyObject *arg) {
  EggXfmSAnim *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmSAnim, (void **)&local_this, "EggXfmSAnim.add_data")) {
    return nullptr;
  }
  // 1-bool EggXfmSAnim::add_data(LMatrix4d const &mat)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggXfmSAnim.add_data", "LMatrix4d");
  }
  bool return_value = ((*local_this).add_data)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_data(const EggXfmSAnim self, const LMatrix4d mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_add_data_1205_comment =
  "C++ Interface:\n"
  "add_data(const EggXfmSAnim self, const LMatrix4d mat)\n"
  "\n"
  "/**\n"
  " * Adds a new matrix to the table, by adding a new row to each of the\n"
  " * subtables.\n"
  " *\n"
  " * This is a convenience function that treats the table of tables as if it\n"
  " * were a single table of matrices.  It is an error to call this if any\n"
  " * SAnimData children of this node have an improper name (e.g.  not a single\n"
  " * letter, or not one of \"ijkabchprxyz\").\n"
  " *\n"
  " * This function has the further requirement that all nine of the subtables\n"
  " * must exist and be of the same length.  Furthermore, the order string must\n"
  " * be the standard order string, which matches the system compose_matrix() and\n"
  " * decompose_matrix() functions.\n"
  " *\n"
  " * Thus, you probably cannot take an existing EggXfmSAnim object and start\n"
  " * adding matrices to the end; you must clear out the original data first.\n"
  " * (As a special exception, if no tables exist, they will be created.)  The\n"
  " * method normalize() will do this for you on an existing EggXfmSAnim.\n"
  " *\n"
  " * This function may fail silently if the matrix cannot be decomposed into\n"
  " * scale, shear, rotate, and translate.  In this case, the closest\n"
  " * approximation is added to the table, and false is returned.\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_add_data_1205_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggXfmSAnim::add_component_data(int component, double value)
 * void EggXfmSAnim::add_component_data(std::string const &component_name, double value)
 */
static PyObject *Dtool_EggXfmSAnim_add_component_data_1206(PyObject *self, PyObject *args, PyObject *kwds) {
  EggXfmSAnim *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmSAnim, (void **)&local_this, "EggXfmSAnim.add_component_data")) {
    return nullptr;
  }
  {
    // -2 void EggXfmSAnim::add_component_data(std::string const &component_name, double value)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
    double param2;
    static const char *keyword_list[] = {"component_name", "value", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#d:add_component_data", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
      ((*local_this).add_component_data)(std::string(param1_str, param1_len), (double)param2);
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  {
    // -2 void EggXfmSAnim::add_component_data(int component, double value)
    int param1;
    double param2;
    static const char *keyword_list[] = {"component", "value", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "id:add_component_data", (char **)keyword_list, &param1, &param2)) {
      ((*local_this).add_component_data)((int)param1, (double)param2);
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  // No coercion possible: void EggXfmSAnim::add_component_data(std::string const &component_name, double value)
  // No coercion possible: void EggXfmSAnim::add_component_data(int component, double value)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_component_data(const EggXfmSAnim self, str component_name, double value)\n"
      "add_component_data(const EggXfmSAnim self, int component, double value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_add_component_data_1206_comment =
  "C++ Interface:\n"
  "add_component_data(const EggXfmSAnim self, str component_name, double value)\n"
  "add_component_data(const EggXfmSAnim self, int component, double value)\n"
  "\n"
  "/**\n"
  " * Adds a new row to the named component (one of matrix_component_letters) of\n"
  " * the table.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds a new row to the indicated component (0-12) of the table.\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_add_component_data_1206_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void EggXfmSAnim::compose_with_order(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, LVecBase3d const &trans, std::string const &order, CoordinateSystem cs)
 */
static PyObject *Dtool_EggXfmSAnim_compose_with_order_1207(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static void EggXfmSAnim::compose_with_order(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, LVecBase3d const &trans, std::string const &order, CoordinateSystem cs)
  PyObject *param0;
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  PyObject *param4;
  const char *param5_str = nullptr;
  Py_ssize_t param5_len;
  int param6;
  static const char *keyword_list[] = {"mat", "scale", "shear", "hpr", "trans", "order", "cs", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOs#i:compose_with_order", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5_str, &param5_len, &param6)) {
    LMatrix4d param0_local;
    LMatrix4d *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
    if (!(param0_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "EggXfmSAnim.compose_with_order", "LMatrix4d");
    }
    LVecBase3d param1_local;
    LVecBase3d const *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "EggXfmSAnim.compose_with_order", "LVecBase3d");
    }
    LVecBase3d param2_local;
    LVecBase3d const *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "EggXfmSAnim.compose_with_order", "LVecBase3d");
    }
    LVecBase3d param3_local;
    LVecBase3d const *param3_this = Dtool_Coerce_LVecBase3d(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "EggXfmSAnim.compose_with_order", "LVecBase3d");
    }
    LVecBase3d param4_local;
    LVecBase3d const *param4_this = Dtool_Coerce_LVecBase3d(param4, param4_local);
    if (!(param4_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param4, 4, "EggXfmSAnim.compose_with_order", "LVecBase3d");
    }
    (EggXfmSAnim::compose_with_order)(*param0_this, *param1_this, *param2_this, *param3_this, *param4_this, std::string(param5_str, param5_len), (CoordinateSystem)param6);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compose_with_order(LMatrix4d mat, const LVecBase3d scale, const LVecBase3d shear, const LVecBase3d hpr, const LVecBase3d trans, str order, int cs)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_compose_with_order_1207_comment =
  "C++ Interface:\n"
  "compose_with_order(LMatrix4d mat, const LVecBase3d scale, const LVecBase3d shear, const LVecBase3d hpr, const LVecBase3d trans, str order, int cs)\n"
  "\n"
  "/**\n"
  " * Composes a matrix out of the nine individual components, respecting the\n"
  " * order string.  The components will be applied in the order indicated by the\n"
  " * string.\n"
  " */";
#else
static const char *Dtool_EggXfmSAnim_compose_with_order_1207_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggXfmSAnim::get_class_type(void)
 */
static PyObject *Dtool_EggXfmSAnim_get_class_type_1208(PyObject *, PyObject *) {
  // 1-static TypeHandle EggXfmSAnim::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggXfmSAnim::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmSAnim_get_class_type_1208_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggXfmSAnim_get_class_type_1208_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EggXfmSAnim::EggXfmSAnim(EggXfmAnimData const &convert_from)
 * inline EggXfmSAnim::EggXfmSAnim(EggXfmSAnim const &copy)
 * inline explicit EggXfmSAnim::EggXfmSAnim(std::string const &name = "", CoordinateSystem cs = ::CS_default)
 */
static int Dtool_Init_EggXfmSAnim(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline explicit EggXfmSAnim::EggXfmSAnim(std::string const &name, CoordinateSystem cs)
      EggXfmSAnim *return_value = new EggXfmSAnim();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggXfmSAnim, true, false);
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 inline explicit EggXfmSAnim::EggXfmSAnim(std::string const &name, CoordinateSystem cs = ::CS_default)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        int param1 = ::CS_default;
        static const char *keyword_list[] = {"name", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|i:EggXfmSAnim", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
          EggXfmSAnim *return_value = new EggXfmSAnim(std::string(param0_str, param0_len), (CoordinateSystem)param1);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggXfmSAnim, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 EggXfmSAnim::EggXfmSAnim(EggXfmAnimData const &convert_from)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "convert_from")) {
          EggXfmAnimData const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_EggXfmAnimData);
          if (param0_this != nullptr) {
            EggXfmSAnim *return_value = new EggXfmSAnim(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggXfmSAnim, true, false);
          }
        }
      }

      {
        // -2 inline EggXfmSAnim::EggXfmSAnim(EggXfmSAnim const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          EggXfmSAnim const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_EggXfmSAnim);
          if (param0_this != nullptr) {
            EggXfmSAnim *return_value = new EggXfmSAnim(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggXfmSAnim, true, false);
          }
        }
      }

      // No coercion possible: inline explicit EggXfmSAnim::EggXfmSAnim(std::string const &name, CoordinateSystem cs = ::CS_default)
      {
        // -2 EggXfmSAnim::EggXfmSAnim(EggXfmAnimData const &convert_from)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "convert_from")) {
          CPT(EggXfmAnimData) param0_this;
          if (Dtool_ConstCoerce_EggXfmAnimData(param0, param0_this)) {
            EggXfmSAnim *return_value = new EggXfmSAnim(*std::move(param0_this));
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggXfmSAnim, true, false);
          }
        }
      }

      {
        // -2 inline EggXfmSAnim::EggXfmSAnim(EggXfmSAnim const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          CPT(EggXfmSAnim) param0_this;
          if (Dtool_ConstCoerce_EggXfmSAnim(param0, param0_this)) {
            EggXfmSAnim *return_value = new EggXfmSAnim(*std::move(param0_this));
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggXfmSAnim, true, false);
          }
        }
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggXfmSAnim() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggXfmSAnim()\n"
      "EggXfmSAnim(str name, int cs)\n"
      "EggXfmSAnim(const EggXfmAnimData convert_from)\n"
      "EggXfmSAnim(const EggXfmSAnim copy)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_EggXfmSAnim(PyObject *args, CPT(EggXfmSAnim) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_EggXfmSAnim)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-EggXfmSAnim::EggXfmSAnim(EggXfmAnimData const &convert_from)
    EggXfmAnimData const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_EggXfmAnimData);
    if (arg_this != nullptr) {
      EggXfmSAnim *return_value = new EggXfmSAnim(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_EggXfmSAnim(PyObject *args, PT(EggXfmSAnim) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_EggXfmSAnim)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-EggXfmSAnim::EggXfmSAnim(EggXfmAnimData const &convert_from)
    EggXfmAnimData const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_EggXfmAnimData);
    if (arg_this != nullptr) {
      EggXfmSAnim *return_value = new EggXfmSAnim(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_EggXfmSAnim(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggXfmSAnim) {
    printf("EggXfmSAnim ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggXfmSAnim *local_this = (EggXfmSAnim *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggXfmSAnim) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggGroupNode) {
    return (EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggGroupNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggXfmSAnim(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggXfmSAnim) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggGroupNode) {
    EggGroupNode* other_this = (EggGroupNode*)from_this;
    return (EggXfmSAnim*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggXfmSAnim*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggXfmSAnim*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggXfmSAnim*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggXfmSAnim*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggXfmSAnim*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggXfmSAnim*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggXfmSAnim*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EggXfmAnimData
 */
/**
 * Python function wrapper for:
 * inline void EggXfmAnimData::operator =(EggXfmAnimData const &copy)
 */
static PyObject *Dtool_EggXfmAnimData_operator_1212(PyObject *self, PyObject *arg) {
  EggXfmAnimData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmAnimData, (void **)&local_this, "EggXfmAnimData.assign")) {
    return nullptr;
  }
  // 1-inline void EggXfmAnimData::operator =(EggXfmAnimData const &copy)
  CPT(EggXfmAnimData) arg_this;
  if (!Dtool_ConstCoerce_EggXfmAnimData(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EggXfmAnimData.assign", "EggXfmAnimData");
  }
  ((*local_this).operator =)(*std::move(arg_this));
  EggXfmAnimData *return_value = local_this;
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggXfmAnimData, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EggXfmAnimData self, const EggXfmAnimData copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggXfmAnimData_operator_1212_comment =
  "C++ Interface:\n"
  "assign(const EggXfmAnimData self, const EggXfmAnimData copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmAnimData_operator_1212_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggXfmAnimData::set_order(std::string const &order)
 */
static PyObject *Dtool_EggXfmAnimData_set_order_1213(PyObject *self, PyObject *arg) {
  EggXfmAnimData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmAnimData, (void **)&local_this, "EggXfmAnimData.set_order")) {
    return nullptr;
  }
  // 1-inline void EggXfmAnimData::set_order(std::string const &order)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_order)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_order(const EggXfmAnimData self, str order)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggXfmAnimData_set_order_1213_comment =
  "C++ Interface:\n"
  "set_order(const EggXfmAnimData self, str order)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmAnimData_set_order_1213_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggXfmAnimData::clear_order(void)
 */
static PyObject *Dtool_EggXfmAnimData_clear_order_1214(PyObject *self, PyObject *) {
  EggXfmAnimData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmAnimData, (void **)&local_this, "EggXfmAnimData.clear_order")) {
    return nullptr;
  }
  // 1-inline void EggXfmAnimData::clear_order(void)
  ((*local_this).clear_order)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggXfmAnimData_clear_order_1214_comment =
  "C++ Interface:\n"
  "clear_order(const EggXfmAnimData self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmAnimData_clear_order_1214_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggXfmAnimData::has_order(void) const
 */
static PyObject *Dtool_EggXfmAnimData_has_order_1215(PyObject *self, PyObject *) {
  EggXfmAnimData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggXfmAnimData)) {
    return nullptr;
  }
  // 1-inline bool EggXfmAnimData::has_order(void) const
  bool return_value = ((*(const EggXfmAnimData*)local_this).has_order)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmAnimData_has_order_1215_comment =
  "C++ Interface:\n"
  "has_order(EggXfmAnimData self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmAnimData_has_order_1215_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &EggXfmAnimData::get_order(void) const
 */
static PyObject *Dtool_EggXfmAnimData_get_order_1216(PyObject *self, PyObject *) {
  EggXfmAnimData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggXfmAnimData)) {
    return nullptr;
  }
  // 1-inline std::string const &EggXfmAnimData::get_order(void) const
  std::string const &return_value = ((*(const EggXfmAnimData*)local_this).get_order)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmAnimData_get_order_1216_comment =
  "C++ Interface:\n"
  "get_order(EggXfmAnimData self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmAnimData_get_order_1216_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline std::string const &EggXfmAnimData::get_standard_order(void)
 */
static PyObject *Dtool_EggXfmAnimData_get_standard_order_1217(PyObject *, PyObject *) {
  // 1-static inline std::string const &EggXfmAnimData::get_standard_order(void)
  std::string const &return_value = (EggXfmAnimData::get_standard_order)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmAnimData_get_standard_order_1217_comment =
  "C++ Interface:\n"
  "get_standard_order()\n"
  "\n"
  "/**\n"
  " * Returns the standard order of matrix component composition.  This is what\n"
  " * the order string must be set to in order to use set_value() or add_data()\n"
  " * successfully.\n"
  " */";
#else
static const char *Dtool_EggXfmAnimData_get_standard_order_1217_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggXfmAnimData::set_contents(std::string const &contents)
 */
static PyObject *Dtool_EggXfmAnimData_set_contents_1218(PyObject *self, PyObject *arg) {
  EggXfmAnimData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmAnimData, (void **)&local_this, "EggXfmAnimData.set_contents")) {
    return nullptr;
  }
  // 1-inline void EggXfmAnimData::set_contents(std::string const &contents)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_contents)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_contents(const EggXfmAnimData self, str contents)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggXfmAnimData_set_contents_1218_comment =
  "C++ Interface:\n"
  "set_contents(const EggXfmAnimData self, str contents)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmAnimData_set_contents_1218_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void EggXfmAnimData::clear_contents(void)
 */
static PyObject *Dtool_EggXfmAnimData_clear_contents_1219(PyObject *self, PyObject *) {
  EggXfmAnimData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EggXfmAnimData, (void **)&local_this, "EggXfmAnimData.clear_contents")) {
    return nullptr;
  }
  // 1-inline void EggXfmAnimData::clear_contents(void)
  ((*local_this).clear_contents)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EggXfmAnimData_clear_contents_1219_comment =
  "C++ Interface:\n"
  "clear_contents(const EggXfmAnimData self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmAnimData_clear_contents_1219_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EggXfmAnimData::has_contents(void) const
 */
static PyObject *Dtool_EggXfmAnimData_has_contents_1220(PyObject *self, PyObject *) {
  EggXfmAnimData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggXfmAnimData)) {
    return nullptr;
  }
  // 1-inline bool EggXfmAnimData::has_contents(void) const
  bool return_value = ((*(const EggXfmAnimData*)local_this).has_contents)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmAnimData_has_contents_1220_comment =
  "C++ Interface:\n"
  "has_contents(EggXfmAnimData self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmAnimData_has_contents_1220_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &EggXfmAnimData::get_contents(void) const
 */
static PyObject *Dtool_EggXfmAnimData_get_contents_1221(PyObject *self, PyObject *) {
  EggXfmAnimData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggXfmAnimData)) {
    return nullptr;
  }
  // 1-inline std::string const &EggXfmAnimData::get_contents(void) const
  std::string const &return_value = ((*(const EggXfmAnimData*)local_this).get_contents)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmAnimData_get_contents_1221_comment =
  "C++ Interface:\n"
  "get_contents(EggXfmAnimData self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EggXfmAnimData_get_contents_1221_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CoordinateSystem EggXfmAnimData::get_coordinate_system(void) const
 */
static PyObject *Dtool_EggXfmAnimData_get_coordinate_system_1222(PyObject *self, PyObject *) {
  EggXfmAnimData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggXfmAnimData)) {
    return nullptr;
  }
  // 1-inline CoordinateSystem EggXfmAnimData::get_coordinate_system(void) const
  CoordinateSystem return_value = ((*(const EggXfmAnimData*)local_this).get_coordinate_system)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmAnimData_get_coordinate_system_1222_comment =
  "C++ Interface:\n"
  "get_coordinate_system(EggXfmAnimData self)\n"
  "\n"
  "/**\n"
  " * Returns the coordinate system this table believes it is defined within.\n"
  " * This should always match the coordinate system of the EggData structure\n"
  " * that owns it.  It is necessary to store it here because the meaning of the\n"
  " * h, p, and r columns depends on the coordinate system.\n"
  " */";
#else
static const char *Dtool_EggXfmAnimData_get_coordinate_system_1222_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggXfmAnimData::get_num_rows(void) const
 */
static PyObject *Dtool_EggXfmAnimData_get_num_rows_1223(PyObject *self, PyObject *) {
  EggXfmAnimData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggXfmAnimData)) {
    return nullptr;
  }
  // 1-inline int EggXfmAnimData::get_num_rows(void) const
  int return_value = ((*(const EggXfmAnimData*)local_this).get_num_rows)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmAnimData_get_num_rows_1223_comment =
  "C++ Interface:\n"
  "get_num_rows(EggXfmAnimData self)\n"
  "\n"
  "/**\n"
  " * Returns the number of rows in the table.\n"
  " */";
#else
static const char *Dtool_EggXfmAnimData_get_num_rows_1223_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EggXfmAnimData::get_num_cols(void) const
 */
static PyObject *Dtool_EggXfmAnimData_get_num_cols_1224(PyObject *self, PyObject *) {
  EggXfmAnimData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggXfmAnimData)) {
    return nullptr;
  }
  // 1-inline int EggXfmAnimData::get_num_cols(void) const
  int return_value = ((*(const EggXfmAnimData*)local_this).get_num_cols)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmAnimData_get_num_cols_1224_comment =
  "C++ Interface:\n"
  "get_num_cols(EggXfmAnimData self)\n"
  "\n"
  "/**\n"
  " * Returns the number of columns in the table.  This is set according to the\n"
  " * \"contents\" string, which defines the meaning of each column.\n"
  " */";
#else
static const char *Dtool_EggXfmAnimData_get_num_cols_1224_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EggXfmAnimData::get_value(int row, LMatrix4d &mat) const
 * inline double EggXfmAnimData::get_value(int row, int col) const
 */
static PyObject *Dtool_EggXfmAnimData_get_value_1225(PyObject *self, PyObject *args, PyObject *kwds) {
  EggXfmAnimData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EggXfmAnimData)) {
    return nullptr;
  }
  {
    // -2 void EggXfmAnimData::get_value(int row, LMatrix4d &mat) const
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"row", "mat", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_value", (char **)keyword_list, &param1, &param2)) {
      LMatrix4d *param2_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_LMatrix4d, 2, "EggXfmAnimData.get_value", false, false);
      if (param2_this != nullptr) {
        ((*(const EggXfmAnimData*)local_this).get_value)((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline double EggXfmAnimData::get_value(int row, int col) const
    int param1;
    int param2;
    static const char *keyword_list[] = {"row", "col", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_value", (char **)keyword_list, &param1, &param2)) {
      double return_value = ((*(const EggXfmAnimData*)local_this).get_value)((int)param1, (int)param2);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    PyErr_Clear();
  }

  {
    // -2 void EggXfmAnimData::get_value(int row, LMatrix4d &mat) const
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"row", "mat", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_value", (char **)keyword_list, &param1, &param2)) {
      LMatrix4d param2_local;
      LMatrix4d *param2_this = Dtool_Coerce_LMatrix4d(param2, param2_local);
      if ((param2_this != nullptr)) {
        ((*(const EggXfmAnimData*)local_this).get_value)((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: inline double EggXfmAnimData::get_value(int row, int col) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_value(EggXfmAnimData self, int row, LMatrix4d mat)\n"
      "get_value(EggXfmAnimData self, int row, int col)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EggXfmAnimData_get_value_1225_comment =
  "C++ Interface:\n"
  "get_value(EggXfmAnimData self, int row, LMatrix4d mat)\n"
  "get_value(EggXfmAnimData self, int row, int col)\n"
  "\n"
  "/**\n"
  " * Returns the value at the indicated row.  Row must be in the range 0 <= row\n"
  " * < get_num_rows(); col must be in the range 0 <= col < get_num_cols().\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the value of the aggregate row of the table as a matrix.  This is a\n"
  " * convenience function that treats the 2-d table as if it were a single table\n"
  " * of matrices.\n"
  " */";
#else
static const char *Dtool_EggXfmAnimData_get_value_1225_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EggXfmAnimData::get_class_type(void)
 */
static PyObject *Dtool_EggXfmAnimData_get_class_type_1226(PyObject *, PyObject *) {
  // 1-static TypeHandle EggXfmAnimData::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EggXfmAnimData::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EggXfmAnimData_get_class_type_1226_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EggXfmAnimData_get_class_type_1226_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EggXfmAnimData::EggXfmAnimData(EggXfmAnimData const &copy)
 * EggXfmAnimData::EggXfmAnimData(EggXfmSAnim const &convert_from)
 * inline explicit EggXfmAnimData::EggXfmAnimData(std::string const &name = "", CoordinateSystem cs = ::CS_default)
 */
static int Dtool_Init_EggXfmAnimData(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline explicit EggXfmAnimData::EggXfmAnimData(std::string const &name, CoordinateSystem cs)
      EggXfmAnimData *return_value = new EggXfmAnimData();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggXfmAnimData, true, false);
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 inline explicit EggXfmAnimData::EggXfmAnimData(std::string const &name, CoordinateSystem cs = ::CS_default)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        int param1 = ::CS_default;
        static const char *keyword_list[] = {"name", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|i:EggXfmAnimData", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
          EggXfmAnimData *return_value = new EggXfmAnimData(std::string(param0_str, param0_len), (CoordinateSystem)param1);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggXfmAnimData, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline EggXfmAnimData::EggXfmAnimData(EggXfmAnimData const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          EggXfmAnimData const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_EggXfmAnimData);
          if (param0_this != nullptr) {
            EggXfmAnimData *return_value = new EggXfmAnimData(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggXfmAnimData, true, false);
          }
        }
      }

      {
        // -2 EggXfmAnimData::EggXfmAnimData(EggXfmSAnim const &convert_from)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "convert_from")) {
          EggXfmSAnim const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_EggXfmSAnim);
          if (param0_this != nullptr) {
            EggXfmAnimData *return_value = new EggXfmAnimData(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggXfmAnimData, true, false);
          }
        }
      }

      // No coercion possible: inline explicit EggXfmAnimData::EggXfmAnimData(std::string const &name, CoordinateSystem cs = ::CS_default)
      {
        // -2 inline EggXfmAnimData::EggXfmAnimData(EggXfmAnimData const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          CPT(EggXfmAnimData) param0_this;
          if (Dtool_ConstCoerce_EggXfmAnimData(param0, param0_this)) {
            EggXfmAnimData *return_value = new EggXfmAnimData(*std::move(param0_this));
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggXfmAnimData, true, false);
          }
        }
      }

      {
        // -2 EggXfmAnimData::EggXfmAnimData(EggXfmSAnim const &convert_from)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "convert_from")) {
          CPT(EggXfmSAnim) param0_this;
          if (Dtool_ConstCoerce_EggXfmSAnim(param0, param0_this)) {
            EggXfmAnimData *return_value = new EggXfmAnimData(*std::move(param0_this));
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EggXfmAnimData, true, false);
          }
        }
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EggXfmAnimData() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EggXfmAnimData()\n"
      "EggXfmAnimData(str name, int cs)\n"
      "EggXfmAnimData(const EggXfmAnimData copy)\n"
      "EggXfmAnimData(const EggXfmSAnim convert_from)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_EggXfmAnimData(PyObject *args, CPT(EggXfmAnimData) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_EggXfmAnimData)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-EggXfmAnimData::EggXfmAnimData(EggXfmSAnim const &convert_from)
    EggXfmSAnim const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_EggXfmSAnim);
    if (arg_this != nullptr) {
      EggXfmAnimData *return_value = new EggXfmAnimData(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_EggXfmAnimData(PyObject *args, PT(EggXfmAnimData) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_EggXfmAnimData)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-EggXfmAnimData::EggXfmAnimData(EggXfmSAnim const &convert_from)
    EggXfmSAnim const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_EggXfmSAnim);
    if (arg_this != nullptr) {
      EggXfmAnimData *return_value = new EggXfmAnimData(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_EggXfmAnimData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EggXfmAnimData) {
    printf("EggXfmAnimData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EggXfmAnimData *local_this = (EggXfmAnimData *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EggXfmAnimData) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_EggAnimData) {
    return (EggAnimData *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNamedObject) {
    return (EggNamedObject *)(EggNode *)(EggAnimData *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggNode) {
    return (EggNode *)(EggAnimData *) local_this;
  }
  if (requested_type == Dtool_Ptr_EggObject) {
    return (EggObject *)(EggNamedObject *)(EggNode *)(EggAnimData *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(EggNamedObject *)(EggNode *)(EggAnimData *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggAnimData *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggAnimData *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(EggObject *)(EggNamedObject *)(EggNode *)(EggAnimData *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EggXfmAnimData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EggXfmAnimData) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_EggAnimData) {
    EggAnimData* other_this = (EggAnimData*)from_this;
    return (EggXfmAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNamedObject) {
    EggNamedObject* other_this = (EggNamedObject*)from_this;
    return (EggXfmAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_EggNode) {
    EggNode* other_this = (EggNode*)from_this;
    return (EggXfmAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_EggObject) {
    EggObject* other_this = (EggObject*)from_this;
    return (EggXfmAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (EggXfmAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EggXfmAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EggXfmAnimData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EggXfmAnimData*)other_this;
  }
  return nullptr;
}

/**
 * Python method tables for EggUserData (EggUserData)
 */
static PyMethodDef Dtool_Methods_EggUserData[] = {
  {"assign", &Dtool_EggUserData_operator_4, METH_O, (const char *)Dtool_EggUserData_operator_4_comment},
  {"get_class_type", &Dtool_EggUserData_get_class_type_5, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggUserData_get_class_type_5_comment},
  {"getClassType", &Dtool_EggUserData_get_class_type_5, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggUserData_get_class_type_5_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EggUserData = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggUserData = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggUserData = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggUserData = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggUserData = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggUserData = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggUserData",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggUserData,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggUserData,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggUserData,
    &Dtool_SequenceMethods_EggUserData,
    &Dtool_MappingMethods_EggUserData,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggUserData,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a base class for a user-defined data type to extend egg structures\n"
    " * in processing code.  The user of the egg library may derive from\n"
    " * EggUserData to associate any arbitrary data with various egg objects.\n"
    " *\n"
    " * However, this data will not be written out to the disk when the egg file is\n"
    " * written; it is an in-memory object only.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggUserData,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggUserData,
    PyType_GenericAlloc,
    Dtool_new_EggUserData,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggUserData,
  Dtool_UpcastInterface_EggUserData,
  Dtool_DowncastInterface_EggUserData,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggUserData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_EggUserData._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_EggUserData._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggUserData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggUserData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggUserData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggUserData);
  }
}

/**
 * Python method tables for EggObject (EggObject)
 */
static PyMethodDef Dtool_Methods_EggObject[] = {
  {"assign", &Dtool_EggObject_operator_8, METH_O, (const char *)Dtool_EggObject_operator_8_comment},
  {"set_user_data", &Dtool_EggObject_set_user_data_9, METH_O, (const char *)Dtool_EggObject_set_user_data_9_comment},
  {"setUserData", &Dtool_EggObject_set_user_data_9, METH_O, (const char *)Dtool_EggObject_set_user_data_9_comment},
  {"get_user_data", &Dtool_EggObject_get_user_data_10, METH_VARARGS, (const char *)Dtool_EggObject_get_user_data_10_comment},
  {"getUserData", &Dtool_EggObject_get_user_data_10, METH_VARARGS, (const char *)Dtool_EggObject_get_user_data_10_comment},
  {"has_user_data", &Dtool_EggObject_has_user_data_11, METH_VARARGS, (const char *)Dtool_EggObject_has_user_data_11_comment},
  {"hasUserData", &Dtool_EggObject_has_user_data_11, METH_VARARGS, (const char *)Dtool_EggObject_has_user_data_11_comment},
  {"clear_user_data", &Dtool_EggObject_clear_user_data_12, METH_VARARGS, (const char *)Dtool_EggObject_clear_user_data_12_comment},
  {"clearUserData", &Dtool_EggObject_clear_user_data_12, METH_VARARGS, (const char *)Dtool_EggObject_clear_user_data_12_comment},
  {"get_class_type", &Dtool_EggObject_get_class_type_13, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggObject_get_class_type_13_comment},
  {"getClassType", &Dtool_EggObject_get_class_type_13, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggObject_get_class_type_13_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EggObject = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggObject = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggObject = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggObject = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggObject = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggObject = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggObject",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggObject,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggObject,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggObject,
    &Dtool_SequenceMethods_EggObject,
    &Dtool_MappingMethods_EggObject,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggObject,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The highest-level base class in the egg directory.  (Almost) all things egg\n"
    " * inherit from this.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggObject,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggObject,
    PyType_GenericAlloc,
    Dtool_new_EggObject,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggObject,
  Dtool_UpcastInterface_EggObject,
  Dtool_DowncastInterface_EggObject,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggObject(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_EggObject._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_EggObject._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggObject._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggObject) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggObject)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggObject);
  }
}

/**
 * Python method tables for EggNamedObject (EggNamedObject)
 */
static PyMethodDef Dtool_Methods_EggNamedObject[] = {
  {"assign", &Dtool_EggNamedObject_operator_21, METH_O, (const char *)Dtool_EggNamedObject_operator_21_comment},
  {"output", &Dtool_EggNamedObject_output_22, METH_O, (const char *)Dtool_EggNamedObject_output_22_comment},
  {"get_class_type", &Dtool_EggNamedObject_get_class_type_23, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggNamedObject_get_class_type_23_comment},
  {"getClassType", &Dtool_EggNamedObject_get_class_type_23, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggNamedObject_get_class_type_23_comment},
  {"upcast_to_EggObject", &Dtool_EggNamedObject_upcast_to_EggObject_15, METH_NOARGS, (const char *)Dtool_EggNamedObject_upcast_to_EggObject_15_comment},
  {"upcastToEggObject", &Dtool_EggNamedObject_upcast_to_EggObject_15, METH_NOARGS, (const char *)Dtool_EggNamedObject_upcast_to_EggObject_15_comment},
  {"upcast_to_Namable", &Dtool_EggNamedObject_upcast_to_Namable_18, METH_NOARGS, (const char *)Dtool_EggNamedObject_upcast_to_Namable_18_comment},
  {"upcastToNamable", &Dtool_EggNamedObject_upcast_to_Namable_18, METH_NOARGS, (const char *)Dtool_EggNamedObject_upcast_to_Namable_18_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     EggNamedObject
//////////////////
static PyObject *Dtool_Repr_EggNamedObject(PyObject *self) {
  EggNamedObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNamedObject, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_EggNamedObject = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggNamedObject = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggNamedObject = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggNamedObject = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggNamedObject = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggNamedObject = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggNamedObject",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggNamedObject,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggNamedObject,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_EggNamedObject,
    &Dtool_NumberMethods_EggNamedObject,
    &Dtool_SequenceMethods_EggNamedObject,
    &Dtool_MappingMethods_EggNamedObject,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_EggNamedObject,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggNamedObject,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a fairly low-level base class--any egg object that has a name.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggNamedObject,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggNamedObject,
    PyType_GenericAlloc,
    Dtool_new_EggNamedObject,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggNamedObject,
  Dtool_UpcastInterface_EggNamedObject,
  Dtool_DowncastInterface_EggNamedObject,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggNamedObject(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggObject(nullptr);
    assert(Dtool_Ptr_Namable != nullptr);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(nullptr);
    Dtool_EggNamedObject._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_EggObject, (PyTypeObject *)Dtool_Ptr_Namable);
    Dtool_EggNamedObject._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggNamedObject._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggNamedObject) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggNamedObject)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggNamedObject);
  }
}

/**
 * Python method tables for EggNode (EggNode)
 */
static PyMethodDef Dtool_Methods_EggNode[] = {
  {"assign", &Dtool_EggNode_operator_26, METH_O, (const char *)Dtool_EggNode_operator_26_comment},
  {"get_parent", &Dtool_EggNode_get_parent_27, METH_NOARGS, (const char *)Dtool_EggNode_get_parent_27_comment},
  {"getParent", &Dtool_EggNode_get_parent_27, METH_NOARGS, (const char *)Dtool_EggNode_get_parent_27_comment},
  {"get_depth", &Dtool_EggNode_get_depth_28, METH_NOARGS, (const char *)Dtool_EggNode_get_depth_28_comment},
  {"getDepth", &Dtool_EggNode_get_depth_28, METH_NOARGS, (const char *)Dtool_EggNode_get_depth_28_comment},
  {"is_under_instance", &Dtool_EggNode_is_under_instance_29, METH_NOARGS, (const char *)Dtool_EggNode_is_under_instance_29_comment},
  {"isUnderInstance", &Dtool_EggNode_is_under_instance_29, METH_NOARGS, (const char *)Dtool_EggNode_is_under_instance_29_comment},
  {"is_under_transform", &Dtool_EggNode_is_under_transform_30, METH_NOARGS, (const char *)Dtool_EggNode_is_under_transform_30_comment},
  {"isUnderTransform", &Dtool_EggNode_is_under_transform_30, METH_NOARGS, (const char *)Dtool_EggNode_is_under_transform_30_comment},
  {"is_local_coord", &Dtool_EggNode_is_local_coord_31, METH_NOARGS, (const char *)Dtool_EggNode_is_local_coord_31_comment},
  {"isLocalCoord", &Dtool_EggNode_is_local_coord_31, METH_NOARGS, (const char *)Dtool_EggNode_is_local_coord_31_comment},
  {"get_vertex_frame", &Dtool_EggNode_get_vertex_frame_80, METH_NOARGS, (const char *)Dtool_EggNode_get_vertex_frame_80_comment},
  {"getVertexFrame", &Dtool_EggNode_get_vertex_frame_80, METH_NOARGS, (const char *)Dtool_EggNode_get_vertex_frame_80_comment},
  {"get_node_frame", &Dtool_EggNode_get_node_frame_81, METH_NOARGS, (const char *)Dtool_EggNode_get_node_frame_81_comment},
  {"getNodeFrame", &Dtool_EggNode_get_node_frame_81, METH_NOARGS, (const char *)Dtool_EggNode_get_node_frame_81_comment},
  {"get_vertex_frame_inv", &Dtool_EggNode_get_vertex_frame_inv_82, METH_NOARGS, (const char *)Dtool_EggNode_get_vertex_frame_inv_82_comment},
  {"getVertexFrameInv", &Dtool_EggNode_get_vertex_frame_inv_82, METH_NOARGS, (const char *)Dtool_EggNode_get_vertex_frame_inv_82_comment},
  {"get_node_frame_inv", &Dtool_EggNode_get_node_frame_inv_83, METH_NOARGS, (const char *)Dtool_EggNode_get_node_frame_inv_83_comment},
  {"getNodeFrameInv", &Dtool_EggNode_get_node_frame_inv_83, METH_NOARGS, (const char *)Dtool_EggNode_get_node_frame_inv_83_comment},
  {"get_vertex_to_node", &Dtool_EggNode_get_vertex_to_node_84, METH_NOARGS, (const char *)Dtool_EggNode_get_vertex_to_node_84_comment},
  {"getVertexToNode", &Dtool_EggNode_get_vertex_to_node_84, METH_NOARGS, (const char *)Dtool_EggNode_get_vertex_to_node_84_comment},
  {"get_node_to_vertex", &Dtool_EggNode_get_node_to_vertex_85, METH_NOARGS, (const char *)Dtool_EggNode_get_node_to_vertex_85_comment},
  {"getNodeToVertex", &Dtool_EggNode_get_node_to_vertex_85, METH_NOARGS, (const char *)Dtool_EggNode_get_node_to_vertex_85_comment},
  {"get_vertex_frame_ptr", &Dtool_EggNode_get_vertex_frame_ptr_86, METH_NOARGS, (const char *)Dtool_EggNode_get_vertex_frame_ptr_86_comment},
  {"getVertexFramePtr", &Dtool_EggNode_get_vertex_frame_ptr_86, METH_NOARGS, (const char *)Dtool_EggNode_get_vertex_frame_ptr_86_comment},
  {"get_node_frame_ptr", &Dtool_EggNode_get_node_frame_ptr_87, METH_NOARGS, (const char *)Dtool_EggNode_get_node_frame_ptr_87_comment},
  {"getNodeFramePtr", &Dtool_EggNode_get_node_frame_ptr_87, METH_NOARGS, (const char *)Dtool_EggNode_get_node_frame_ptr_87_comment},
  {"get_vertex_frame_inv_ptr", &Dtool_EggNode_get_vertex_frame_inv_ptr_88, METH_NOARGS, (const char *)Dtool_EggNode_get_vertex_frame_inv_ptr_88_comment},
  {"getVertexFrameInvPtr", &Dtool_EggNode_get_vertex_frame_inv_ptr_88, METH_NOARGS, (const char *)Dtool_EggNode_get_vertex_frame_inv_ptr_88_comment},
  {"get_node_frame_inv_ptr", &Dtool_EggNode_get_node_frame_inv_ptr_89, METH_NOARGS, (const char *)Dtool_EggNode_get_node_frame_inv_ptr_89_comment},
  {"getNodeFrameInvPtr", &Dtool_EggNode_get_node_frame_inv_ptr_89, METH_NOARGS, (const char *)Dtool_EggNode_get_node_frame_inv_ptr_89_comment},
  {"get_vertex_to_node_ptr", &Dtool_EggNode_get_vertex_to_node_ptr_90, METH_NOARGS, (const char *)Dtool_EggNode_get_vertex_to_node_ptr_90_comment},
  {"getVertexToNodePtr", &Dtool_EggNode_get_vertex_to_node_ptr_90, METH_NOARGS, (const char *)Dtool_EggNode_get_vertex_to_node_ptr_90_comment},
  {"get_node_to_vertex_ptr", &Dtool_EggNode_get_node_to_vertex_ptr_91, METH_NOARGS, (const char *)Dtool_EggNode_get_node_to_vertex_ptr_91_comment},
  {"getNodeToVertexPtr", &Dtool_EggNode_get_node_to_vertex_ptr_91, METH_NOARGS, (const char *)Dtool_EggNode_get_node_to_vertex_ptr_91_comment},
  {"transform", &Dtool_EggNode_transform_92, METH_O, (const char *)Dtool_EggNode_transform_92_comment},
  {"transform_vertices_only", &Dtool_EggNode_transform_vertices_only_93, METH_O, (const char *)Dtool_EggNode_transform_vertices_only_93_comment},
  {"transformVerticesOnly", &Dtool_EggNode_transform_vertices_only_93, METH_O, (const char *)Dtool_EggNode_transform_vertices_only_93_comment},
  {"flatten_transforms", &Dtool_EggNode_flatten_transforms_94, METH_NOARGS, (const char *)Dtool_EggNode_flatten_transforms_94_comment},
  {"flattenTransforms", &Dtool_EggNode_flatten_transforms_94, METH_NOARGS, (const char *)Dtool_EggNode_flatten_transforms_94_comment},
  {"apply_texmats", &Dtool_EggNode_apply_texmats_95, METH_NOARGS, (const char *)Dtool_EggNode_apply_texmats_95_comment},
  {"applyTexmats", &Dtool_EggNode_apply_texmats_95, METH_NOARGS, (const char *)Dtool_EggNode_apply_texmats_95_comment},
  {"is_joint", &Dtool_EggNode_is_joint_97, METH_NOARGS, (const char *)Dtool_EggNode_is_joint_97_comment},
  {"isJoint", &Dtool_EggNode_is_joint_97, METH_NOARGS, (const char *)Dtool_EggNode_is_joint_97_comment},
  {"is_anim_matrix", &Dtool_EggNode_is_anim_matrix_98, METH_NOARGS, (const char *)Dtool_EggNode_is_anim_matrix_98_comment},
  {"isAnimMatrix", &Dtool_EggNode_is_anim_matrix_98, METH_NOARGS, (const char *)Dtool_EggNode_is_anim_matrix_98_comment},
  {"determine_alpha_mode", &Dtool_EggNode_determine_alpha_mode_99, METH_NOARGS, (const char *)Dtool_EggNode_determine_alpha_mode_99_comment},
  {"determineAlphaMode", &Dtool_EggNode_determine_alpha_mode_99, METH_NOARGS, (const char *)Dtool_EggNode_determine_alpha_mode_99_comment},
  {"determine_depth_write_mode", &Dtool_EggNode_determine_depth_write_mode_100, METH_NOARGS, (const char *)Dtool_EggNode_determine_depth_write_mode_100_comment},
  {"determineDepthWriteMode", &Dtool_EggNode_determine_depth_write_mode_100, METH_NOARGS, (const char *)Dtool_EggNode_determine_depth_write_mode_100_comment},
  {"determine_depth_test_mode", &Dtool_EggNode_determine_depth_test_mode_101, METH_NOARGS, (const char *)Dtool_EggNode_determine_depth_test_mode_101_comment},
  {"determineDepthTestMode", &Dtool_EggNode_determine_depth_test_mode_101, METH_NOARGS, (const char *)Dtool_EggNode_determine_depth_test_mode_101_comment},
  {"determine_visibility_mode", &Dtool_EggNode_determine_visibility_mode_102, METH_NOARGS, (const char *)Dtool_EggNode_determine_visibility_mode_102_comment},
  {"determineVisibilityMode", &Dtool_EggNode_determine_visibility_mode_102, METH_NOARGS, (const char *)Dtool_EggNode_determine_visibility_mode_102_comment},
  {"determine_depth_offset", &Dtool_EggNode_determine_depth_offset_103, METH_NOARGS, (const char *)Dtool_EggNode_determine_depth_offset_103_comment},
  {"determineDepthOffset", &Dtool_EggNode_determine_depth_offset_103, METH_NOARGS, (const char *)Dtool_EggNode_determine_depth_offset_103_comment},
  {"determine_draw_order", &Dtool_EggNode_determine_draw_order_104, METH_NOARGS, (const char *)Dtool_EggNode_determine_draw_order_104_comment},
  {"determineDrawOrder", &Dtool_EggNode_determine_draw_order_104, METH_NOARGS, (const char *)Dtool_EggNode_determine_draw_order_104_comment},
  {"determine_bin", &Dtool_EggNode_determine_bin_105, METH_NOARGS, (const char *)Dtool_EggNode_determine_bin_105_comment},
  {"determineBin", &Dtool_EggNode_determine_bin_105, METH_NOARGS, (const char *)Dtool_EggNode_determine_bin_105_comment},
  {"determine_indexed", &Dtool_EggNode_determine_indexed_106, METH_NOARGS, (const char *)Dtool_EggNode_determine_indexed_106_comment},
  {"determineIndexed", &Dtool_EggNode_determine_indexed_106, METH_NOARGS, (const char *)Dtool_EggNode_determine_indexed_106_comment},
  {"determine_decal", &Dtool_EggNode_determine_decal_107, METH_NOARGS, (const char *)Dtool_EggNode_determine_decal_107_comment},
  {"determineDecal", &Dtool_EggNode_determine_decal_107, METH_NOARGS, (const char *)Dtool_EggNode_determine_decal_107_comment},
  {"write", (PyCFunction) &Dtool_EggNode_write_108, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNode_write_108_comment},
  {"parse_egg", &Dtool_EggNode_parse_egg_109, METH_O, (const char *)Dtool_EggNode_parse_egg_109_comment},
  {"parseEgg", &Dtool_EggNode_parse_egg_109, METH_O, (const char *)Dtool_EggNode_parse_egg_109_comment},
  {"test_under_integrity", &Dtool_EggNode_test_under_integrity_110, METH_NOARGS, (const char *)Dtool_EggNode_test_under_integrity_110_comment},
  {"testUnderIntegrity", &Dtool_EggNode_test_under_integrity_110, METH_NOARGS, (const char *)Dtool_EggNode_test_under_integrity_110_comment},
  {"get_class_type", &Dtool_EggNode_get_class_type_111, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggNode_get_class_type_111_comment},
  {"getClassType", &Dtool_EggNode_get_class_type_111, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggNode_get_class_type_111_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     EggNode
//////////////////
static PyObject *Dtool_Str_EggNode(PyObject *self) {
  EggNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggNode, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_EggNode[] = {
  {(char *)"parent", &Dtool_EggNode_parent_Getter, nullptr, nullptr, nullptr},
  {(char *)"depth", &Dtool_EggNode_depth_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_EggNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggNode,
    &Dtool_SequenceMethods_EggNode,
    &Dtool_MappingMethods_EggNode,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_EggNode,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A base class for things that may be directly added into the egg hierarchy.\n"
    " * This includes groups, joints, polygons, vertex pools, etc., but does not\n"
    " * include things like vertices.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggNode,
    nullptr, // tp_members
    Dtool_Properties_EggNode,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggNode,
    PyType_GenericAlloc,
    Dtool_new_EggNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggNode,
  Dtool_UpcastInterface_EggNode,
  Dtool_DowncastInterface_EggNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggNamedObject(nullptr);
    Dtool_EggNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggNamedObject);
    Dtool_EggNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggNode);
  }
}

/**
 * Python method tables for EggGroupNode (EggGroupNode)
 */
static PyMethodDef Dtool_Methods_EggGroupNode[] = {
  {"assign", &Dtool_EggGroupNode_operator_36, METH_O, (const char *)Dtool_EggGroupNode_operator_36_comment},
  {"empty", &Dtool_EggGroupNode_empty_37, METH_NOARGS, (const char *)Dtool_EggGroupNode_empty_37_comment},
  {"size", &Dtool_EggGroupNode_size_38, METH_NOARGS, (const char *)Dtool_EggGroupNode_size_38_comment},
  {"clear", &Dtool_EggGroupNode_clear_39, METH_NOARGS, (const char *)Dtool_EggGroupNode_clear_39_comment},
  {"get_first_child", &Dtool_EggGroupNode_get_first_child_40, METH_NOARGS, (const char *)Dtool_EggGroupNode_get_first_child_40_comment},
  {"getFirstChild", &Dtool_EggGroupNode_get_first_child_40, METH_NOARGS, (const char *)Dtool_EggGroupNode_get_first_child_40_comment},
  {"get_next_child", &Dtool_EggGroupNode_get_next_child_41, METH_NOARGS, (const char *)Dtool_EggGroupNode_get_next_child_41_comment},
  {"getNextChild", &Dtool_EggGroupNode_get_next_child_41, METH_NOARGS, (const char *)Dtool_EggGroupNode_get_next_child_41_comment},
  {"get_children", &Dtool_EggGroupNode_get_children_42, METH_NOARGS, (const char *)Dtool_EggGroupNode_get_children_42_comment},
  {"getChildren", &Dtool_EggGroupNode_get_children_42, METH_NOARGS, (const char *)Dtool_EggGroupNode_get_children_42_comment},
  {"add_child", &Dtool_EggGroupNode_add_child_47, METH_O, (const char *)Dtool_EggGroupNode_add_child_47_comment},
  {"addChild", &Dtool_EggGroupNode_add_child_47, METH_O, (const char *)Dtool_EggGroupNode_add_child_47_comment},
  {"remove_child", &Dtool_EggGroupNode_remove_child_48, METH_O, (const char *)Dtool_EggGroupNode_remove_child_48_comment},
  {"removeChild", &Dtool_EggGroupNode_remove_child_48, METH_O, (const char *)Dtool_EggGroupNode_remove_child_48_comment},
  {"steal_children", &Dtool_EggGroupNode_steal_children_49, METH_O, (const char *)Dtool_EggGroupNode_steal_children_49_comment},
  {"stealChildren", &Dtool_EggGroupNode_steal_children_49, METH_O, (const char *)Dtool_EggGroupNode_steal_children_49_comment},
  {"find_child", &Dtool_EggGroupNode_find_child_50, METH_O, (const char *)Dtool_EggGroupNode_find_child_50_comment},
  {"findChild", &Dtool_EggGroupNode_find_child_50, METH_O, (const char *)Dtool_EggGroupNode_find_child_50_comment},
  {"has_absolute_pathnames", &Dtool_EggGroupNode_has_absolute_pathnames_51, METH_NOARGS, (const char *)Dtool_EggGroupNode_has_absolute_pathnames_51_comment},
  {"hasAbsolutePathnames", &Dtool_EggGroupNode_has_absolute_pathnames_51, METH_NOARGS, (const char *)Dtool_EggGroupNode_has_absolute_pathnames_51_comment},
  {"resolve_filenames", &Dtool_EggGroupNode_resolve_filenames_52, METH_O, (const char *)Dtool_EggGroupNode_resolve_filenames_52_comment},
  {"resolveFilenames", &Dtool_EggGroupNode_resolve_filenames_52, METH_O, (const char *)Dtool_EggGroupNode_resolve_filenames_52_comment},
  {"force_filenames", &Dtool_EggGroupNode_force_filenames_53, METH_O, (const char *)Dtool_EggGroupNode_force_filenames_53_comment},
  {"forceFilenames", &Dtool_EggGroupNode_force_filenames_53, METH_O, (const char *)Dtool_EggGroupNode_force_filenames_53_comment},
  {"reverse_vertex_ordering", &Dtool_EggGroupNode_reverse_vertex_ordering_54, METH_NOARGS, (const char *)Dtool_EggGroupNode_reverse_vertex_ordering_54_comment},
  {"reverseVertexOrdering", &Dtool_EggGroupNode_reverse_vertex_ordering_54, METH_NOARGS, (const char *)Dtool_EggGroupNode_reverse_vertex_ordering_54_comment},
  {"recompute_vertex_normals", (PyCFunction) &Dtool_EggGroupNode_recompute_vertex_normals_55, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroupNode_recompute_vertex_normals_55_comment},
  {"recomputeVertexNormals", (PyCFunction) &Dtool_EggGroupNode_recompute_vertex_normals_55, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroupNode_recompute_vertex_normals_55_comment},
  {"recompute_polygon_normals", (PyCFunction) &Dtool_EggGroupNode_recompute_polygon_normals_56, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroupNode_recompute_polygon_normals_56_comment},
  {"recomputePolygonNormals", (PyCFunction) &Dtool_EggGroupNode_recompute_polygon_normals_56, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroupNode_recompute_polygon_normals_56_comment},
  {"strip_normals", &Dtool_EggGroupNode_strip_normals_57, METH_NOARGS, (const char *)Dtool_EggGroupNode_strip_normals_57_comment},
  {"stripNormals", &Dtool_EggGroupNode_strip_normals_57, METH_NOARGS, (const char *)Dtool_EggGroupNode_strip_normals_57_comment},
  {"recompute_tangent_binormal", &Dtool_EggGroupNode_recompute_tangent_binormal_58, METH_O, (const char *)Dtool_EggGroupNode_recompute_tangent_binormal_58_comment},
  {"recomputeTangentBinormal", &Dtool_EggGroupNode_recompute_tangent_binormal_58, METH_O, (const char *)Dtool_EggGroupNode_recompute_tangent_binormal_58_comment},
  {"recompute_tangent_binormal_auto", &Dtool_EggGroupNode_recompute_tangent_binormal_auto_59, METH_NOARGS, (const char *)Dtool_EggGroupNode_recompute_tangent_binormal_auto_59_comment},
  {"recomputeTangentBinormalAuto", &Dtool_EggGroupNode_recompute_tangent_binormal_auto_59, METH_NOARGS, (const char *)Dtool_EggGroupNode_recompute_tangent_binormal_auto_59_comment},
  {"triangulate_polygons", &Dtool_EggGroupNode_triangulate_polygons_61, METH_O, (const char *)Dtool_EggGroupNode_triangulate_polygons_61_comment},
  {"triangulatePolygons", &Dtool_EggGroupNode_triangulate_polygons_61, METH_O, (const char *)Dtool_EggGroupNode_triangulate_polygons_61_comment},
  {"mesh_triangles", &Dtool_EggGroupNode_mesh_triangles_62, METH_O, (const char *)Dtool_EggGroupNode_mesh_triangles_62_comment},
  {"meshTriangles", &Dtool_EggGroupNode_mesh_triangles_62, METH_O, (const char *)Dtool_EggGroupNode_mesh_triangles_62_comment},
  {"make_point_primitives", &Dtool_EggGroupNode_make_point_primitives_63, METH_NOARGS, (const char *)Dtool_EggGroupNode_make_point_primitives_63_comment},
  {"makePointPrimitives", &Dtool_EggGroupNode_make_point_primitives_63, METH_NOARGS, (const char *)Dtool_EggGroupNode_make_point_primitives_63_comment},
  {"remove_unused_vertices", &Dtool_EggGroupNode_remove_unused_vertices_65, METH_O, (const char *)Dtool_EggGroupNode_remove_unused_vertices_65_comment},
  {"removeUnusedVertices", &Dtool_EggGroupNode_remove_unused_vertices_65, METH_O, (const char *)Dtool_EggGroupNode_remove_unused_vertices_65_comment},
  {"remove_invalid_primitives", &Dtool_EggGroupNode_remove_invalid_primitives_66, METH_O, (const char *)Dtool_EggGroupNode_remove_invalid_primitives_66_comment},
  {"removeInvalidPrimitives", &Dtool_EggGroupNode_remove_invalid_primitives_66, METH_O, (const char *)Dtool_EggGroupNode_remove_invalid_primitives_66_comment},
  {"clear_connected_shading", &Dtool_EggGroupNode_clear_connected_shading_67, METH_NOARGS, (const char *)Dtool_EggGroupNode_clear_connected_shading_67_comment},
  {"clearConnectedShading", &Dtool_EggGroupNode_clear_connected_shading_67, METH_NOARGS, (const char *)Dtool_EggGroupNode_clear_connected_shading_67_comment},
  {"get_connected_shading", &Dtool_EggGroupNode_get_connected_shading_68, METH_NOARGS, (const char *)Dtool_EggGroupNode_get_connected_shading_68_comment},
  {"getConnectedShading", &Dtool_EggGroupNode_get_connected_shading_68, METH_NOARGS, (const char *)Dtool_EggGroupNode_get_connected_shading_68_comment},
  {"unify_attributes", (PyCFunction) &Dtool_EggGroupNode_unify_attributes_69, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroupNode_unify_attributes_69_comment},
  {"unifyAttributes", (PyCFunction) &Dtool_EggGroupNode_unify_attributes_69, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroupNode_unify_attributes_69_comment},
  {"apply_last_attribute", &Dtool_EggGroupNode_apply_last_attribute_70, METH_O, (const char *)Dtool_EggGroupNode_apply_last_attribute_70_comment},
  {"applyLastAttribute", &Dtool_EggGroupNode_apply_last_attribute_70, METH_O, (const char *)Dtool_EggGroupNode_apply_last_attribute_70_comment},
  {"apply_first_attribute", &Dtool_EggGroupNode_apply_first_attribute_71, METH_O, (const char *)Dtool_EggGroupNode_apply_first_attribute_71_comment},
  {"applyFirstAttribute", &Dtool_EggGroupNode_apply_first_attribute_71, METH_O, (const char *)Dtool_EggGroupNode_apply_first_attribute_71_comment},
  {"post_apply_flat_attribute", &Dtool_EggGroupNode_post_apply_flat_attribute_72, METH_O, (const char *)Dtool_EggGroupNode_post_apply_flat_attribute_72_comment},
  {"postApplyFlatAttribute", &Dtool_EggGroupNode_post_apply_flat_attribute_72, METH_O, (const char *)Dtool_EggGroupNode_post_apply_flat_attribute_72_comment},
  {"has_primitives", &Dtool_EggGroupNode_has_primitives_73, METH_NOARGS, (const char *)Dtool_EggGroupNode_has_primitives_73_comment},
  {"hasPrimitives", &Dtool_EggGroupNode_has_primitives_73, METH_NOARGS, (const char *)Dtool_EggGroupNode_has_primitives_73_comment},
  {"joint_has_primitives", &Dtool_EggGroupNode_joint_has_primitives_74, METH_NOARGS, (const char *)Dtool_EggGroupNode_joint_has_primitives_74_comment},
  {"jointHasPrimitives", &Dtool_EggGroupNode_joint_has_primitives_74, METH_NOARGS, (const char *)Dtool_EggGroupNode_joint_has_primitives_74_comment},
  {"has_normals", &Dtool_EggGroupNode_has_normals_75, METH_NOARGS, (const char *)Dtool_EggGroupNode_has_normals_75_comment},
  {"hasNormals", &Dtool_EggGroupNode_has_normals_75, METH_NOARGS, (const char *)Dtool_EggGroupNode_has_normals_75_comment},
  {"is_right", (PyCFunction) &Dtool_EggGroupNode_is_right_76, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_EggGroupNode_is_right_76_comment},
  {"isRight", (PyCFunction) &Dtool_EggGroupNode_is_right_76, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_EggGroupNode_is_right_76_comment},
  {"get_class_type", &Dtool_EggGroupNode_get_class_type_77, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggGroupNode_get_class_type_77_comment},
  {"getClassType", &Dtool_EggGroupNode_get_class_type_77, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggGroupNode_get_class_type_77_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_EggGroupNode[] = {
  {(char *)"children", &Dtool_EggGroupNode_children_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_EggGroupNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggGroupNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggGroupNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggGroupNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggGroupNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggGroupNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggGroupNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggGroupNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggGroupNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggGroupNode,
    &Dtool_SequenceMethods_EggGroupNode,
    &Dtool_MappingMethods_EggGroupNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggGroupNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A base class for nodes in the hierarchy that are not leaf nodes.  (See also\n"
    " * EggGroup, which is specifically the \"<Group>\" node in egg.)\n"
    " *\n"
    " * An EggGroupNode is an STL-style container of pointers to EggNodes, like a\n"
    " * vector.  Functions push_back()/pop_back() and insert()/erase() are provided\n"
    " * to manipulate the list.  The list may also be operated on (read-only) via\n"
    " * iterators and begin()/end().\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggGroupNode,
    nullptr, // tp_members
    Dtool_Properties_EggGroupNode,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggGroupNode,
    PyType_GenericAlloc,
    Dtool_new_EggGroupNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggGroupNode,
  Dtool_UpcastInterface_EggGroupNode,
  Dtool_DowncastInterface_EggGroupNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggGroupNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggNode(nullptr);
    Dtool_EggGroupNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggNode);
    Dtool_EggGroupNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(11);
    Dtool_EggGroupNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum EggGroupNode::TriangulateFlags;
    PyDict_SetItemString(dict, "T_polygon", Dtool_WrapValue(EggGroupNode::T_polygon));
    PyDict_SetItemString(dict, "TPolygon", Dtool_WrapValue(EggGroupNode::T_polygon));
    PyDict_SetItemString(dict, "T_convex", Dtool_WrapValue(EggGroupNode::T_convex));
    PyDict_SetItemString(dict, "TConvex", Dtool_WrapValue(EggGroupNode::T_convex));
    PyDict_SetItemString(dict, "T_composite", Dtool_WrapValue(EggGroupNode::T_composite));
    PyDict_SetItemString(dict, "TComposite", Dtool_WrapValue(EggGroupNode::T_composite));
    PyDict_SetItemString(dict, "T_recurse", Dtool_WrapValue(EggGroupNode::T_recurse));
    PyDict_SetItemString(dict, "TRecurse", Dtool_WrapValue(EggGroupNode::T_recurse));
    PyDict_SetItemString(dict, "T_flat_shaded", Dtool_WrapValue(EggGroupNode::T_flat_shaded));
    PyDict_SetItemString(dict, "TFlatShaded", Dtool_WrapValue(EggGroupNode::T_flat_shaded));
    if (PyType_Ready((PyTypeObject *)&Dtool_EggGroupNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggGroupNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggGroupNode);
  }
}

/**
 * Python method tables for EggAnimData (EggAnimData)
 */
static PyMethodDef Dtool_Methods_EggAnimData[] = {
  {"assign", &Dtool_EggAnimData_operator_114, METH_O, (const char *)Dtool_EggAnimData_operator_114_comment},
  {"set_fps", &Dtool_EggAnimData_set_fps_115, METH_O, (const char *)Dtool_EggAnimData_set_fps_115_comment},
  {"setFps", &Dtool_EggAnimData_set_fps_115, METH_O, (const char *)Dtool_EggAnimData_set_fps_115_comment},
  {"clear_fps", &Dtool_EggAnimData_clear_fps_116, METH_NOARGS, (const char *)Dtool_EggAnimData_clear_fps_116_comment},
  {"clearFps", &Dtool_EggAnimData_clear_fps_116, METH_NOARGS, (const char *)Dtool_EggAnimData_clear_fps_116_comment},
  {"has_fps", &Dtool_EggAnimData_has_fps_117, METH_NOARGS, (const char *)Dtool_EggAnimData_has_fps_117_comment},
  {"hasFps", &Dtool_EggAnimData_has_fps_117, METH_NOARGS, (const char *)Dtool_EggAnimData_has_fps_117_comment},
  {"get_fps", &Dtool_EggAnimData_get_fps_118, METH_NOARGS, (const char *)Dtool_EggAnimData_get_fps_118_comment},
  {"getFps", &Dtool_EggAnimData_get_fps_118, METH_NOARGS, (const char *)Dtool_EggAnimData_get_fps_118_comment},
  {"clear_data", &Dtool_EggAnimData_clear_data_119, METH_NOARGS, (const char *)Dtool_EggAnimData_clear_data_119_comment},
  {"clearData", &Dtool_EggAnimData_clear_data_119, METH_NOARGS, (const char *)Dtool_EggAnimData_clear_data_119_comment},
  {"add_data", &Dtool_EggAnimData_add_data_120, METH_O, (const char *)Dtool_EggAnimData_add_data_120_comment},
  {"addData", &Dtool_EggAnimData_add_data_120, METH_O, (const char *)Dtool_EggAnimData_add_data_120_comment},
  {"get_size", &Dtool_EggAnimData_get_size_121, METH_NOARGS, (const char *)Dtool_EggAnimData_get_size_121_comment},
  {"getSize", &Dtool_EggAnimData_get_size_121, METH_NOARGS, (const char *)Dtool_EggAnimData_get_size_121_comment},
  {"quantize", &Dtool_EggAnimData_quantize_122, METH_O, (const char *)Dtool_EggAnimData_quantize_122_comment},
  {"get_class_type", &Dtool_EggAnimData_get_class_type_123, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggAnimData_get_class_type_123_comment},
  {"getClassType", &Dtool_EggAnimData_get_class_type_123, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggAnimData_get_class_type_123_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EggAnimData = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggAnimData = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggAnimData = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggAnimData = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggAnimData = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggAnimData = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggAnimData",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggAnimData,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggAnimData,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggAnimData,
    &Dtool_SequenceMethods_EggAnimData,
    &Dtool_MappingMethods_EggAnimData,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggAnimData,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A base class for EggSAnimData and EggXfmAnimData, which contain rows and\n"
    " * columns of numbers.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggAnimData,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggAnimData,
    PyType_GenericAlloc,
    Dtool_new_EggAnimData,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggAnimData,
  Dtool_UpcastInterface_EggAnimData,
  Dtool_DowncastInterface_EggAnimData,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggAnimData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggNode(nullptr);
    Dtool_EggAnimData._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggNode);
    Dtool_EggAnimData._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggAnimData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggAnimData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggAnimData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggAnimData);
  }
}

/**
 * Python method tables for EggAnimPreload (EggAnimPreload)
 */
static PyMethodDef Dtool_Methods_EggAnimPreload[] = {
  {"assign", &Dtool_EggAnimPreload_operator_127, METH_O, (const char *)Dtool_EggAnimPreload_operator_127_comment},
  {"set_fps", &Dtool_EggAnimPreload_set_fps_128, METH_O, (const char *)Dtool_EggAnimPreload_set_fps_128_comment},
  {"setFps", &Dtool_EggAnimPreload_set_fps_128, METH_O, (const char *)Dtool_EggAnimPreload_set_fps_128_comment},
  {"clear_fps", &Dtool_EggAnimPreload_clear_fps_129, METH_NOARGS, (const char *)Dtool_EggAnimPreload_clear_fps_129_comment},
  {"clearFps", &Dtool_EggAnimPreload_clear_fps_129, METH_NOARGS, (const char *)Dtool_EggAnimPreload_clear_fps_129_comment},
  {"has_fps", &Dtool_EggAnimPreload_has_fps_130, METH_NOARGS, (const char *)Dtool_EggAnimPreload_has_fps_130_comment},
  {"hasFps", &Dtool_EggAnimPreload_has_fps_130, METH_NOARGS, (const char *)Dtool_EggAnimPreload_has_fps_130_comment},
  {"get_fps", &Dtool_EggAnimPreload_get_fps_131, METH_NOARGS, (const char *)Dtool_EggAnimPreload_get_fps_131_comment},
  {"getFps", &Dtool_EggAnimPreload_get_fps_131, METH_NOARGS, (const char *)Dtool_EggAnimPreload_get_fps_131_comment},
  {"set_num_frames", &Dtool_EggAnimPreload_set_num_frames_132, METH_O, (const char *)Dtool_EggAnimPreload_set_num_frames_132_comment},
  {"setNumFrames", &Dtool_EggAnimPreload_set_num_frames_132, METH_O, (const char *)Dtool_EggAnimPreload_set_num_frames_132_comment},
  {"clear_num_frames", &Dtool_EggAnimPreload_clear_num_frames_133, METH_NOARGS, (const char *)Dtool_EggAnimPreload_clear_num_frames_133_comment},
  {"clearNumFrames", &Dtool_EggAnimPreload_clear_num_frames_133, METH_NOARGS, (const char *)Dtool_EggAnimPreload_clear_num_frames_133_comment},
  {"has_num_frames", &Dtool_EggAnimPreload_has_num_frames_134, METH_NOARGS, (const char *)Dtool_EggAnimPreload_has_num_frames_134_comment},
  {"hasNumFrames", &Dtool_EggAnimPreload_has_num_frames_134, METH_NOARGS, (const char *)Dtool_EggAnimPreload_has_num_frames_134_comment},
  {"get_num_frames", &Dtool_EggAnimPreload_get_num_frames_135, METH_NOARGS, (const char *)Dtool_EggAnimPreload_get_num_frames_135_comment},
  {"getNumFrames", &Dtool_EggAnimPreload_get_num_frames_135, METH_NOARGS, (const char *)Dtool_EggAnimPreload_get_num_frames_135_comment},
  {"get_class_type", &Dtool_EggAnimPreload_get_class_type_136, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggAnimPreload_get_class_type_136_comment},
  {"getClassType", &Dtool_EggAnimPreload_get_class_type_136, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggAnimPreload_get_class_type_136_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EggAnimPreload = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggAnimPreload = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggAnimPreload = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggAnimPreload = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggAnimPreload = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggAnimPreload = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggAnimPreload",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggAnimPreload,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggAnimPreload,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggAnimPreload,
    &Dtool_SequenceMethods_EggAnimPreload,
    &Dtool_MappingMethods_EggAnimPreload,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggAnimPreload,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This corresponds to an <AnimPreload> entry.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggAnimPreload,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggAnimPreload,
    PyType_GenericAlloc,
    Dtool_new_EggAnimPreload,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggAnimPreload,
  Dtool_UpcastInterface_EggAnimPreload,
  Dtool_DowncastInterface_EggAnimPreload,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggAnimPreload(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggNode(nullptr);
    Dtool_EggAnimPreload._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggNode);
    Dtool_EggAnimPreload._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggAnimPreload._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggAnimPreload) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggAnimPreload)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggAnimPreload);
  }
}

/**
 * Python method tables for EggAttributes (EggAttributes)
 */
static PyMethodDef Dtool_Methods_EggAttributes[] = {
  {"assign", &Dtool_EggAttributes_operator_143, METH_O, (const char *)Dtool_EggAttributes_operator_143_comment},
  {"has_normal", &Dtool_EggAttributes_has_normal_145, METH_NOARGS, (const char *)Dtool_EggAttributes_has_normal_145_comment},
  {"hasNormal", &Dtool_EggAttributes_has_normal_145, METH_NOARGS, (const char *)Dtool_EggAttributes_has_normal_145_comment},
  {"get_normal", &Dtool_EggAttributes_get_normal_146, METH_NOARGS, (const char *)Dtool_EggAttributes_get_normal_146_comment},
  {"getNormal", &Dtool_EggAttributes_get_normal_146, METH_NOARGS, (const char *)Dtool_EggAttributes_get_normal_146_comment},
  {"set_normal", &Dtool_EggAttributes_set_normal_147, METH_O, (const char *)Dtool_EggAttributes_set_normal_147_comment},
  {"setNormal", &Dtool_EggAttributes_set_normal_147, METH_O, (const char *)Dtool_EggAttributes_set_normal_147_comment},
  {"clear_normal", &Dtool_EggAttributes_clear_normal_148, METH_NOARGS, (const char *)Dtool_EggAttributes_clear_normal_148_comment},
  {"clearNormal", &Dtool_EggAttributes_clear_normal_148, METH_NOARGS, (const char *)Dtool_EggAttributes_clear_normal_148_comment},
  {"matches_normal", &Dtool_EggAttributes_matches_normal_149, METH_O, (const char *)Dtool_EggAttributes_matches_normal_149_comment},
  {"matchesNormal", &Dtool_EggAttributes_matches_normal_149, METH_O, (const char *)Dtool_EggAttributes_matches_normal_149_comment},
  {"copy_normal", &Dtool_EggAttributes_copy_normal_150, METH_O, (const char *)Dtool_EggAttributes_copy_normal_150_comment},
  {"copyNormal", &Dtool_EggAttributes_copy_normal_150, METH_O, (const char *)Dtool_EggAttributes_copy_normal_150_comment},
  {"has_color", &Dtool_EggAttributes_has_color_151, METH_NOARGS, (const char *)Dtool_EggAttributes_has_color_151_comment},
  {"hasColor", &Dtool_EggAttributes_has_color_151, METH_NOARGS, (const char *)Dtool_EggAttributes_has_color_151_comment},
  {"get_color", &Dtool_EggAttributes_get_color_152, METH_NOARGS, (const char *)Dtool_EggAttributes_get_color_152_comment},
  {"getColor", &Dtool_EggAttributes_get_color_152, METH_NOARGS, (const char *)Dtool_EggAttributes_get_color_152_comment},
  {"set_color", &Dtool_EggAttributes_set_color_153, METH_O, (const char *)Dtool_EggAttributes_set_color_153_comment},
  {"setColor", &Dtool_EggAttributes_set_color_153, METH_O, (const char *)Dtool_EggAttributes_set_color_153_comment},
  {"clear_color", &Dtool_EggAttributes_clear_color_154, METH_NOARGS, (const char *)Dtool_EggAttributes_clear_color_154_comment},
  {"clearColor", &Dtool_EggAttributes_clear_color_154, METH_NOARGS, (const char *)Dtool_EggAttributes_clear_color_154_comment},
  {"matches_color", &Dtool_EggAttributes_matches_color_155, METH_O, (const char *)Dtool_EggAttributes_matches_color_155_comment},
  {"matchesColor", &Dtool_EggAttributes_matches_color_155, METH_O, (const char *)Dtool_EggAttributes_matches_color_155_comment},
  {"copy_color", &Dtool_EggAttributes_copy_color_156, METH_O, (const char *)Dtool_EggAttributes_copy_color_156_comment},
  {"copyColor", &Dtool_EggAttributes_copy_color_156, METH_O, (const char *)Dtool_EggAttributes_copy_color_156_comment},
  {"write", (PyCFunction) &Dtool_EggAttributes_write_157, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggAttributes_write_157_comment},
  {"sorts_less_than", &Dtool_EggAttributes_sorts_less_than_158, METH_O, (const char *)Dtool_EggAttributes_sorts_less_than_158_comment},
  {"sortsLessThan", &Dtool_EggAttributes_sorts_less_than_158, METH_O, (const char *)Dtool_EggAttributes_sorts_less_than_158_comment},
  {"compare_to", &Dtool_EggAttributes_compare_to_159, METH_O, (const char *)Dtool_EggAttributes_compare_to_159_comment},
  {"compareTo", &Dtool_EggAttributes_compare_to_159, METH_O, (const char *)Dtool_EggAttributes_compare_to_159_comment},
  {"transform", &Dtool_EggAttributes_transform_160, METH_O, (const char *)Dtool_EggAttributes_transform_160_comment},
  {"get_class_type", &Dtool_EggAttributes_get_class_type_169, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggAttributes_get_class_type_169_comment},
  {"getClassType", &Dtool_EggAttributes_get_class_type_169, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggAttributes_get_class_type_169_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// EggAttributes slot tp_compare -> compare_to
//////////////////
static int Dtool_EggAttributes_compare_to_159_tp_compare(PyObject *self, PyObject *arg) {
  EggAttributes *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggAttributes, (void **)&local_this)) {
    return -1;
  }

  // 1-int EggAttributes::compare_to(EggAttributes const &other) const
  EggAttributes const *arg_this = (EggAttributes *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggAttributes, 1, "EggAttributes.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const EggAttributes*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (int)(return_value > 0) - (int)(return_value < 0);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(EggAttributes self, const EggAttributes other)\n");
  }
  return -1;
}

//////////////////
//  A __str__ function
//     EggAttributes
//////////////////
static PyObject *Dtool_Str_EggAttributes(PyObject *self) {
  EggAttributes *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggAttributes, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     EggAttributes
//////////////////
static PyObject *Dtool_RichCompare_EggAttributes(PyObject *self, PyObject *arg, int op) {
  EggAttributes *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggAttributes, (void **)&local_this)) {
    return nullptr;
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_EggAttributes_compare_to_159_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_EggAttributes = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggAttributes = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggAttributes = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggAttributes = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggAttributes = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggAttributes = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggAttributes",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggAttributes,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggAttributes,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_EggAttributes_compare_to_159_tp_compare,
#endif
    nullptr,
    &Dtool_NumberMethods_EggAttributes,
    &Dtool_SequenceMethods_EggAttributes,
    &Dtool_MappingMethods_EggAttributes,
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Str_EggAttributes,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggAttributes,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The set of attributes that may be applied to vertices as well as polygons,\n"
    " * such as surface normal and color.\n"
    " *\n"
    " * This class cannot inherit from EggObject, because it causes problems at the\n"
    " * EggPolygon level with multiple appearances of the EggObject base class.\n"
    " * And making EggObject a virtual base class is just no fun.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_EggAttributes,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggAttributes,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggAttributes,
    PyType_GenericAlloc,
    Dtool_new_EggAttributes,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggAttributes,
  Dtool_UpcastInterface_EggAttributes,
  Dtool_DowncastInterface_EggAttributes,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggAttributes(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_EggAttributes._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggAttributes._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggAttributes) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggAttributes)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggAttributes);
  }
}

/**
 * Python method tables for EggVertexUV (EggVertexUV)
 */
static PyMethodDef Dtool_Methods_EggVertexUV[] = {
  {"assign", &Dtool_EggVertexUV_operator_172, METH_O, (const char *)Dtool_EggVertexUV_operator_172_comment},
  {"filter_name", &Dtool_EggVertexUV_filter_name_173, METH_O | METH_STATIC, (const char *)Dtool_EggVertexUV_filter_name_173_comment},
  {"filterName", &Dtool_EggVertexUV_filter_name_173, METH_O | METH_STATIC, (const char *)Dtool_EggVertexUV_filter_name_173_comment},
  {"set_name", &Dtool_EggVertexUV_set_name_174, METH_O, (const char *)Dtool_EggVertexUV_set_name_174_comment},
  {"setName", &Dtool_EggVertexUV_set_name_174, METH_O, (const char *)Dtool_EggVertexUV_set_name_174_comment},
  {"get_num_dimensions", &Dtool_EggVertexUV_get_num_dimensions_175, METH_NOARGS, (const char *)Dtool_EggVertexUV_get_num_dimensions_175_comment},
  {"getNumDimensions", &Dtool_EggVertexUV_get_num_dimensions_175, METH_NOARGS, (const char *)Dtool_EggVertexUV_get_num_dimensions_175_comment},
  {"has_w", &Dtool_EggVertexUV_has_w_176, METH_NOARGS, (const char *)Dtool_EggVertexUV_has_w_176_comment},
  {"hasW", &Dtool_EggVertexUV_has_w_176, METH_NOARGS, (const char *)Dtool_EggVertexUV_has_w_176_comment},
  {"get_uv", &Dtool_EggVertexUV_get_uv_177, METH_NOARGS, (const char *)Dtool_EggVertexUV_get_uv_177_comment},
  {"getUv", &Dtool_EggVertexUV_get_uv_177, METH_NOARGS, (const char *)Dtool_EggVertexUV_get_uv_177_comment},
  {"get_uvw", &Dtool_EggVertexUV_get_uvw_178, METH_NOARGS, (const char *)Dtool_EggVertexUV_get_uvw_178_comment},
  {"getUvw", &Dtool_EggVertexUV_get_uvw_178, METH_NOARGS, (const char *)Dtool_EggVertexUV_get_uvw_178_comment},
  {"set_uv", &Dtool_EggVertexUV_set_uv_179, METH_O, (const char *)Dtool_EggVertexUV_set_uv_179_comment},
  {"setUv", &Dtool_EggVertexUV_set_uv_179, METH_O, (const char *)Dtool_EggVertexUV_set_uv_179_comment},
  {"set_uvw", &Dtool_EggVertexUV_set_uvw_180, METH_O, (const char *)Dtool_EggVertexUV_set_uvw_180_comment},
  {"setUvw", &Dtool_EggVertexUV_set_uvw_180, METH_O, (const char *)Dtool_EggVertexUV_set_uvw_180_comment},
  {"has_tangent", &Dtool_EggVertexUV_has_tangent_181, METH_NOARGS, (const char *)Dtool_EggVertexUV_has_tangent_181_comment},
  {"hasTangent", &Dtool_EggVertexUV_has_tangent_181, METH_NOARGS, (const char *)Dtool_EggVertexUV_has_tangent_181_comment},
  {"has_tangent4", &Dtool_EggVertexUV_has_tangent4_182, METH_NOARGS, (const char *)Dtool_EggVertexUV_has_tangent4_182_comment},
  {"hasTangent4", &Dtool_EggVertexUV_has_tangent4_182, METH_NOARGS, (const char *)Dtool_EggVertexUV_has_tangent4_182_comment},
  {"get_tangent", &Dtool_EggVertexUV_get_tangent_183, METH_NOARGS, (const char *)Dtool_EggVertexUV_get_tangent_183_comment},
  {"getTangent", &Dtool_EggVertexUV_get_tangent_183, METH_NOARGS, (const char *)Dtool_EggVertexUV_get_tangent_183_comment},
  {"get_tangent4", &Dtool_EggVertexUV_get_tangent4_184, METH_NOARGS, (const char *)Dtool_EggVertexUV_get_tangent4_184_comment},
  {"getTangent4", &Dtool_EggVertexUV_get_tangent4_184, METH_NOARGS, (const char *)Dtool_EggVertexUV_get_tangent4_184_comment},
  {"set_tangent", &Dtool_EggVertexUV_set_tangent_185, METH_O, (const char *)Dtool_EggVertexUV_set_tangent_185_comment},
  {"setTangent", &Dtool_EggVertexUV_set_tangent_185, METH_O, (const char *)Dtool_EggVertexUV_set_tangent_185_comment},
  {"set_tangent4", &Dtool_EggVertexUV_set_tangent4_186, METH_O, (const char *)Dtool_EggVertexUV_set_tangent4_186_comment},
  {"setTangent4", &Dtool_EggVertexUV_set_tangent4_186, METH_O, (const char *)Dtool_EggVertexUV_set_tangent4_186_comment},
  {"clear_tangent", &Dtool_EggVertexUV_clear_tangent_187, METH_NOARGS, (const char *)Dtool_EggVertexUV_clear_tangent_187_comment},
  {"clearTangent", &Dtool_EggVertexUV_clear_tangent_187, METH_NOARGS, (const char *)Dtool_EggVertexUV_clear_tangent_187_comment},
  {"has_binormal", &Dtool_EggVertexUV_has_binormal_188, METH_NOARGS, (const char *)Dtool_EggVertexUV_has_binormal_188_comment},
  {"hasBinormal", &Dtool_EggVertexUV_has_binormal_188, METH_NOARGS, (const char *)Dtool_EggVertexUV_has_binormal_188_comment},
  {"get_binormal", &Dtool_EggVertexUV_get_binormal_189, METH_NOARGS, (const char *)Dtool_EggVertexUV_get_binormal_189_comment},
  {"getBinormal", &Dtool_EggVertexUV_get_binormal_189, METH_NOARGS, (const char *)Dtool_EggVertexUV_get_binormal_189_comment},
  {"set_binormal", &Dtool_EggVertexUV_set_binormal_190, METH_O, (const char *)Dtool_EggVertexUV_set_binormal_190_comment},
  {"setBinormal", &Dtool_EggVertexUV_set_binormal_190, METH_O, (const char *)Dtool_EggVertexUV_set_binormal_190_comment},
  {"clear_binormal", &Dtool_EggVertexUV_clear_binormal_191, METH_NOARGS, (const char *)Dtool_EggVertexUV_clear_binormal_191_comment},
  {"clearBinormal", &Dtool_EggVertexUV_clear_binormal_191, METH_NOARGS, (const char *)Dtool_EggVertexUV_clear_binormal_191_comment},
  {"make_average", (PyCFunction) &Dtool_EggVertexUV_make_average_192, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_EggVertexUV_make_average_192_comment},
  {"makeAverage", (PyCFunction) &Dtool_EggVertexUV_make_average_192, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_EggVertexUV_make_average_192_comment},
  {"transform", &Dtool_EggVertexUV_transform_193, METH_O, (const char *)Dtool_EggVertexUV_transform_193_comment},
  {"write", (PyCFunction) &Dtool_EggVertexUV_write_194, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggVertexUV_write_194_comment},
  {"compare_to", &Dtool_EggVertexUV_compare_to_195, METH_O, (const char *)Dtool_EggVertexUV_compare_to_195_comment},
  {"compareTo", &Dtool_EggVertexUV_compare_to_195, METH_O, (const char *)Dtool_EggVertexUV_compare_to_195_comment},
  {"get_class_type", &Dtool_EggVertexUV_get_class_type_200, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggVertexUV_get_class_type_200_comment},
  {"getClassType", &Dtool_EggVertexUV_get_class_type_200, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggVertexUV_get_class_type_200_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// EggVertexUV slot tp_compare -> compare_to
//////////////////
static int Dtool_EggVertexUV_compare_to_195_tp_compare(PyObject *self, PyObject *arg) {
  EggVertexUV *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexUV, (void **)&local_this)) {
    return -1;
  }

  // 1-int EggVertexUV::compare_to(EggVertexUV const &other) const
  EggVertexUV const *arg_this = (EggVertexUV *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertexUV, 1, "EggVertexUV.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const EggVertexUV*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (int)(return_value > 0) - (int)(return_value < 0);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(EggVertexUV self, const EggVertexUV other)\n");
  }
  return -1;
}

//////////////////
//  A __str__ function
//     EggVertexUV
//////////////////
static PyObject *Dtool_Str_EggVertexUV(PyObject *self) {
  EggVertexUV *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexUV, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     EggVertexUV
//////////////////
static PyObject *Dtool_RichCompare_EggVertexUV(PyObject *self, PyObject *arg, int op) {
  EggVertexUV *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexUV, (void **)&local_this)) {
    return nullptr;
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_EggVertexUV_compare_to_195_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_EggVertexUV = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggVertexUV = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggVertexUV = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggVertexUV = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggVertexUV = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggVertexUV = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggVertexUV",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggVertexUV,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggVertexUV,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_EggVertexUV_compare_to_195_tp_compare,
#endif
    nullptr,
    &Dtool_NumberMethods_EggVertexUV,
    &Dtool_SequenceMethods_EggVertexUV,
    &Dtool_MappingMethods_EggVertexUV,
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Str_EggVertexUV,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggVertexUV,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The set of UV's that may or may not be assigned to a vertex.  To support\n"
    " * multitexturing, there may be multiple sets of UV's on a particular vertex,\n"
    " * each with its own name.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_EggVertexUV,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggVertexUV,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggVertexUV,
    PyType_GenericAlloc,
    Dtool_new_EggVertexUV,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggVertexUV,
  Dtool_UpcastInterface_EggVertexUV,
  Dtool_DowncastInterface_EggVertexUV,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggVertexUV(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggNamedObject(nullptr);
    Dtool_EggVertexUV._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggNamedObject);
    Dtool_EggVertexUV._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggVertexUV._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggVertexUV) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggVertexUV)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggVertexUV);
  }
}

/**
 * Python method tables for EggVertexAux (EggVertexAux)
 */
static PyMethodDef Dtool_Methods_EggVertexAux[] = {
  {"assign", &Dtool_EggVertexAux_operator_203, METH_O, (const char *)Dtool_EggVertexAux_operator_203_comment},
  {"set_name", &Dtool_EggVertexAux_set_name_204, METH_O, (const char *)Dtool_EggVertexAux_set_name_204_comment},
  {"setName", &Dtool_EggVertexAux_set_name_204, METH_O, (const char *)Dtool_EggVertexAux_set_name_204_comment},
  {"get_aux", &Dtool_EggVertexAux_get_aux_205, METH_NOARGS, (const char *)Dtool_EggVertexAux_get_aux_205_comment},
  {"getAux", &Dtool_EggVertexAux_get_aux_205, METH_NOARGS, (const char *)Dtool_EggVertexAux_get_aux_205_comment},
  {"set_aux", &Dtool_EggVertexAux_set_aux_206, METH_O, (const char *)Dtool_EggVertexAux_set_aux_206_comment},
  {"setAux", &Dtool_EggVertexAux_set_aux_206, METH_O, (const char *)Dtool_EggVertexAux_set_aux_206_comment},
  {"make_average", (PyCFunction) &Dtool_EggVertexAux_make_average_207, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_EggVertexAux_make_average_207_comment},
  {"makeAverage", (PyCFunction) &Dtool_EggVertexAux_make_average_207, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_EggVertexAux_make_average_207_comment},
  {"write", (PyCFunction) &Dtool_EggVertexAux_write_208, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggVertexAux_write_208_comment},
  {"compare_to", &Dtool_EggVertexAux_compare_to_209, METH_O, (const char *)Dtool_EggVertexAux_compare_to_209_comment},
  {"compareTo", &Dtool_EggVertexAux_compare_to_209, METH_O, (const char *)Dtool_EggVertexAux_compare_to_209_comment},
  {"get_class_type", &Dtool_EggVertexAux_get_class_type_210, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggVertexAux_get_class_type_210_comment},
  {"getClassType", &Dtool_EggVertexAux_get_class_type_210, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggVertexAux_get_class_type_210_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// EggVertexAux slot tp_compare -> compare_to
//////////////////
static int Dtool_EggVertexAux_compare_to_209_tp_compare(PyObject *self, PyObject *arg) {
  EggVertexAux *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexAux, (void **)&local_this)) {
    return -1;
  }

  // 1-int EggVertexAux::compare_to(EggVertexAux const &other) const
  EggVertexAux const *arg_this = (EggVertexAux *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertexAux, 1, "EggVertexAux.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const EggVertexAux*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (int)(return_value > 0) - (int)(return_value < 0);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(EggVertexAux self, const EggVertexAux other)\n");
  }
  return -1;
}

//////////////////
//  A __str__ function
//     EggVertexAux
//////////////////
static PyObject *Dtool_Str_EggVertexAux(PyObject *self) {
  EggVertexAux *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexAux, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     EggVertexAux
//////////////////
static PyObject *Dtool_RichCompare_EggVertexAux(PyObject *self, PyObject *arg, int op) {
  EggVertexAux *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexAux, (void **)&local_this)) {
    return nullptr;
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_EggVertexAux_compare_to_209_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_EggVertexAux = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggVertexAux = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggVertexAux = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggVertexAux = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggVertexAux = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggVertexAux = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggVertexAux",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggVertexAux,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggVertexAux,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_EggVertexAux_compare_to_209_tp_compare,
#endif
    nullptr,
    &Dtool_NumberMethods_EggVertexAux,
    &Dtool_SequenceMethods_EggVertexAux,
    &Dtool_MappingMethods_EggVertexAux,
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Str_EggVertexAux,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggVertexAux,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The set of named auxiliary data that may or may not be assigned to a\n"
    " * vertex.  Panda will import this data and create a custom column for it in\n"
    " * the vertex data, but will not otherwise interpret it.  Presumably, a shader\n"
    " * will process the data later.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_EggVertexAux,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggVertexAux,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggVertexAux,
    PyType_GenericAlloc,
    Dtool_new_EggVertexAux,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggVertexAux,
  Dtool_UpcastInterface_EggVertexAux,
  Dtool_DowncastInterface_EggVertexAux,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggVertexAux(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggNamedObject(nullptr);
    Dtool_EggVertexAux._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggNamedObject);
    Dtool_EggVertexAux._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggVertexAux._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggVertexAux) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggVertexAux)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggVertexAux);
  }
}

/**
 * Python method tables for EggVertex (EggVertex)
 */
static PyMethodDef Dtool_Methods_EggVertex[] = {
  {"assign", &Dtool_EggVertex_operator_217, METH_O, (const char *)Dtool_EggVertex_operator_217_comment},
  {"get_pool", &Dtool_EggVertex_get_pool_219, METH_NOARGS, (const char *)Dtool_EggVertex_get_pool_219_comment},
  {"getPool", &Dtool_EggVertex_get_pool_219, METH_NOARGS, (const char *)Dtool_EggVertex_get_pool_219_comment},
  {"is_forward_reference", &Dtool_EggVertex_is_forward_reference_220, METH_NOARGS, (const char *)Dtool_EggVertex_is_forward_reference_220_comment},
  {"isForwardReference", &Dtool_EggVertex_is_forward_reference_220, METH_NOARGS, (const char *)Dtool_EggVertex_is_forward_reference_220_comment},
  {"set_pos", &Dtool_EggVertex_set_pos_221, METH_O, (const char *)Dtool_EggVertex_set_pos_221_comment},
  {"setPos", &Dtool_EggVertex_set_pos_221, METH_O, (const char *)Dtool_EggVertex_set_pos_221_comment},
  {"set_pos4", &Dtool_EggVertex_set_pos4_222, METH_O, (const char *)Dtool_EggVertex_set_pos4_222_comment},
  {"setPos4", &Dtool_EggVertex_set_pos4_222, METH_O, (const char *)Dtool_EggVertex_set_pos4_222_comment},
  {"get_num_dimensions", &Dtool_EggVertex_get_num_dimensions_223, METH_NOARGS, (const char *)Dtool_EggVertex_get_num_dimensions_223_comment},
  {"getNumDimensions", &Dtool_EggVertex_get_num_dimensions_223, METH_NOARGS, (const char *)Dtool_EggVertex_get_num_dimensions_223_comment},
  {"get_pos1", &Dtool_EggVertex_get_pos1_224, METH_NOARGS, (const char *)Dtool_EggVertex_get_pos1_224_comment},
  {"getPos1", &Dtool_EggVertex_get_pos1_224, METH_NOARGS, (const char *)Dtool_EggVertex_get_pos1_224_comment},
  {"get_pos2", &Dtool_EggVertex_get_pos2_225, METH_NOARGS, (const char *)Dtool_EggVertex_get_pos2_225_comment},
  {"getPos2", &Dtool_EggVertex_get_pos2_225, METH_NOARGS, (const char *)Dtool_EggVertex_get_pos2_225_comment},
  {"get_pos3", &Dtool_EggVertex_get_pos3_226, METH_NOARGS, (const char *)Dtool_EggVertex_get_pos3_226_comment},
  {"getPos3", &Dtool_EggVertex_get_pos3_226, METH_NOARGS, (const char *)Dtool_EggVertex_get_pos3_226_comment},
  {"get_pos4", &Dtool_EggVertex_get_pos4_227, METH_NOARGS, (const char *)Dtool_EggVertex_get_pos4_227_comment},
  {"getPos4", &Dtool_EggVertex_get_pos4_227, METH_NOARGS, (const char *)Dtool_EggVertex_get_pos4_227_comment},
  {"has_uv", &Dtool_EggVertex_has_uv_228, METH_VARARGS, (const char *)Dtool_EggVertex_has_uv_228_comment},
  {"hasUv", &Dtool_EggVertex_has_uv_228, METH_VARARGS, (const char *)Dtool_EggVertex_has_uv_228_comment},
  {"get_uv", &Dtool_EggVertex_get_uv_229, METH_VARARGS, (const char *)Dtool_EggVertex_get_uv_229_comment},
  {"getUv", &Dtool_EggVertex_get_uv_229, METH_VARARGS, (const char *)Dtool_EggVertex_get_uv_229_comment},
  {"set_uv", (PyCFunction) &Dtool_EggVertex_set_uv_230, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggVertex_set_uv_230_comment},
  {"setUv", (PyCFunction) &Dtool_EggVertex_set_uv_230, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggVertex_set_uv_230_comment},
  {"clear_uv", &Dtool_EggVertex_clear_uv_231, METH_VARARGS, (const char *)Dtool_EggVertex_clear_uv_231_comment},
  {"clearUv", &Dtool_EggVertex_clear_uv_231, METH_VARARGS, (const char *)Dtool_EggVertex_clear_uv_231_comment},
  {"has_uvw", &Dtool_EggVertex_has_uvw_232, METH_O, (const char *)Dtool_EggVertex_has_uvw_232_comment},
  {"hasUvw", &Dtool_EggVertex_has_uvw_232, METH_O, (const char *)Dtool_EggVertex_has_uvw_232_comment},
  {"get_uvw", &Dtool_EggVertex_get_uvw_233, METH_O, (const char *)Dtool_EggVertex_get_uvw_233_comment},
  {"getUvw", &Dtool_EggVertex_get_uvw_233, METH_O, (const char *)Dtool_EggVertex_get_uvw_233_comment},
  {"set_uvw", (PyCFunction) &Dtool_EggVertex_set_uvw_234, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggVertex_set_uvw_234_comment},
  {"setUvw", (PyCFunction) &Dtool_EggVertex_set_uvw_234, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggVertex_set_uvw_234_comment},
  {"get_uv_obj", &Dtool_EggVertex_get_uv_obj_235, METH_O, (const char *)Dtool_EggVertex_get_uv_obj_235_comment},
  {"getUvObj", &Dtool_EggVertex_get_uv_obj_235, METH_O, (const char *)Dtool_EggVertex_get_uv_obj_235_comment},
  {"modify_uv_obj", &Dtool_EggVertex_modify_uv_obj_236, METH_O, (const char *)Dtool_EggVertex_modify_uv_obj_236_comment},
  {"modifyUvObj", &Dtool_EggVertex_modify_uv_obj_236, METH_O, (const char *)Dtool_EggVertex_modify_uv_obj_236_comment},
  {"set_uv_obj", &Dtool_EggVertex_set_uv_obj_237, METH_O, (const char *)Dtool_EggVertex_set_uv_obj_237_comment},
  {"setUvObj", &Dtool_EggVertex_set_uv_obj_237, METH_O, (const char *)Dtool_EggVertex_set_uv_obj_237_comment},
  {"has_aux", &Dtool_EggVertex_has_aux_238, METH_VARARGS, (const char *)Dtool_EggVertex_has_aux_238_comment},
  {"hasAux", &Dtool_EggVertex_has_aux_238, METH_VARARGS, (const char *)Dtool_EggVertex_has_aux_238_comment},
  {"clear_aux", &Dtool_EggVertex_clear_aux_239, METH_VARARGS, (const char *)Dtool_EggVertex_clear_aux_239_comment},
  {"clearAux", &Dtool_EggVertex_clear_aux_239, METH_VARARGS, (const char *)Dtool_EggVertex_clear_aux_239_comment},
  {"get_aux", &Dtool_EggVertex_get_aux_240, METH_O, (const char *)Dtool_EggVertex_get_aux_240_comment},
  {"getAux", &Dtool_EggVertex_get_aux_240, METH_O, (const char *)Dtool_EggVertex_get_aux_240_comment},
  {"set_aux", (PyCFunction) &Dtool_EggVertex_set_aux_241, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggVertex_set_aux_241_comment},
  {"setAux", (PyCFunction) &Dtool_EggVertex_set_aux_241, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggVertex_set_aux_241_comment},
  {"get_aux_obj", &Dtool_EggVertex_get_aux_obj_242, METH_O, (const char *)Dtool_EggVertex_get_aux_obj_242_comment},
  {"getAuxObj", &Dtool_EggVertex_get_aux_obj_242, METH_O, (const char *)Dtool_EggVertex_get_aux_obj_242_comment},
  {"modify_aux_obj", &Dtool_EggVertex_modify_aux_obj_243, METH_O, (const char *)Dtool_EggVertex_modify_aux_obj_243_comment},
  {"modifyAuxObj", &Dtool_EggVertex_modify_aux_obj_243, METH_O, (const char *)Dtool_EggVertex_modify_aux_obj_243_comment},
  {"set_aux_obj", &Dtool_EggVertex_set_aux_obj_244, METH_O, (const char *)Dtool_EggVertex_set_aux_obj_244_comment},
  {"setAuxObj", &Dtool_EggVertex_set_aux_obj_244, METH_O, (const char *)Dtool_EggVertex_set_aux_obj_244_comment},
  {"make_average", (PyCFunction) &Dtool_EggVertex_make_average_245, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_EggVertex_make_average_245_comment},
  {"makeAverage", (PyCFunction) &Dtool_EggVertex_make_average_245, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_EggVertex_make_average_245_comment},
  {"get_index", &Dtool_EggVertex_get_index_246, METH_NOARGS, (const char *)Dtool_EggVertex_get_index_246_comment},
  {"getIndex", &Dtool_EggVertex_get_index_246, METH_NOARGS, (const char *)Dtool_EggVertex_get_index_246_comment},
  {"set_external_index", &Dtool_EggVertex_set_external_index_247, METH_O, (const char *)Dtool_EggVertex_set_external_index_247_comment},
  {"setExternalIndex", &Dtool_EggVertex_set_external_index_247, METH_O, (const char *)Dtool_EggVertex_set_external_index_247_comment},
  {"get_external_index", &Dtool_EggVertex_get_external_index_248, METH_NOARGS, (const char *)Dtool_EggVertex_get_external_index_248_comment},
  {"getExternalIndex", &Dtool_EggVertex_get_external_index_248, METH_NOARGS, (const char *)Dtool_EggVertex_get_external_index_248_comment},
  {"set_external_index2", &Dtool_EggVertex_set_external_index2_249, METH_O, (const char *)Dtool_EggVertex_set_external_index2_249_comment},
  {"setExternalIndex2", &Dtool_EggVertex_set_external_index2_249, METH_O, (const char *)Dtool_EggVertex_set_external_index2_249_comment},
  {"get_external_index2", &Dtool_EggVertex_get_external_index2_250, METH_NOARGS, (const char *)Dtool_EggVertex_get_external_index2_250_comment},
  {"getExternalIndex2", &Dtool_EggVertex_get_external_index2_250, METH_NOARGS, (const char *)Dtool_EggVertex_get_external_index2_250_comment},
  {"write", (PyCFunction) &Dtool_EggVertex_write_251, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggVertex_write_251_comment},
  {"sorts_less_than", &Dtool_EggVertex_sorts_less_than_252, METH_O, (const char *)Dtool_EggVertex_sorts_less_than_252_comment},
  {"sortsLessThan", &Dtool_EggVertex_sorts_less_than_252, METH_O, (const char *)Dtool_EggVertex_sorts_less_than_252_comment},
  {"compare_to", &Dtool_EggVertex_compare_to_253, METH_O, (const char *)Dtool_EggVertex_compare_to_253_comment},
  {"compareTo", &Dtool_EggVertex_compare_to_253, METH_O, (const char *)Dtool_EggVertex_compare_to_253_comment},
  {"get_num_local_coord", &Dtool_EggVertex_get_num_local_coord_254, METH_NOARGS, (const char *)Dtool_EggVertex_get_num_local_coord_254_comment},
  {"getNumLocalCoord", &Dtool_EggVertex_get_num_local_coord_254, METH_NOARGS, (const char *)Dtool_EggVertex_get_num_local_coord_254_comment},
  {"get_num_global_coord", &Dtool_EggVertex_get_num_global_coord_255, METH_NOARGS, (const char *)Dtool_EggVertex_get_num_global_coord_255_comment},
  {"getNumGlobalCoord", &Dtool_EggVertex_get_num_global_coord_255, METH_NOARGS, (const char *)Dtool_EggVertex_get_num_global_coord_255_comment},
  {"transform", &Dtool_EggVertex_transform_256, METH_O, (const char *)Dtool_EggVertex_transform_256_comment},
  {"has_gref", &Dtool_EggVertex_has_gref_257, METH_O, (const char *)Dtool_EggVertex_has_gref_257_comment},
  {"hasGref", &Dtool_EggVertex_has_gref_257, METH_O, (const char *)Dtool_EggVertex_has_gref_257_comment},
  {"copy_grefs_from", &Dtool_EggVertex_copy_grefs_from_258, METH_O, (const char *)Dtool_EggVertex_copy_grefs_from_258_comment},
  {"copyGrefsFrom", &Dtool_EggVertex_copy_grefs_from_258, METH_O, (const char *)Dtool_EggVertex_copy_grefs_from_258_comment},
  {"clear_grefs", &Dtool_EggVertex_clear_grefs_259, METH_NOARGS, (const char *)Dtool_EggVertex_clear_grefs_259_comment},
  {"clearGrefs", &Dtool_EggVertex_clear_grefs_259, METH_NOARGS, (const char *)Dtool_EggVertex_clear_grefs_259_comment},
  {"has_pref", &Dtool_EggVertex_has_pref_260, METH_O, (const char *)Dtool_EggVertex_has_pref_260_comment},
  {"hasPref", &Dtool_EggVertex_has_pref_260, METH_O, (const char *)Dtool_EggVertex_has_pref_260_comment},
  {"test_gref_integrity", &Dtool_EggVertex_test_gref_integrity_261, METH_NOARGS, (const char *)Dtool_EggVertex_test_gref_integrity_261_comment},
  {"testGrefIntegrity", &Dtool_EggVertex_test_gref_integrity_261, METH_NOARGS, (const char *)Dtool_EggVertex_test_gref_integrity_261_comment},
  {"test_pref_integrity", &Dtool_EggVertex_test_pref_integrity_262, METH_NOARGS, (const char *)Dtool_EggVertex_test_pref_integrity_262_comment},
  {"testPrefIntegrity", &Dtool_EggVertex_test_pref_integrity_262, METH_NOARGS, (const char *)Dtool_EggVertex_test_pref_integrity_262_comment},
  {"output", &Dtool_EggVertex_output_263, METH_O, (const char *)Dtool_EggVertex_output_263_comment},
  {"get_class_type", &Dtool_EggVertex_get_class_type_268, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggVertex_get_class_type_268_comment},
  {"getClassType", &Dtool_EggVertex_get_class_type_268, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggVertex_get_class_type_268_comment},
  {"upcast_to_EggObject", &Dtool_EggVertex_upcast_to_EggObject_212, METH_NOARGS, (const char *)Dtool_EggVertex_upcast_to_EggObject_212_comment},
  {"upcastToEggObject", &Dtool_EggVertex_upcast_to_EggObject_212, METH_NOARGS, (const char *)Dtool_EggVertex_upcast_to_EggObject_212_comment},
  {"upcast_to_EggAttributes", &Dtool_EggVertex_upcast_to_EggAttributes_214, METH_NOARGS, (const char *)Dtool_EggVertex_upcast_to_EggAttributes_214_comment},
  {"upcastToEggAttributes", &Dtool_EggVertex_upcast_to_EggAttributes_214, METH_NOARGS, (const char *)Dtool_EggVertex_upcast_to_EggAttributes_214_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// EggVertex slot tp_compare -> compare_to
//////////////////
static int Dtool_EggVertex_compare_to_253_tp_compare(PyObject *self, PyObject *arg) {
  EggVertex *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return -1;
  }

  // 1-int EggVertex::compare_to(EggVertex const &other) const
  EggVertex const *arg_this = (EggVertex *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EggVertex, 1, "EggVertex.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const EggVertex*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (int)(return_value > 0) - (int)(return_value < 0);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(EggVertex self, const EggVertex other)\n");
  }
  return -1;
}

//////////////////
//  A __repr__ function
//     EggVertex
//////////////////
static PyObject *Dtool_Repr_EggVertex(PyObject *self) {
  EggVertex *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     EggVertex
//////////////////
static PyObject *Dtool_Str_EggVertex(PyObject *self) {
  EggVertex *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     EggVertex
//////////////////
static PyObject *Dtool_RichCompare_EggVertex(PyObject *self, PyObject *arg, int op) {
  EggVertex *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertex, (void **)&local_this)) {
    return nullptr;
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_EggVertex_compare_to_253_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_EggVertex = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggVertex = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggVertex = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggVertex = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggVertex = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggVertex = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggVertex",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggVertex,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggVertex,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_EggVertex_compare_to_253_tp_compare,
#endif
    &Dtool_Repr_EggVertex,
    &Dtool_NumberMethods_EggVertex,
    &Dtool_SequenceMethods_EggVertex,
    &Dtool_MappingMethods_EggVertex,
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Str_EggVertex,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggVertex,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Any one-, two-, three-, or four-component vertex, possibly with attributes\n"
    " * such as a normal.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_EggVertex,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggVertex,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggVertex,
    PyType_GenericAlloc,
    Dtool_new_EggVertex,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggVertex,
  Dtool_UpcastInterface_EggVertex,
  Dtool_DowncastInterface_EggVertex,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggVertex(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggObject(nullptr);
    Dtool_PyModuleClassInit_EggAttributes(nullptr);
    Dtool_EggVertex._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_EggObject, (PyTypeObject *)&Dtool_EggAttributes);
    Dtool_EggVertex._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggVertex._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggVertex) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggVertex)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggVertex);
  }
}

/**
 * Python method tables for EggVertexPool (EggVertexPool)
 */
static PyMethodDef Dtool_Methods_EggVertexPool[] = {
  {"has_vertex", &Dtool_EggVertexPool_has_vertex_271, METH_O, (const char *)Dtool_EggVertexPool_has_vertex_271_comment},
  {"hasVertex", &Dtool_EggVertexPool_has_vertex_271, METH_O, (const char *)Dtool_EggVertexPool_has_vertex_271_comment},
  {"has_forward_vertices", &Dtool_EggVertexPool_has_forward_vertices_272, METH_NOARGS, (const char *)Dtool_EggVertexPool_has_forward_vertices_272_comment},
  {"hasForwardVertices", &Dtool_EggVertexPool_has_forward_vertices_272, METH_NOARGS, (const char *)Dtool_EggVertexPool_has_forward_vertices_272_comment},
  {"has_defined_vertices", &Dtool_EggVertexPool_has_defined_vertices_273, METH_NOARGS, (const char *)Dtool_EggVertexPool_has_defined_vertices_273_comment},
  {"hasDefinedVertices", &Dtool_EggVertexPool_has_defined_vertices_273, METH_NOARGS, (const char *)Dtool_EggVertexPool_has_defined_vertices_273_comment},
  {"get_vertex", &Dtool_EggVertexPool_get_vertex_274, METH_O, (const char *)Dtool_EggVertexPool_get_vertex_274_comment},
  {"getVertex", &Dtool_EggVertexPool_get_vertex_274, METH_O, (const char *)Dtool_EggVertexPool_get_vertex_274_comment},
  {"get_forward_vertex", &Dtool_EggVertexPool_get_forward_vertex_276, METH_O, (const char *)Dtool_EggVertexPool_get_forward_vertex_276_comment},
  {"getForwardVertex", &Dtool_EggVertexPool_get_forward_vertex_276, METH_O, (const char *)Dtool_EggVertexPool_get_forward_vertex_276_comment},
  {"get_highest_index", &Dtool_EggVertexPool_get_highest_index_277, METH_NOARGS, (const char *)Dtool_EggVertexPool_get_highest_index_277_comment},
  {"getHighestIndex", &Dtool_EggVertexPool_get_highest_index_277, METH_NOARGS, (const char *)Dtool_EggVertexPool_get_highest_index_277_comment},
  {"set_highest_index", &Dtool_EggVertexPool_set_highest_index_278, METH_O, (const char *)Dtool_EggVertexPool_set_highest_index_278_comment},
  {"setHighestIndex", &Dtool_EggVertexPool_set_highest_index_278, METH_O, (const char *)Dtool_EggVertexPool_set_highest_index_278_comment},
  {"get_num_dimensions", &Dtool_EggVertexPool_get_num_dimensions_279, METH_NOARGS, (const char *)Dtool_EggVertexPool_get_num_dimensions_279_comment},
  {"getNumDimensions", &Dtool_EggVertexPool_get_num_dimensions_279, METH_NOARGS, (const char *)Dtool_EggVertexPool_get_num_dimensions_279_comment},
  {"has_normals", &Dtool_EggVertexPool_has_normals_280, METH_NOARGS, (const char *)Dtool_EggVertexPool_has_normals_280_comment},
  {"hasNormals", &Dtool_EggVertexPool_has_normals_280, METH_NOARGS, (const char *)Dtool_EggVertexPool_has_normals_280_comment},
  {"has_colors", &Dtool_EggVertexPool_has_colors_281, METH_NOARGS, (const char *)Dtool_EggVertexPool_has_colors_281_comment},
  {"hasColors", &Dtool_EggVertexPool_has_colors_281, METH_NOARGS, (const char *)Dtool_EggVertexPool_has_colors_281_comment},
  {"has_nonwhite_colors", &Dtool_EggVertexPool_has_nonwhite_colors_282, METH_NOARGS, (const char *)Dtool_EggVertexPool_has_nonwhite_colors_282_comment},
  {"hasNonwhiteColors", &Dtool_EggVertexPool_has_nonwhite_colors_282, METH_NOARGS, (const char *)Dtool_EggVertexPool_has_nonwhite_colors_282_comment},
  {"has_uvs", &Dtool_EggVertexPool_has_uvs_284, METH_NOARGS, (const char *)Dtool_EggVertexPool_has_uvs_284_comment},
  {"hasUvs", &Dtool_EggVertexPool_has_uvs_284, METH_NOARGS, (const char *)Dtool_EggVertexPool_has_uvs_284_comment},
  {"has_aux", &Dtool_EggVertexPool_has_aux_285, METH_NOARGS, (const char *)Dtool_EggVertexPool_has_aux_285_comment},
  {"hasAux", &Dtool_EggVertexPool_has_aux_285, METH_NOARGS, (const char *)Dtool_EggVertexPool_has_aux_285_comment},
  {"add_vertex", (PyCFunction) &Dtool_EggVertexPool_add_vertex_289, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggVertexPool_add_vertex_289_comment},
  {"addVertex", (PyCFunction) &Dtool_EggVertexPool_add_vertex_289, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggVertexPool_add_vertex_289_comment},
  {"make_new_vertex", &Dtool_EggVertexPool_make_new_vertex_290, METH_VARARGS, (const char *)Dtool_EggVertexPool_make_new_vertex_290_comment},
  {"makeNewVertex", &Dtool_EggVertexPool_make_new_vertex_290, METH_VARARGS, (const char *)Dtool_EggVertexPool_make_new_vertex_290_comment},
  {"create_unique_vertex", &Dtool_EggVertexPool_create_unique_vertex_291, METH_O, (const char *)Dtool_EggVertexPool_create_unique_vertex_291_comment},
  {"createUniqueVertex", &Dtool_EggVertexPool_create_unique_vertex_291, METH_O, (const char *)Dtool_EggVertexPool_create_unique_vertex_291_comment},
  {"find_matching_vertex", &Dtool_EggVertexPool_find_matching_vertex_292, METH_O, (const char *)Dtool_EggVertexPool_find_matching_vertex_292_comment},
  {"findMatchingVertex", &Dtool_EggVertexPool_find_matching_vertex_292, METH_O, (const char *)Dtool_EggVertexPool_find_matching_vertex_292_comment},
  {"remove_vertex", &Dtool_EggVertexPool_remove_vertex_293, METH_O, (const char *)Dtool_EggVertexPool_remove_vertex_293_comment},
  {"removeVertex", &Dtool_EggVertexPool_remove_vertex_293, METH_O, (const char *)Dtool_EggVertexPool_remove_vertex_293_comment},
  {"remove_unused_vertices", &Dtool_EggVertexPool_remove_unused_vertices_294, METH_NOARGS, (const char *)Dtool_EggVertexPool_remove_unused_vertices_294_comment},
  {"removeUnusedVertices", &Dtool_EggVertexPool_remove_unused_vertices_294, METH_NOARGS, (const char *)Dtool_EggVertexPool_remove_unused_vertices_294_comment},
  {"add_unused_vertices_to_prim", &Dtool_EggVertexPool_add_unused_vertices_to_prim_295, METH_O, (const char *)Dtool_EggVertexPool_add_unused_vertices_to_prim_295_comment},
  {"addUnusedVerticesToPrim", &Dtool_EggVertexPool_add_unused_vertices_to_prim_295, METH_O, (const char *)Dtool_EggVertexPool_add_unused_vertices_to_prim_295_comment},
  {"transform", &Dtool_EggVertexPool_transform_296, METH_O, (const char *)Dtool_EggVertexPool_transform_296_comment},
  {"sort_by_external_index", &Dtool_EggVertexPool_sort_by_external_index_297, METH_NOARGS, (const char *)Dtool_EggVertexPool_sort_by_external_index_297_comment},
  {"sortByExternalIndex", &Dtool_EggVertexPool_sort_by_external_index_297, METH_NOARGS, (const char *)Dtool_EggVertexPool_sort_by_external_index_297_comment},
  {"get_class_type", &Dtool_EggVertexPool_get_class_type_298, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggVertexPool_get_class_type_298_comment},
  {"getClassType", &Dtool_EggVertexPool_get_class_type_298, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggVertexPool_get_class_type_298_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// EggVertexPool slot sq_item -> operator []
//////////////////
static PyObject *Dtool_EggVertexPool_operator_275_sq_item(PyObject *self, Py_ssize_t index) {
  EggVertexPool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexPool, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "EggVertexPool index out of range");
    return nullptr;
  }
  // 1-inline EggVertex *EggVertexPool::operator [](int index) const
  EggVertex *return_value = ((*(const EggVertexPool*)local_this).operator [])(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggVertex, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(EggVertexPool self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// EggVertexPool slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_EggVertexPool_size_288_sq_length(PyObject *self) {
  EggVertexPool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggVertexPool, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_EggVertexPool = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggVertexPool = {
  &Dtool_EggVertexPool_size_288_sq_length,
  nullptr,
  nullptr,
  &Dtool_EggVertexPool_operator_275_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggVertexPool = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggVertexPool = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggVertexPool = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggVertexPool = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggVertexPool",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggVertexPool,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggVertexPool,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggVertexPool,
    &Dtool_SequenceMethods_EggVertexPool,
    &Dtool_MappingMethods_EggVertexPool,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggVertexPool,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A collection of vertices.  There may be any number of vertex pools in a\n"
    " * single egg structure.  The vertices in a single pool need not necessarily\n"
    " * have any connection to each other, but it is necessary that any one\n"
    " * primitive (e.g.  a polygon) must pull all its vertices from the same pool.\n"
    " *\n"
    " * An EggVertexPool is an STL-style container of pointers to EggVertex's.\n"
    " * Functions add_vertex() and remove_vertex() are provided to manipulate the\n"
    " * list.  The list may also be operated on (read-only) via iterators and\n"
    " * begin()/end().\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggVertexPool,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggVertexPool,
    PyType_GenericAlloc,
    Dtool_new_EggVertexPool,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggVertexPool,
  Dtool_UpcastInterface_EggVertexPool,
  Dtool_DowncastInterface_EggVertexPool,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggVertexPool(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggNode(nullptr);
    Dtool_EggVertexPool._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggNode);
    Dtool_EggVertexPool._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggVertexPool._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggVertexPool) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggVertexPool)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggVertexPool);
  }
}

/**
 * Python method tables for EggRenderMode (EggRenderMode)
 */
static PyMethodDef Dtool_Methods_EggRenderMode[] = {
  {"assign", &Dtool_EggRenderMode_operator_301, METH_O, (const char *)Dtool_EggRenderMode_operator_301_comment},
  {"write", (PyCFunction) &Dtool_EggRenderMode_write_302, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggRenderMode_write_302_comment},
  {"set_alpha_mode", &Dtool_EggRenderMode_set_alpha_mode_307, METH_O, (const char *)Dtool_EggRenderMode_set_alpha_mode_307_comment},
  {"setAlphaMode", &Dtool_EggRenderMode_set_alpha_mode_307, METH_O, (const char *)Dtool_EggRenderMode_set_alpha_mode_307_comment},
  {"get_alpha_mode", &Dtool_EggRenderMode_get_alpha_mode_308, METH_NOARGS, (const char *)Dtool_EggRenderMode_get_alpha_mode_308_comment},
  {"getAlphaMode", &Dtool_EggRenderMode_get_alpha_mode_308, METH_NOARGS, (const char *)Dtool_EggRenderMode_get_alpha_mode_308_comment},
  {"set_depth_write_mode", &Dtool_EggRenderMode_set_depth_write_mode_309, METH_O, (const char *)Dtool_EggRenderMode_set_depth_write_mode_309_comment},
  {"setDepthWriteMode", &Dtool_EggRenderMode_set_depth_write_mode_309, METH_O, (const char *)Dtool_EggRenderMode_set_depth_write_mode_309_comment},
  {"get_depth_write_mode", &Dtool_EggRenderMode_get_depth_write_mode_310, METH_NOARGS, (const char *)Dtool_EggRenderMode_get_depth_write_mode_310_comment},
  {"getDepthWriteMode", &Dtool_EggRenderMode_get_depth_write_mode_310, METH_NOARGS, (const char *)Dtool_EggRenderMode_get_depth_write_mode_310_comment},
  {"set_depth_test_mode", &Dtool_EggRenderMode_set_depth_test_mode_311, METH_O, (const char *)Dtool_EggRenderMode_set_depth_test_mode_311_comment},
  {"setDepthTestMode", &Dtool_EggRenderMode_set_depth_test_mode_311, METH_O, (const char *)Dtool_EggRenderMode_set_depth_test_mode_311_comment},
  {"get_depth_test_mode", &Dtool_EggRenderMode_get_depth_test_mode_312, METH_NOARGS, (const char *)Dtool_EggRenderMode_get_depth_test_mode_312_comment},
  {"getDepthTestMode", &Dtool_EggRenderMode_get_depth_test_mode_312, METH_NOARGS, (const char *)Dtool_EggRenderMode_get_depth_test_mode_312_comment},
  {"set_visibility_mode", &Dtool_EggRenderMode_set_visibility_mode_313, METH_O, (const char *)Dtool_EggRenderMode_set_visibility_mode_313_comment},
  {"setVisibilityMode", &Dtool_EggRenderMode_set_visibility_mode_313, METH_O, (const char *)Dtool_EggRenderMode_set_visibility_mode_313_comment},
  {"get_visibility_mode", &Dtool_EggRenderMode_get_visibility_mode_314, METH_NOARGS, (const char *)Dtool_EggRenderMode_get_visibility_mode_314_comment},
  {"getVisibilityMode", &Dtool_EggRenderMode_get_visibility_mode_314, METH_NOARGS, (const char *)Dtool_EggRenderMode_get_visibility_mode_314_comment},
  {"set_depth_offset", &Dtool_EggRenderMode_set_depth_offset_315, METH_O, (const char *)Dtool_EggRenderMode_set_depth_offset_315_comment},
  {"setDepthOffset", &Dtool_EggRenderMode_set_depth_offset_315, METH_O, (const char *)Dtool_EggRenderMode_set_depth_offset_315_comment},
  {"get_depth_offset", &Dtool_EggRenderMode_get_depth_offset_316, METH_NOARGS, (const char *)Dtool_EggRenderMode_get_depth_offset_316_comment},
  {"getDepthOffset", &Dtool_EggRenderMode_get_depth_offset_316, METH_NOARGS, (const char *)Dtool_EggRenderMode_get_depth_offset_316_comment},
  {"has_depth_offset", &Dtool_EggRenderMode_has_depth_offset_317, METH_NOARGS, (const char *)Dtool_EggRenderMode_has_depth_offset_317_comment},
  {"hasDepthOffset", &Dtool_EggRenderMode_has_depth_offset_317, METH_NOARGS, (const char *)Dtool_EggRenderMode_has_depth_offset_317_comment},
  {"clear_depth_offset", &Dtool_EggRenderMode_clear_depth_offset_318, METH_NOARGS, (const char *)Dtool_EggRenderMode_clear_depth_offset_318_comment},
  {"clearDepthOffset", &Dtool_EggRenderMode_clear_depth_offset_318, METH_NOARGS, (const char *)Dtool_EggRenderMode_clear_depth_offset_318_comment},
  {"set_draw_order", &Dtool_EggRenderMode_set_draw_order_319, METH_O, (const char *)Dtool_EggRenderMode_set_draw_order_319_comment},
  {"setDrawOrder", &Dtool_EggRenderMode_set_draw_order_319, METH_O, (const char *)Dtool_EggRenderMode_set_draw_order_319_comment},
  {"get_draw_order", &Dtool_EggRenderMode_get_draw_order_320, METH_NOARGS, (const char *)Dtool_EggRenderMode_get_draw_order_320_comment},
  {"getDrawOrder", &Dtool_EggRenderMode_get_draw_order_320, METH_NOARGS, (const char *)Dtool_EggRenderMode_get_draw_order_320_comment},
  {"has_draw_order", &Dtool_EggRenderMode_has_draw_order_321, METH_NOARGS, (const char *)Dtool_EggRenderMode_has_draw_order_321_comment},
  {"hasDrawOrder", &Dtool_EggRenderMode_has_draw_order_321, METH_NOARGS, (const char *)Dtool_EggRenderMode_has_draw_order_321_comment},
  {"clear_draw_order", &Dtool_EggRenderMode_clear_draw_order_322, METH_NOARGS, (const char *)Dtool_EggRenderMode_clear_draw_order_322_comment},
  {"clearDrawOrder", &Dtool_EggRenderMode_clear_draw_order_322, METH_NOARGS, (const char *)Dtool_EggRenderMode_clear_draw_order_322_comment},
  {"set_bin", &Dtool_EggRenderMode_set_bin_323, METH_O, (const char *)Dtool_EggRenderMode_set_bin_323_comment},
  {"setBin", &Dtool_EggRenderMode_set_bin_323, METH_O, (const char *)Dtool_EggRenderMode_set_bin_323_comment},
  {"get_bin", &Dtool_EggRenderMode_get_bin_324, METH_NOARGS, (const char *)Dtool_EggRenderMode_get_bin_324_comment},
  {"getBin", &Dtool_EggRenderMode_get_bin_324, METH_NOARGS, (const char *)Dtool_EggRenderMode_get_bin_324_comment},
  {"has_bin", &Dtool_EggRenderMode_has_bin_325, METH_NOARGS, (const char *)Dtool_EggRenderMode_has_bin_325_comment},
  {"hasBin", &Dtool_EggRenderMode_has_bin_325, METH_NOARGS, (const char *)Dtool_EggRenderMode_has_bin_325_comment},
  {"clear_bin", &Dtool_EggRenderMode_clear_bin_326, METH_NOARGS, (const char *)Dtool_EggRenderMode_clear_bin_326_comment},
  {"clearBin", &Dtool_EggRenderMode_clear_bin_326, METH_NOARGS, (const char *)Dtool_EggRenderMode_clear_bin_326_comment},
  {"string_alpha_mode", &Dtool_EggRenderMode_string_alpha_mode_330, METH_O | METH_STATIC, (const char *)Dtool_EggRenderMode_string_alpha_mode_330_comment},
  {"stringAlphaMode", &Dtool_EggRenderMode_string_alpha_mode_330, METH_O | METH_STATIC, (const char *)Dtool_EggRenderMode_string_alpha_mode_330_comment},
  {"string_depth_write_mode", &Dtool_EggRenderMode_string_depth_write_mode_331, METH_O | METH_STATIC, (const char *)Dtool_EggRenderMode_string_depth_write_mode_331_comment},
  {"stringDepthWriteMode", &Dtool_EggRenderMode_string_depth_write_mode_331, METH_O | METH_STATIC, (const char *)Dtool_EggRenderMode_string_depth_write_mode_331_comment},
  {"string_depth_test_mode", &Dtool_EggRenderMode_string_depth_test_mode_332, METH_O | METH_STATIC, (const char *)Dtool_EggRenderMode_string_depth_test_mode_332_comment},
  {"stringDepthTestMode", &Dtool_EggRenderMode_string_depth_test_mode_332, METH_O | METH_STATIC, (const char *)Dtool_EggRenderMode_string_depth_test_mode_332_comment},
  {"string_visibility_mode", &Dtool_EggRenderMode_string_visibility_mode_333, METH_O | METH_STATIC, (const char *)Dtool_EggRenderMode_string_visibility_mode_333_comment},
  {"stringVisibilityMode", &Dtool_EggRenderMode_string_visibility_mode_333, METH_O | METH_STATIC, (const char *)Dtool_EggRenderMode_string_visibility_mode_333_comment},
  {"get_class_type", &Dtool_EggRenderMode_get_class_type_334, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggRenderMode_get_class_type_334_comment},
  {"getClassType", &Dtool_EggRenderMode_get_class_type_334, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggRenderMode_get_class_type_334_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     EggRenderMode
//////////////////
static PyObject *Dtool_Str_EggRenderMode(PyObject *self) {
  EggRenderMode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggRenderMode, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     EggRenderMode
//////////////////
static PyObject *Dtool_RichCompare_EggRenderMode(PyObject *self, PyObject *arg, int op) {
  EggRenderMode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggRenderMode, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-bool EggRenderMode::operator ==(EggRenderMode const &other) const
      EggRenderMode const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_EggRenderMode);
      if (arg_this != nullptr) {
        bool return_value = ((*(const EggRenderMode*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool EggRenderMode::operator !=(EggRenderMode const &other) const
      EggRenderMode const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_EggRenderMode);
      if (arg_this != nullptr) {
        bool return_value = ((*(const EggRenderMode*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-bool EggRenderMode::operator <(EggRenderMode const &other) const
      EggRenderMode const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_EggRenderMode);
      if (arg_this != nullptr) {
        bool return_value = ((*(const EggRenderMode*)local_this).operator <)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_EggRenderMode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_EggRenderMode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggRenderMode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggRenderMode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &DtoolInstance_ComparePointers,
#endif
    nullptr,
    &Dtool_NumberMethods_EggRenderMode,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Str_EggRenderMode,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class stores miscellaneous rendering properties that is associated\n"
    " * with geometry, and which may be set on the geometry primitive level, on the\n"
    " * group above it, or indirectly via a texture.  It's intended to be a base\n"
    " * class for egg objects that can have these properties set.\n"
    " *\n"
    " * This class cannot inherit from EggObject, because it causes problems at the\n"
    " * EggPolygon level with multiple appearances of the EggObject base class.\n"
    " * And making EggObject a virtual base class is just no fun.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_EggRenderMode,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggRenderMode,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggRenderMode,
    PyType_GenericAlloc,
    Dtool_new_EggRenderMode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggRenderMode,
  Dtool_UpcastInterface_EggRenderMode,
  Dtool_DowncastInterface_EggRenderMode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggRenderMode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_EggRenderMode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(39);
    Dtool_EggRenderMode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum EggRenderMode::AlphaMode;
    PyDict_SetItemString(dict, "AM_unspecified", Dtool_WrapValue(EggRenderMode::AM_unspecified));
    PyDict_SetItemString(dict, "AMUnspecified", Dtool_WrapValue(EggRenderMode::AM_unspecified));
    PyDict_SetItemString(dict, "AM_off", Dtool_WrapValue(EggRenderMode::AM_off));
    PyDict_SetItemString(dict, "AMOff", Dtool_WrapValue(EggRenderMode::AM_off));
    PyDict_SetItemString(dict, "AM_on", Dtool_WrapValue(EggRenderMode::AM_on));
    PyDict_SetItemString(dict, "AMOn", Dtool_WrapValue(EggRenderMode::AM_on));
    PyDict_SetItemString(dict, "AM_blend", Dtool_WrapValue(EggRenderMode::AM_blend));
    PyDict_SetItemString(dict, "AMBlend", Dtool_WrapValue(EggRenderMode::AM_blend));
    PyDict_SetItemString(dict, "AM_blend_no_occlude", Dtool_WrapValue(EggRenderMode::AM_blend_no_occlude));
    PyDict_SetItemString(dict, "AMBlendNoOcclude", Dtool_WrapValue(EggRenderMode::AM_blend_no_occlude));
    PyDict_SetItemString(dict, "AM_ms", Dtool_WrapValue(EggRenderMode::AM_ms));
    PyDict_SetItemString(dict, "AMMs", Dtool_WrapValue(EggRenderMode::AM_ms));
    PyDict_SetItemString(dict, "AM_ms_mask", Dtool_WrapValue(EggRenderMode::AM_ms_mask));
    PyDict_SetItemString(dict, "AMMsMask", Dtool_WrapValue(EggRenderMode::AM_ms_mask));
    PyDict_SetItemString(dict, "AM_binary", Dtool_WrapValue(EggRenderMode::AM_binary));
    PyDict_SetItemString(dict, "AMBinary", Dtool_WrapValue(EggRenderMode::AM_binary));
    PyDict_SetItemString(dict, "AM_dual", Dtool_WrapValue(EggRenderMode::AM_dual));
    PyDict_SetItemString(dict, "AMDual", Dtool_WrapValue(EggRenderMode::AM_dual));
    PyDict_SetItemString(dict, "AM_premultiplied", Dtool_WrapValue(EggRenderMode::AM_premultiplied));
    PyDict_SetItemString(dict, "AMPremultiplied", Dtool_WrapValue(EggRenderMode::AM_premultiplied));
    // enum EggRenderMode::DepthWriteMode;
    PyDict_SetItemString(dict, "DWM_unspecified", Dtool_WrapValue(EggRenderMode::DWM_unspecified));
    PyDict_SetItemString(dict, "DWMUnspecified", Dtool_WrapValue(EggRenderMode::DWM_unspecified));
    PyDict_SetItemString(dict, "DWM_off", Dtool_WrapValue(EggRenderMode::DWM_off));
    PyDict_SetItemString(dict, "DWMOff", Dtool_WrapValue(EggRenderMode::DWM_off));
    PyDict_SetItemString(dict, "DWM_on", Dtool_WrapValue(EggRenderMode::DWM_on));
    PyDict_SetItemString(dict, "DWMOn", Dtool_WrapValue(EggRenderMode::DWM_on));
    // enum EggRenderMode::DepthTestMode;
    PyDict_SetItemString(dict, "DTM_unspecified", Dtool_WrapValue(EggRenderMode::DTM_unspecified));
    PyDict_SetItemString(dict, "DTMUnspecified", Dtool_WrapValue(EggRenderMode::DTM_unspecified));
    PyDict_SetItemString(dict, "DTM_off", Dtool_WrapValue(EggRenderMode::DTM_off));
    PyDict_SetItemString(dict, "DTMOff", Dtool_WrapValue(EggRenderMode::DTM_off));
    PyDict_SetItemString(dict, "DTM_on", Dtool_WrapValue(EggRenderMode::DTM_on));
    PyDict_SetItemString(dict, "DTMOn", Dtool_WrapValue(EggRenderMode::DTM_on));
    // enum EggRenderMode::VisibilityMode;
    PyDict_SetItemString(dict, "VM_unspecified", Dtool_WrapValue(EggRenderMode::VM_unspecified));
    PyDict_SetItemString(dict, "VMUnspecified", Dtool_WrapValue(EggRenderMode::VM_unspecified));
    PyDict_SetItemString(dict, "VM_hidden", Dtool_WrapValue(EggRenderMode::VM_hidden));
    PyDict_SetItemString(dict, "VMHidden", Dtool_WrapValue(EggRenderMode::VM_hidden));
    PyDict_SetItemString(dict, "VM_normal", Dtool_WrapValue(EggRenderMode::VM_normal));
    PyDict_SetItemString(dict, "VMNormal", Dtool_WrapValue(EggRenderMode::VM_normal));
    if (PyType_Ready((PyTypeObject *)&Dtool_EggRenderMode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggRenderMode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggRenderMode);
  }
}

/**
 * Python method tables for EggTransform (EggTransform)
 */
static PyMethodDef Dtool_Methods_EggTransform[] = {
  {"assign", &Dtool_EggTransform_operator_338, METH_O, (const char *)Dtool_EggTransform_operator_338_comment},
  {"clear_transform", &Dtool_EggTransform_clear_transform_340, METH_NOARGS, (const char *)Dtool_EggTransform_clear_transform_340_comment},
  {"clearTransform", &Dtool_EggTransform_clear_transform_340, METH_NOARGS, (const char *)Dtool_EggTransform_clear_transform_340_comment},
  {"add_translate2d", &Dtool_EggTransform_add_translate2d_341, METH_O, (const char *)Dtool_EggTransform_add_translate2d_341_comment},
  {"addTranslate2d", &Dtool_EggTransform_add_translate2d_341, METH_O, (const char *)Dtool_EggTransform_add_translate2d_341_comment},
  {"add_translate3d", &Dtool_EggTransform_add_translate3d_342, METH_O, (const char *)Dtool_EggTransform_add_translate3d_342_comment},
  {"addTranslate3d", &Dtool_EggTransform_add_translate3d_342, METH_O, (const char *)Dtool_EggTransform_add_translate3d_342_comment},
  {"add_rotate2d", &Dtool_EggTransform_add_rotate2d_343, METH_O, (const char *)Dtool_EggTransform_add_rotate2d_343_comment},
  {"addRotate2d", &Dtool_EggTransform_add_rotate2d_343, METH_O, (const char *)Dtool_EggTransform_add_rotate2d_343_comment},
  {"add_rotx", &Dtool_EggTransform_add_rotx_344, METH_O, (const char *)Dtool_EggTransform_add_rotx_344_comment},
  {"addRotx", &Dtool_EggTransform_add_rotx_344, METH_O, (const char *)Dtool_EggTransform_add_rotx_344_comment},
  {"add_roty", &Dtool_EggTransform_add_roty_345, METH_O, (const char *)Dtool_EggTransform_add_roty_345_comment},
  {"addRoty", &Dtool_EggTransform_add_roty_345, METH_O, (const char *)Dtool_EggTransform_add_roty_345_comment},
  {"add_rotz", &Dtool_EggTransform_add_rotz_346, METH_O, (const char *)Dtool_EggTransform_add_rotz_346_comment},
  {"addRotz", &Dtool_EggTransform_add_rotz_346, METH_O, (const char *)Dtool_EggTransform_add_rotz_346_comment},
  {"add_rotate3d", (PyCFunction) &Dtool_EggTransform_add_rotate3d_347, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTransform_add_rotate3d_347_comment},
  {"addRotate3d", (PyCFunction) &Dtool_EggTransform_add_rotate3d_347, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTransform_add_rotate3d_347_comment},
  {"add_scale2d", &Dtool_EggTransform_add_scale2d_348, METH_O, (const char *)Dtool_EggTransform_add_scale2d_348_comment},
  {"addScale2d", &Dtool_EggTransform_add_scale2d_348, METH_O, (const char *)Dtool_EggTransform_add_scale2d_348_comment},
  {"add_scale3d", &Dtool_EggTransform_add_scale3d_349, METH_O, (const char *)Dtool_EggTransform_add_scale3d_349_comment},
  {"addScale3d", &Dtool_EggTransform_add_scale3d_349, METH_O, (const char *)Dtool_EggTransform_add_scale3d_349_comment},
  {"add_uniform_scale", &Dtool_EggTransform_add_uniform_scale_350, METH_O, (const char *)Dtool_EggTransform_add_uniform_scale_350_comment},
  {"addUniformScale", &Dtool_EggTransform_add_uniform_scale_350, METH_O, (const char *)Dtool_EggTransform_add_uniform_scale_350_comment},
  {"add_matrix3", &Dtool_EggTransform_add_matrix3_351, METH_O, (const char *)Dtool_EggTransform_add_matrix3_351_comment},
  {"addMatrix3", &Dtool_EggTransform_add_matrix3_351, METH_O, (const char *)Dtool_EggTransform_add_matrix3_351_comment},
  {"add_matrix4", &Dtool_EggTransform_add_matrix4_352, METH_O, (const char *)Dtool_EggTransform_add_matrix4_352_comment},
  {"addMatrix4", &Dtool_EggTransform_add_matrix4_352, METH_O, (const char *)Dtool_EggTransform_add_matrix4_352_comment},
  {"has_transform", &Dtool_EggTransform_has_transform_353, METH_NOARGS, (const char *)Dtool_EggTransform_has_transform_353_comment},
  {"hasTransform", &Dtool_EggTransform_has_transform_353, METH_NOARGS, (const char *)Dtool_EggTransform_has_transform_353_comment},
  {"has_transform2d", &Dtool_EggTransform_has_transform2d_354, METH_NOARGS, (const char *)Dtool_EggTransform_has_transform2d_354_comment},
  {"hasTransform2d", &Dtool_EggTransform_has_transform2d_354, METH_NOARGS, (const char *)Dtool_EggTransform_has_transform2d_354_comment},
  {"set_transform2d", &Dtool_EggTransform_set_transform2d_355, METH_O, (const char *)Dtool_EggTransform_set_transform2d_355_comment},
  {"setTransform2d", &Dtool_EggTransform_set_transform2d_355, METH_O, (const char *)Dtool_EggTransform_set_transform2d_355_comment},
  {"has_transform3d", &Dtool_EggTransform_has_transform3d_356, METH_NOARGS, (const char *)Dtool_EggTransform_has_transform3d_356_comment},
  {"hasTransform3d", &Dtool_EggTransform_has_transform3d_356, METH_NOARGS, (const char *)Dtool_EggTransform_has_transform3d_356_comment},
  {"set_transform3d", &Dtool_EggTransform_set_transform3d_357, METH_O, (const char *)Dtool_EggTransform_set_transform3d_357_comment},
  {"setTransform3d", &Dtool_EggTransform_set_transform3d_357, METH_O, (const char *)Dtool_EggTransform_set_transform3d_357_comment},
  {"get_transform2d", &Dtool_EggTransform_get_transform2d_358, METH_NOARGS, (const char *)Dtool_EggTransform_get_transform2d_358_comment},
  {"getTransform2d", &Dtool_EggTransform_get_transform2d_358, METH_NOARGS, (const char *)Dtool_EggTransform_get_transform2d_358_comment},
  {"get_transform3d", &Dtool_EggTransform_get_transform3d_359, METH_NOARGS, (const char *)Dtool_EggTransform_get_transform3d_359_comment},
  {"getTransform3d", &Dtool_EggTransform_get_transform3d_359, METH_NOARGS, (const char *)Dtool_EggTransform_get_transform3d_359_comment},
  {"transform_is_identity", &Dtool_EggTransform_transform_is_identity_360, METH_NOARGS, (const char *)Dtool_EggTransform_transform_is_identity_360_comment},
  {"transformIsIdentity", &Dtool_EggTransform_transform_is_identity_360, METH_NOARGS, (const char *)Dtool_EggTransform_transform_is_identity_360_comment},
  {"get_num_components", &Dtool_EggTransform_get_num_components_362, METH_NOARGS, (const char *)Dtool_EggTransform_get_num_components_362_comment},
  {"getNumComponents", &Dtool_EggTransform_get_num_components_362, METH_NOARGS, (const char *)Dtool_EggTransform_get_num_components_362_comment},
  {"get_component_type", &Dtool_EggTransform_get_component_type_363, METH_O, (const char *)Dtool_EggTransform_get_component_type_363_comment},
  {"getComponentType", &Dtool_EggTransform_get_component_type_363, METH_O, (const char *)Dtool_EggTransform_get_component_type_363_comment},
  {"get_component_number", &Dtool_EggTransform_get_component_number_364, METH_O, (const char *)Dtool_EggTransform_get_component_number_364_comment},
  {"getComponentNumber", &Dtool_EggTransform_get_component_number_364, METH_O, (const char *)Dtool_EggTransform_get_component_number_364_comment},
  {"get_component_vec2", &Dtool_EggTransform_get_component_vec2_365, METH_O, (const char *)Dtool_EggTransform_get_component_vec2_365_comment},
  {"getComponentVec2", &Dtool_EggTransform_get_component_vec2_365, METH_O, (const char *)Dtool_EggTransform_get_component_vec2_365_comment},
  {"get_component_vec3", &Dtool_EggTransform_get_component_vec3_366, METH_O, (const char *)Dtool_EggTransform_get_component_vec3_366_comment},
  {"getComponentVec3", &Dtool_EggTransform_get_component_vec3_366, METH_O, (const char *)Dtool_EggTransform_get_component_vec3_366_comment},
  {"get_component_mat3", &Dtool_EggTransform_get_component_mat3_367, METH_O, (const char *)Dtool_EggTransform_get_component_mat3_367_comment},
  {"getComponentMat3", &Dtool_EggTransform_get_component_mat3_367, METH_O, (const char *)Dtool_EggTransform_get_component_mat3_367_comment},
  {"get_component_mat4", &Dtool_EggTransform_get_component_mat4_368, METH_O, (const char *)Dtool_EggTransform_get_component_mat4_368_comment},
  {"getComponentMat4", &Dtool_EggTransform_get_component_mat4_368, METH_O, (const char *)Dtool_EggTransform_get_component_mat4_368_comment},
  {"write", (PyCFunction) &Dtool_EggTransform_write_369, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTransform_write_369_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EggTransform = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_EggTransform = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggTransform",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggTransform,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggTransform,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This represents the <Transform> entry of a group or texture node: a list of\n"
    " * component transform operations, applied in order, that describe a net\n"
    " * transform matrix.\n"
    " *\n"
    " * This may be either a 3-d transform, and therefore described by a 4x4\n"
    " * matrix, or a 2-d transform, described by a 3x3 matrix.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggTransform,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggTransform,
    PyType_GenericAlloc,
    Dtool_new_EggTransform,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggTransform,
  Dtool_UpcastInterface_EggTransform,
  Dtool_DowncastInterface_EggTransform,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggTransform(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_EggTransform._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(27);
    Dtool_EggTransform._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum EggTransform::ComponentType;
    PyDict_SetItemString(dict, "CT_invalid", Dtool_WrapValue(EggTransform::CT_invalid));
    PyDict_SetItemString(dict, "CTInvalid", Dtool_WrapValue(EggTransform::CT_invalid));
    PyDict_SetItemString(dict, "CT_translate2d", Dtool_WrapValue(EggTransform::CT_translate2d));
    PyDict_SetItemString(dict, "CTTranslate2d", Dtool_WrapValue(EggTransform::CT_translate2d));
    PyDict_SetItemString(dict, "CT_translate3d", Dtool_WrapValue(EggTransform::CT_translate3d));
    PyDict_SetItemString(dict, "CTTranslate3d", Dtool_WrapValue(EggTransform::CT_translate3d));
    PyDict_SetItemString(dict, "CT_rotate2d", Dtool_WrapValue(EggTransform::CT_rotate2d));
    PyDict_SetItemString(dict, "CTRotate2d", Dtool_WrapValue(EggTransform::CT_rotate2d));
    PyDict_SetItemString(dict, "CT_rotx", Dtool_WrapValue(EggTransform::CT_rotx));
    PyDict_SetItemString(dict, "CTRotx", Dtool_WrapValue(EggTransform::CT_rotx));
    PyDict_SetItemString(dict, "CT_roty", Dtool_WrapValue(EggTransform::CT_roty));
    PyDict_SetItemString(dict, "CTRoty", Dtool_WrapValue(EggTransform::CT_roty));
    PyDict_SetItemString(dict, "CT_rotz", Dtool_WrapValue(EggTransform::CT_rotz));
    PyDict_SetItemString(dict, "CTRotz", Dtool_WrapValue(EggTransform::CT_rotz));
    PyDict_SetItemString(dict, "CT_rotate3d", Dtool_WrapValue(EggTransform::CT_rotate3d));
    PyDict_SetItemString(dict, "CTRotate3d", Dtool_WrapValue(EggTransform::CT_rotate3d));
    PyDict_SetItemString(dict, "CT_scale2d", Dtool_WrapValue(EggTransform::CT_scale2d));
    PyDict_SetItemString(dict, "CTScale2d", Dtool_WrapValue(EggTransform::CT_scale2d));
    PyDict_SetItemString(dict, "CT_scale3d", Dtool_WrapValue(EggTransform::CT_scale3d));
    PyDict_SetItemString(dict, "CTScale3d", Dtool_WrapValue(EggTransform::CT_scale3d));
    PyDict_SetItemString(dict, "CT_uniform_scale", Dtool_WrapValue(EggTransform::CT_uniform_scale));
    PyDict_SetItemString(dict, "CTUniformScale", Dtool_WrapValue(EggTransform::CT_uniform_scale));
    PyDict_SetItemString(dict, "CT_matrix3", Dtool_WrapValue(EggTransform::CT_matrix3));
    PyDict_SetItemString(dict, "CTMatrix3", Dtool_WrapValue(EggTransform::CT_matrix3));
    PyDict_SetItemString(dict, "CT_matrix4", Dtool_WrapValue(EggTransform::CT_matrix4));
    PyDict_SetItemString(dict, "CTMatrix4", Dtool_WrapValue(EggTransform::CT_matrix4));
    if (PyType_Ready((PyTypeObject *)&Dtool_EggTransform) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggTransform)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggTransform);
  }
}

/**
 * Python method tables for EggSwitchCondition (EggSwitchCondition)
 */
static PyMethodDef Dtool_Methods_EggSwitchCondition[] = {
  {"make_copy", &Dtool_EggSwitchCondition_make_copy_371, METH_NOARGS, (const char *)Dtool_EggSwitchCondition_make_copy_371_comment},
  {"makeCopy", &Dtool_EggSwitchCondition_make_copy_371, METH_NOARGS, (const char *)Dtool_EggSwitchCondition_make_copy_371_comment},
  {"write", (PyCFunction) &Dtool_EggSwitchCondition_write_372, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggSwitchCondition_write_372_comment},
  {"transform", &Dtool_EggSwitchCondition_transform_373, METH_O, (const char *)Dtool_EggSwitchCondition_transform_373_comment},
  {"get_class_type", &Dtool_EggSwitchCondition_get_class_type_374, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggSwitchCondition_get_class_type_374_comment},
  {"getClassType", &Dtool_EggSwitchCondition_get_class_type_374, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggSwitchCondition_get_class_type_374_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     EggSwitchCondition
//////////////////
static PyObject *Dtool_Str_EggSwitchCondition(PyObject *self) {
  EggSwitchCondition *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggSwitchCondition, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_EggSwitchCondition = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggSwitchCondition = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggSwitchCondition = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggSwitchCondition = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggSwitchCondition = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggSwitchCondition = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggSwitchCondition",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggSwitchCondition,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggSwitchCondition,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggSwitchCondition,
    &Dtool_SequenceMethods_EggSwitchCondition,
    &Dtool_MappingMethods_EggSwitchCondition,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_EggSwitchCondition,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggSwitchCondition,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This corresponds to a <SwitchCondition> entry within a group.  It indicates\n"
    " * the condition at which a level-of-detail is switched in or out.  This is\n"
    " * actually an abstract base class for potentially any number of specific\n"
    " * different kinds of switching conditions; presently, only a <Distance> type\n"
    " * is actually supported.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggSwitchCondition,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggSwitchCondition,
    PyType_GenericAlloc,
    Dtool_new_EggSwitchCondition,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggSwitchCondition,
  Dtool_UpcastInterface_EggSwitchCondition,
  Dtool_DowncastInterface_EggSwitchCondition,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggSwitchCondition(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggObject(nullptr);
    Dtool_EggSwitchCondition._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggObject);
    Dtool_EggSwitchCondition._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggSwitchCondition._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggSwitchCondition) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggSwitchCondition)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggSwitchCondition);
  }
}

/**
 * Python method tables for EggSwitchConditionDistance (EggSwitchConditionDistance)
 */
static PyMethodDef Dtool_Methods_EggSwitchConditionDistance[] = {
  {"get_class_type", &Dtool_EggSwitchConditionDistance_get_class_type_378, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggSwitchConditionDistance_get_class_type_378_comment},
  {"getClassType", &Dtool_EggSwitchConditionDistance_get_class_type_378, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggSwitchConditionDistance_get_class_type_378_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EggSwitchConditionDistance = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggSwitchConditionDistance = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggSwitchConditionDistance = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggSwitchConditionDistance = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggSwitchConditionDistance = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggSwitchConditionDistance = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggSwitchConditionDistance",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggSwitchConditionDistance,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggSwitchConditionDistance,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggSwitchConditionDistance,
    &Dtool_SequenceMethods_EggSwitchConditionDistance,
    &Dtool_MappingMethods_EggSwitchConditionDistance,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggSwitchConditionDistance,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A SwitchCondition that switches the levels-of-detail based on distance from\n"
    " * the camera's eyepoint.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggSwitchConditionDistance,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggSwitchConditionDistance,
    PyType_GenericAlloc,
    Dtool_new_EggSwitchConditionDistance,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggSwitchConditionDistance,
  Dtool_UpcastInterface_EggSwitchConditionDistance,
  Dtool_DowncastInterface_EggSwitchConditionDistance,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggSwitchConditionDistance(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggSwitchCondition(nullptr);
    Dtool_EggSwitchConditionDistance._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggSwitchCondition);
    Dtool_EggSwitchConditionDistance._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggSwitchConditionDistance._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggSwitchConditionDistance) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggSwitchConditionDistance)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggSwitchConditionDistance);
  }
}

/**
 * Python method tables for EggGroup (EggGroup)
 */
static PyMethodDef Dtool_Methods_EggGroup[] = {
  {"assign", &Dtool_EggGroup_operator_400, METH_O, (const char *)Dtool_EggGroup_operator_400_comment},
  {"write", (PyCFunction) &Dtool_EggGroup_write_402, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_402_comment},
  {"write_billboard_flags", (PyCFunction) &Dtool_EggGroup_write_billboard_flags_403, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_billboard_flags_403_comment},
  {"writeBillboardFlags", (PyCFunction) &Dtool_EggGroup_write_billboard_flags_403, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_billboard_flags_403_comment},
  {"write_collide_flags", (PyCFunction) &Dtool_EggGroup_write_collide_flags_404, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_collide_flags_404_comment},
  {"writeCollideFlags", (PyCFunction) &Dtool_EggGroup_write_collide_flags_404, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_collide_flags_404_comment},
  {"write_model_flags", (PyCFunction) &Dtool_EggGroup_write_model_flags_405, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_model_flags_405_comment},
  {"writeModelFlags", (PyCFunction) &Dtool_EggGroup_write_model_flags_405, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_model_flags_405_comment},
  {"write_switch_flags", (PyCFunction) &Dtool_EggGroup_write_switch_flags_406, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_switch_flags_406_comment},
  {"writeSwitchFlags", (PyCFunction) &Dtool_EggGroup_write_switch_flags_406, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_switch_flags_406_comment},
  {"write_object_types", (PyCFunction) &Dtool_EggGroup_write_object_types_407, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_object_types_407_comment},
  {"writeObjectTypes", (PyCFunction) &Dtool_EggGroup_write_object_types_407, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_object_types_407_comment},
  {"write_decal_flags", (PyCFunction) &Dtool_EggGroup_write_decal_flags_408, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_decal_flags_408_comment},
  {"writeDecalFlags", (PyCFunction) &Dtool_EggGroup_write_decal_flags_408, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_decal_flags_408_comment},
  {"write_tags", (PyCFunction) &Dtool_EggGroup_write_tags_409, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_tags_409_comment},
  {"writeTags", (PyCFunction) &Dtool_EggGroup_write_tags_409, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_tags_409_comment},
  {"write_render_mode", (PyCFunction) &Dtool_EggGroup_write_render_mode_410, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_render_mode_410_comment},
  {"writeRenderMode", (PyCFunction) &Dtool_EggGroup_write_render_mode_410, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_write_render_mode_410_comment},
  {"is_joint", &Dtool_EggGroup_is_joint_411, METH_NOARGS, (const char *)Dtool_EggGroup_is_joint_411_comment},
  {"isJoint", &Dtool_EggGroup_is_joint_411, METH_NOARGS, (const char *)Dtool_EggGroup_is_joint_411_comment},
  {"determine_alpha_mode", &Dtool_EggGroup_determine_alpha_mode_412, METH_NOARGS, (const char *)Dtool_EggGroup_determine_alpha_mode_412_comment},
  {"determineAlphaMode", &Dtool_EggGroup_determine_alpha_mode_412, METH_NOARGS, (const char *)Dtool_EggGroup_determine_alpha_mode_412_comment},
  {"determine_depth_write_mode", &Dtool_EggGroup_determine_depth_write_mode_413, METH_NOARGS, (const char *)Dtool_EggGroup_determine_depth_write_mode_413_comment},
  {"determineDepthWriteMode", &Dtool_EggGroup_determine_depth_write_mode_413, METH_NOARGS, (const char *)Dtool_EggGroup_determine_depth_write_mode_413_comment},
  {"determine_depth_test_mode", &Dtool_EggGroup_determine_depth_test_mode_414, METH_NOARGS, (const char *)Dtool_EggGroup_determine_depth_test_mode_414_comment},
  {"determineDepthTestMode", &Dtool_EggGroup_determine_depth_test_mode_414, METH_NOARGS, (const char *)Dtool_EggGroup_determine_depth_test_mode_414_comment},
  {"determine_visibility_mode", &Dtool_EggGroup_determine_visibility_mode_415, METH_NOARGS, (const char *)Dtool_EggGroup_determine_visibility_mode_415_comment},
  {"determineVisibilityMode", &Dtool_EggGroup_determine_visibility_mode_415, METH_NOARGS, (const char *)Dtool_EggGroup_determine_visibility_mode_415_comment},
  {"determine_depth_offset", &Dtool_EggGroup_determine_depth_offset_416, METH_NOARGS, (const char *)Dtool_EggGroup_determine_depth_offset_416_comment},
  {"determineDepthOffset", &Dtool_EggGroup_determine_depth_offset_416, METH_NOARGS, (const char *)Dtool_EggGroup_determine_depth_offset_416_comment},
  {"determine_draw_order", &Dtool_EggGroup_determine_draw_order_417, METH_NOARGS, (const char *)Dtool_EggGroup_determine_draw_order_417_comment},
  {"determineDrawOrder", &Dtool_EggGroup_determine_draw_order_417, METH_NOARGS, (const char *)Dtool_EggGroup_determine_draw_order_417_comment},
  {"determine_bin", &Dtool_EggGroup_determine_bin_418, METH_NOARGS, (const char *)Dtool_EggGroup_determine_bin_418_comment},
  {"determineBin", &Dtool_EggGroup_determine_bin_418, METH_NOARGS, (const char *)Dtool_EggGroup_determine_bin_418_comment},
  {"determine_indexed", &Dtool_EggGroup_determine_indexed_419, METH_NOARGS, (const char *)Dtool_EggGroup_determine_indexed_419_comment},
  {"determineIndexed", &Dtool_EggGroup_determine_indexed_419, METH_NOARGS, (const char *)Dtool_EggGroup_determine_indexed_419_comment},
  {"determine_decal", &Dtool_EggGroup_determine_decal_420, METH_NOARGS, (const char *)Dtool_EggGroup_determine_decal_420_comment},
  {"determineDecal", &Dtool_EggGroup_determine_decal_420, METH_NOARGS, (const char *)Dtool_EggGroup_determine_decal_420_comment},
  {"set_group_type", &Dtool_EggGroup_set_group_type_421, METH_O, (const char *)Dtool_EggGroup_set_group_type_421_comment},
  {"setGroupType", &Dtool_EggGroup_set_group_type_421, METH_O, (const char *)Dtool_EggGroup_set_group_type_421_comment},
  {"get_group_type", &Dtool_EggGroup_get_group_type_422, METH_NOARGS, (const char *)Dtool_EggGroup_get_group_type_422_comment},
  {"getGroupType", &Dtool_EggGroup_get_group_type_422, METH_NOARGS, (const char *)Dtool_EggGroup_get_group_type_422_comment},
  {"is_instance_type", &Dtool_EggGroup_is_instance_type_423, METH_NOARGS, (const char *)Dtool_EggGroup_is_instance_type_423_comment},
  {"isInstanceType", &Dtool_EggGroup_is_instance_type_423, METH_NOARGS, (const char *)Dtool_EggGroup_is_instance_type_423_comment},
  {"set_billboard_type", &Dtool_EggGroup_set_billboard_type_424, METH_O, (const char *)Dtool_EggGroup_set_billboard_type_424_comment},
  {"setBillboardType", &Dtool_EggGroup_set_billboard_type_424, METH_O, (const char *)Dtool_EggGroup_set_billboard_type_424_comment},
  {"get_billboard_type", &Dtool_EggGroup_get_billboard_type_425, METH_NOARGS, (const char *)Dtool_EggGroup_get_billboard_type_425_comment},
  {"getBillboardType", &Dtool_EggGroup_get_billboard_type_425, METH_NOARGS, (const char *)Dtool_EggGroup_get_billboard_type_425_comment},
  {"set_billboard_center", &Dtool_EggGroup_set_billboard_center_426, METH_O, (const char *)Dtool_EggGroup_set_billboard_center_426_comment},
  {"setBillboardCenter", &Dtool_EggGroup_set_billboard_center_426, METH_O, (const char *)Dtool_EggGroup_set_billboard_center_426_comment},
  {"clear_billboard_center", &Dtool_EggGroup_clear_billboard_center_427, METH_NOARGS, (const char *)Dtool_EggGroup_clear_billboard_center_427_comment},
  {"clearBillboardCenter", &Dtool_EggGroup_clear_billboard_center_427, METH_NOARGS, (const char *)Dtool_EggGroup_clear_billboard_center_427_comment},
  {"has_billboard_center", &Dtool_EggGroup_has_billboard_center_428, METH_NOARGS, (const char *)Dtool_EggGroup_has_billboard_center_428_comment},
  {"hasBillboardCenter", &Dtool_EggGroup_has_billboard_center_428, METH_NOARGS, (const char *)Dtool_EggGroup_has_billboard_center_428_comment},
  {"get_billboard_center", &Dtool_EggGroup_get_billboard_center_429, METH_NOARGS, (const char *)Dtool_EggGroup_get_billboard_center_429_comment},
  {"getBillboardCenter", &Dtool_EggGroup_get_billboard_center_429, METH_NOARGS, (const char *)Dtool_EggGroup_get_billboard_center_429_comment},
  {"set_cs_type", &Dtool_EggGroup_set_cs_type_430, METH_O, (const char *)Dtool_EggGroup_set_cs_type_430_comment},
  {"setCsType", &Dtool_EggGroup_set_cs_type_430, METH_O, (const char *)Dtool_EggGroup_set_cs_type_430_comment},
  {"get_cs_type", &Dtool_EggGroup_get_cs_type_431, METH_NOARGS, (const char *)Dtool_EggGroup_get_cs_type_431_comment},
  {"getCsType", &Dtool_EggGroup_get_cs_type_431, METH_NOARGS, (const char *)Dtool_EggGroup_get_cs_type_431_comment},
  {"set_collide_flags", &Dtool_EggGroup_set_collide_flags_432, METH_O, (const char *)Dtool_EggGroup_set_collide_flags_432_comment},
  {"setCollideFlags", &Dtool_EggGroup_set_collide_flags_432, METH_O, (const char *)Dtool_EggGroup_set_collide_flags_432_comment},
  {"get_collide_flags", &Dtool_EggGroup_get_collide_flags_433, METH_NOARGS, (const char *)Dtool_EggGroup_get_collide_flags_433_comment},
  {"getCollideFlags", &Dtool_EggGroup_get_collide_flags_433, METH_NOARGS, (const char *)Dtool_EggGroup_get_collide_flags_433_comment},
  {"set_collision_name", &Dtool_EggGroup_set_collision_name_434, METH_O, (const char *)Dtool_EggGroup_set_collision_name_434_comment},
  {"setCollisionName", &Dtool_EggGroup_set_collision_name_434, METH_O, (const char *)Dtool_EggGroup_set_collision_name_434_comment},
  {"clear_collision_name", &Dtool_EggGroup_clear_collision_name_435, METH_NOARGS, (const char *)Dtool_EggGroup_clear_collision_name_435_comment},
  {"clearCollisionName", &Dtool_EggGroup_clear_collision_name_435, METH_NOARGS, (const char *)Dtool_EggGroup_clear_collision_name_435_comment},
  {"has_collision_name", &Dtool_EggGroup_has_collision_name_436, METH_NOARGS, (const char *)Dtool_EggGroup_has_collision_name_436_comment},
  {"hasCollisionName", &Dtool_EggGroup_has_collision_name_436, METH_NOARGS, (const char *)Dtool_EggGroup_has_collision_name_436_comment},
  {"get_collision_name", &Dtool_EggGroup_get_collision_name_437, METH_NOARGS, (const char *)Dtool_EggGroup_get_collision_name_437_comment},
  {"getCollisionName", &Dtool_EggGroup_get_collision_name_437, METH_NOARGS, (const char *)Dtool_EggGroup_get_collision_name_437_comment},
  {"set_dcs_type", &Dtool_EggGroup_set_dcs_type_438, METH_O, (const char *)Dtool_EggGroup_set_dcs_type_438_comment},
  {"setDcsType", &Dtool_EggGroup_set_dcs_type_438, METH_O, (const char *)Dtool_EggGroup_set_dcs_type_438_comment},
  {"get_dcs_type", &Dtool_EggGroup_get_dcs_type_439, METH_NOARGS, (const char *)Dtool_EggGroup_get_dcs_type_439_comment},
  {"getDcsType", &Dtool_EggGroup_get_dcs_type_439, METH_NOARGS, (const char *)Dtool_EggGroup_get_dcs_type_439_comment},
  {"has_dcs_type", &Dtool_EggGroup_has_dcs_type_440, METH_NOARGS, (const char *)Dtool_EggGroup_has_dcs_type_440_comment},
  {"hasDcsType", &Dtool_EggGroup_has_dcs_type_440, METH_NOARGS, (const char *)Dtool_EggGroup_has_dcs_type_440_comment},
  {"set_dart_type", &Dtool_EggGroup_set_dart_type_441, METH_O, (const char *)Dtool_EggGroup_set_dart_type_441_comment},
  {"setDartType", &Dtool_EggGroup_set_dart_type_441, METH_O, (const char *)Dtool_EggGroup_set_dart_type_441_comment},
  {"get_dart_type", &Dtool_EggGroup_get_dart_type_442, METH_NOARGS, (const char *)Dtool_EggGroup_get_dart_type_442_comment},
  {"getDartType", &Dtool_EggGroup_get_dart_type_442, METH_NOARGS, (const char *)Dtool_EggGroup_get_dart_type_442_comment},
  {"set_switch_flag", &Dtool_EggGroup_set_switch_flag_443, METH_O, (const char *)Dtool_EggGroup_set_switch_flag_443_comment},
  {"setSwitchFlag", &Dtool_EggGroup_set_switch_flag_443, METH_O, (const char *)Dtool_EggGroup_set_switch_flag_443_comment},
  {"get_switch_flag", &Dtool_EggGroup_get_switch_flag_444, METH_NOARGS, (const char *)Dtool_EggGroup_get_switch_flag_444_comment},
  {"getSwitchFlag", &Dtool_EggGroup_get_switch_flag_444, METH_NOARGS, (const char *)Dtool_EggGroup_get_switch_flag_444_comment},
  {"set_switch_fps", &Dtool_EggGroup_set_switch_fps_445, METH_O, (const char *)Dtool_EggGroup_set_switch_fps_445_comment},
  {"setSwitchFps", &Dtool_EggGroup_set_switch_fps_445, METH_O, (const char *)Dtool_EggGroup_set_switch_fps_445_comment},
  {"get_switch_fps", &Dtool_EggGroup_get_switch_fps_446, METH_NOARGS, (const char *)Dtool_EggGroup_get_switch_fps_446_comment},
  {"getSwitchFps", &Dtool_EggGroup_get_switch_fps_446, METH_NOARGS, (const char *)Dtool_EggGroup_get_switch_fps_446_comment},
  {"add_object_type", &Dtool_EggGroup_add_object_type_447, METH_O, (const char *)Dtool_EggGroup_add_object_type_447_comment},
  {"addObjectType", &Dtool_EggGroup_add_object_type_447, METH_O, (const char *)Dtool_EggGroup_add_object_type_447_comment},
  {"clear_object_types", &Dtool_EggGroup_clear_object_types_448, METH_NOARGS, (const char *)Dtool_EggGroup_clear_object_types_448_comment},
  {"clearObjectTypes", &Dtool_EggGroup_clear_object_types_448, METH_NOARGS, (const char *)Dtool_EggGroup_clear_object_types_448_comment},
  {"get_num_object_types", &Dtool_EggGroup_get_num_object_types_449, METH_NOARGS, (const char *)Dtool_EggGroup_get_num_object_types_449_comment},
  {"getNumObjectTypes", &Dtool_EggGroup_get_num_object_types_449, METH_NOARGS, (const char *)Dtool_EggGroup_get_num_object_types_449_comment},
  {"get_object_type", &Dtool_EggGroup_get_object_type_450, METH_O, (const char *)Dtool_EggGroup_get_object_type_450_comment},
  {"getObjectType", &Dtool_EggGroup_get_object_type_450, METH_O, (const char *)Dtool_EggGroup_get_object_type_450_comment},
  {"has_object_type", &Dtool_EggGroup_has_object_type_452, METH_O, (const char *)Dtool_EggGroup_has_object_type_452_comment},
  {"hasObjectType", &Dtool_EggGroup_has_object_type_452, METH_O, (const char *)Dtool_EggGroup_has_object_type_452_comment},
  {"remove_object_type", &Dtool_EggGroup_remove_object_type_453, METH_O, (const char *)Dtool_EggGroup_remove_object_type_453_comment},
  {"removeObjectType", &Dtool_EggGroup_remove_object_type_453, METH_O, (const char *)Dtool_EggGroup_remove_object_type_453_comment},
  {"set_model_flag", &Dtool_EggGroup_set_model_flag_454, METH_O, (const char *)Dtool_EggGroup_set_model_flag_454_comment},
  {"setModelFlag", &Dtool_EggGroup_set_model_flag_454, METH_O, (const char *)Dtool_EggGroup_set_model_flag_454_comment},
  {"get_model_flag", &Dtool_EggGroup_get_model_flag_455, METH_NOARGS, (const char *)Dtool_EggGroup_get_model_flag_455_comment},
  {"getModelFlag", &Dtool_EggGroup_get_model_flag_455, METH_NOARGS, (const char *)Dtool_EggGroup_get_model_flag_455_comment},
  {"set_texlist_flag", &Dtool_EggGroup_set_texlist_flag_456, METH_O, (const char *)Dtool_EggGroup_set_texlist_flag_456_comment},
  {"setTexlistFlag", &Dtool_EggGroup_set_texlist_flag_456, METH_O, (const char *)Dtool_EggGroup_set_texlist_flag_456_comment},
  {"get_texlist_flag", &Dtool_EggGroup_get_texlist_flag_457, METH_NOARGS, (const char *)Dtool_EggGroup_get_texlist_flag_457_comment},
  {"getTexlistFlag", &Dtool_EggGroup_get_texlist_flag_457, METH_NOARGS, (const char *)Dtool_EggGroup_get_texlist_flag_457_comment},
  {"set_nofog_flag", &Dtool_EggGroup_set_nofog_flag_458, METH_O, (const char *)Dtool_EggGroup_set_nofog_flag_458_comment},
  {"setNofogFlag", &Dtool_EggGroup_set_nofog_flag_458, METH_O, (const char *)Dtool_EggGroup_set_nofog_flag_458_comment},
  {"get_nofog_flag", &Dtool_EggGroup_get_nofog_flag_459, METH_NOARGS, (const char *)Dtool_EggGroup_get_nofog_flag_459_comment},
  {"getNofogFlag", &Dtool_EggGroup_get_nofog_flag_459, METH_NOARGS, (const char *)Dtool_EggGroup_get_nofog_flag_459_comment},
  {"set_decal_flag", &Dtool_EggGroup_set_decal_flag_460, METH_O, (const char *)Dtool_EggGroup_set_decal_flag_460_comment},
  {"setDecalFlag", &Dtool_EggGroup_set_decal_flag_460, METH_O, (const char *)Dtool_EggGroup_set_decal_flag_460_comment},
  {"get_decal_flag", &Dtool_EggGroup_get_decal_flag_461, METH_NOARGS, (const char *)Dtool_EggGroup_get_decal_flag_461_comment},
  {"getDecalFlag", &Dtool_EggGroup_get_decal_flag_461, METH_NOARGS, (const char *)Dtool_EggGroup_get_decal_flag_461_comment},
  {"set_direct_flag", &Dtool_EggGroup_set_direct_flag_462, METH_O, (const char *)Dtool_EggGroup_set_direct_flag_462_comment},
  {"setDirectFlag", &Dtool_EggGroup_set_direct_flag_462, METH_O, (const char *)Dtool_EggGroup_set_direct_flag_462_comment},
  {"get_direct_flag", &Dtool_EggGroup_get_direct_flag_463, METH_NOARGS, (const char *)Dtool_EggGroup_get_direct_flag_463_comment},
  {"getDirectFlag", &Dtool_EggGroup_get_direct_flag_463, METH_NOARGS, (const char *)Dtool_EggGroup_get_direct_flag_463_comment},
  {"set_portal_flag", &Dtool_EggGroup_set_portal_flag_464, METH_O, (const char *)Dtool_EggGroup_set_portal_flag_464_comment},
  {"setPortalFlag", &Dtool_EggGroup_set_portal_flag_464, METH_O, (const char *)Dtool_EggGroup_set_portal_flag_464_comment},
  {"get_portal_flag", &Dtool_EggGroup_get_portal_flag_465, METH_NOARGS, (const char *)Dtool_EggGroup_get_portal_flag_465_comment},
  {"getPortalFlag", &Dtool_EggGroup_get_portal_flag_465, METH_NOARGS, (const char *)Dtool_EggGroup_get_portal_flag_465_comment},
  {"set_occluder_flag", &Dtool_EggGroup_set_occluder_flag_466, METH_O, (const char *)Dtool_EggGroup_set_occluder_flag_466_comment},
  {"setOccluderFlag", &Dtool_EggGroup_set_occluder_flag_466, METH_O, (const char *)Dtool_EggGroup_set_occluder_flag_466_comment},
  {"get_occluder_flag", &Dtool_EggGroup_get_occluder_flag_467, METH_NOARGS, (const char *)Dtool_EggGroup_get_occluder_flag_467_comment},
  {"getOccluderFlag", &Dtool_EggGroup_get_occluder_flag_467, METH_NOARGS, (const char *)Dtool_EggGroup_get_occluder_flag_467_comment},
  {"set_polylight_flag", &Dtool_EggGroup_set_polylight_flag_468, METH_O, (const char *)Dtool_EggGroup_set_polylight_flag_468_comment},
  {"setPolylightFlag", &Dtool_EggGroup_set_polylight_flag_468, METH_O, (const char *)Dtool_EggGroup_set_polylight_flag_468_comment},
  {"get_polylight_flag", &Dtool_EggGroup_get_polylight_flag_469, METH_NOARGS, (const char *)Dtool_EggGroup_get_polylight_flag_469_comment},
  {"getPolylightFlag", &Dtool_EggGroup_get_polylight_flag_469, METH_NOARGS, (const char *)Dtool_EggGroup_get_polylight_flag_469_comment},
  {"set_indexed_flag", &Dtool_EggGroup_set_indexed_flag_470, METH_O, (const char *)Dtool_EggGroup_set_indexed_flag_470_comment},
  {"setIndexedFlag", &Dtool_EggGroup_set_indexed_flag_470, METH_O, (const char *)Dtool_EggGroup_set_indexed_flag_470_comment},
  {"clear_indexed_flag", &Dtool_EggGroup_clear_indexed_flag_471, METH_NOARGS, (const char *)Dtool_EggGroup_clear_indexed_flag_471_comment},
  {"clearIndexedFlag", &Dtool_EggGroup_clear_indexed_flag_471, METH_NOARGS, (const char *)Dtool_EggGroup_clear_indexed_flag_471_comment},
  {"has_indexed_flag", &Dtool_EggGroup_has_indexed_flag_472, METH_NOARGS, (const char *)Dtool_EggGroup_has_indexed_flag_472_comment},
  {"hasIndexedFlag", &Dtool_EggGroup_has_indexed_flag_472, METH_NOARGS, (const char *)Dtool_EggGroup_has_indexed_flag_472_comment},
  {"get_indexed_flag", &Dtool_EggGroup_get_indexed_flag_473, METH_NOARGS, (const char *)Dtool_EggGroup_get_indexed_flag_473_comment},
  {"getIndexedFlag", &Dtool_EggGroup_get_indexed_flag_473, METH_NOARGS, (const char *)Dtool_EggGroup_get_indexed_flag_473_comment},
  {"set_collide_mask", &Dtool_EggGroup_set_collide_mask_474, METH_O, (const char *)Dtool_EggGroup_set_collide_mask_474_comment},
  {"setCollideMask", &Dtool_EggGroup_set_collide_mask_474, METH_O, (const char *)Dtool_EggGroup_set_collide_mask_474_comment},
  {"clear_collide_mask", &Dtool_EggGroup_clear_collide_mask_475, METH_NOARGS, (const char *)Dtool_EggGroup_clear_collide_mask_475_comment},
  {"clearCollideMask", &Dtool_EggGroup_clear_collide_mask_475, METH_NOARGS, (const char *)Dtool_EggGroup_clear_collide_mask_475_comment},
  {"has_collide_mask", &Dtool_EggGroup_has_collide_mask_476, METH_NOARGS, (const char *)Dtool_EggGroup_has_collide_mask_476_comment},
  {"hasCollideMask", &Dtool_EggGroup_has_collide_mask_476, METH_NOARGS, (const char *)Dtool_EggGroup_has_collide_mask_476_comment},
  {"get_collide_mask", &Dtool_EggGroup_get_collide_mask_477, METH_NOARGS, (const char *)Dtool_EggGroup_get_collide_mask_477_comment},
  {"getCollideMask", &Dtool_EggGroup_get_collide_mask_477, METH_NOARGS, (const char *)Dtool_EggGroup_get_collide_mask_477_comment},
  {"set_from_collide_mask", &Dtool_EggGroup_set_from_collide_mask_478, METH_O, (const char *)Dtool_EggGroup_set_from_collide_mask_478_comment},
  {"setFromCollideMask", &Dtool_EggGroup_set_from_collide_mask_478, METH_O, (const char *)Dtool_EggGroup_set_from_collide_mask_478_comment},
  {"clear_from_collide_mask", &Dtool_EggGroup_clear_from_collide_mask_479, METH_NOARGS, (const char *)Dtool_EggGroup_clear_from_collide_mask_479_comment},
  {"clearFromCollideMask", &Dtool_EggGroup_clear_from_collide_mask_479, METH_NOARGS, (const char *)Dtool_EggGroup_clear_from_collide_mask_479_comment},
  {"has_from_collide_mask", &Dtool_EggGroup_has_from_collide_mask_480, METH_NOARGS, (const char *)Dtool_EggGroup_has_from_collide_mask_480_comment},
  {"hasFromCollideMask", &Dtool_EggGroup_has_from_collide_mask_480, METH_NOARGS, (const char *)Dtool_EggGroup_has_from_collide_mask_480_comment},
  {"get_from_collide_mask", &Dtool_EggGroup_get_from_collide_mask_481, METH_NOARGS, (const char *)Dtool_EggGroup_get_from_collide_mask_481_comment},
  {"getFromCollideMask", &Dtool_EggGroup_get_from_collide_mask_481, METH_NOARGS, (const char *)Dtool_EggGroup_get_from_collide_mask_481_comment},
  {"set_into_collide_mask", &Dtool_EggGroup_set_into_collide_mask_482, METH_O, (const char *)Dtool_EggGroup_set_into_collide_mask_482_comment},
  {"setIntoCollideMask", &Dtool_EggGroup_set_into_collide_mask_482, METH_O, (const char *)Dtool_EggGroup_set_into_collide_mask_482_comment},
  {"clear_into_collide_mask", &Dtool_EggGroup_clear_into_collide_mask_483, METH_NOARGS, (const char *)Dtool_EggGroup_clear_into_collide_mask_483_comment},
  {"clearIntoCollideMask", &Dtool_EggGroup_clear_into_collide_mask_483, METH_NOARGS, (const char *)Dtool_EggGroup_clear_into_collide_mask_483_comment},
  {"has_into_collide_mask", &Dtool_EggGroup_has_into_collide_mask_484, METH_NOARGS, (const char *)Dtool_EggGroup_has_into_collide_mask_484_comment},
  {"hasIntoCollideMask", &Dtool_EggGroup_has_into_collide_mask_484, METH_NOARGS, (const char *)Dtool_EggGroup_has_into_collide_mask_484_comment},
  {"get_into_collide_mask", &Dtool_EggGroup_get_into_collide_mask_485, METH_NOARGS, (const char *)Dtool_EggGroup_get_into_collide_mask_485_comment},
  {"getIntoCollideMask", &Dtool_EggGroup_get_into_collide_mask_485, METH_NOARGS, (const char *)Dtool_EggGroup_get_into_collide_mask_485_comment},
  {"set_blend_mode", &Dtool_EggGroup_set_blend_mode_486, METH_O, (const char *)Dtool_EggGroup_set_blend_mode_486_comment},
  {"setBlendMode", &Dtool_EggGroup_set_blend_mode_486, METH_O, (const char *)Dtool_EggGroup_set_blend_mode_486_comment},
  {"get_blend_mode", &Dtool_EggGroup_get_blend_mode_487, METH_NOARGS, (const char *)Dtool_EggGroup_get_blend_mode_487_comment},
  {"getBlendMode", &Dtool_EggGroup_get_blend_mode_487, METH_NOARGS, (const char *)Dtool_EggGroup_get_blend_mode_487_comment},
  {"set_blend_operand_a", &Dtool_EggGroup_set_blend_operand_a_488, METH_O, (const char *)Dtool_EggGroup_set_blend_operand_a_488_comment},
  {"setBlendOperandA", &Dtool_EggGroup_set_blend_operand_a_488, METH_O, (const char *)Dtool_EggGroup_set_blend_operand_a_488_comment},
  {"get_blend_operand_a", &Dtool_EggGroup_get_blend_operand_a_489, METH_NOARGS, (const char *)Dtool_EggGroup_get_blend_operand_a_489_comment},
  {"getBlendOperandA", &Dtool_EggGroup_get_blend_operand_a_489, METH_NOARGS, (const char *)Dtool_EggGroup_get_blend_operand_a_489_comment},
  {"set_blend_operand_b", &Dtool_EggGroup_set_blend_operand_b_490, METH_O, (const char *)Dtool_EggGroup_set_blend_operand_b_490_comment},
  {"setBlendOperandB", &Dtool_EggGroup_set_blend_operand_b_490, METH_O, (const char *)Dtool_EggGroup_set_blend_operand_b_490_comment},
  {"get_blend_operand_b", &Dtool_EggGroup_get_blend_operand_b_491, METH_NOARGS, (const char *)Dtool_EggGroup_get_blend_operand_b_491_comment},
  {"getBlendOperandB", &Dtool_EggGroup_get_blend_operand_b_491, METH_NOARGS, (const char *)Dtool_EggGroup_get_blend_operand_b_491_comment},
  {"set_blend_color", &Dtool_EggGroup_set_blend_color_492, METH_O, (const char *)Dtool_EggGroup_set_blend_color_492_comment},
  {"setBlendColor", &Dtool_EggGroup_set_blend_color_492, METH_O, (const char *)Dtool_EggGroup_set_blend_color_492_comment},
  {"clear_blend_color", &Dtool_EggGroup_clear_blend_color_493, METH_NOARGS, (const char *)Dtool_EggGroup_clear_blend_color_493_comment},
  {"clearBlendColor", &Dtool_EggGroup_clear_blend_color_493, METH_NOARGS, (const char *)Dtool_EggGroup_clear_blend_color_493_comment},
  {"has_blend_color", &Dtool_EggGroup_has_blend_color_494, METH_NOARGS, (const char *)Dtool_EggGroup_has_blend_color_494_comment},
  {"hasBlendColor", &Dtool_EggGroup_has_blend_color_494, METH_NOARGS, (const char *)Dtool_EggGroup_has_blend_color_494_comment},
  {"get_blend_color", &Dtool_EggGroup_get_blend_color_495, METH_NOARGS, (const char *)Dtool_EggGroup_get_blend_color_495_comment},
  {"getBlendColor", &Dtool_EggGroup_get_blend_color_495, METH_NOARGS, (const char *)Dtool_EggGroup_get_blend_color_495_comment},
  {"set_lod", &Dtool_EggGroup_set_lod_496, METH_O, (const char *)Dtool_EggGroup_set_lod_496_comment},
  {"setLod", &Dtool_EggGroup_set_lod_496, METH_O, (const char *)Dtool_EggGroup_set_lod_496_comment},
  {"clear_lod", &Dtool_EggGroup_clear_lod_497, METH_NOARGS, (const char *)Dtool_EggGroup_clear_lod_497_comment},
  {"clearLod", &Dtool_EggGroup_clear_lod_497, METH_NOARGS, (const char *)Dtool_EggGroup_clear_lod_497_comment},
  {"has_lod", &Dtool_EggGroup_has_lod_498, METH_NOARGS, (const char *)Dtool_EggGroup_has_lod_498_comment},
  {"hasLod", &Dtool_EggGroup_has_lod_498, METH_NOARGS, (const char *)Dtool_EggGroup_has_lod_498_comment},
  {"get_lod", &Dtool_EggGroup_get_lod_499, METH_NOARGS, (const char *)Dtool_EggGroup_get_lod_499_comment},
  {"getLod", &Dtool_EggGroup_get_lod_499, METH_NOARGS, (const char *)Dtool_EggGroup_get_lod_499_comment},
  {"set_tag", (PyCFunction) &Dtool_EggGroup_set_tag_500, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_set_tag_500_comment},
  {"setTag", (PyCFunction) &Dtool_EggGroup_set_tag_500, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_set_tag_500_comment},
  {"get_tag", &Dtool_EggGroup_get_tag_501, METH_O, (const char *)Dtool_EggGroup_get_tag_501_comment},
  {"getTag", &Dtool_EggGroup_get_tag_501, METH_O, (const char *)Dtool_EggGroup_get_tag_501_comment},
  {"has_tag", &Dtool_EggGroup_has_tag_502, METH_O, (const char *)Dtool_EggGroup_has_tag_502_comment},
  {"hasTag", &Dtool_EggGroup_has_tag_502, METH_O, (const char *)Dtool_EggGroup_has_tag_502_comment},
  {"clear_tag", &Dtool_EggGroup_clear_tag_503, METH_O, (const char *)Dtool_EggGroup_clear_tag_503_comment},
  {"clearTag", &Dtool_EggGroup_clear_tag_503, METH_O, (const char *)Dtool_EggGroup_clear_tag_503_comment},
  {"get_default_pose", &Dtool_EggGroup_get_default_pose_504, METH_NOARGS, (const char *)Dtool_EggGroup_get_default_pose_504_comment},
  {"getDefaultPose", &Dtool_EggGroup_get_default_pose_504, METH_NOARGS, (const char *)Dtool_EggGroup_get_default_pose_504_comment},
  {"modify_default_pose", &Dtool_EggGroup_modify_default_pose_505, METH_NOARGS, (const char *)Dtool_EggGroup_modify_default_pose_505_comment},
  {"modifyDefaultPose", &Dtool_EggGroup_modify_default_pose_505, METH_NOARGS, (const char *)Dtool_EggGroup_modify_default_pose_505_comment},
  {"set_default_pose", &Dtool_EggGroup_set_default_pose_506, METH_O, (const char *)Dtool_EggGroup_set_default_pose_506_comment},
  {"setDefaultPose", &Dtool_EggGroup_set_default_pose_506, METH_O, (const char *)Dtool_EggGroup_set_default_pose_506_comment},
  {"clear_default_pose", &Dtool_EggGroup_clear_default_pose_507, METH_NOARGS, (const char *)Dtool_EggGroup_clear_default_pose_507_comment},
  {"clearDefaultPose", &Dtool_EggGroup_clear_default_pose_507, METH_NOARGS, (const char *)Dtool_EggGroup_clear_default_pose_507_comment},
  {"set_scroll_u", &Dtool_EggGroup_set_scroll_u_508, METH_O, (const char *)Dtool_EggGroup_set_scroll_u_508_comment},
  {"setScrollU", &Dtool_EggGroup_set_scroll_u_508, METH_O, (const char *)Dtool_EggGroup_set_scroll_u_508_comment},
  {"set_scroll_v", &Dtool_EggGroup_set_scroll_v_509, METH_O, (const char *)Dtool_EggGroup_set_scroll_v_509_comment},
  {"setScrollV", &Dtool_EggGroup_set_scroll_v_509, METH_O, (const char *)Dtool_EggGroup_set_scroll_v_509_comment},
  {"set_scroll_w", &Dtool_EggGroup_set_scroll_w_510, METH_O, (const char *)Dtool_EggGroup_set_scroll_w_510_comment},
  {"setScrollW", &Dtool_EggGroup_set_scroll_w_510, METH_O, (const char *)Dtool_EggGroup_set_scroll_w_510_comment},
  {"set_scroll_r", &Dtool_EggGroup_set_scroll_r_511, METH_O, (const char *)Dtool_EggGroup_set_scroll_r_511_comment},
  {"setScrollR", &Dtool_EggGroup_set_scroll_r_511, METH_O, (const char *)Dtool_EggGroup_set_scroll_r_511_comment},
  {"get_scroll_u", &Dtool_EggGroup_get_scroll_u_512, METH_NOARGS, (const char *)Dtool_EggGroup_get_scroll_u_512_comment},
  {"getScrollU", &Dtool_EggGroup_get_scroll_u_512, METH_NOARGS, (const char *)Dtool_EggGroup_get_scroll_u_512_comment},
  {"get_scroll_v", &Dtool_EggGroup_get_scroll_v_513, METH_NOARGS, (const char *)Dtool_EggGroup_get_scroll_v_513_comment},
  {"getScrollV", &Dtool_EggGroup_get_scroll_v_513, METH_NOARGS, (const char *)Dtool_EggGroup_get_scroll_v_513_comment},
  {"get_scroll_w", &Dtool_EggGroup_get_scroll_w_514, METH_NOARGS, (const char *)Dtool_EggGroup_get_scroll_w_514_comment},
  {"getScrollW", &Dtool_EggGroup_get_scroll_w_514, METH_NOARGS, (const char *)Dtool_EggGroup_get_scroll_w_514_comment},
  {"get_scroll_r", &Dtool_EggGroup_get_scroll_r_515, METH_NOARGS, (const char *)Dtool_EggGroup_get_scroll_r_515_comment},
  {"getScrollR", &Dtool_EggGroup_get_scroll_r_515, METH_NOARGS, (const char *)Dtool_EggGroup_get_scroll_r_515_comment},
  {"has_scrolling_uvs", &Dtool_EggGroup_has_scrolling_uvs_516, METH_NOARGS, (const char *)Dtool_EggGroup_has_scrolling_uvs_516_comment},
  {"hasScrollingUvs", &Dtool_EggGroup_has_scrolling_uvs_516, METH_NOARGS, (const char *)Dtool_EggGroup_has_scrolling_uvs_516_comment},
  {"ref_vertex", (PyCFunction) &Dtool_EggGroup_ref_vertex_565, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_ref_vertex_565_comment},
  {"refVertex", (PyCFunction) &Dtool_EggGroup_ref_vertex_565, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_ref_vertex_565_comment},
  {"unref_vertex", &Dtool_EggGroup_unref_vertex_566, METH_O, (const char *)Dtool_EggGroup_unref_vertex_566_comment},
  {"unrefVertex", &Dtool_EggGroup_unref_vertex_566, METH_O, (const char *)Dtool_EggGroup_unref_vertex_566_comment},
  {"unref_all_vertices", &Dtool_EggGroup_unref_all_vertices_567, METH_NOARGS, (const char *)Dtool_EggGroup_unref_all_vertices_567_comment},
  {"unrefAllVertices", &Dtool_EggGroup_unref_all_vertices_567, METH_NOARGS, (const char *)Dtool_EggGroup_unref_all_vertices_567_comment},
  {"get_vertex_membership", &Dtool_EggGroup_get_vertex_membership_568, METH_O, (const char *)Dtool_EggGroup_get_vertex_membership_568_comment},
  {"getVertexMembership", &Dtool_EggGroup_get_vertex_membership_568, METH_O, (const char *)Dtool_EggGroup_get_vertex_membership_568_comment},
  {"set_vertex_membership", (PyCFunction) &Dtool_EggGroup_set_vertex_membership_569, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_set_vertex_membership_569_comment},
  {"setVertexMembership", (PyCFunction) &Dtool_EggGroup_set_vertex_membership_569, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggGroup_set_vertex_membership_569_comment},
  {"steal_vrefs", &Dtool_EggGroup_steal_vrefs_570, METH_O, (const char *)Dtool_EggGroup_steal_vrefs_570_comment},
  {"stealVrefs", &Dtool_EggGroup_steal_vrefs_570, METH_O, (const char *)Dtool_EggGroup_steal_vrefs_570_comment},
  {"test_vref_integrity", &Dtool_EggGroup_test_vref_integrity_571, METH_NOARGS, (const char *)Dtool_EggGroup_test_vref_integrity_571_comment},
  {"testVrefIntegrity", &Dtool_EggGroup_test_vref_integrity_571, METH_NOARGS, (const char *)Dtool_EggGroup_test_vref_integrity_571_comment},
  {"add_group_ref", &Dtool_EggGroup_add_group_ref_572, METH_O, (const char *)Dtool_EggGroup_add_group_ref_572_comment},
  {"addGroupRef", &Dtool_EggGroup_add_group_ref_572, METH_O, (const char *)Dtool_EggGroup_add_group_ref_572_comment},
  {"get_num_group_refs", &Dtool_EggGroup_get_num_group_refs_573, METH_NOARGS, (const char *)Dtool_EggGroup_get_num_group_refs_573_comment},
  {"getNumGroupRefs", &Dtool_EggGroup_get_num_group_refs_573, METH_NOARGS, (const char *)Dtool_EggGroup_get_num_group_refs_573_comment},
  {"get_group_ref", &Dtool_EggGroup_get_group_ref_574, METH_O, (const char *)Dtool_EggGroup_get_group_ref_574_comment},
  {"getGroupRef", &Dtool_EggGroup_get_group_ref_574, METH_O, (const char *)Dtool_EggGroup_get_group_ref_574_comment},
  {"remove_group_ref", &Dtool_EggGroup_remove_group_ref_576, METH_O, (const char *)Dtool_EggGroup_remove_group_ref_576_comment},
  {"removeGroupRef", &Dtool_EggGroup_remove_group_ref_576, METH_O, (const char *)Dtool_EggGroup_remove_group_ref_576_comment},
  {"clear_group_refs", &Dtool_EggGroup_clear_group_refs_577, METH_NOARGS, (const char *)Dtool_EggGroup_clear_group_refs_577_comment},
  {"clearGroupRefs", &Dtool_EggGroup_clear_group_refs_577, METH_NOARGS, (const char *)Dtool_EggGroup_clear_group_refs_577_comment},
  {"string_group_type", &Dtool_EggGroup_string_group_type_578, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_group_type_578_comment},
  {"stringGroupType", &Dtool_EggGroup_string_group_type_578, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_group_type_578_comment},
  {"string_dart_type", &Dtool_EggGroup_string_dart_type_579, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_dart_type_579_comment},
  {"stringDartType", &Dtool_EggGroup_string_dart_type_579, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_dart_type_579_comment},
  {"string_dcs_type", &Dtool_EggGroup_string_dcs_type_580, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_dcs_type_580_comment},
  {"stringDcsType", &Dtool_EggGroup_string_dcs_type_580, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_dcs_type_580_comment},
  {"string_billboard_type", &Dtool_EggGroup_string_billboard_type_581, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_billboard_type_581_comment},
  {"stringBillboardType", &Dtool_EggGroup_string_billboard_type_581, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_billboard_type_581_comment},
  {"string_cs_type", &Dtool_EggGroup_string_cs_type_582, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_cs_type_582_comment},
  {"stringCsType", &Dtool_EggGroup_string_cs_type_582, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_cs_type_582_comment},
  {"string_collide_flags", &Dtool_EggGroup_string_collide_flags_583, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_collide_flags_583_comment},
  {"stringCollideFlags", &Dtool_EggGroup_string_collide_flags_583, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_collide_flags_583_comment},
  {"string_blend_mode", &Dtool_EggGroup_string_blend_mode_584, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_blend_mode_584_comment},
  {"stringBlendMode", &Dtool_EggGroup_string_blend_mode_584, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_blend_mode_584_comment},
  {"string_blend_operand", &Dtool_EggGroup_string_blend_operand_585, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_blend_operand_585_comment},
  {"stringBlendOperand", &Dtool_EggGroup_string_blend_operand_585, METH_O | METH_STATIC, (const char *)Dtool_EggGroup_string_blend_operand_585_comment},
  {"get_class_type", &Dtool_EggGroup_get_class_type_586, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggGroup_get_class_type_586_comment},
  {"getClassType", &Dtool_EggGroup_get_class_type_586, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggGroup_get_class_type_586_comment},
  {"upcast_to_EggGroupNode", &Dtool_EggGroup_upcast_to_EggGroupNode_381, METH_NOARGS, (const char *)Dtool_EggGroup_upcast_to_EggGroupNode_381_comment},
  {"upcastToEggGroupNode", &Dtool_EggGroup_upcast_to_EggGroupNode_381, METH_NOARGS, (const char *)Dtool_EggGroup_upcast_to_EggGroupNode_381_comment},
  {"upcast_to_EggRenderMode", &Dtool_EggGroup_upcast_to_EggRenderMode_383, METH_NOARGS, (const char *)Dtool_EggGroup_upcast_to_EggRenderMode_383_comment},
  {"upcastToEggRenderMode", &Dtool_EggGroup_upcast_to_EggRenderMode_383, METH_NOARGS, (const char *)Dtool_EggGroup_upcast_to_EggRenderMode_383_comment},
  {"upcast_to_EggTransform", &Dtool_EggGroup_upcast_to_EggTransform_385, METH_NOARGS, (const char *)Dtool_EggGroup_upcast_to_EggTransform_385_comment},
  {"upcastToEggTransform", &Dtool_EggGroup_upcast_to_EggTransform_385, METH_NOARGS, (const char *)Dtool_EggGroup_upcast_to_EggTransform_385_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_object_types", (PyCFunction) &MakeSeq_EggGroup_get_object_types, METH_NOARGS, nullptr},
  { "getObjectTypes", (PyCFunction) &MakeSeq_EggGroup_get_object_types, METH_NOARGS, nullptr},
  {"get_group_refs", (PyCFunction) &MakeSeq_EggGroup_get_group_refs, METH_NOARGS, nullptr},
  { "getGroupRefs", (PyCFunction) &MakeSeq_EggGroup_get_group_refs, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     EggGroup
//////////////////
static PyObject *Dtool_Str_EggGroup(PyObject *self) {
  EggGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggGroup, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_EggGroup[] = {
  {(char *)"group_type", &Dtool_EggGroup_group_type_Getter, &Dtool_EggGroup_group_type_Setter, nullptr, nullptr},
  {(char *)"billboard_type", &Dtool_EggGroup_billboard_type_Getter, &Dtool_EggGroup_billboard_type_Setter, nullptr, nullptr},
  {(char *)"billboard_center", &Dtool_EggGroup_billboard_center_Getter, &Dtool_EggGroup_billboard_center_Setter, nullptr, nullptr},
  {(char *)"cs_type", &Dtool_EggGroup_cs_type_Getter, &Dtool_EggGroup_cs_type_Setter, nullptr, nullptr},
  {(char *)"collide_flags", &Dtool_EggGroup_collide_flags_Getter, &Dtool_EggGroup_collide_flags_Setter, nullptr, nullptr},
  {(char *)"collision_name", &Dtool_EggGroup_collision_name_Getter, &Dtool_EggGroup_collision_name_Setter, nullptr, nullptr},
  {(char *)"dcs_type", &Dtool_EggGroup_dcs_type_Getter, &Dtool_EggGroup_dcs_type_Setter, nullptr, nullptr},
  {(char *)"dart_type", &Dtool_EggGroup_dart_type_Getter, &Dtool_EggGroup_dart_type_Setter, nullptr, nullptr},
  {(char *)"switch_flag", &Dtool_EggGroup_switch_flag_Getter, &Dtool_EggGroup_switch_flag_Setter, nullptr, nullptr},
  {(char *)"switch_fps", &Dtool_EggGroup_switch_fps_Getter, &Dtool_EggGroup_switch_fps_Setter, nullptr, nullptr},
  {(char *)"object_types", &Dtool_EggGroup_object_types_Getter, nullptr, nullptr, nullptr},
  {(char *)"model_flag", &Dtool_EggGroup_model_flag_Getter, &Dtool_EggGroup_model_flag_Setter, nullptr, nullptr},
  {(char *)"texlist_flag", &Dtool_EggGroup_texlist_flag_Getter, &Dtool_EggGroup_texlist_flag_Setter, nullptr, nullptr},
  {(char *)"nofog_flag", &Dtool_EggGroup_nofog_flag_Getter, &Dtool_EggGroup_nofog_flag_Setter, nullptr, nullptr},
  {(char *)"decal_flag", &Dtool_EggGroup_decal_flag_Getter, &Dtool_EggGroup_decal_flag_Setter, nullptr, nullptr},
  {(char *)"direct_flag", &Dtool_EggGroup_direct_flag_Getter, &Dtool_EggGroup_direct_flag_Setter, nullptr, nullptr},
  {(char *)"portal_flag", &Dtool_EggGroup_portal_flag_Getter, &Dtool_EggGroup_portal_flag_Setter, nullptr, nullptr},
  {(char *)"occluder_flag", &Dtool_EggGroup_occluder_flag_Getter, &Dtool_EggGroup_occluder_flag_Setter, nullptr, nullptr},
  {(char *)"indexed_flag", &Dtool_EggGroup_indexed_flag_Getter, &Dtool_EggGroup_indexed_flag_Setter, nullptr, nullptr},
  {(char *)"collide_mask", &Dtool_EggGroup_collide_mask_Getter, &Dtool_EggGroup_collide_mask_Setter, nullptr, nullptr},
  {(char *)"from_collide_mask", &Dtool_EggGroup_from_collide_mask_Getter, &Dtool_EggGroup_from_collide_mask_Setter, nullptr, nullptr},
  {(char *)"into_collide_mask", &Dtool_EggGroup_into_collide_mask_Getter, &Dtool_EggGroup_into_collide_mask_Setter, nullptr, nullptr},
  {(char *)"blend_mode", &Dtool_EggGroup_blend_mode_Getter, &Dtool_EggGroup_blend_mode_Setter, nullptr, nullptr},
  {(char *)"blend_operand_a", &Dtool_EggGroup_blend_operand_a_Getter, &Dtool_EggGroup_blend_operand_a_Setter, nullptr, nullptr},
  {(char *)"blend_operand_b", &Dtool_EggGroup_blend_operand_b_Getter, &Dtool_EggGroup_blend_operand_b_Setter, nullptr, nullptr},
  {(char *)"blend_color", &Dtool_EggGroup_blend_color_Getter, &Dtool_EggGroup_blend_color_Setter, nullptr, nullptr},
  {(char *)"lod", &Dtool_EggGroup_lod_Getter, &Dtool_EggGroup_lod_Setter, nullptr, nullptr},
  {(char *)"default_pose", &Dtool_EggGroup_default_pose_Getter, &Dtool_EggGroup_default_pose_Setter, nullptr, nullptr},
  {(char *)"scroll_u", &Dtool_EggGroup_scroll_u_Getter, &Dtool_EggGroup_scroll_u_Setter, nullptr, nullptr},
  {(char *)"scroll_v", &Dtool_EggGroup_scroll_v_Getter, &Dtool_EggGroup_scroll_v_Setter, nullptr, nullptr},
  {(char *)"scroll_w", &Dtool_EggGroup_scroll_w_Getter, &Dtool_EggGroup_scroll_w_Setter, nullptr, nullptr},
  {(char *)"scroll_r", &Dtool_EggGroup_scroll_r_Getter, &Dtool_EggGroup_scroll_r_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_EggGroup = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggGroup = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggGroup = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggGroup = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggGroup = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggGroup = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggGroup",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggGroup,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggGroup,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggGroup,
    &Dtool_SequenceMethods_EggGroup,
    &Dtool_MappingMethods_EggGroup,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_EggGroup,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggGroup,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The main glue of the egg hierarchy, this corresponds to the <Group>,\n"
    " * <Instance>, and <Joint> type nodes.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggGroup,
    nullptr, // tp_members
    Dtool_Properties_EggGroup,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggGroup,
    PyType_GenericAlloc,
    Dtool_new_EggGroup,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggGroup,
  Dtool_UpcastInterface_EggGroup,
  Dtool_DowncastInterface_EggGroup,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggGroup(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggGroupNode(nullptr);
    Dtool_PyModuleClassInit_EggRenderMode(nullptr);
    Dtool_PyModuleClassInit_EggTransform(nullptr);
    Dtool_EggGroup._PyType.tp_bases = PyTuple_Pack(3, (PyTypeObject *)&Dtool_EggGroupNode, (PyTypeObject *)&Dtool_EggRenderMode, (PyTypeObject *)&Dtool_EggTransform);
    Dtool_EggGroup._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(129);
    Dtool_EggGroup._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum EggGroup::GroupType;
    PyDict_SetItemString(dict, "GT_invalid", Dtool_WrapValue(EggGroup::GT_invalid));
    PyDict_SetItemString(dict, "GTInvalid", Dtool_WrapValue(EggGroup::GT_invalid));
    PyDict_SetItemString(dict, "GT_group", Dtool_WrapValue(EggGroup::GT_group));
    PyDict_SetItemString(dict, "GTGroup", Dtool_WrapValue(EggGroup::GT_group));
    PyDict_SetItemString(dict, "GT_instance", Dtool_WrapValue(EggGroup::GT_instance));
    PyDict_SetItemString(dict, "GTInstance", Dtool_WrapValue(EggGroup::GT_instance));
    PyDict_SetItemString(dict, "GT_joint", Dtool_WrapValue(EggGroup::GT_joint));
    PyDict_SetItemString(dict, "GTJoint", Dtool_WrapValue(EggGroup::GT_joint));
    // enum EggGroup::DCSType;
    PyDict_SetItemString(dict, "DC_unspecified", Dtool_WrapValue(EggGroup::DC_unspecified));
    PyDict_SetItemString(dict, "DCUnspecified", Dtool_WrapValue(EggGroup::DC_unspecified));
    PyDict_SetItemString(dict, "DC_none", Dtool_WrapValue(EggGroup::DC_none));
    PyDict_SetItemString(dict, "DCNone", Dtool_WrapValue(EggGroup::DC_none));
    PyDict_SetItemString(dict, "DC_local", Dtool_WrapValue(EggGroup::DC_local));
    PyDict_SetItemString(dict, "DCLocal", Dtool_WrapValue(EggGroup::DC_local));
    PyDict_SetItemString(dict, "DC_net", Dtool_WrapValue(EggGroup::DC_net));
    PyDict_SetItemString(dict, "DCNet", Dtool_WrapValue(EggGroup::DC_net));
    PyDict_SetItemString(dict, "DC_no_touch", Dtool_WrapValue(EggGroup::DC_no_touch));
    PyDict_SetItemString(dict, "DCNoTouch", Dtool_WrapValue(EggGroup::DC_no_touch));
    PyDict_SetItemString(dict, "DC_default", Dtool_WrapValue(EggGroup::DC_default));
    PyDict_SetItemString(dict, "DCDefault", Dtool_WrapValue(EggGroup::DC_default));
    // enum EggGroup::BillboardType;
    PyDict_SetItemString(dict, "BT_none", Dtool_WrapValue(EggGroup::BT_none));
    PyDict_SetItemString(dict, "BTNone", Dtool_WrapValue(EggGroup::BT_none));
    PyDict_SetItemString(dict, "BT_axis", Dtool_WrapValue(EggGroup::BT_axis));
    PyDict_SetItemString(dict, "BTAxis", Dtool_WrapValue(EggGroup::BT_axis));
    PyDict_SetItemString(dict, "BT_point_camera_relative", Dtool_WrapValue(EggGroup::BT_point_camera_relative));
    PyDict_SetItemString(dict, "BTPointCameraRelative", Dtool_WrapValue(EggGroup::BT_point_camera_relative));
    PyDict_SetItemString(dict, "BT_point_world_relative", Dtool_WrapValue(EggGroup::BT_point_world_relative));
    PyDict_SetItemString(dict, "BTPointWorldRelative", Dtool_WrapValue(EggGroup::BT_point_world_relative));
    // enum EggGroup::CollisionSolidType;
    PyDict_SetItemString(dict, "CST_none", Dtool_WrapValue(EggGroup::CST_none));
    PyDict_SetItemString(dict, "CSTNone", Dtool_WrapValue(EggGroup::CST_none));
    PyDict_SetItemString(dict, "CST_plane", Dtool_WrapValue(EggGroup::CST_plane));
    PyDict_SetItemString(dict, "CSTPlane", Dtool_WrapValue(EggGroup::CST_plane));
    PyDict_SetItemString(dict, "CST_polygon", Dtool_WrapValue(EggGroup::CST_polygon));
    PyDict_SetItemString(dict, "CSTPolygon", Dtool_WrapValue(EggGroup::CST_polygon));
    PyDict_SetItemString(dict, "CST_polyset", Dtool_WrapValue(EggGroup::CST_polyset));
    PyDict_SetItemString(dict, "CSTPolyset", Dtool_WrapValue(EggGroup::CST_polyset));
    PyDict_SetItemString(dict, "CST_sphere", Dtool_WrapValue(EggGroup::CST_sphere));
    PyDict_SetItemString(dict, "CSTSphere", Dtool_WrapValue(EggGroup::CST_sphere));
    PyDict_SetItemString(dict, "CST_tube", Dtool_WrapValue(EggGroup::CST_tube));
    PyDict_SetItemString(dict, "CSTTube", Dtool_WrapValue(EggGroup::CST_tube));
    PyDict_SetItemString(dict, "CST_inv_sphere", Dtool_WrapValue(EggGroup::CST_inv_sphere));
    PyDict_SetItemString(dict, "CSTInvSphere", Dtool_WrapValue(EggGroup::CST_inv_sphere));
    PyDict_SetItemString(dict, "CST_box", Dtool_WrapValue(EggGroup::CST_box));
    PyDict_SetItemString(dict, "CSTBox", Dtool_WrapValue(EggGroup::CST_box));
    PyDict_SetItemString(dict, "CST_floor_mesh", Dtool_WrapValue(EggGroup::CST_floor_mesh));
    PyDict_SetItemString(dict, "CSTFloorMesh", Dtool_WrapValue(EggGroup::CST_floor_mesh));
    // enum EggGroup::CollideFlags;
    PyDict_SetItemString(dict, "CF_none", Dtool_WrapValue(EggGroup::CF_none));
    PyDict_SetItemString(dict, "CFNone", Dtool_WrapValue(EggGroup::CF_none));
    PyDict_SetItemString(dict, "CF_descend", Dtool_WrapValue(EggGroup::CF_descend));
    PyDict_SetItemString(dict, "CFDescend", Dtool_WrapValue(EggGroup::CF_descend));
    PyDict_SetItemString(dict, "CF_event", Dtool_WrapValue(EggGroup::CF_event));
    PyDict_SetItemString(dict, "CFEvent", Dtool_WrapValue(EggGroup::CF_event));
    PyDict_SetItemString(dict, "CF_keep", Dtool_WrapValue(EggGroup::CF_keep));
    PyDict_SetItemString(dict, "CFKeep", Dtool_WrapValue(EggGroup::CF_keep));
    PyDict_SetItemString(dict, "CF_solid", Dtool_WrapValue(EggGroup::CF_solid));
    PyDict_SetItemString(dict, "CFSolid", Dtool_WrapValue(EggGroup::CF_solid));
    PyDict_SetItemString(dict, "CF_center", Dtool_WrapValue(EggGroup::CF_center));
    PyDict_SetItemString(dict, "CFCenter", Dtool_WrapValue(EggGroup::CF_center));
    PyDict_SetItemString(dict, "CF_turnstile", Dtool_WrapValue(EggGroup::CF_turnstile));
    PyDict_SetItemString(dict, "CFTurnstile", Dtool_WrapValue(EggGroup::CF_turnstile));
    PyDict_SetItemString(dict, "CF_level", Dtool_WrapValue(EggGroup::CF_level));
    PyDict_SetItemString(dict, "CFLevel", Dtool_WrapValue(EggGroup::CF_level));
    PyDict_SetItemString(dict, "CF_intangible", Dtool_WrapValue(EggGroup::CF_intangible));
    PyDict_SetItemString(dict, "CFIntangible", Dtool_WrapValue(EggGroup::CF_intangible));
    // enum EggGroup::DartType;
    PyDict_SetItemString(dict, "DT_none", Dtool_WrapValue(EggGroup::DT_none));
    PyDict_SetItemString(dict, "DTNone", Dtool_WrapValue(EggGroup::DT_none));
    PyDict_SetItemString(dict, "DT_structured", Dtool_WrapValue(EggGroup::DT_structured));
    PyDict_SetItemString(dict, "DTStructured", Dtool_WrapValue(EggGroup::DT_structured));
    PyDict_SetItemString(dict, "DT_sync", Dtool_WrapValue(EggGroup::DT_sync));
    PyDict_SetItemString(dict, "DTSync", Dtool_WrapValue(EggGroup::DT_sync));
    PyDict_SetItemString(dict, "DT_nosync", Dtool_WrapValue(EggGroup::DT_nosync));
    PyDict_SetItemString(dict, "DTNosync", Dtool_WrapValue(EggGroup::DT_nosync));
    PyDict_SetItemString(dict, "DT_default", Dtool_WrapValue(EggGroup::DT_default));
    PyDict_SetItemString(dict, "DTDefault", Dtool_WrapValue(EggGroup::DT_default));
    // enum EggGroup::BlendMode;
    PyDict_SetItemString(dict, "BM_unspecified", Dtool_WrapValue(EggGroup::BM_unspecified));
    PyDict_SetItemString(dict, "BMUnspecified", Dtool_WrapValue(EggGroup::BM_unspecified));
    PyDict_SetItemString(dict, "BM_none", Dtool_WrapValue(EggGroup::BM_none));
    PyDict_SetItemString(dict, "BMNone", Dtool_WrapValue(EggGroup::BM_none));
    PyDict_SetItemString(dict, "BM_add", Dtool_WrapValue(EggGroup::BM_add));
    PyDict_SetItemString(dict, "BMAdd", Dtool_WrapValue(EggGroup::BM_add));
    PyDict_SetItemString(dict, "BM_subtract", Dtool_WrapValue(EggGroup::BM_subtract));
    PyDict_SetItemString(dict, "BMSubtract", Dtool_WrapValue(EggGroup::BM_subtract));
    PyDict_SetItemString(dict, "BM_inv_subtract", Dtool_WrapValue(EggGroup::BM_inv_subtract));
    PyDict_SetItemString(dict, "BMInvSubtract", Dtool_WrapValue(EggGroup::BM_inv_subtract));
    PyDict_SetItemString(dict, "BM_min", Dtool_WrapValue(EggGroup::BM_min));
    PyDict_SetItemString(dict, "BMMin", Dtool_WrapValue(EggGroup::BM_min));
    PyDict_SetItemString(dict, "BM_max", Dtool_WrapValue(EggGroup::BM_max));
    PyDict_SetItemString(dict, "BMMax", Dtool_WrapValue(EggGroup::BM_max));
    // enum EggGroup::BlendOperand;
    PyDict_SetItemString(dict, "BO_unspecified", Dtool_WrapValue(EggGroup::BO_unspecified));
    PyDict_SetItemString(dict, "BOUnspecified", Dtool_WrapValue(EggGroup::BO_unspecified));
    PyDict_SetItemString(dict, "BO_zero", Dtool_WrapValue(EggGroup::BO_zero));
    PyDict_SetItemString(dict, "BOZero", Dtool_WrapValue(EggGroup::BO_zero));
    PyDict_SetItemString(dict, "BO_one", Dtool_WrapValue(EggGroup::BO_one));
    PyDict_SetItemString(dict, "BOOne", Dtool_WrapValue(EggGroup::BO_one));
    PyDict_SetItemString(dict, "BO_incoming_color", Dtool_WrapValue(EggGroup::BO_incoming_color));
    PyDict_SetItemString(dict, "BOIncomingColor", Dtool_WrapValue(EggGroup::BO_incoming_color));
    PyDict_SetItemString(dict, "BO_one_minus_incoming_color", Dtool_WrapValue(EggGroup::BO_one_minus_incoming_color));
    PyDict_SetItemString(dict, "BOOneMinusIncomingColor", Dtool_WrapValue(EggGroup::BO_one_minus_incoming_color));
    PyDict_SetItemString(dict, "BO_fbuffer_color", Dtool_WrapValue(EggGroup::BO_fbuffer_color));
    PyDict_SetItemString(dict, "BOFbufferColor", Dtool_WrapValue(EggGroup::BO_fbuffer_color));
    PyDict_SetItemString(dict, "BO_one_minus_fbuffer_color", Dtool_WrapValue(EggGroup::BO_one_minus_fbuffer_color));
    PyDict_SetItemString(dict, "BOOneMinusFbufferColor", Dtool_WrapValue(EggGroup::BO_one_minus_fbuffer_color));
    PyDict_SetItemString(dict, "BO_incoming_alpha", Dtool_WrapValue(EggGroup::BO_incoming_alpha));
    PyDict_SetItemString(dict, "BOIncomingAlpha", Dtool_WrapValue(EggGroup::BO_incoming_alpha));
    PyDict_SetItemString(dict, "BO_one_minus_incoming_alpha", Dtool_WrapValue(EggGroup::BO_one_minus_incoming_alpha));
    PyDict_SetItemString(dict, "BOOneMinusIncomingAlpha", Dtool_WrapValue(EggGroup::BO_one_minus_incoming_alpha));
    PyDict_SetItemString(dict, "BO_fbuffer_alpha", Dtool_WrapValue(EggGroup::BO_fbuffer_alpha));
    PyDict_SetItemString(dict, "BOFbufferAlpha", Dtool_WrapValue(EggGroup::BO_fbuffer_alpha));
    PyDict_SetItemString(dict, "BO_one_minus_fbuffer_alpha", Dtool_WrapValue(EggGroup::BO_one_minus_fbuffer_alpha));
    PyDict_SetItemString(dict, "BOOneMinusFbufferAlpha", Dtool_WrapValue(EggGroup::BO_one_minus_fbuffer_alpha));
    PyDict_SetItemString(dict, "BO_constant_color", Dtool_WrapValue(EggGroup::BO_constant_color));
    PyDict_SetItemString(dict, "BOConstantColor", Dtool_WrapValue(EggGroup::BO_constant_color));
    PyDict_SetItemString(dict, "BO_one_minus_constant_color", Dtool_WrapValue(EggGroup::BO_one_minus_constant_color));
    PyDict_SetItemString(dict, "BOOneMinusConstantColor", Dtool_WrapValue(EggGroup::BO_one_minus_constant_color));
    PyDict_SetItemString(dict, "BO_constant_alpha", Dtool_WrapValue(EggGroup::BO_constant_alpha));
    PyDict_SetItemString(dict, "BOConstantAlpha", Dtool_WrapValue(EggGroup::BO_constant_alpha));
    PyDict_SetItemString(dict, "BO_one_minus_constant_alpha", Dtool_WrapValue(EggGroup::BO_one_minus_constant_alpha));
    PyDict_SetItemString(dict, "BOOneMinusConstantAlpha", Dtool_WrapValue(EggGroup::BO_one_minus_constant_alpha));
    PyDict_SetItemString(dict, "BO_incoming_color_saturate", Dtool_WrapValue(EggGroup::BO_incoming_color_saturate));
    PyDict_SetItemString(dict, "BOIncomingColorSaturate", Dtool_WrapValue(EggGroup::BO_incoming_color_saturate));
    PyDict_SetItemString(dict, "BO_color_scale", Dtool_WrapValue(EggGroup::BO_color_scale));
    PyDict_SetItemString(dict, "BOColorScale", Dtool_WrapValue(EggGroup::BO_color_scale));
    PyDict_SetItemString(dict, "BO_one_minus_color_scale", Dtool_WrapValue(EggGroup::BO_one_minus_color_scale));
    PyDict_SetItemString(dict, "BOOneMinusColorScale", Dtool_WrapValue(EggGroup::BO_one_minus_color_scale));
    PyDict_SetItemString(dict, "BO_alpha_scale", Dtool_WrapValue(EggGroup::BO_alpha_scale));
    PyDict_SetItemString(dict, "BOAlphaScale", Dtool_WrapValue(EggGroup::BO_alpha_scale));
    PyDict_SetItemString(dict, "BO_one_minus_alpha_scale", Dtool_WrapValue(EggGroup::BO_one_minus_alpha_scale));
    PyDict_SetItemString(dict, "BOOneMinusAlphaScale", Dtool_WrapValue(EggGroup::BO_one_minus_alpha_scale));
    if (PyType_Ready((PyTypeObject *)&Dtool_EggGroup) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggGroup)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggGroup);
  }
}

/**
 * Python method tables for EggBin (EggBin)
 */
static PyMethodDef Dtool_Methods_EggBin[] = {
  {"set_bin_number", &Dtool_EggBin_set_bin_number_589, METH_O, (const char *)Dtool_EggBin_set_bin_number_589_comment},
  {"setBinNumber", &Dtool_EggBin_set_bin_number_589, METH_O, (const char *)Dtool_EggBin_set_bin_number_589_comment},
  {"get_bin_number", &Dtool_EggBin_get_bin_number_590, METH_NOARGS, (const char *)Dtool_EggBin_get_bin_number_590_comment},
  {"getBinNumber", &Dtool_EggBin_get_bin_number_590, METH_NOARGS, (const char *)Dtool_EggBin_get_bin_number_590_comment},
  {"get_class_type", &Dtool_EggBin_get_class_type_591, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggBin_get_class_type_591_comment},
  {"getClassType", &Dtool_EggBin_get_class_type_591, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggBin_get_class_type_591_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EggBin = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggBin = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggBin = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggBin = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggBin = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggBin = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggBin",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggBin,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggBin,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggBin,
    &Dtool_SequenceMethods_EggBin,
    &Dtool_MappingMethods_EggBin,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggBin,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A type of group node that holds related subnodes.  This is a special kind\n"
    " * of node that will never be read in from an egg file, but can only exist in\n"
    " * the egg scene graph if it is created via the use of an EggBinMaker.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggBin,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggBin,
    PyType_GenericAlloc,
    Dtool_new_EggBin,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggBin,
  Dtool_UpcastInterface_EggBin,
  Dtool_DowncastInterface_EggBin,
  (CoerceFunction)Dtool_ConstCoerce_EggBin,
  (CoerceFunction)Dtool_Coerce_EggBin,
};

static void Dtool_PyModuleClassInit_EggBin(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggGroup(nullptr);
    Dtool_EggBin._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggGroup);
    Dtool_EggBin._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggBin._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggBin) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggBin)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggBin);
  }
}

/**
 * Python method tables for EggBinMaker (EggBinMaker)
 */
static PyMethodDef Dtool_Methods_EggBinMaker[] = {
  {"make_bins", &Dtool_EggBinMaker_make_bins_594, METH_O, (const char *)Dtool_EggBinMaker_make_bins_594_comment},
  {"makeBins", &Dtool_EggBinMaker_make_bins_594, METH_O, (const char *)Dtool_EggBinMaker_make_bins_594_comment},
  {"prepare_node", &Dtool_EggBinMaker_prepare_node_595, METH_O, (const char *)Dtool_EggBinMaker_prepare_node_595_comment},
  {"prepareNode", &Dtool_EggBinMaker_prepare_node_595, METH_O, (const char *)Dtool_EggBinMaker_prepare_node_595_comment},
  {"get_bin_number", &Dtool_EggBinMaker_get_bin_number_596, METH_O, (const char *)Dtool_EggBinMaker_get_bin_number_596_comment},
  {"getBinNumber", &Dtool_EggBinMaker_get_bin_number_596, METH_O, (const char *)Dtool_EggBinMaker_get_bin_number_596_comment},
  {"sorts_less", (PyCFunction) &Dtool_EggBinMaker_sorts_less_597, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggBinMaker_sorts_less_597_comment},
  {"sortsLess", (PyCFunction) &Dtool_EggBinMaker_sorts_less_597, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggBinMaker_sorts_less_597_comment},
  {"collapse_group", (PyCFunction) &Dtool_EggBinMaker_collapse_group_598, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggBinMaker_collapse_group_598_comment},
  {"collapseGroup", (PyCFunction) &Dtool_EggBinMaker_collapse_group_598, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggBinMaker_collapse_group_598_comment},
  {"get_bin_name", (PyCFunction) &Dtool_EggBinMaker_get_bin_name_599, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggBinMaker_get_bin_name_599_comment},
  {"getBinName", (PyCFunction) &Dtool_EggBinMaker_get_bin_name_599, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggBinMaker_get_bin_name_599_comment},
  {"make_bin", (PyCFunction) &Dtool_EggBinMaker_make_bin_600, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggBinMaker_make_bin_600_comment},
  {"makeBin", (PyCFunction) &Dtool_EggBinMaker_make_bin_600, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggBinMaker_make_bin_600_comment},
  {"get_class_type", &Dtool_EggBinMaker_get_class_type_601, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggBinMaker_get_class_type_601_comment},
  {"getClassType", &Dtool_EggBinMaker_get_class_type_601, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggBinMaker_get_class_type_601_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EggBinMaker = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggBinMaker = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggBinMaker = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggBinMaker = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggBinMaker = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggBinMaker = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggBinMaker",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggBinMaker,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggBinMaker,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggBinMaker,
    &Dtool_SequenceMethods_EggBinMaker,
    &Dtool_MappingMethods_EggBinMaker,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggBinMaker,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a handy class for collecting related nodes together.  It is an\n"
    " * abstract class; to use it you must subclass off of it.  See the somewhat\n"
    " * lengthy comment above.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggBinMaker,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggBinMaker,
    PyType_GenericAlloc,
    Dtool_new_EggBinMaker,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggBinMaker,
  Dtool_UpcastInterface_EggBinMaker,
  Dtool_DowncastInterface_EggBinMaker,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggBinMaker(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggObject(nullptr);
    Dtool_EggBinMaker._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggObject);
    Dtool_EggBinMaker._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggBinMaker._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggBinMaker) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggBinMaker)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggBinMaker);
  }
}

/**
 * Python method tables for EggComment (EggComment)
 */
static PyMethodDef Dtool_Methods_EggComment[] = {
  {"assign", &Dtool_EggComment_operator_604, METH_O, (const char *)Dtool_EggComment_operator_604_comment},
  {"set_comment", &Dtool_EggComment_set_comment_606, METH_O, (const char *)Dtool_EggComment_set_comment_606_comment},
  {"setComment", &Dtool_EggComment_set_comment_606, METH_O, (const char *)Dtool_EggComment_set_comment_606_comment},
  {"get_comment", &Dtool_EggComment_get_comment_607, METH_NOARGS, (const char *)Dtool_EggComment_get_comment_607_comment},
  {"getComment", &Dtool_EggComment_get_comment_607, METH_NOARGS, (const char *)Dtool_EggComment_get_comment_607_comment},
  {"get_class_type", &Dtool_EggComment_get_class_type_608, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggComment_get_class_type_608_comment},
  {"getClassType", &Dtool_EggComment_get_class_type_608, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggComment_get_class_type_608_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// EggComment slot tp_str -> operator typecast
//////////////////
static PyObject *Dtool_EggComment_operator_typecast_605_tp_str(PyObject *self) {
  EggComment *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggComment, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline operator std::string const &(void) const
  std::string const &return_value = (std::string const &)*(const EggComment*)local_this;
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "operator_typecast(EggComment self)\n");
  }
  return nullptr;
}

static PyNumberMethods Dtool_NumberMethods_EggComment = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggComment = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggComment = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggComment = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggComment = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggComment = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggComment",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggComment,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggComment,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggComment,
    &Dtool_SequenceMethods_EggComment,
    &Dtool_MappingMethods_EggComment,
    nullptr, // tp_hash
    nullptr,
    &Dtool_EggComment_operator_typecast_605_tp_str,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggComment,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A comment that appears in an egg file within a <Comment> entry.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggComment,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggComment,
    PyType_GenericAlloc,
    Dtool_new_EggComment,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggComment,
  Dtool_UpcastInterface_EggComment,
  Dtool_DowncastInterface_EggComment,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggComment(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggNode(nullptr);
    Dtool_EggComment._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggNode);
    Dtool_EggComment._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggComment._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggComment) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggComment)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggComment);
  }
}

/**
 * Python method tables for EggFilenameNode (EggFilenameNode)
 */
static PyMethodDef Dtool_Methods_EggFilenameNode[] = {
  {"assign", &Dtool_EggFilenameNode_operator_611, METH_O, (const char *)Dtool_EggFilenameNode_operator_611_comment},
  {"get_default_extension", &Dtool_EggFilenameNode_get_default_extension_612, METH_NOARGS, (const char *)Dtool_EggFilenameNode_get_default_extension_612_comment},
  {"getDefaultExtension", &Dtool_EggFilenameNode_get_default_extension_612, METH_NOARGS, (const char *)Dtool_EggFilenameNode_get_default_extension_612_comment},
  {"get_filename", &Dtool_EggFilenameNode_get_filename_613, METH_NOARGS, (const char *)Dtool_EggFilenameNode_get_filename_613_comment},
  {"getFilename", &Dtool_EggFilenameNode_get_filename_613, METH_NOARGS, (const char *)Dtool_EggFilenameNode_get_filename_613_comment},
  {"set_filename", &Dtool_EggFilenameNode_set_filename_614, METH_O, (const char *)Dtool_EggFilenameNode_set_filename_614_comment},
  {"setFilename", &Dtool_EggFilenameNode_set_filename_614, METH_O, (const char *)Dtool_EggFilenameNode_set_filename_614_comment},
  {"get_fullpath", &Dtool_EggFilenameNode_get_fullpath_615, METH_NOARGS, (const char *)Dtool_EggFilenameNode_get_fullpath_615_comment},
  {"getFullpath", &Dtool_EggFilenameNode_get_fullpath_615, METH_NOARGS, (const char *)Dtool_EggFilenameNode_get_fullpath_615_comment},
  {"set_fullpath", &Dtool_EggFilenameNode_set_fullpath_616, METH_O, (const char *)Dtool_EggFilenameNode_set_fullpath_616_comment},
  {"setFullpath", &Dtool_EggFilenameNode_set_fullpath_616, METH_O, (const char *)Dtool_EggFilenameNode_set_fullpath_616_comment},
  {"get_class_type", &Dtool_EggFilenameNode_get_class_type_617, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggFilenameNode_get_class_type_617_comment},
  {"getClassType", &Dtool_EggFilenameNode_get_class_type_617, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggFilenameNode_get_class_type_617_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EggFilenameNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggFilenameNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggFilenameNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggFilenameNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggFilenameNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggFilenameNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggFilenameNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggFilenameNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggFilenameNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggFilenameNode,
    &Dtool_SequenceMethods_EggFilenameNode,
    &Dtool_MappingMethods_EggFilenameNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggFilenameNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is an egg node that contains a filename.  It references a physical\n"
    " * file relative to the directory the egg file was loaded in.  It is a base\n"
    " * class for EggTexture and EggExternalReference.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggFilenameNode,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggFilenameNode,
    PyType_GenericAlloc,
    Dtool_new_EggFilenameNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggFilenameNode,
  Dtool_UpcastInterface_EggFilenameNode,
  Dtool_DowncastInterface_EggFilenameNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggFilenameNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggNode(nullptr);
    Dtool_EggFilenameNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggNode);
    Dtool_EggFilenameNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggFilenameNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggFilenameNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggFilenameNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggFilenameNode);
  }
}

/**
 * Python method tables for EggTexture (EggTexture)
 */
static PyMethodDef Dtool_Methods_EggTexture[] = {
  {"assign", &Dtool_EggTexture_operator_627, METH_O, (const char *)Dtool_EggTexture_operator_627_comment},
  {"write", (PyCFunction) &Dtool_EggTexture_write_629, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTexture_write_629_comment},
  {"is_equivalent_to", (PyCFunction) &Dtool_EggTexture_is_equivalent_to_631, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTexture_is_equivalent_to_631_comment},
  {"isEquivalentTo", (PyCFunction) &Dtool_EggTexture_is_equivalent_to_631, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTexture_is_equivalent_to_631_comment},
  {"sorts_less_than", (PyCFunction) &Dtool_EggTexture_sorts_less_than_632, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTexture_sorts_less_than_632_comment},
  {"sortsLessThan", (PyCFunction) &Dtool_EggTexture_sorts_less_than_632, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTexture_sorts_less_than_632_comment},
  {"has_alpha_channel", &Dtool_EggTexture_has_alpha_channel_633, METH_O, (const char *)Dtool_EggTexture_has_alpha_channel_633_comment},
  {"hasAlphaChannel", &Dtool_EggTexture_has_alpha_channel_633, METH_O, (const char *)Dtool_EggTexture_has_alpha_channel_633_comment},
  {"set_texture_type", &Dtool_EggTexture_set_texture_type_647, METH_O, (const char *)Dtool_EggTexture_set_texture_type_647_comment},
  {"setTextureType", &Dtool_EggTexture_set_texture_type_647, METH_O, (const char *)Dtool_EggTexture_set_texture_type_647_comment},
  {"get_texture_type", &Dtool_EggTexture_get_texture_type_648, METH_NOARGS, (const char *)Dtool_EggTexture_get_texture_type_648_comment},
  {"getTextureType", &Dtool_EggTexture_get_texture_type_648, METH_NOARGS, (const char *)Dtool_EggTexture_get_texture_type_648_comment},
  {"set_format", &Dtool_EggTexture_set_format_649, METH_O, (const char *)Dtool_EggTexture_set_format_649_comment},
  {"setFormat", &Dtool_EggTexture_set_format_649, METH_O, (const char *)Dtool_EggTexture_set_format_649_comment},
  {"get_format", &Dtool_EggTexture_get_format_650, METH_NOARGS, (const char *)Dtool_EggTexture_get_format_650_comment},
  {"getFormat", &Dtool_EggTexture_get_format_650, METH_NOARGS, (const char *)Dtool_EggTexture_get_format_650_comment},
  {"set_compression_mode", &Dtool_EggTexture_set_compression_mode_651, METH_O, (const char *)Dtool_EggTexture_set_compression_mode_651_comment},
  {"setCompressionMode", &Dtool_EggTexture_set_compression_mode_651, METH_O, (const char *)Dtool_EggTexture_set_compression_mode_651_comment},
  {"get_compression_mode", &Dtool_EggTexture_get_compression_mode_652, METH_NOARGS, (const char *)Dtool_EggTexture_get_compression_mode_652_comment},
  {"getCompressionMode", &Dtool_EggTexture_get_compression_mode_652, METH_NOARGS, (const char *)Dtool_EggTexture_get_compression_mode_652_comment},
  {"set_wrap_mode", &Dtool_EggTexture_set_wrap_mode_653, METH_O, (const char *)Dtool_EggTexture_set_wrap_mode_653_comment},
  {"setWrapMode", &Dtool_EggTexture_set_wrap_mode_653, METH_O, (const char *)Dtool_EggTexture_set_wrap_mode_653_comment},
  {"get_wrap_mode", &Dtool_EggTexture_get_wrap_mode_654, METH_NOARGS, (const char *)Dtool_EggTexture_get_wrap_mode_654_comment},
  {"getWrapMode", &Dtool_EggTexture_get_wrap_mode_654, METH_NOARGS, (const char *)Dtool_EggTexture_get_wrap_mode_654_comment},
  {"set_wrap_u", &Dtool_EggTexture_set_wrap_u_655, METH_O, (const char *)Dtool_EggTexture_set_wrap_u_655_comment},
  {"setWrapU", &Dtool_EggTexture_set_wrap_u_655, METH_O, (const char *)Dtool_EggTexture_set_wrap_u_655_comment},
  {"get_wrap_u", &Dtool_EggTexture_get_wrap_u_656, METH_NOARGS, (const char *)Dtool_EggTexture_get_wrap_u_656_comment},
  {"getWrapU", &Dtool_EggTexture_get_wrap_u_656, METH_NOARGS, (const char *)Dtool_EggTexture_get_wrap_u_656_comment},
  {"determine_wrap_u", &Dtool_EggTexture_determine_wrap_u_657, METH_NOARGS, (const char *)Dtool_EggTexture_determine_wrap_u_657_comment},
  {"determineWrapU", &Dtool_EggTexture_determine_wrap_u_657, METH_NOARGS, (const char *)Dtool_EggTexture_determine_wrap_u_657_comment},
  {"set_wrap_v", &Dtool_EggTexture_set_wrap_v_658, METH_O, (const char *)Dtool_EggTexture_set_wrap_v_658_comment},
  {"setWrapV", &Dtool_EggTexture_set_wrap_v_658, METH_O, (const char *)Dtool_EggTexture_set_wrap_v_658_comment},
  {"get_wrap_v", &Dtool_EggTexture_get_wrap_v_659, METH_NOARGS, (const char *)Dtool_EggTexture_get_wrap_v_659_comment},
  {"getWrapV", &Dtool_EggTexture_get_wrap_v_659, METH_NOARGS, (const char *)Dtool_EggTexture_get_wrap_v_659_comment},
  {"determine_wrap_v", &Dtool_EggTexture_determine_wrap_v_660, METH_NOARGS, (const char *)Dtool_EggTexture_determine_wrap_v_660_comment},
  {"determineWrapV", &Dtool_EggTexture_determine_wrap_v_660, METH_NOARGS, (const char *)Dtool_EggTexture_determine_wrap_v_660_comment},
  {"set_wrap_w", &Dtool_EggTexture_set_wrap_w_661, METH_O, (const char *)Dtool_EggTexture_set_wrap_w_661_comment},
  {"setWrapW", &Dtool_EggTexture_set_wrap_w_661, METH_O, (const char *)Dtool_EggTexture_set_wrap_w_661_comment},
  {"get_wrap_w", &Dtool_EggTexture_get_wrap_w_662, METH_NOARGS, (const char *)Dtool_EggTexture_get_wrap_w_662_comment},
  {"getWrapW", &Dtool_EggTexture_get_wrap_w_662, METH_NOARGS, (const char *)Dtool_EggTexture_get_wrap_w_662_comment},
  {"determine_wrap_w", &Dtool_EggTexture_determine_wrap_w_663, METH_NOARGS, (const char *)Dtool_EggTexture_determine_wrap_w_663_comment},
  {"determineWrapW", &Dtool_EggTexture_determine_wrap_w_663, METH_NOARGS, (const char *)Dtool_EggTexture_determine_wrap_w_663_comment},
  {"set_minfilter", &Dtool_EggTexture_set_minfilter_664, METH_O, (const char *)Dtool_EggTexture_set_minfilter_664_comment},
  {"setMinfilter", &Dtool_EggTexture_set_minfilter_664, METH_O, (const char *)Dtool_EggTexture_set_minfilter_664_comment},
  {"get_minfilter", &Dtool_EggTexture_get_minfilter_665, METH_NOARGS, (const char *)Dtool_EggTexture_get_minfilter_665_comment},
  {"getMinfilter", &Dtool_EggTexture_get_minfilter_665, METH_NOARGS, (const char *)Dtool_EggTexture_get_minfilter_665_comment},
  {"set_magfilter", &Dtool_EggTexture_set_magfilter_666, METH_O, (const char *)Dtool_EggTexture_set_magfilter_666_comment},
  {"setMagfilter", &Dtool_EggTexture_set_magfilter_666, METH_O, (const char *)Dtool_EggTexture_set_magfilter_666_comment},
  {"get_magfilter", &Dtool_EggTexture_get_magfilter_667, METH_NOARGS, (const char *)Dtool_EggTexture_get_magfilter_667_comment},
  {"getMagfilter", &Dtool_EggTexture_get_magfilter_667, METH_NOARGS, (const char *)Dtool_EggTexture_get_magfilter_667_comment},
  {"set_anisotropic_degree", &Dtool_EggTexture_set_anisotropic_degree_668, METH_O, (const char *)Dtool_EggTexture_set_anisotropic_degree_668_comment},
  {"setAnisotropicDegree", &Dtool_EggTexture_set_anisotropic_degree_668, METH_O, (const char *)Dtool_EggTexture_set_anisotropic_degree_668_comment},
  {"clear_anisotropic_degree", &Dtool_EggTexture_clear_anisotropic_degree_669, METH_NOARGS, (const char *)Dtool_EggTexture_clear_anisotropic_degree_669_comment},
  {"clearAnisotropicDegree", &Dtool_EggTexture_clear_anisotropic_degree_669, METH_NOARGS, (const char *)Dtool_EggTexture_clear_anisotropic_degree_669_comment},
  {"has_anisotropic_degree", &Dtool_EggTexture_has_anisotropic_degree_670, METH_NOARGS, (const char *)Dtool_EggTexture_has_anisotropic_degree_670_comment},
  {"hasAnisotropicDegree", &Dtool_EggTexture_has_anisotropic_degree_670, METH_NOARGS, (const char *)Dtool_EggTexture_has_anisotropic_degree_670_comment},
  {"get_anisotropic_degree", &Dtool_EggTexture_get_anisotropic_degree_671, METH_NOARGS, (const char *)Dtool_EggTexture_get_anisotropic_degree_671_comment},
  {"getAnisotropicDegree", &Dtool_EggTexture_get_anisotropic_degree_671, METH_NOARGS, (const char *)Dtool_EggTexture_get_anisotropic_degree_671_comment},
  {"set_env_type", &Dtool_EggTexture_set_env_type_672, METH_O, (const char *)Dtool_EggTexture_set_env_type_672_comment},
  {"setEnvType", &Dtool_EggTexture_set_env_type_672, METH_O, (const char *)Dtool_EggTexture_set_env_type_672_comment},
  {"get_env_type", &Dtool_EggTexture_get_env_type_673, METH_NOARGS, (const char *)Dtool_EggTexture_get_env_type_673_comment},
  {"getEnvType", &Dtool_EggTexture_get_env_type_673, METH_NOARGS, (const char *)Dtool_EggTexture_get_env_type_673_comment},
  {"affects_polygon_alpha", &Dtool_EggTexture_affects_polygon_alpha_674, METH_NOARGS, (const char *)Dtool_EggTexture_affects_polygon_alpha_674_comment},
  {"affectsPolygonAlpha", &Dtool_EggTexture_affects_polygon_alpha_674, METH_NOARGS, (const char *)Dtool_EggTexture_affects_polygon_alpha_674_comment},
  {"set_combine_mode", (PyCFunction) &Dtool_EggTexture_set_combine_mode_675, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTexture_set_combine_mode_675_comment},
  {"setCombineMode", (PyCFunction) &Dtool_EggTexture_set_combine_mode_675, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTexture_set_combine_mode_675_comment},
  {"get_combine_mode", &Dtool_EggTexture_get_combine_mode_676, METH_O, (const char *)Dtool_EggTexture_get_combine_mode_676_comment},
  {"getCombineMode", &Dtool_EggTexture_get_combine_mode_676, METH_O, (const char *)Dtool_EggTexture_get_combine_mode_676_comment},
  {"set_combine_source", (PyCFunction) &Dtool_EggTexture_set_combine_source_677, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTexture_set_combine_source_677_comment},
  {"setCombineSource", (PyCFunction) &Dtool_EggTexture_set_combine_source_677, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTexture_set_combine_source_677_comment},
  {"get_combine_source", (PyCFunction) &Dtool_EggTexture_get_combine_source_678, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTexture_get_combine_source_678_comment},
  {"getCombineSource", (PyCFunction) &Dtool_EggTexture_get_combine_source_678, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTexture_get_combine_source_678_comment},
  {"set_combine_operand", (PyCFunction) &Dtool_EggTexture_set_combine_operand_679, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTexture_set_combine_operand_679_comment},
  {"setCombineOperand", (PyCFunction) &Dtool_EggTexture_set_combine_operand_679, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTexture_set_combine_operand_679_comment},
  {"get_combine_operand", (PyCFunction) &Dtool_EggTexture_get_combine_operand_680, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTexture_get_combine_operand_680_comment},
  {"getCombineOperand", (PyCFunction) &Dtool_EggTexture_get_combine_operand_680, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTexture_get_combine_operand_680_comment},
  {"set_saved_result", &Dtool_EggTexture_set_saved_result_681, METH_O, (const char *)Dtool_EggTexture_set_saved_result_681_comment},
  {"setSavedResult", &Dtool_EggTexture_set_saved_result_681, METH_O, (const char *)Dtool_EggTexture_set_saved_result_681_comment},
  {"get_saved_result", &Dtool_EggTexture_get_saved_result_682, METH_NOARGS, (const char *)Dtool_EggTexture_get_saved_result_682_comment},
  {"getSavedResult", &Dtool_EggTexture_get_saved_result_682, METH_NOARGS, (const char *)Dtool_EggTexture_get_saved_result_682_comment},
  {"set_tex_gen", &Dtool_EggTexture_set_tex_gen_683, METH_O, (const char *)Dtool_EggTexture_set_tex_gen_683_comment},
  {"setTexGen", &Dtool_EggTexture_set_tex_gen_683, METH_O, (const char *)Dtool_EggTexture_set_tex_gen_683_comment},
  {"get_tex_gen", &Dtool_EggTexture_get_tex_gen_684, METH_NOARGS, (const char *)Dtool_EggTexture_get_tex_gen_684_comment},
  {"getTexGen", &Dtool_EggTexture_get_tex_gen_684, METH_NOARGS, (const char *)Dtool_EggTexture_get_tex_gen_684_comment},
  {"set_quality_level", &Dtool_EggTexture_set_quality_level_685, METH_O, (const char *)Dtool_EggTexture_set_quality_level_685_comment},
  {"setQualityLevel", &Dtool_EggTexture_set_quality_level_685, METH_O, (const char *)Dtool_EggTexture_set_quality_level_685_comment},
  {"get_quality_level", &Dtool_EggTexture_get_quality_level_686, METH_NOARGS, (const char *)Dtool_EggTexture_get_quality_level_686_comment},
  {"getQualityLevel", &Dtool_EggTexture_get_quality_level_686, METH_NOARGS, (const char *)Dtool_EggTexture_get_quality_level_686_comment},
  {"set_stage_name", &Dtool_EggTexture_set_stage_name_687, METH_O, (const char *)Dtool_EggTexture_set_stage_name_687_comment},
  {"setStageName", &Dtool_EggTexture_set_stage_name_687, METH_O, (const char *)Dtool_EggTexture_set_stage_name_687_comment},
  {"clear_stage_name", &Dtool_EggTexture_clear_stage_name_688, METH_NOARGS, (const char *)Dtool_EggTexture_clear_stage_name_688_comment},
  {"clearStageName", &Dtool_EggTexture_clear_stage_name_688, METH_NOARGS, (const char *)Dtool_EggTexture_clear_stage_name_688_comment},
  {"has_stage_name", &Dtool_EggTexture_has_stage_name_689, METH_NOARGS, (const char *)Dtool_EggTexture_has_stage_name_689_comment},
  {"hasStageName", &Dtool_EggTexture_has_stage_name_689, METH_NOARGS, (const char *)Dtool_EggTexture_has_stage_name_689_comment},
  {"get_stage_name", &Dtool_EggTexture_get_stage_name_690, METH_NOARGS, (const char *)Dtool_EggTexture_get_stage_name_690_comment},
  {"getStageName", &Dtool_EggTexture_get_stage_name_690, METH_NOARGS, (const char *)Dtool_EggTexture_get_stage_name_690_comment},
  {"set_priority", &Dtool_EggTexture_set_priority_691, METH_O, (const char *)Dtool_EggTexture_set_priority_691_comment},
  {"setPriority", &Dtool_EggTexture_set_priority_691, METH_O, (const char *)Dtool_EggTexture_set_priority_691_comment},
  {"clear_priority", &Dtool_EggTexture_clear_priority_692, METH_NOARGS, (const char *)Dtool_EggTexture_clear_priority_692_comment},
  {"clearPriority", &Dtool_EggTexture_clear_priority_692, METH_NOARGS, (const char *)Dtool_EggTexture_clear_priority_692_comment},
  {"has_priority", &Dtool_EggTexture_has_priority_693, METH_NOARGS, (const char *)Dtool_EggTexture_has_priority_693_comment},
  {"hasPriority", &Dtool_EggTexture_has_priority_693, METH_NOARGS, (const char *)Dtool_EggTexture_has_priority_693_comment},
  {"get_priority", &Dtool_EggTexture_get_priority_694, METH_NOARGS, (const char *)Dtool_EggTexture_get_priority_694_comment},
  {"getPriority", &Dtool_EggTexture_get_priority_694, METH_NOARGS, (const char *)Dtool_EggTexture_get_priority_694_comment},
  {"set_color", &Dtool_EggTexture_set_color_695, METH_O, (const char *)Dtool_EggTexture_set_color_695_comment},
  {"setColor", &Dtool_EggTexture_set_color_695, METH_O, (const char *)Dtool_EggTexture_set_color_695_comment},
  {"clear_color", &Dtool_EggTexture_clear_color_696, METH_NOARGS, (const char *)Dtool_EggTexture_clear_color_696_comment},
  {"clearColor", &Dtool_EggTexture_clear_color_696, METH_NOARGS, (const char *)Dtool_EggTexture_clear_color_696_comment},
  {"has_color", &Dtool_EggTexture_has_color_697, METH_NOARGS, (const char *)Dtool_EggTexture_has_color_697_comment},
  {"hasColor", &Dtool_EggTexture_has_color_697, METH_NOARGS, (const char *)Dtool_EggTexture_has_color_697_comment},
  {"get_color", &Dtool_EggTexture_get_color_698, METH_NOARGS, (const char *)Dtool_EggTexture_get_color_698_comment},
  {"getColor", &Dtool_EggTexture_get_color_698, METH_NOARGS, (const char *)Dtool_EggTexture_get_color_698_comment},
  {"set_border_color", &Dtool_EggTexture_set_border_color_699, METH_O, (const char *)Dtool_EggTexture_set_border_color_699_comment},
  {"setBorderColor", &Dtool_EggTexture_set_border_color_699, METH_O, (const char *)Dtool_EggTexture_set_border_color_699_comment},
  {"clear_border_color", &Dtool_EggTexture_clear_border_color_700, METH_NOARGS, (const char *)Dtool_EggTexture_clear_border_color_700_comment},
  {"clearBorderColor", &Dtool_EggTexture_clear_border_color_700, METH_NOARGS, (const char *)Dtool_EggTexture_clear_border_color_700_comment},
  {"has_border_color", &Dtool_EggTexture_has_border_color_701, METH_NOARGS, (const char *)Dtool_EggTexture_has_border_color_701_comment},
  {"hasBorderColor", &Dtool_EggTexture_has_border_color_701, METH_NOARGS, (const char *)Dtool_EggTexture_has_border_color_701_comment},
  {"get_border_color", &Dtool_EggTexture_get_border_color_702, METH_NOARGS, (const char *)Dtool_EggTexture_get_border_color_702_comment},
  {"getBorderColor", &Dtool_EggTexture_get_border_color_702, METH_NOARGS, (const char *)Dtool_EggTexture_get_border_color_702_comment},
  {"set_uv_name", &Dtool_EggTexture_set_uv_name_703, METH_O, (const char *)Dtool_EggTexture_set_uv_name_703_comment},
  {"setUvName", &Dtool_EggTexture_set_uv_name_703, METH_O, (const char *)Dtool_EggTexture_set_uv_name_703_comment},
  {"clear_uv_name", &Dtool_EggTexture_clear_uv_name_704, METH_NOARGS, (const char *)Dtool_EggTexture_clear_uv_name_704_comment},
  {"clearUvName", &Dtool_EggTexture_clear_uv_name_704, METH_NOARGS, (const char *)Dtool_EggTexture_clear_uv_name_704_comment},
  {"has_uv_name", &Dtool_EggTexture_has_uv_name_705, METH_NOARGS, (const char *)Dtool_EggTexture_has_uv_name_705_comment},
  {"hasUvName", &Dtool_EggTexture_has_uv_name_705, METH_NOARGS, (const char *)Dtool_EggTexture_has_uv_name_705_comment},
  {"get_uv_name", &Dtool_EggTexture_get_uv_name_706, METH_NOARGS, (const char *)Dtool_EggTexture_get_uv_name_706_comment},
  {"getUvName", &Dtool_EggTexture_get_uv_name_706, METH_NOARGS, (const char *)Dtool_EggTexture_get_uv_name_706_comment},
  {"set_rgb_scale", &Dtool_EggTexture_set_rgb_scale_707, METH_O, (const char *)Dtool_EggTexture_set_rgb_scale_707_comment},
  {"setRgbScale", &Dtool_EggTexture_set_rgb_scale_707, METH_O, (const char *)Dtool_EggTexture_set_rgb_scale_707_comment},
  {"clear_rgb_scale", &Dtool_EggTexture_clear_rgb_scale_708, METH_NOARGS, (const char *)Dtool_EggTexture_clear_rgb_scale_708_comment},
  {"clearRgbScale", &Dtool_EggTexture_clear_rgb_scale_708, METH_NOARGS, (const char *)Dtool_EggTexture_clear_rgb_scale_708_comment},
  {"has_rgb_scale", &Dtool_EggTexture_has_rgb_scale_709, METH_NOARGS, (const char *)Dtool_EggTexture_has_rgb_scale_709_comment},
  {"hasRgbScale", &Dtool_EggTexture_has_rgb_scale_709, METH_NOARGS, (const char *)Dtool_EggTexture_has_rgb_scale_709_comment},
  {"get_rgb_scale", &Dtool_EggTexture_get_rgb_scale_710, METH_NOARGS, (const char *)Dtool_EggTexture_get_rgb_scale_710_comment},
  {"getRgbScale", &Dtool_EggTexture_get_rgb_scale_710, METH_NOARGS, (const char *)Dtool_EggTexture_get_rgb_scale_710_comment},
  {"set_alpha_scale", &Dtool_EggTexture_set_alpha_scale_711, METH_O, (const char *)Dtool_EggTexture_set_alpha_scale_711_comment},
  {"setAlphaScale", &Dtool_EggTexture_set_alpha_scale_711, METH_O, (const char *)Dtool_EggTexture_set_alpha_scale_711_comment},
  {"clear_alpha_scale", &Dtool_EggTexture_clear_alpha_scale_712, METH_NOARGS, (const char *)Dtool_EggTexture_clear_alpha_scale_712_comment},
  {"clearAlphaScale", &Dtool_EggTexture_clear_alpha_scale_712, METH_NOARGS, (const char *)Dtool_EggTexture_clear_alpha_scale_712_comment},
  {"has_alpha_scale", &Dtool_EggTexture_has_alpha_scale_713, METH_NOARGS, (const char *)Dtool_EggTexture_has_alpha_scale_713_comment},
  {"hasAlphaScale", &Dtool_EggTexture_has_alpha_scale_713, METH_NOARGS, (const char *)Dtool_EggTexture_has_alpha_scale_713_comment},
  {"get_alpha_scale", &Dtool_EggTexture_get_alpha_scale_714, METH_NOARGS, (const char *)Dtool_EggTexture_get_alpha_scale_714_comment},
  {"getAlphaScale", &Dtool_EggTexture_get_alpha_scale_714, METH_NOARGS, (const char *)Dtool_EggTexture_get_alpha_scale_714_comment},
  {"set_alpha_filename", &Dtool_EggTexture_set_alpha_filename_715, METH_O, (const char *)Dtool_EggTexture_set_alpha_filename_715_comment},
  {"setAlphaFilename", &Dtool_EggTexture_set_alpha_filename_715, METH_O, (const char *)Dtool_EggTexture_set_alpha_filename_715_comment},
  {"clear_alpha_filename", &Dtool_EggTexture_clear_alpha_filename_716, METH_NOARGS, (const char *)Dtool_EggTexture_clear_alpha_filename_716_comment},
  {"clearAlphaFilename", &Dtool_EggTexture_clear_alpha_filename_716, METH_NOARGS, (const char *)Dtool_EggTexture_clear_alpha_filename_716_comment},
  {"has_alpha_filename", &Dtool_EggTexture_has_alpha_filename_717, METH_NOARGS, (const char *)Dtool_EggTexture_has_alpha_filename_717_comment},
  {"hasAlphaFilename", &Dtool_EggTexture_has_alpha_filename_717, METH_NOARGS, (const char *)Dtool_EggTexture_has_alpha_filename_717_comment},
  {"get_alpha_filename", &Dtool_EggTexture_get_alpha_filename_718, METH_NOARGS, (const char *)Dtool_EggTexture_get_alpha_filename_718_comment},
  {"getAlphaFilename", &Dtool_EggTexture_get_alpha_filename_718, METH_NOARGS, (const char *)Dtool_EggTexture_get_alpha_filename_718_comment},
  {"set_alpha_fullpath", &Dtool_EggTexture_set_alpha_fullpath_719, METH_O, (const char *)Dtool_EggTexture_set_alpha_fullpath_719_comment},
  {"setAlphaFullpath", &Dtool_EggTexture_set_alpha_fullpath_719, METH_O, (const char *)Dtool_EggTexture_set_alpha_fullpath_719_comment},
  {"get_alpha_fullpath", &Dtool_EggTexture_get_alpha_fullpath_720, METH_NOARGS, (const char *)Dtool_EggTexture_get_alpha_fullpath_720_comment},
  {"getAlphaFullpath", &Dtool_EggTexture_get_alpha_fullpath_720, METH_NOARGS, (const char *)Dtool_EggTexture_get_alpha_fullpath_720_comment},
  {"set_alpha_file_channel", &Dtool_EggTexture_set_alpha_file_channel_721, METH_O, (const char *)Dtool_EggTexture_set_alpha_file_channel_721_comment},
  {"setAlphaFileChannel", &Dtool_EggTexture_set_alpha_file_channel_721, METH_O, (const char *)Dtool_EggTexture_set_alpha_file_channel_721_comment},
  {"clear_alpha_file_channel", &Dtool_EggTexture_clear_alpha_file_channel_722, METH_NOARGS, (const char *)Dtool_EggTexture_clear_alpha_file_channel_722_comment},
  {"clearAlphaFileChannel", &Dtool_EggTexture_clear_alpha_file_channel_722, METH_NOARGS, (const char *)Dtool_EggTexture_clear_alpha_file_channel_722_comment},
  {"has_alpha_file_channel", &Dtool_EggTexture_has_alpha_file_channel_723, METH_NOARGS, (const char *)Dtool_EggTexture_has_alpha_file_channel_723_comment},
  {"hasAlphaFileChannel", &Dtool_EggTexture_has_alpha_file_channel_723, METH_NOARGS, (const char *)Dtool_EggTexture_has_alpha_file_channel_723_comment},
  {"get_alpha_file_channel", &Dtool_EggTexture_get_alpha_file_channel_724, METH_NOARGS, (const char *)Dtool_EggTexture_get_alpha_file_channel_724_comment},
  {"getAlphaFileChannel", &Dtool_EggTexture_get_alpha_file_channel_724, METH_NOARGS, (const char *)Dtool_EggTexture_get_alpha_file_channel_724_comment},
  {"set_multiview", &Dtool_EggTexture_set_multiview_725, METH_O, (const char *)Dtool_EggTexture_set_multiview_725_comment},
  {"setMultiview", &Dtool_EggTexture_set_multiview_725, METH_O, (const char *)Dtool_EggTexture_set_multiview_725_comment},
  {"get_multiview", &Dtool_EggTexture_get_multiview_726, METH_NOARGS, (const char *)Dtool_EggTexture_get_multiview_726_comment},
  {"getMultiview", &Dtool_EggTexture_get_multiview_726, METH_NOARGS, (const char *)Dtool_EggTexture_get_multiview_726_comment},
  {"set_num_views", &Dtool_EggTexture_set_num_views_727, METH_O, (const char *)Dtool_EggTexture_set_num_views_727_comment},
  {"setNumViews", &Dtool_EggTexture_set_num_views_727, METH_O, (const char *)Dtool_EggTexture_set_num_views_727_comment},
  {"clear_num_views", &Dtool_EggTexture_clear_num_views_728, METH_NOARGS, (const char *)Dtool_EggTexture_clear_num_views_728_comment},
  {"clearNumViews", &Dtool_EggTexture_clear_num_views_728, METH_NOARGS, (const char *)Dtool_EggTexture_clear_num_views_728_comment},
  {"has_num_views", &Dtool_EggTexture_has_num_views_729, METH_NOARGS, (const char *)Dtool_EggTexture_has_num_views_729_comment},
  {"hasNumViews", &Dtool_EggTexture_has_num_views_729, METH_NOARGS, (const char *)Dtool_EggTexture_has_num_views_729_comment},
  {"get_num_views", &Dtool_EggTexture_get_num_views_730, METH_NOARGS, (const char *)Dtool_EggTexture_get_num_views_730_comment},
  {"getNumViews", &Dtool_EggTexture_get_num_views_730, METH_NOARGS, (const char *)Dtool_EggTexture_get_num_views_730_comment},
  {"set_read_mipmaps", &Dtool_EggTexture_set_read_mipmaps_731, METH_O, (const char *)Dtool_EggTexture_set_read_mipmaps_731_comment},
  {"setReadMipmaps", &Dtool_EggTexture_set_read_mipmaps_731, METH_O, (const char *)Dtool_EggTexture_set_read_mipmaps_731_comment},
  {"get_read_mipmaps", &Dtool_EggTexture_get_read_mipmaps_732, METH_NOARGS, (const char *)Dtool_EggTexture_get_read_mipmaps_732_comment},
  {"getReadMipmaps", &Dtool_EggTexture_get_read_mipmaps_732, METH_NOARGS, (const char *)Dtool_EggTexture_get_read_mipmaps_732_comment},
  {"set_min_lod", &Dtool_EggTexture_set_min_lod_733, METH_O, (const char *)Dtool_EggTexture_set_min_lod_733_comment},
  {"setMinLod", &Dtool_EggTexture_set_min_lod_733, METH_O, (const char *)Dtool_EggTexture_set_min_lod_733_comment},
  {"clear_min_lod", &Dtool_EggTexture_clear_min_lod_734, METH_NOARGS, (const char *)Dtool_EggTexture_clear_min_lod_734_comment},
  {"clearMinLod", &Dtool_EggTexture_clear_min_lod_734, METH_NOARGS, (const char *)Dtool_EggTexture_clear_min_lod_734_comment},
  {"has_min_lod", &Dtool_EggTexture_has_min_lod_735, METH_NOARGS, (const char *)Dtool_EggTexture_has_min_lod_735_comment},
  {"hasMinLod", &Dtool_EggTexture_has_min_lod_735, METH_NOARGS, (const char *)Dtool_EggTexture_has_min_lod_735_comment},
  {"get_min_lod", &Dtool_EggTexture_get_min_lod_736, METH_NOARGS, (const char *)Dtool_EggTexture_get_min_lod_736_comment},
  {"getMinLod", &Dtool_EggTexture_get_min_lod_736, METH_NOARGS, (const char *)Dtool_EggTexture_get_min_lod_736_comment},
  {"set_max_lod", &Dtool_EggTexture_set_max_lod_737, METH_O, (const char *)Dtool_EggTexture_set_max_lod_737_comment},
  {"setMaxLod", &Dtool_EggTexture_set_max_lod_737, METH_O, (const char *)Dtool_EggTexture_set_max_lod_737_comment},
  {"clear_max_lod", &Dtool_EggTexture_clear_max_lod_738, METH_NOARGS, (const char *)Dtool_EggTexture_clear_max_lod_738_comment},
  {"clearMaxLod", &Dtool_EggTexture_clear_max_lod_738, METH_NOARGS, (const char *)Dtool_EggTexture_clear_max_lod_738_comment},
  {"has_max_lod", &Dtool_EggTexture_has_max_lod_739, METH_NOARGS, (const char *)Dtool_EggTexture_has_max_lod_739_comment},
  {"hasMaxLod", &Dtool_EggTexture_has_max_lod_739, METH_NOARGS, (const char *)Dtool_EggTexture_has_max_lod_739_comment},
  {"get_max_lod", &Dtool_EggTexture_get_max_lod_740, METH_NOARGS, (const char *)Dtool_EggTexture_get_max_lod_740_comment},
  {"getMaxLod", &Dtool_EggTexture_get_max_lod_740, METH_NOARGS, (const char *)Dtool_EggTexture_get_max_lod_740_comment},
  {"set_lod_bias", &Dtool_EggTexture_set_lod_bias_741, METH_O, (const char *)Dtool_EggTexture_set_lod_bias_741_comment},
  {"setLodBias", &Dtool_EggTexture_set_lod_bias_741, METH_O, (const char *)Dtool_EggTexture_set_lod_bias_741_comment},
  {"clear_lod_bias", &Dtool_EggTexture_clear_lod_bias_742, METH_NOARGS, (const char *)Dtool_EggTexture_clear_lod_bias_742_comment},
  {"clearLodBias", &Dtool_EggTexture_clear_lod_bias_742, METH_NOARGS, (const char *)Dtool_EggTexture_clear_lod_bias_742_comment},
  {"has_lod_bias", &Dtool_EggTexture_has_lod_bias_743, METH_NOARGS, (const char *)Dtool_EggTexture_has_lod_bias_743_comment},
  {"hasLodBias", &Dtool_EggTexture_has_lod_bias_743, METH_NOARGS, (const char *)Dtool_EggTexture_has_lod_bias_743_comment},
  {"get_lod_bias", &Dtool_EggTexture_get_lod_bias_744, METH_NOARGS, (const char *)Dtool_EggTexture_get_lod_bias_744_comment},
  {"getLodBias", &Dtool_EggTexture_get_lod_bias_744, METH_NOARGS, (const char *)Dtool_EggTexture_get_lod_bias_744_comment},
  {"clear_multitexture", &Dtool_EggTexture_clear_multitexture_745, METH_NOARGS, (const char *)Dtool_EggTexture_clear_multitexture_745_comment},
  {"clearMultitexture", &Dtool_EggTexture_clear_multitexture_745, METH_NOARGS, (const char *)Dtool_EggTexture_clear_multitexture_745_comment},
  {"multitexture_over", &Dtool_EggTexture_multitexture_over_746, METH_O, (const char *)Dtool_EggTexture_multitexture_over_746_comment},
  {"multitextureOver", &Dtool_EggTexture_multitexture_over_746, METH_O, (const char *)Dtool_EggTexture_multitexture_over_746_comment},
  {"get_multitexture_sort", &Dtool_EggTexture_get_multitexture_sort_747, METH_NOARGS, (const char *)Dtool_EggTexture_get_multitexture_sort_747_comment},
  {"getMultitextureSort", &Dtool_EggTexture_get_multitexture_sort_747, METH_NOARGS, (const char *)Dtool_EggTexture_get_multitexture_sort_747_comment},
  {"string_texture_type", &Dtool_EggTexture_string_texture_type_748, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_texture_type_748_comment},
  {"stringTextureType", &Dtool_EggTexture_string_texture_type_748, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_texture_type_748_comment},
  {"string_format", &Dtool_EggTexture_string_format_749, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_format_749_comment},
  {"stringFormat", &Dtool_EggTexture_string_format_749, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_format_749_comment},
  {"string_compression_mode", &Dtool_EggTexture_string_compression_mode_750, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_compression_mode_750_comment},
  {"stringCompressionMode", &Dtool_EggTexture_string_compression_mode_750, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_compression_mode_750_comment},
  {"string_wrap_mode", &Dtool_EggTexture_string_wrap_mode_751, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_wrap_mode_751_comment},
  {"stringWrapMode", &Dtool_EggTexture_string_wrap_mode_751, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_wrap_mode_751_comment},
  {"string_filter_type", &Dtool_EggTexture_string_filter_type_752, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_filter_type_752_comment},
  {"stringFilterType", &Dtool_EggTexture_string_filter_type_752, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_filter_type_752_comment},
  {"string_env_type", &Dtool_EggTexture_string_env_type_753, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_env_type_753_comment},
  {"stringEnvType", &Dtool_EggTexture_string_env_type_753, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_env_type_753_comment},
  {"string_combine_mode", &Dtool_EggTexture_string_combine_mode_754, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_combine_mode_754_comment},
  {"stringCombineMode", &Dtool_EggTexture_string_combine_mode_754, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_combine_mode_754_comment},
  {"string_combine_source", &Dtool_EggTexture_string_combine_source_755, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_combine_source_755_comment},
  {"stringCombineSource", &Dtool_EggTexture_string_combine_source_755, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_combine_source_755_comment},
  {"string_combine_operand", &Dtool_EggTexture_string_combine_operand_756, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_combine_operand_756_comment},
  {"stringCombineOperand", &Dtool_EggTexture_string_combine_operand_756, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_combine_operand_756_comment},
  {"string_tex_gen", &Dtool_EggTexture_string_tex_gen_757, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_tex_gen_757_comment},
  {"stringTexGen", &Dtool_EggTexture_string_tex_gen_757, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_tex_gen_757_comment},
  {"string_quality_level", &Dtool_EggTexture_string_quality_level_758, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_quality_level_758_comment},
  {"stringQualityLevel", &Dtool_EggTexture_string_quality_level_758, METH_O | METH_STATIC, (const char *)Dtool_EggTexture_string_quality_level_758_comment},
  {"get_class_type", &Dtool_EggTexture_get_class_type_792, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggTexture_get_class_type_792_comment},
  {"getClassType", &Dtool_EggTexture_get_class_type_792, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggTexture_get_class_type_792_comment},
  {"upcast_to_EggFilenameNode", &Dtool_EggTexture_upcast_to_EggFilenameNode_620, METH_NOARGS, (const char *)Dtool_EggTexture_upcast_to_EggFilenameNode_620_comment},
  {"upcastToEggFilenameNode", &Dtool_EggTexture_upcast_to_EggFilenameNode_620, METH_NOARGS, (const char *)Dtool_EggTexture_upcast_to_EggFilenameNode_620_comment},
  {"upcast_to_EggRenderMode", &Dtool_EggTexture_upcast_to_EggRenderMode_622, METH_NOARGS, (const char *)Dtool_EggTexture_upcast_to_EggRenderMode_622_comment},
  {"upcastToEggRenderMode", &Dtool_EggTexture_upcast_to_EggRenderMode_622, METH_NOARGS, (const char *)Dtool_EggTexture_upcast_to_EggRenderMode_622_comment},
  {"upcast_to_EggTransform", &Dtool_EggTexture_upcast_to_EggTransform_624, METH_NOARGS, (const char *)Dtool_EggTexture_upcast_to_EggTransform_624_comment},
  {"upcastToEggTransform", &Dtool_EggTexture_upcast_to_EggTransform_624, METH_NOARGS, (const char *)Dtool_EggTexture_upcast_to_EggTransform_624_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     EggTexture
//////////////////
static PyObject *Dtool_Str_EggTexture(PyObject *self) {
  EggTexture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTexture, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_EggTexture[] = {
  {(char *)"texture_type", &Dtool_EggTexture_texture_type_Getter, &Dtool_EggTexture_texture_type_Setter, nullptr, nullptr},
  {(char *)"format", &Dtool_EggTexture_format_Getter, &Dtool_EggTexture_format_Setter, nullptr, nullptr},
  {(char *)"compression_mode", &Dtool_EggTexture_compression_mode_Getter, &Dtool_EggTexture_compression_mode_Setter, nullptr, nullptr},
  {(char *)"wrap_mode", &Dtool_EggTexture_wrap_mode_Getter, &Dtool_EggTexture_wrap_mode_Setter, nullptr, nullptr},
  {(char *)"wrap_u", &Dtool_EggTexture_wrap_u_Getter, &Dtool_EggTexture_wrap_u_Setter, nullptr, nullptr},
  {(char *)"wrap_v", &Dtool_EggTexture_wrap_v_Getter, &Dtool_EggTexture_wrap_v_Setter, nullptr, nullptr},
  {(char *)"wrap_w", &Dtool_EggTexture_wrap_w_Getter, &Dtool_EggTexture_wrap_w_Setter, nullptr, nullptr},
  {(char *)"minfilter", &Dtool_EggTexture_minfilter_Getter, &Dtool_EggTexture_minfilter_Setter, nullptr, nullptr},
  {(char *)"magfilter", &Dtool_EggTexture_magfilter_Getter, &Dtool_EggTexture_magfilter_Setter, nullptr, nullptr},
  {(char *)"anisotropic_degree", &Dtool_EggTexture_anisotropic_degree_Getter, &Dtool_EggTexture_anisotropic_degree_Setter, nullptr, nullptr},
  {(char *)"env_type", &Dtool_EggTexture_env_type_Getter, &Dtool_EggTexture_env_type_Setter, nullptr, nullptr},
  {(char *)"saved_result", &Dtool_EggTexture_saved_result_Getter, &Dtool_EggTexture_saved_result_Setter, nullptr, nullptr},
  {(char *)"tex_gen", &Dtool_EggTexture_tex_gen_Getter, &Dtool_EggTexture_tex_gen_Setter, nullptr, nullptr},
  {(char *)"quality_level", &Dtool_EggTexture_quality_level_Getter, &Dtool_EggTexture_quality_level_Setter, nullptr, nullptr},
  {(char *)"stage_name", &Dtool_EggTexture_stage_name_Getter, &Dtool_EggTexture_stage_name_Setter, nullptr, nullptr},
  {(char *)"priority", &Dtool_EggTexture_priority_Getter, &Dtool_EggTexture_priority_Setter, nullptr, nullptr},
  {(char *)"color", &Dtool_EggTexture_color_Getter, &Dtool_EggTexture_color_Setter, nullptr, nullptr},
  {(char *)"border_color", &Dtool_EggTexture_border_color_Getter, &Dtool_EggTexture_border_color_Setter, nullptr, nullptr},
  {(char *)"uv_name", &Dtool_EggTexture_uv_name_Getter, &Dtool_EggTexture_uv_name_Setter, nullptr, nullptr},
  {(char *)"rgb_scale", &Dtool_EggTexture_rgb_scale_Getter, &Dtool_EggTexture_rgb_scale_Setter, nullptr, nullptr},
  {(char *)"alpha_scale", &Dtool_EggTexture_alpha_scale_Getter, &Dtool_EggTexture_alpha_scale_Setter, nullptr, nullptr},
  {(char *)"alpha_filename", &Dtool_EggTexture_alpha_filename_Getter, &Dtool_EggTexture_alpha_filename_Setter, nullptr, nullptr},
  {(char *)"alpha_fullpath", &Dtool_EggTexture_alpha_fullpath_Getter, &Dtool_EggTexture_alpha_fullpath_Setter, nullptr, nullptr},
  {(char *)"alpha_file_channel", &Dtool_EggTexture_alpha_file_channel_Getter, &Dtool_EggTexture_alpha_file_channel_Setter, nullptr, nullptr},
  {(char *)"multiview", &Dtool_EggTexture_multiview_Getter, &Dtool_EggTexture_multiview_Setter, nullptr, nullptr},
  {(char *)"num_views", &Dtool_EggTexture_num_views_Getter, &Dtool_EggTexture_num_views_Setter, nullptr, nullptr},
  {(char *)"read_mipmaps", &Dtool_EggTexture_read_mipmaps_Getter, &Dtool_EggTexture_read_mipmaps_Setter, nullptr, nullptr},
  {(char *)"min_lod", &Dtool_EggTexture_min_lod_Getter, &Dtool_EggTexture_min_lod_Setter, nullptr, nullptr},
  {(char *)"max_lod", &Dtool_EggTexture_max_lod_Getter, &Dtool_EggTexture_max_lod_Setter, nullptr, nullptr},
  {(char *)"lod_bias", &Dtool_EggTexture_lod_bias_Getter, &Dtool_EggTexture_lod_bias_Setter, nullptr, nullptr},
  {(char *)"multitexture_sort", &Dtool_EggTexture_multitexture_sort_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_EggTexture = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggTexture = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggTexture = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggTexture = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggTexture = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggTexture = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggTexture",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggTexture,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggTexture,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggTexture,
    &Dtool_SequenceMethods_EggTexture,
    &Dtool_MappingMethods_EggTexture,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_EggTexture,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggTexture,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Defines a texture map that may be applied to geometry.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggTexture,
    nullptr, // tp_members
    Dtool_Properties_EggTexture,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggTexture,
    PyType_GenericAlloc,
    Dtool_new_EggTexture,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggTexture,
  Dtool_UpcastInterface_EggTexture,
  Dtool_DowncastInterface_EggTexture,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggTexture(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggFilenameNode(nullptr);
    Dtool_PyModuleClassInit_EggRenderMode(nullptr);
    Dtool_PyModuleClassInit_EggTransform(nullptr);
    Dtool_EggTexture._PyType.tp_bases = PyTuple_Pack(3, (PyTypeObject *)&Dtool_EggFilenameNode, (PyTypeObject *)&Dtool_EggRenderMode, (PyTypeObject *)&Dtool_EggTransform);
    Dtool_EggTexture._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(217);
    Dtool_EggTexture._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum EggTexture::Equivalence;
    PyDict_SetItemString(dict, "E_basename", Dtool_WrapValue(EggTexture::E_basename));
    PyDict_SetItemString(dict, "EBasename", Dtool_WrapValue(EggTexture::E_basename));
    PyDict_SetItemString(dict, "E_extension", Dtool_WrapValue(EggTexture::E_extension));
    PyDict_SetItemString(dict, "EExtension", Dtool_WrapValue(EggTexture::E_extension));
    PyDict_SetItemString(dict, "E_dirname", Dtool_WrapValue(EggTexture::E_dirname));
    PyDict_SetItemString(dict, "EDirname", Dtool_WrapValue(EggTexture::E_dirname));
    PyDict_SetItemString(dict, "E_complete_filename", Dtool_WrapValue(EggTexture::E_complete_filename));
    PyDict_SetItemString(dict, "ECompleteFilename", Dtool_WrapValue(EggTexture::E_complete_filename));
    PyDict_SetItemString(dict, "E_transform", Dtool_WrapValue(EggTexture::E_transform));
    PyDict_SetItemString(dict, "ETransform", Dtool_WrapValue(EggTexture::E_transform));
    PyDict_SetItemString(dict, "E_attributes", Dtool_WrapValue(EggTexture::E_attributes));
    PyDict_SetItemString(dict, "EAttributes", Dtool_WrapValue(EggTexture::E_attributes));
    PyDict_SetItemString(dict, "E_tref_name", Dtool_WrapValue(EggTexture::E_tref_name));
    PyDict_SetItemString(dict, "ETrefName", Dtool_WrapValue(EggTexture::E_tref_name));
    // enum EggTexture::TextureType;
    PyDict_SetItemString(dict, "TT_unspecified", Dtool_WrapValue(EggTexture::TT_unspecified));
    PyDict_SetItemString(dict, "TTUnspecified", Dtool_WrapValue(EggTexture::TT_unspecified));
    PyDict_SetItemString(dict, "TT_1d_texture", Dtool_WrapValue(EggTexture::TT_1d_texture));
    PyDict_SetItemString(dict, "TT1dTexture", Dtool_WrapValue(EggTexture::TT_1d_texture));
    PyDict_SetItemString(dict, "TT_2d_texture", Dtool_WrapValue(EggTexture::TT_2d_texture));
    PyDict_SetItemString(dict, "TT2dTexture", Dtool_WrapValue(EggTexture::TT_2d_texture));
    PyDict_SetItemString(dict, "TT_3d_texture", Dtool_WrapValue(EggTexture::TT_3d_texture));
    PyDict_SetItemString(dict, "TT3dTexture", Dtool_WrapValue(EggTexture::TT_3d_texture));
    PyDict_SetItemString(dict, "TT_cube_map", Dtool_WrapValue(EggTexture::TT_cube_map));
    PyDict_SetItemString(dict, "TTCubeMap", Dtool_WrapValue(EggTexture::TT_cube_map));
    // enum EggTexture::Format;
    PyDict_SetItemString(dict, "F_unspecified", Dtool_WrapValue(EggTexture::F_unspecified));
    PyDict_SetItemString(dict, "FUnspecified", Dtool_WrapValue(EggTexture::F_unspecified));
    PyDict_SetItemString(dict, "F_rgba", Dtool_WrapValue(EggTexture::F_rgba));
    PyDict_SetItemString(dict, "FRgba", Dtool_WrapValue(EggTexture::F_rgba));
    PyDict_SetItemString(dict, "F_rgbm", Dtool_WrapValue(EggTexture::F_rgbm));
    PyDict_SetItemString(dict, "FRgbm", Dtool_WrapValue(EggTexture::F_rgbm));
    PyDict_SetItemString(dict, "F_rgba12", Dtool_WrapValue(EggTexture::F_rgba12));
    PyDict_SetItemString(dict, "FRgba12", Dtool_WrapValue(EggTexture::F_rgba12));
    PyDict_SetItemString(dict, "F_rgba8", Dtool_WrapValue(EggTexture::F_rgba8));
    PyDict_SetItemString(dict, "FRgba8", Dtool_WrapValue(EggTexture::F_rgba8));
    PyDict_SetItemString(dict, "F_rgba4", Dtool_WrapValue(EggTexture::F_rgba4));
    PyDict_SetItemString(dict, "FRgba4", Dtool_WrapValue(EggTexture::F_rgba4));
    PyDict_SetItemString(dict, "F_rgba5", Dtool_WrapValue(EggTexture::F_rgba5));
    PyDict_SetItemString(dict, "FRgba5", Dtool_WrapValue(EggTexture::F_rgba5));
    PyDict_SetItemString(dict, "F_rgb", Dtool_WrapValue(EggTexture::F_rgb));
    PyDict_SetItemString(dict, "FRgb", Dtool_WrapValue(EggTexture::F_rgb));
    PyDict_SetItemString(dict, "F_rgb12", Dtool_WrapValue(EggTexture::F_rgb12));
    PyDict_SetItemString(dict, "FRgb12", Dtool_WrapValue(EggTexture::F_rgb12));
    PyDict_SetItemString(dict, "F_rgb8", Dtool_WrapValue(EggTexture::F_rgb8));
    PyDict_SetItemString(dict, "FRgb8", Dtool_WrapValue(EggTexture::F_rgb8));
    PyDict_SetItemString(dict, "F_rgb5", Dtool_WrapValue(EggTexture::F_rgb5));
    PyDict_SetItemString(dict, "FRgb5", Dtool_WrapValue(EggTexture::F_rgb5));
    PyDict_SetItemString(dict, "F_rgb332", Dtool_WrapValue(EggTexture::F_rgb332));
    PyDict_SetItemString(dict, "FRgb332", Dtool_WrapValue(EggTexture::F_rgb332));
    PyDict_SetItemString(dict, "F_red", Dtool_WrapValue(EggTexture::F_red));
    PyDict_SetItemString(dict, "FRed", Dtool_WrapValue(EggTexture::F_red));
    PyDict_SetItemString(dict, "F_green", Dtool_WrapValue(EggTexture::F_green));
    PyDict_SetItemString(dict, "FGreen", Dtool_WrapValue(EggTexture::F_green));
    PyDict_SetItemString(dict, "F_blue", Dtool_WrapValue(EggTexture::F_blue));
    PyDict_SetItemString(dict, "FBlue", Dtool_WrapValue(EggTexture::F_blue));
    PyDict_SetItemString(dict, "F_alpha", Dtool_WrapValue(EggTexture::F_alpha));
    PyDict_SetItemString(dict, "FAlpha", Dtool_WrapValue(EggTexture::F_alpha));
    PyDict_SetItemString(dict, "F_luminance", Dtool_WrapValue(EggTexture::F_luminance));
    PyDict_SetItemString(dict, "FLuminance", Dtool_WrapValue(EggTexture::F_luminance));
    PyDict_SetItemString(dict, "F_luminance_alpha", Dtool_WrapValue(EggTexture::F_luminance_alpha));
    PyDict_SetItemString(dict, "FLuminanceAlpha", Dtool_WrapValue(EggTexture::F_luminance_alpha));
    PyDict_SetItemString(dict, "F_luminance_alphamask", Dtool_WrapValue(EggTexture::F_luminance_alphamask));
    PyDict_SetItemString(dict, "FLuminanceAlphamask", Dtool_WrapValue(EggTexture::F_luminance_alphamask));
    // enum EggTexture::CompressionMode;
    PyDict_SetItemString(dict, "CM_default", Dtool_WrapValue(EggTexture::CM_default));
    PyDict_SetItemString(dict, "CMDefault", Dtool_WrapValue(EggTexture::CM_default));
    PyDict_SetItemString(dict, "CM_off", Dtool_WrapValue(EggTexture::CM_off));
    PyDict_SetItemString(dict, "CMOff", Dtool_WrapValue(EggTexture::CM_off));
    PyDict_SetItemString(dict, "CM_on", Dtool_WrapValue(EggTexture::CM_on));
    PyDict_SetItemString(dict, "CMOn", Dtool_WrapValue(EggTexture::CM_on));
    PyDict_SetItemString(dict, "CM_fxt1", Dtool_WrapValue(EggTexture::CM_fxt1));
    PyDict_SetItemString(dict, "CMFxt1", Dtool_WrapValue(EggTexture::CM_fxt1));
    PyDict_SetItemString(dict, "CM_dxt1", Dtool_WrapValue(EggTexture::CM_dxt1));
    PyDict_SetItemString(dict, "CMDxt1", Dtool_WrapValue(EggTexture::CM_dxt1));
    PyDict_SetItemString(dict, "CM_dxt2", Dtool_WrapValue(EggTexture::CM_dxt2));
    PyDict_SetItemString(dict, "CMDxt2", Dtool_WrapValue(EggTexture::CM_dxt2));
    PyDict_SetItemString(dict, "CM_dxt3", Dtool_WrapValue(EggTexture::CM_dxt3));
    PyDict_SetItemString(dict, "CMDxt3", Dtool_WrapValue(EggTexture::CM_dxt3));
    PyDict_SetItemString(dict, "CM_dxt4", Dtool_WrapValue(EggTexture::CM_dxt4));
    PyDict_SetItemString(dict, "CMDxt4", Dtool_WrapValue(EggTexture::CM_dxt4));
    PyDict_SetItemString(dict, "CM_dxt5", Dtool_WrapValue(EggTexture::CM_dxt5));
    PyDict_SetItemString(dict, "CMDxt5", Dtool_WrapValue(EggTexture::CM_dxt5));
    // enum EggTexture::WrapMode;
    PyDict_SetItemString(dict, "WM_unspecified", Dtool_WrapValue(EggTexture::WM_unspecified));
    PyDict_SetItemString(dict, "WMUnspecified", Dtool_WrapValue(EggTexture::WM_unspecified));
    PyDict_SetItemString(dict, "WM_clamp", Dtool_WrapValue(EggTexture::WM_clamp));
    PyDict_SetItemString(dict, "WMClamp", Dtool_WrapValue(EggTexture::WM_clamp));
    PyDict_SetItemString(dict, "WM_repeat", Dtool_WrapValue(EggTexture::WM_repeat));
    PyDict_SetItemString(dict, "WMRepeat", Dtool_WrapValue(EggTexture::WM_repeat));
    PyDict_SetItemString(dict, "WM_mirror", Dtool_WrapValue(EggTexture::WM_mirror));
    PyDict_SetItemString(dict, "WMMirror", Dtool_WrapValue(EggTexture::WM_mirror));
    PyDict_SetItemString(dict, "WM_mirror_once", Dtool_WrapValue(EggTexture::WM_mirror_once));
    PyDict_SetItemString(dict, "WMMirrorOnce", Dtool_WrapValue(EggTexture::WM_mirror_once));
    PyDict_SetItemString(dict, "WM_border_color", Dtool_WrapValue(EggTexture::WM_border_color));
    PyDict_SetItemString(dict, "WMBorderColor", Dtool_WrapValue(EggTexture::WM_border_color));
    // enum EggTexture::FilterType;
    PyDict_SetItemString(dict, "FT_unspecified", Dtool_WrapValue(EggTexture::FT_unspecified));
    PyDict_SetItemString(dict, "FTUnspecified", Dtool_WrapValue(EggTexture::FT_unspecified));
    PyDict_SetItemString(dict, "FT_nearest", Dtool_WrapValue(EggTexture::FT_nearest));
    PyDict_SetItemString(dict, "FTNearest", Dtool_WrapValue(EggTexture::FT_nearest));
    PyDict_SetItemString(dict, "FT_linear", Dtool_WrapValue(EggTexture::FT_linear));
    PyDict_SetItemString(dict, "FTLinear", Dtool_WrapValue(EggTexture::FT_linear));
    PyDict_SetItemString(dict, "FT_nearest_mipmap_nearest", Dtool_WrapValue(EggTexture::FT_nearest_mipmap_nearest));
    PyDict_SetItemString(dict, "FTNearestMipmapNearest", Dtool_WrapValue(EggTexture::FT_nearest_mipmap_nearest));
    PyDict_SetItemString(dict, "FT_linear_mipmap_nearest", Dtool_WrapValue(EggTexture::FT_linear_mipmap_nearest));
    PyDict_SetItemString(dict, "FTLinearMipmapNearest", Dtool_WrapValue(EggTexture::FT_linear_mipmap_nearest));
    PyDict_SetItemString(dict, "FT_nearest_mipmap_linear", Dtool_WrapValue(EggTexture::FT_nearest_mipmap_linear));
    PyDict_SetItemString(dict, "FTNearestMipmapLinear", Dtool_WrapValue(EggTexture::FT_nearest_mipmap_linear));
    PyDict_SetItemString(dict, "FT_linear_mipmap_linear", Dtool_WrapValue(EggTexture::FT_linear_mipmap_linear));
    PyDict_SetItemString(dict, "FTLinearMipmapLinear", Dtool_WrapValue(EggTexture::FT_linear_mipmap_linear));
    // enum EggTexture::EnvType;
    PyDict_SetItemString(dict, "ET_unspecified", Dtool_WrapValue(EggTexture::ET_unspecified));
    PyDict_SetItemString(dict, "ETUnspecified", Dtool_WrapValue(EggTexture::ET_unspecified));
    PyDict_SetItemString(dict, "ET_modulate", Dtool_WrapValue(EggTexture::ET_modulate));
    PyDict_SetItemString(dict, "ETModulate", Dtool_WrapValue(EggTexture::ET_modulate));
    PyDict_SetItemString(dict, "ET_decal", Dtool_WrapValue(EggTexture::ET_decal));
    PyDict_SetItemString(dict, "ETDecal", Dtool_WrapValue(EggTexture::ET_decal));
    PyDict_SetItemString(dict, "ET_blend", Dtool_WrapValue(EggTexture::ET_blend));
    PyDict_SetItemString(dict, "ETBlend", Dtool_WrapValue(EggTexture::ET_blend));
    PyDict_SetItemString(dict, "ET_replace", Dtool_WrapValue(EggTexture::ET_replace));
    PyDict_SetItemString(dict, "ETReplace", Dtool_WrapValue(EggTexture::ET_replace));
    PyDict_SetItemString(dict, "ET_add", Dtool_WrapValue(EggTexture::ET_add));
    PyDict_SetItemString(dict, "ETAdd", Dtool_WrapValue(EggTexture::ET_add));
    PyDict_SetItemString(dict, "ET_blend_color_scale", Dtool_WrapValue(EggTexture::ET_blend_color_scale));
    PyDict_SetItemString(dict, "ETBlendColorScale", Dtool_WrapValue(EggTexture::ET_blend_color_scale));
    PyDict_SetItemString(dict, "ET_modulate_glow", Dtool_WrapValue(EggTexture::ET_modulate_glow));
    PyDict_SetItemString(dict, "ETModulateGlow", Dtool_WrapValue(EggTexture::ET_modulate_glow));
    PyDict_SetItemString(dict, "ET_modulate_gloss", Dtool_WrapValue(EggTexture::ET_modulate_gloss));
    PyDict_SetItemString(dict, "ETModulateGloss", Dtool_WrapValue(EggTexture::ET_modulate_gloss));
    PyDict_SetItemString(dict, "ET_normal", Dtool_WrapValue(EggTexture::ET_normal));
    PyDict_SetItemString(dict, "ETNormal", Dtool_WrapValue(EggTexture::ET_normal));
    PyDict_SetItemString(dict, "ET_normal_height", Dtool_WrapValue(EggTexture::ET_normal_height));
    PyDict_SetItemString(dict, "ETNormalHeight", Dtool_WrapValue(EggTexture::ET_normal_height));
    PyDict_SetItemString(dict, "ET_glow", Dtool_WrapValue(EggTexture::ET_glow));
    PyDict_SetItemString(dict, "ETGlow", Dtool_WrapValue(EggTexture::ET_glow));
    PyDict_SetItemString(dict, "ET_gloss", Dtool_WrapValue(EggTexture::ET_gloss));
    PyDict_SetItemString(dict, "ETGloss", Dtool_WrapValue(EggTexture::ET_gloss));
    PyDict_SetItemString(dict, "ET_height", Dtool_WrapValue(EggTexture::ET_height));
    PyDict_SetItemString(dict, "ETHeight", Dtool_WrapValue(EggTexture::ET_height));
    PyDict_SetItemString(dict, "ET_selector", Dtool_WrapValue(EggTexture::ET_selector));
    PyDict_SetItemString(dict, "ETSelector", Dtool_WrapValue(EggTexture::ET_selector));
    PyDict_SetItemString(dict, "ET_normal_gloss", Dtool_WrapValue(EggTexture::ET_normal_gloss));
    PyDict_SetItemString(dict, "ETNormalGloss", Dtool_WrapValue(EggTexture::ET_normal_gloss));
    // enum EggTexture::CombineMode;
    PyDict_SetItemString(dict, "CM_unspecified", Dtool_WrapValue(EggTexture::CM_unspecified));
    PyDict_SetItemString(dict, "CMUnspecified", Dtool_WrapValue(EggTexture::CM_unspecified));
    PyDict_SetItemString(dict, "CM_replace", Dtool_WrapValue(EggTexture::CM_replace));
    PyDict_SetItemString(dict, "CMReplace", Dtool_WrapValue(EggTexture::CM_replace));
    PyDict_SetItemString(dict, "CM_modulate", Dtool_WrapValue(EggTexture::CM_modulate));
    PyDict_SetItemString(dict, "CMModulate", Dtool_WrapValue(EggTexture::CM_modulate));
    PyDict_SetItemString(dict, "CM_add", Dtool_WrapValue(EggTexture::CM_add));
    PyDict_SetItemString(dict, "CMAdd", Dtool_WrapValue(EggTexture::CM_add));
    PyDict_SetItemString(dict, "CM_add_signed", Dtool_WrapValue(EggTexture::CM_add_signed));
    PyDict_SetItemString(dict, "CMAddSigned", Dtool_WrapValue(EggTexture::CM_add_signed));
    PyDict_SetItemString(dict, "CM_interpolate", Dtool_WrapValue(EggTexture::CM_interpolate));
    PyDict_SetItemString(dict, "CMInterpolate", Dtool_WrapValue(EggTexture::CM_interpolate));
    PyDict_SetItemString(dict, "CM_subtract", Dtool_WrapValue(EggTexture::CM_subtract));
    PyDict_SetItemString(dict, "CMSubtract", Dtool_WrapValue(EggTexture::CM_subtract));
    PyDict_SetItemString(dict, "CM_dot3_rgb", Dtool_WrapValue(EggTexture::CM_dot3_rgb));
    PyDict_SetItemString(dict, "CMDot3Rgb", Dtool_WrapValue(EggTexture::CM_dot3_rgb));
    PyDict_SetItemString(dict, "CM_dot3_rgba", Dtool_WrapValue(EggTexture::CM_dot3_rgba));
    PyDict_SetItemString(dict, "CMDot3Rgba", Dtool_WrapValue(EggTexture::CM_dot3_rgba));
    // enum EggTexture::CombineChannel;
    PyDict_SetItemString(dict, "CC_rgb", Dtool_WrapValue(EggTexture::CC_rgb));
    PyDict_SetItemString(dict, "CCRgb", Dtool_WrapValue(EggTexture::CC_rgb));
    PyDict_SetItemString(dict, "CC_alpha", Dtool_WrapValue(EggTexture::CC_alpha));
    PyDict_SetItemString(dict, "CCAlpha", Dtool_WrapValue(EggTexture::CC_alpha));
    PyDict_SetItemString(dict, "CC_num_channels", Dtool_WrapValue(EggTexture::CC_num_channels));
    PyDict_SetItemString(dict, "CCNumChannels", Dtool_WrapValue(EggTexture::CC_num_channels));
    // enum EggTexture::CombineIndex;
    PyDict_SetItemString(dict, "CI_num_indices", Dtool_WrapValue(EggTexture::CI_num_indices));
    PyDict_SetItemString(dict, "CINumIndices", Dtool_WrapValue(EggTexture::CI_num_indices));
    // enum EggTexture::CombineSource;
    PyDict_SetItemString(dict, "CS_unspecified", Dtool_WrapValue(EggTexture::CS_unspecified));
    PyDict_SetItemString(dict, "CSUnspecified", Dtool_WrapValue(EggTexture::CS_unspecified));
    PyDict_SetItemString(dict, "CS_texture", Dtool_WrapValue(EggTexture::CS_texture));
    PyDict_SetItemString(dict, "CSTexture", Dtool_WrapValue(EggTexture::CS_texture));
    PyDict_SetItemString(dict, "CS_constant", Dtool_WrapValue(EggTexture::CS_constant));
    PyDict_SetItemString(dict, "CSConstant", Dtool_WrapValue(EggTexture::CS_constant));
    PyDict_SetItemString(dict, "CS_primary_color", Dtool_WrapValue(EggTexture::CS_primary_color));
    PyDict_SetItemString(dict, "CSPrimaryColor", Dtool_WrapValue(EggTexture::CS_primary_color));
    PyDict_SetItemString(dict, "CS_previous", Dtool_WrapValue(EggTexture::CS_previous));
    PyDict_SetItemString(dict, "CSPrevious", Dtool_WrapValue(EggTexture::CS_previous));
    PyDict_SetItemString(dict, "CS_constant_color_scale", Dtool_WrapValue(EggTexture::CS_constant_color_scale));
    PyDict_SetItemString(dict, "CSConstantColorScale", Dtool_WrapValue(EggTexture::CS_constant_color_scale));
    PyDict_SetItemString(dict, "CS_last_saved_result", Dtool_WrapValue(EggTexture::CS_last_saved_result));
    PyDict_SetItemString(dict, "CSLastSavedResult", Dtool_WrapValue(EggTexture::CS_last_saved_result));
    // enum EggTexture::CombineOperand;
    PyDict_SetItemString(dict, "CO_unspecified", Dtool_WrapValue(EggTexture::CO_unspecified));
    PyDict_SetItemString(dict, "COUnspecified", Dtool_WrapValue(EggTexture::CO_unspecified));
    PyDict_SetItemString(dict, "CO_src_color", Dtool_WrapValue(EggTexture::CO_src_color));
    PyDict_SetItemString(dict, "COSrcColor", Dtool_WrapValue(EggTexture::CO_src_color));
    PyDict_SetItemString(dict, "CO_one_minus_src_color", Dtool_WrapValue(EggTexture::CO_one_minus_src_color));
    PyDict_SetItemString(dict, "COOneMinusSrcColor", Dtool_WrapValue(EggTexture::CO_one_minus_src_color));
    PyDict_SetItemString(dict, "CO_src_alpha", Dtool_WrapValue(EggTexture::CO_src_alpha));
    PyDict_SetItemString(dict, "COSrcAlpha", Dtool_WrapValue(EggTexture::CO_src_alpha));
    PyDict_SetItemString(dict, "CO_one_minus_src_alpha", Dtool_WrapValue(EggTexture::CO_one_minus_src_alpha));
    PyDict_SetItemString(dict, "COOneMinusSrcAlpha", Dtool_WrapValue(EggTexture::CO_one_minus_src_alpha));
    // enum EggTexture::TexGen;
    PyDict_SetItemString(dict, "TG_unspecified", Dtool_WrapValue(EggTexture::TG_unspecified));
    PyDict_SetItemString(dict, "TGUnspecified", Dtool_WrapValue(EggTexture::TG_unspecified));
    PyDict_SetItemString(dict, "TG_eye_sphere_map", Dtool_WrapValue(EggTexture::TG_eye_sphere_map));
    PyDict_SetItemString(dict, "TGEyeSphereMap", Dtool_WrapValue(EggTexture::TG_eye_sphere_map));
    PyDict_SetItemString(dict, "TG_world_cube_map", Dtool_WrapValue(EggTexture::TG_world_cube_map));
    PyDict_SetItemString(dict, "TGWorldCubeMap", Dtool_WrapValue(EggTexture::TG_world_cube_map));
    PyDict_SetItemString(dict, "TG_eye_cube_map", Dtool_WrapValue(EggTexture::TG_eye_cube_map));
    PyDict_SetItemString(dict, "TGEyeCubeMap", Dtool_WrapValue(EggTexture::TG_eye_cube_map));
    PyDict_SetItemString(dict, "TG_world_normal", Dtool_WrapValue(EggTexture::TG_world_normal));
    PyDict_SetItemString(dict, "TGWorldNormal", Dtool_WrapValue(EggTexture::TG_world_normal));
    PyDict_SetItemString(dict, "TG_eye_normal", Dtool_WrapValue(EggTexture::TG_eye_normal));
    PyDict_SetItemString(dict, "TGEyeNormal", Dtool_WrapValue(EggTexture::TG_eye_normal));
    PyDict_SetItemString(dict, "TG_world_position", Dtool_WrapValue(EggTexture::TG_world_position));
    PyDict_SetItemString(dict, "TGWorldPosition", Dtool_WrapValue(EggTexture::TG_world_position));
    PyDict_SetItemString(dict, "TG_eye_position", Dtool_WrapValue(EggTexture::TG_eye_position));
    PyDict_SetItemString(dict, "TGEyePosition", Dtool_WrapValue(EggTexture::TG_eye_position));
    PyDict_SetItemString(dict, "TG_point_sprite", Dtool_WrapValue(EggTexture::TG_point_sprite));
    PyDict_SetItemString(dict, "TGPointSprite", Dtool_WrapValue(EggTexture::TG_point_sprite));
    // enum EggTexture::QualityLevel;
    PyDict_SetItemString(dict, "QL_unspecified", Dtool_WrapValue(EggTexture::QL_unspecified));
    PyDict_SetItemString(dict, "QLUnspecified", Dtool_WrapValue(EggTexture::QL_unspecified));
    PyDict_SetItemString(dict, "QL_default", Dtool_WrapValue(EggTexture::QL_default));
    PyDict_SetItemString(dict, "QLDefault", Dtool_WrapValue(EggTexture::QL_default));
    PyDict_SetItemString(dict, "QL_fastest", Dtool_WrapValue(EggTexture::QL_fastest));
    PyDict_SetItemString(dict, "QLFastest", Dtool_WrapValue(EggTexture::QL_fastest));
    PyDict_SetItemString(dict, "QL_normal", Dtool_WrapValue(EggTexture::QL_normal));
    PyDict_SetItemString(dict, "QLNormal", Dtool_WrapValue(EggTexture::QL_normal));
    PyDict_SetItemString(dict, "QL_best", Dtool_WrapValue(EggTexture::QL_best));
    PyDict_SetItemString(dict, "QLBest", Dtool_WrapValue(EggTexture::QL_best));
    if (PyType_Ready((PyTypeObject *)&Dtool_EggTexture) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggTexture)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggTexture);
  }
}

/**
 * Python method tables for EggMaterial (EggMaterial)
 */
static PyMethodDef Dtool_Methods_EggMaterial[] = {
  {"is_equivalent_to", (PyCFunction) &Dtool_EggMaterial_is_equivalent_to_796, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggMaterial_is_equivalent_to_796_comment},
  {"isEquivalentTo", (PyCFunction) &Dtool_EggMaterial_is_equivalent_to_796, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggMaterial_is_equivalent_to_796_comment},
  {"sorts_less_than", (PyCFunction) &Dtool_EggMaterial_sorts_less_than_797, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggMaterial_sorts_less_than_797_comment},
  {"sortsLessThan", (PyCFunction) &Dtool_EggMaterial_sorts_less_than_797, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggMaterial_sorts_less_than_797_comment},
  {"set_base", &Dtool_EggMaterial_set_base_798, METH_O, (const char *)Dtool_EggMaterial_set_base_798_comment},
  {"setBase", &Dtool_EggMaterial_set_base_798, METH_O, (const char *)Dtool_EggMaterial_set_base_798_comment},
  {"clear_base", &Dtool_EggMaterial_clear_base_799, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_base_799_comment},
  {"clearBase", &Dtool_EggMaterial_clear_base_799, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_base_799_comment},
  {"has_base", &Dtool_EggMaterial_has_base_800, METH_NOARGS, (const char *)Dtool_EggMaterial_has_base_800_comment},
  {"hasBase", &Dtool_EggMaterial_has_base_800, METH_NOARGS, (const char *)Dtool_EggMaterial_has_base_800_comment},
  {"get_base", &Dtool_EggMaterial_get_base_801, METH_NOARGS, (const char *)Dtool_EggMaterial_get_base_801_comment},
  {"getBase", &Dtool_EggMaterial_get_base_801, METH_NOARGS, (const char *)Dtool_EggMaterial_get_base_801_comment},
  {"set_diff", &Dtool_EggMaterial_set_diff_802, METH_O, (const char *)Dtool_EggMaterial_set_diff_802_comment},
  {"setDiff", &Dtool_EggMaterial_set_diff_802, METH_O, (const char *)Dtool_EggMaterial_set_diff_802_comment},
  {"clear_diff", &Dtool_EggMaterial_clear_diff_803, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_diff_803_comment},
  {"clearDiff", &Dtool_EggMaterial_clear_diff_803, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_diff_803_comment},
  {"has_diff", &Dtool_EggMaterial_has_diff_804, METH_NOARGS, (const char *)Dtool_EggMaterial_has_diff_804_comment},
  {"hasDiff", &Dtool_EggMaterial_has_diff_804, METH_NOARGS, (const char *)Dtool_EggMaterial_has_diff_804_comment},
  {"get_diff", &Dtool_EggMaterial_get_diff_805, METH_NOARGS, (const char *)Dtool_EggMaterial_get_diff_805_comment},
  {"getDiff", &Dtool_EggMaterial_get_diff_805, METH_NOARGS, (const char *)Dtool_EggMaterial_get_diff_805_comment},
  {"set_amb", &Dtool_EggMaterial_set_amb_806, METH_O, (const char *)Dtool_EggMaterial_set_amb_806_comment},
  {"setAmb", &Dtool_EggMaterial_set_amb_806, METH_O, (const char *)Dtool_EggMaterial_set_amb_806_comment},
  {"clear_amb", &Dtool_EggMaterial_clear_amb_807, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_amb_807_comment},
  {"clearAmb", &Dtool_EggMaterial_clear_amb_807, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_amb_807_comment},
  {"has_amb", &Dtool_EggMaterial_has_amb_808, METH_NOARGS, (const char *)Dtool_EggMaterial_has_amb_808_comment},
  {"hasAmb", &Dtool_EggMaterial_has_amb_808, METH_NOARGS, (const char *)Dtool_EggMaterial_has_amb_808_comment},
  {"get_amb", &Dtool_EggMaterial_get_amb_809, METH_NOARGS, (const char *)Dtool_EggMaterial_get_amb_809_comment},
  {"getAmb", &Dtool_EggMaterial_get_amb_809, METH_NOARGS, (const char *)Dtool_EggMaterial_get_amb_809_comment},
  {"set_emit", &Dtool_EggMaterial_set_emit_810, METH_O, (const char *)Dtool_EggMaterial_set_emit_810_comment},
  {"setEmit", &Dtool_EggMaterial_set_emit_810, METH_O, (const char *)Dtool_EggMaterial_set_emit_810_comment},
  {"clear_emit", &Dtool_EggMaterial_clear_emit_811, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_emit_811_comment},
  {"clearEmit", &Dtool_EggMaterial_clear_emit_811, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_emit_811_comment},
  {"has_emit", &Dtool_EggMaterial_has_emit_812, METH_NOARGS, (const char *)Dtool_EggMaterial_has_emit_812_comment},
  {"hasEmit", &Dtool_EggMaterial_has_emit_812, METH_NOARGS, (const char *)Dtool_EggMaterial_has_emit_812_comment},
  {"get_emit", &Dtool_EggMaterial_get_emit_813, METH_NOARGS, (const char *)Dtool_EggMaterial_get_emit_813_comment},
  {"getEmit", &Dtool_EggMaterial_get_emit_813, METH_NOARGS, (const char *)Dtool_EggMaterial_get_emit_813_comment},
  {"set_spec", &Dtool_EggMaterial_set_spec_814, METH_O, (const char *)Dtool_EggMaterial_set_spec_814_comment},
  {"setSpec", &Dtool_EggMaterial_set_spec_814, METH_O, (const char *)Dtool_EggMaterial_set_spec_814_comment},
  {"clear_spec", &Dtool_EggMaterial_clear_spec_815, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_spec_815_comment},
  {"clearSpec", &Dtool_EggMaterial_clear_spec_815, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_spec_815_comment},
  {"has_spec", &Dtool_EggMaterial_has_spec_816, METH_NOARGS, (const char *)Dtool_EggMaterial_has_spec_816_comment},
  {"hasSpec", &Dtool_EggMaterial_has_spec_816, METH_NOARGS, (const char *)Dtool_EggMaterial_has_spec_816_comment},
  {"get_spec", &Dtool_EggMaterial_get_spec_817, METH_NOARGS, (const char *)Dtool_EggMaterial_get_spec_817_comment},
  {"getSpec", &Dtool_EggMaterial_get_spec_817, METH_NOARGS, (const char *)Dtool_EggMaterial_get_spec_817_comment},
  {"set_shininess", &Dtool_EggMaterial_set_shininess_818, METH_O, (const char *)Dtool_EggMaterial_set_shininess_818_comment},
  {"setShininess", &Dtool_EggMaterial_set_shininess_818, METH_O, (const char *)Dtool_EggMaterial_set_shininess_818_comment},
  {"clear_shininess", &Dtool_EggMaterial_clear_shininess_819, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_shininess_819_comment},
  {"clearShininess", &Dtool_EggMaterial_clear_shininess_819, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_shininess_819_comment},
  {"has_shininess", &Dtool_EggMaterial_has_shininess_820, METH_NOARGS, (const char *)Dtool_EggMaterial_has_shininess_820_comment},
  {"hasShininess", &Dtool_EggMaterial_has_shininess_820, METH_NOARGS, (const char *)Dtool_EggMaterial_has_shininess_820_comment},
  {"get_shininess", &Dtool_EggMaterial_get_shininess_821, METH_NOARGS, (const char *)Dtool_EggMaterial_get_shininess_821_comment},
  {"getShininess", &Dtool_EggMaterial_get_shininess_821, METH_NOARGS, (const char *)Dtool_EggMaterial_get_shininess_821_comment},
  {"set_roughness", &Dtool_EggMaterial_set_roughness_822, METH_O, (const char *)Dtool_EggMaterial_set_roughness_822_comment},
  {"setRoughness", &Dtool_EggMaterial_set_roughness_822, METH_O, (const char *)Dtool_EggMaterial_set_roughness_822_comment},
  {"clear_roughness", &Dtool_EggMaterial_clear_roughness_823, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_roughness_823_comment},
  {"clearRoughness", &Dtool_EggMaterial_clear_roughness_823, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_roughness_823_comment},
  {"has_roughness", &Dtool_EggMaterial_has_roughness_824, METH_NOARGS, (const char *)Dtool_EggMaterial_has_roughness_824_comment},
  {"hasRoughness", &Dtool_EggMaterial_has_roughness_824, METH_NOARGS, (const char *)Dtool_EggMaterial_has_roughness_824_comment},
  {"get_roughness", &Dtool_EggMaterial_get_roughness_825, METH_NOARGS, (const char *)Dtool_EggMaterial_get_roughness_825_comment},
  {"getRoughness", &Dtool_EggMaterial_get_roughness_825, METH_NOARGS, (const char *)Dtool_EggMaterial_get_roughness_825_comment},
  {"set_metallic", &Dtool_EggMaterial_set_metallic_826, METH_O, (const char *)Dtool_EggMaterial_set_metallic_826_comment},
  {"setMetallic", &Dtool_EggMaterial_set_metallic_826, METH_O, (const char *)Dtool_EggMaterial_set_metallic_826_comment},
  {"clear_metallic", &Dtool_EggMaterial_clear_metallic_827, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_metallic_827_comment},
  {"clearMetallic", &Dtool_EggMaterial_clear_metallic_827, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_metallic_827_comment},
  {"has_metallic", &Dtool_EggMaterial_has_metallic_828, METH_NOARGS, (const char *)Dtool_EggMaterial_has_metallic_828_comment},
  {"hasMetallic", &Dtool_EggMaterial_has_metallic_828, METH_NOARGS, (const char *)Dtool_EggMaterial_has_metallic_828_comment},
  {"get_metallic", &Dtool_EggMaterial_get_metallic_829, METH_NOARGS, (const char *)Dtool_EggMaterial_get_metallic_829_comment},
  {"getMetallic", &Dtool_EggMaterial_get_metallic_829, METH_NOARGS, (const char *)Dtool_EggMaterial_get_metallic_829_comment},
  {"set_ior", &Dtool_EggMaterial_set_ior_830, METH_O, (const char *)Dtool_EggMaterial_set_ior_830_comment},
  {"setIor", &Dtool_EggMaterial_set_ior_830, METH_O, (const char *)Dtool_EggMaterial_set_ior_830_comment},
  {"clear_ior", &Dtool_EggMaterial_clear_ior_831, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_ior_831_comment},
  {"clearIor", &Dtool_EggMaterial_clear_ior_831, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_ior_831_comment},
  {"has_ior", &Dtool_EggMaterial_has_ior_832, METH_NOARGS, (const char *)Dtool_EggMaterial_has_ior_832_comment},
  {"hasIor", &Dtool_EggMaterial_has_ior_832, METH_NOARGS, (const char *)Dtool_EggMaterial_has_ior_832_comment},
  {"get_ior", &Dtool_EggMaterial_get_ior_833, METH_NOARGS, (const char *)Dtool_EggMaterial_get_ior_833_comment},
  {"getIor", &Dtool_EggMaterial_get_ior_833, METH_NOARGS, (const char *)Dtool_EggMaterial_get_ior_833_comment},
  {"set_local", &Dtool_EggMaterial_set_local_834, METH_O, (const char *)Dtool_EggMaterial_set_local_834_comment},
  {"setLocal", &Dtool_EggMaterial_set_local_834, METH_O, (const char *)Dtool_EggMaterial_set_local_834_comment},
  {"clear_local", &Dtool_EggMaterial_clear_local_835, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_local_835_comment},
  {"clearLocal", &Dtool_EggMaterial_clear_local_835, METH_NOARGS, (const char *)Dtool_EggMaterial_clear_local_835_comment},
  {"has_local", &Dtool_EggMaterial_has_local_836, METH_NOARGS, (const char *)Dtool_EggMaterial_has_local_836_comment},
  {"hasLocal", &Dtool_EggMaterial_has_local_836, METH_NOARGS, (const char *)Dtool_EggMaterial_has_local_836_comment},
  {"get_local", &Dtool_EggMaterial_get_local_837, METH_NOARGS, (const char *)Dtool_EggMaterial_get_local_837_comment},
  {"getLocal", &Dtool_EggMaterial_get_local_837, METH_NOARGS, (const char *)Dtool_EggMaterial_get_local_837_comment},
  {"get_class_type", &Dtool_EggMaterial_get_class_type_848, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggMaterial_get_class_type_848_comment},
  {"getClassType", &Dtool_EggMaterial_get_class_type_848, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggMaterial_get_class_type_848_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_EggMaterial[] = {
  {(char *)"base", &Dtool_EggMaterial_base_Getter, &Dtool_EggMaterial_base_Setter, nullptr, nullptr},
  {(char *)"diff", &Dtool_EggMaterial_diff_Getter, &Dtool_EggMaterial_diff_Setter, nullptr, nullptr},
  {(char *)"amb", &Dtool_EggMaterial_amb_Getter, &Dtool_EggMaterial_amb_Setter, nullptr, nullptr},
  {(char *)"emit", &Dtool_EggMaterial_emit_Getter, &Dtool_EggMaterial_emit_Setter, nullptr, nullptr},
  {(char *)"spec", &Dtool_EggMaterial_spec_Getter, &Dtool_EggMaterial_spec_Setter, nullptr, nullptr},
  {(char *)"shininess", &Dtool_EggMaterial_shininess_Getter, &Dtool_EggMaterial_shininess_Setter, nullptr, nullptr},
  {(char *)"roughness", &Dtool_EggMaterial_roughness_Getter, &Dtool_EggMaterial_roughness_Setter, nullptr, nullptr},
  {(char *)"metallic", &Dtool_EggMaterial_metallic_Getter, &Dtool_EggMaterial_metallic_Setter, nullptr, nullptr},
  {(char *)"ior", &Dtool_EggMaterial_ior_Getter, &Dtool_EggMaterial_ior_Setter, nullptr, nullptr},
  {(char *)"local", &Dtool_EggMaterial_local_Getter, &Dtool_EggMaterial_local_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_EggMaterial = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggMaterial = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggMaterial = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggMaterial = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggMaterial = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggMaterial = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggMaterial",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggMaterial,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggMaterial,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggMaterial,
    &Dtool_SequenceMethods_EggMaterial,
    &Dtool_MappingMethods_EggMaterial,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggMaterial,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggMaterial,
    nullptr, // tp_members
    Dtool_Properties_EggMaterial,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggMaterial,
    PyType_GenericAlloc,
    Dtool_new_EggMaterial,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggMaterial,
  Dtool_UpcastInterface_EggMaterial,
  Dtool_DowncastInterface_EggMaterial,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggMaterial(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggNode(nullptr);
    Dtool_EggMaterial._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggNode);
    Dtool_EggMaterial._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggMaterial._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum EggMaterial::Equivalence;
    PyDict_SetItemString(dict, "E_attributes", Dtool_WrapValue(EggMaterial::E_attributes));
    PyDict_SetItemString(dict, "EAttributes", Dtool_WrapValue(EggMaterial::E_attributes));
    PyDict_SetItemString(dict, "E_mref_name", Dtool_WrapValue(EggMaterial::E_mref_name));
    PyDict_SetItemString(dict, "EMrefName", Dtool_WrapValue(EggMaterial::E_mref_name));
    if (PyType_Ready((PyTypeObject *)&Dtool_EggMaterial) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggMaterial)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggMaterial);
  }
}

/**
 * Python method tables for EggPrimitive (EggPrimitive)
 */
static PyMethodDef Dtool_Methods_EggPrimitive[] = {
  {"assign", &Dtool_EggPrimitive_operator_858, METH_O, (const char *)Dtool_EggPrimitive_operator_858_comment},
  {"make_copy", &Dtool_EggPrimitive_make_copy_860, METH_NOARGS, (const char *)Dtool_EggPrimitive_make_copy_860_comment},
  {"makeCopy", &Dtool_EggPrimitive_make_copy_860, METH_NOARGS, (const char *)Dtool_EggPrimitive_make_copy_860_comment},
  {"determine_alpha_mode", &Dtool_EggPrimitive_determine_alpha_mode_861, METH_NOARGS, (const char *)Dtool_EggPrimitive_determine_alpha_mode_861_comment},
  {"determineAlphaMode", &Dtool_EggPrimitive_determine_alpha_mode_861, METH_NOARGS, (const char *)Dtool_EggPrimitive_determine_alpha_mode_861_comment},
  {"determine_depth_write_mode", &Dtool_EggPrimitive_determine_depth_write_mode_862, METH_NOARGS, (const char *)Dtool_EggPrimitive_determine_depth_write_mode_862_comment},
  {"determineDepthWriteMode", &Dtool_EggPrimitive_determine_depth_write_mode_862, METH_NOARGS, (const char *)Dtool_EggPrimitive_determine_depth_write_mode_862_comment},
  {"determine_depth_test_mode", &Dtool_EggPrimitive_determine_depth_test_mode_863, METH_NOARGS, (const char *)Dtool_EggPrimitive_determine_depth_test_mode_863_comment},
  {"determineDepthTestMode", &Dtool_EggPrimitive_determine_depth_test_mode_863, METH_NOARGS, (const char *)Dtool_EggPrimitive_determine_depth_test_mode_863_comment},
  {"determine_visibility_mode", &Dtool_EggPrimitive_determine_visibility_mode_864, METH_NOARGS, (const char *)Dtool_EggPrimitive_determine_visibility_mode_864_comment},
  {"determineVisibilityMode", &Dtool_EggPrimitive_determine_visibility_mode_864, METH_NOARGS, (const char *)Dtool_EggPrimitive_determine_visibility_mode_864_comment},
  {"determine_depth_offset", &Dtool_EggPrimitive_determine_depth_offset_865, METH_NOARGS, (const char *)Dtool_EggPrimitive_determine_depth_offset_865_comment},
  {"determineDepthOffset", &Dtool_EggPrimitive_determine_depth_offset_865, METH_NOARGS, (const char *)Dtool_EggPrimitive_determine_depth_offset_865_comment},
  {"determine_draw_order", &Dtool_EggPrimitive_determine_draw_order_866, METH_NOARGS, (const char *)Dtool_EggPrimitive_determine_draw_order_866_comment},
  {"determineDrawOrder", &Dtool_EggPrimitive_determine_draw_order_866, METH_NOARGS, (const char *)Dtool_EggPrimitive_determine_draw_order_866_comment},
  {"determine_bin", &Dtool_EggPrimitive_determine_bin_867, METH_NOARGS, (const char *)Dtool_EggPrimitive_determine_bin_867_comment},
  {"determineBin", &Dtool_EggPrimitive_determine_bin_867, METH_NOARGS, (const char *)Dtool_EggPrimitive_determine_bin_867_comment},
  {"get_sort_name", &Dtool_EggPrimitive_get_sort_name_868, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_sort_name_868_comment},
  {"getSortName", &Dtool_EggPrimitive_get_sort_name_868, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_sort_name_868_comment},
  {"get_shading", &Dtool_EggPrimitive_get_shading_869, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_shading_869_comment},
  {"getShading", &Dtool_EggPrimitive_get_shading_869, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_shading_869_comment},
  {"clear_connected_shading", &Dtool_EggPrimitive_clear_connected_shading_870, METH_NOARGS, (const char *)Dtool_EggPrimitive_clear_connected_shading_870_comment},
  {"clearConnectedShading", &Dtool_EggPrimitive_clear_connected_shading_870, METH_NOARGS, (const char *)Dtool_EggPrimitive_clear_connected_shading_870_comment},
  {"get_connected_shading", &Dtool_EggPrimitive_get_connected_shading_871, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_connected_shading_871_comment},
  {"getConnectedShading", &Dtool_EggPrimitive_get_connected_shading_871, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_connected_shading_871_comment},
  {"set_texture", &Dtool_EggPrimitive_set_texture_872, METH_O, (const char *)Dtool_EggPrimitive_set_texture_872_comment},
  {"setTexture", &Dtool_EggPrimitive_set_texture_872, METH_O, (const char *)Dtool_EggPrimitive_set_texture_872_comment},
  {"has_texture", &Dtool_EggPrimitive_has_texture_873, METH_VARARGS, (const char *)Dtool_EggPrimitive_has_texture_873_comment},
  {"hasTexture", &Dtool_EggPrimitive_has_texture_873, METH_VARARGS, (const char *)Dtool_EggPrimitive_has_texture_873_comment},
  {"get_texture", &Dtool_EggPrimitive_get_texture_874, METH_VARARGS, (const char *)Dtool_EggPrimitive_get_texture_874_comment},
  {"getTexture", &Dtool_EggPrimitive_get_texture_874, METH_VARARGS, (const char *)Dtool_EggPrimitive_get_texture_874_comment},
  {"add_texture", &Dtool_EggPrimitive_add_texture_875, METH_O, (const char *)Dtool_EggPrimitive_add_texture_875_comment},
  {"addTexture", &Dtool_EggPrimitive_add_texture_875, METH_O, (const char *)Dtool_EggPrimitive_add_texture_875_comment},
  {"clear_texture", &Dtool_EggPrimitive_clear_texture_876, METH_NOARGS, (const char *)Dtool_EggPrimitive_clear_texture_876_comment},
  {"clearTexture", &Dtool_EggPrimitive_clear_texture_876, METH_NOARGS, (const char *)Dtool_EggPrimitive_clear_texture_876_comment},
  {"get_num_textures", &Dtool_EggPrimitive_get_num_textures_877, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_num_textures_877_comment},
  {"getNumTextures", &Dtool_EggPrimitive_get_num_textures_877, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_num_textures_877_comment},
  {"set_material", &Dtool_EggPrimitive_set_material_879, METH_O, (const char *)Dtool_EggPrimitive_set_material_879_comment},
  {"setMaterial", &Dtool_EggPrimitive_set_material_879, METH_O, (const char *)Dtool_EggPrimitive_set_material_879_comment},
  {"clear_material", &Dtool_EggPrimitive_clear_material_880, METH_NOARGS, (const char *)Dtool_EggPrimitive_clear_material_880_comment},
  {"clearMaterial", &Dtool_EggPrimitive_clear_material_880, METH_NOARGS, (const char *)Dtool_EggPrimitive_clear_material_880_comment},
  {"get_material", &Dtool_EggPrimitive_get_material_881, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_material_881_comment},
  {"getMaterial", &Dtool_EggPrimitive_get_material_881, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_material_881_comment},
  {"has_material", &Dtool_EggPrimitive_has_material_882, METH_NOARGS, (const char *)Dtool_EggPrimitive_has_material_882_comment},
  {"hasMaterial", &Dtool_EggPrimitive_has_material_882, METH_NOARGS, (const char *)Dtool_EggPrimitive_has_material_882_comment},
  {"set_bface_flag", &Dtool_EggPrimitive_set_bface_flag_883, METH_O, (const char *)Dtool_EggPrimitive_set_bface_flag_883_comment},
  {"setBfaceFlag", &Dtool_EggPrimitive_set_bface_flag_883, METH_O, (const char *)Dtool_EggPrimitive_set_bface_flag_883_comment},
  {"get_bface_flag", &Dtool_EggPrimitive_get_bface_flag_884, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_bface_flag_884_comment},
  {"getBfaceFlag", &Dtool_EggPrimitive_get_bface_flag_884, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_bface_flag_884_comment},
  {"copy_attributes", &Dtool_EggPrimitive_copy_attributes_893, METH_O, (const char *)Dtool_EggPrimitive_copy_attributes_893_comment},
  {"copyAttributes", &Dtool_EggPrimitive_copy_attributes_893, METH_O, (const char *)Dtool_EggPrimitive_copy_attributes_893_comment},
  {"has_vertex_normal", &Dtool_EggPrimitive_has_vertex_normal_894, METH_NOARGS, (const char *)Dtool_EggPrimitive_has_vertex_normal_894_comment},
  {"hasVertexNormal", &Dtool_EggPrimitive_has_vertex_normal_894, METH_NOARGS, (const char *)Dtool_EggPrimitive_has_vertex_normal_894_comment},
  {"has_vertex_color", &Dtool_EggPrimitive_has_vertex_color_895, METH_NOARGS, (const char *)Dtool_EggPrimitive_has_vertex_color_895_comment},
  {"hasVertexColor", &Dtool_EggPrimitive_has_vertex_color_895, METH_NOARGS, (const char *)Dtool_EggPrimitive_has_vertex_color_895_comment},
  {"unify_attributes", &Dtool_EggPrimitive_unify_attributes_896, METH_O, (const char *)Dtool_EggPrimitive_unify_attributes_896_comment},
  {"unifyAttributes", &Dtool_EggPrimitive_unify_attributes_896, METH_O, (const char *)Dtool_EggPrimitive_unify_attributes_896_comment},
  {"apply_last_attribute", &Dtool_EggPrimitive_apply_last_attribute_897, METH_NOARGS, (const char *)Dtool_EggPrimitive_apply_last_attribute_897_comment},
  {"applyLastAttribute", &Dtool_EggPrimitive_apply_last_attribute_897, METH_NOARGS, (const char *)Dtool_EggPrimitive_apply_last_attribute_897_comment},
  {"apply_first_attribute", &Dtool_EggPrimitive_apply_first_attribute_898, METH_NOARGS, (const char *)Dtool_EggPrimitive_apply_first_attribute_898_comment},
  {"applyFirstAttribute", &Dtool_EggPrimitive_apply_first_attribute_898, METH_NOARGS, (const char *)Dtool_EggPrimitive_apply_first_attribute_898_comment},
  {"post_apply_flat_attribute", &Dtool_EggPrimitive_post_apply_flat_attribute_899, METH_NOARGS, (const char *)Dtool_EggPrimitive_post_apply_flat_attribute_899_comment},
  {"postApplyFlatAttribute", &Dtool_EggPrimitive_post_apply_flat_attribute_899, METH_NOARGS, (const char *)Dtool_EggPrimitive_post_apply_flat_attribute_899_comment},
  {"reverse_vertex_ordering", &Dtool_EggPrimitive_reverse_vertex_ordering_900, METH_NOARGS, (const char *)Dtool_EggPrimitive_reverse_vertex_ordering_900_comment},
  {"reverseVertexOrdering", &Dtool_EggPrimitive_reverse_vertex_ordering_900, METH_NOARGS, (const char *)Dtool_EggPrimitive_reverse_vertex_ordering_900_comment},
  {"cleanup", &Dtool_EggPrimitive_cleanup_901, METH_NOARGS, (const char *)Dtool_EggPrimitive_cleanup_901_comment},
  {"remove_doubled_verts", &Dtool_EggPrimitive_remove_doubled_verts_902, METH_O, (const char *)Dtool_EggPrimitive_remove_doubled_verts_902_comment},
  {"removeDoubledVerts", &Dtool_EggPrimitive_remove_doubled_verts_902, METH_O, (const char *)Dtool_EggPrimitive_remove_doubled_verts_902_comment},
  {"remove_nonunique_verts", &Dtool_EggPrimitive_remove_nonunique_verts_903, METH_NOARGS, (const char *)Dtool_EggPrimitive_remove_nonunique_verts_903_comment},
  {"removeNonuniqueVerts", &Dtool_EggPrimitive_remove_nonunique_verts_903, METH_NOARGS, (const char *)Dtool_EggPrimitive_remove_nonunique_verts_903_comment},
  {"has_primitives", &Dtool_EggPrimitive_has_primitives_904, METH_NOARGS, (const char *)Dtool_EggPrimitive_has_primitives_904_comment},
  {"hasPrimitives", &Dtool_EggPrimitive_has_primitives_904, METH_NOARGS, (const char *)Dtool_EggPrimitive_has_primitives_904_comment},
  {"joint_has_primitives", &Dtool_EggPrimitive_joint_has_primitives_905, METH_NOARGS, (const char *)Dtool_EggPrimitive_joint_has_primitives_905_comment},
  {"jointHasPrimitives", &Dtool_EggPrimitive_joint_has_primitives_905, METH_NOARGS, (const char *)Dtool_EggPrimitive_joint_has_primitives_905_comment},
  {"has_normals", &Dtool_EggPrimitive_has_normals_906, METH_NOARGS, (const char *)Dtool_EggPrimitive_has_normals_906_comment},
  {"hasNormals", &Dtool_EggPrimitive_has_normals_906, METH_NOARGS, (const char *)Dtool_EggPrimitive_has_normals_906_comment},
  {"clear", &Dtool_EggPrimitive_clear_907, METH_NOARGS, (const char *)Dtool_EggPrimitive_clear_907_comment},
  {"add_vertex", &Dtool_EggPrimitive_add_vertex_908, METH_O, (const char *)Dtool_EggPrimitive_add_vertex_908_comment},
  {"addVertex", &Dtool_EggPrimitive_add_vertex_908, METH_O, (const char *)Dtool_EggPrimitive_add_vertex_908_comment},
  {"remove_vertex", &Dtool_EggPrimitive_remove_vertex_909, METH_O, (const char *)Dtool_EggPrimitive_remove_vertex_909_comment},
  {"removeVertex", &Dtool_EggPrimitive_remove_vertex_909, METH_O, (const char *)Dtool_EggPrimitive_remove_vertex_909_comment},
  {"copy_vertices", &Dtool_EggPrimitive_copy_vertices_910, METH_O, (const char *)Dtool_EggPrimitive_copy_vertices_910_comment},
  {"copyVertices", &Dtool_EggPrimitive_copy_vertices_910, METH_O, (const char *)Dtool_EggPrimitive_copy_vertices_910_comment},
  {"get_num_vertices", &Dtool_EggPrimitive_get_num_vertices_911, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_num_vertices_911_comment},
  {"getNumVertices", &Dtool_EggPrimitive_get_num_vertices_911, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_num_vertices_911_comment},
  {"get_vertex", &Dtool_EggPrimitive_get_vertex_912, METH_O, (const char *)Dtool_EggPrimitive_get_vertex_912_comment},
  {"getVertex", &Dtool_EggPrimitive_get_vertex_912, METH_O, (const char *)Dtool_EggPrimitive_get_vertex_912_comment},
  {"set_vertex", (PyCFunction) &Dtool_EggPrimitive_set_vertex_913, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggPrimitive_set_vertex_913_comment},
  {"setVertex", (PyCFunction) &Dtool_EggPrimitive_set_vertex_913, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggPrimitive_set_vertex_913_comment},
  {"insert_vertex", (PyCFunction) &Dtool_EggPrimitive_insert_vertex_914, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggPrimitive_insert_vertex_914_comment},
  {"insertVertex", (PyCFunction) &Dtool_EggPrimitive_insert_vertex_914, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggPrimitive_insert_vertex_914_comment},
  {"get_pool", &Dtool_EggPrimitive_get_pool_916, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_pool_916_comment},
  {"getPool", &Dtool_EggPrimitive_get_pool_916, METH_NOARGS, (const char *)Dtool_EggPrimitive_get_pool_916_comment},
  {"write", (PyCFunction) &Dtool_EggPrimitive_write_921, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggPrimitive_write_921_comment},
  {"test_vref_integrity", &Dtool_EggPrimitive_test_vref_integrity_922, METH_NOARGS, (const char *)Dtool_EggPrimitive_test_vref_integrity_922_comment},
  {"testVrefIntegrity", &Dtool_EggPrimitive_test_vref_integrity_922, METH_NOARGS, (const char *)Dtool_EggPrimitive_test_vref_integrity_922_comment},
  {"get_class_type", &Dtool_EggPrimitive_get_class_type_923, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggPrimitive_get_class_type_923_comment},
  {"getClassType", &Dtool_EggPrimitive_get_class_type_923, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggPrimitive_get_class_type_923_comment},
  {"upcast_to_EggNode", &Dtool_EggPrimitive_upcast_to_EggNode_851, METH_NOARGS, (const char *)Dtool_EggPrimitive_upcast_to_EggNode_851_comment},
  {"upcastToEggNode", &Dtool_EggPrimitive_upcast_to_EggNode_851, METH_NOARGS, (const char *)Dtool_EggPrimitive_upcast_to_EggNode_851_comment},
  {"upcast_to_EggAttributes", &Dtool_EggPrimitive_upcast_to_EggAttributes_853, METH_NOARGS, (const char *)Dtool_EggPrimitive_upcast_to_EggAttributes_853_comment},
  {"upcastToEggAttributes", &Dtool_EggPrimitive_upcast_to_EggAttributes_853, METH_NOARGS, (const char *)Dtool_EggPrimitive_upcast_to_EggAttributes_853_comment},
  {"upcast_to_EggRenderMode", &Dtool_EggPrimitive_upcast_to_EggRenderMode_855, METH_NOARGS, (const char *)Dtool_EggPrimitive_upcast_to_EggRenderMode_855_comment},
  {"upcastToEggRenderMode", &Dtool_EggPrimitive_upcast_to_EggRenderMode_855, METH_NOARGS, (const char *)Dtool_EggPrimitive_upcast_to_EggRenderMode_855_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_textures", (PyCFunction) &MakeSeq_EggPrimitive_get_textures, METH_NOARGS, nullptr},
  { "getTextures", (PyCFunction) &MakeSeq_EggPrimitive_get_textures, METH_NOARGS, nullptr},
  {"get_vertices", (PyCFunction) &MakeSeq_EggPrimitive_get_vertices, METH_NOARGS, nullptr},
  { "getVertices", (PyCFunction) &MakeSeq_EggPrimitive_get_vertices, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     EggPrimitive
//////////////////
static PyObject *Dtool_Str_EggPrimitive(PyObject *self) {
  EggPrimitive *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggPrimitive, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_EggPrimitive[] = {
  {(char *)"sort_name", &Dtool_EggPrimitive_sort_name_Getter, nullptr, nullptr, nullptr},
  {(char *)"shading", &Dtool_EggPrimitive_shading_Getter, nullptr, nullptr, nullptr},
  {(char *)"connected_shading", &Dtool_EggPrimitive_connected_shading_Getter, nullptr, nullptr, nullptr},
  {(char *)"textures", &Dtool_EggPrimitive_textures_Getter, nullptr, nullptr, nullptr},
  {(char *)"material", &Dtool_EggPrimitive_material_Getter, &Dtool_EggPrimitive_material_Setter, nullptr, nullptr},
  {(char *)"bface_flag", &Dtool_EggPrimitive_bface_flag_Getter, &Dtool_EggPrimitive_bface_flag_Setter, nullptr, nullptr},
  {(char *)"vertices", &Dtool_EggPrimitive_vertices_Getter, nullptr, nullptr, nullptr},
  {(char *)"pool", &Dtool_EggPrimitive_pool_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_EggPrimitive = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggPrimitive = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggPrimitive = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggPrimitive = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggPrimitive = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggPrimitive = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggPrimitive",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggPrimitive,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggPrimitive,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggPrimitive,
    &Dtool_SequenceMethods_EggPrimitive,
    &Dtool_MappingMethods_EggPrimitive,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_EggPrimitive,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggPrimitive,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A base class for any of a number of kinds of geometry primitives: polygons,\n"
    " * point lights, nurbs patches, parametrics curves, etc.  Things with a set of\n"
    " * vertices and some rendering properties like color.\n"
    " *\n"
    " * An EggPrimitive is an STL-style container of pointers to EggVertex's.  In\n"
    " * fact, it IS a vector, and can be manipulated in all the ways that vectors\n"
    " * can.  However, it is necessary that all vertices belong to the same vertex\n"
    " * pool.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggPrimitive,
    nullptr, // tp_members
    Dtool_Properties_EggPrimitive,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggPrimitive,
    PyType_GenericAlloc,
    Dtool_new_EggPrimitive,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggPrimitive,
  Dtool_UpcastInterface_EggPrimitive,
  Dtool_DowncastInterface_EggPrimitive,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggPrimitive(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggNode(nullptr);
    Dtool_PyModuleClassInit_EggAttributes(nullptr);
    Dtool_PyModuleClassInit_EggRenderMode(nullptr);
    Dtool_EggPrimitive._PyType.tp_bases = PyTuple_Pack(3, (PyTypeObject *)&Dtool_EggNode, (PyTypeObject *)&Dtool_EggAttributes, (PyTypeObject *)&Dtool_EggRenderMode);
    Dtool_EggPrimitive._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(9);
    Dtool_EggPrimitive._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum EggPrimitive::Shading;
    PyDict_SetItemString(dict, "S_unknown", Dtool_WrapValue(EggPrimitive::S_unknown));
    PyDict_SetItemString(dict, "SUnknown", Dtool_WrapValue(EggPrimitive::S_unknown));
    PyDict_SetItemString(dict, "S_overall", Dtool_WrapValue(EggPrimitive::S_overall));
    PyDict_SetItemString(dict, "SOverall", Dtool_WrapValue(EggPrimitive::S_overall));
    PyDict_SetItemString(dict, "S_per_face", Dtool_WrapValue(EggPrimitive::S_per_face));
    PyDict_SetItemString(dict, "SPerFace", Dtool_WrapValue(EggPrimitive::S_per_face));
    PyDict_SetItemString(dict, "S_per_vertex", Dtool_WrapValue(EggPrimitive::S_per_vertex));
    PyDict_SetItemString(dict, "SPerVertex", Dtool_WrapValue(EggPrimitive::S_per_vertex));
    if (PyType_Ready((PyTypeObject *)&Dtool_EggPrimitive) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggPrimitive)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggPrimitive);
  }
}

/**
 * Python method tables for EggCompositePrimitive (EggCompositePrimitive)
 */
static PyMethodDef Dtool_Methods_EggCompositePrimitive[] = {
  {"assign", &Dtool_EggCompositePrimitive_operator_925, METH_O, (const char *)Dtool_EggCompositePrimitive_operator_925_comment},
  {"get_num_components", &Dtool_EggCompositePrimitive_get_num_components_926, METH_NOARGS, (const char *)Dtool_EggCompositePrimitive_get_num_components_926_comment},
  {"getNumComponents", &Dtool_EggCompositePrimitive_get_num_components_926, METH_NOARGS, (const char *)Dtool_EggCompositePrimitive_get_num_components_926_comment},
  {"get_component", &Dtool_EggCompositePrimitive_get_component_927, METH_O, (const char *)Dtool_EggCompositePrimitive_get_component_927_comment},
  {"getComponent", &Dtool_EggCompositePrimitive_get_component_927, METH_O, (const char *)Dtool_EggCompositePrimitive_get_component_927_comment},
  {"set_component", (PyCFunction) &Dtool_EggCompositePrimitive_set_component_929, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggCompositePrimitive_set_component_929_comment},
  {"setComponent", (PyCFunction) &Dtool_EggCompositePrimitive_set_component_929, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggCompositePrimitive_set_component_929_comment},
  {"triangulate_into", &Dtool_EggCompositePrimitive_triangulate_into_932, METH_O, (const char *)Dtool_EggCompositePrimitive_triangulate_into_932_comment},
  {"triangulateInto", &Dtool_EggCompositePrimitive_triangulate_into_932, METH_O, (const char *)Dtool_EggCompositePrimitive_triangulate_into_932_comment},
  {"triangulate_in_place", &Dtool_EggCompositePrimitive_triangulate_in_place_933, METH_NOARGS, (const char *)Dtool_EggCompositePrimitive_triangulate_in_place_933_comment},
  {"triangulateInPlace", &Dtool_EggCompositePrimitive_triangulate_in_place_933, METH_NOARGS, (const char *)Dtool_EggCompositePrimitive_triangulate_in_place_933_comment},
  {"get_class_type", &Dtool_EggCompositePrimitive_get_class_type_934, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggCompositePrimitive_get_class_type_934_comment},
  {"getClassType", &Dtool_EggCompositePrimitive_get_class_type_934, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggCompositePrimitive_get_class_type_934_comment},
  {"get_components", (PyCFunction) &MakeSeq_EggCompositePrimitive_get_components, METH_NOARGS, nullptr},
  { "getComponents", (PyCFunction) &MakeSeq_EggCompositePrimitive_get_components, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_EggCompositePrimitive[] = {
  {(char *)"components", &Dtool_EggCompositePrimitive_components_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_EggCompositePrimitive = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggCompositePrimitive = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggCompositePrimitive = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggCompositePrimitive = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggCompositePrimitive = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggCompositePrimitive = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggCompositePrimitive",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggCompositePrimitive,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggCompositePrimitive,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggCompositePrimitive,
    &Dtool_SequenceMethods_EggCompositePrimitive,
    &Dtool_MappingMethods_EggCompositePrimitive,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggCompositePrimitive,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The base class for primitives such as triangle strips and triangle fans,\n"
    " * which include several component triangles, each of which might have its own\n"
    " * color and/or normal.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggCompositePrimitive,
    nullptr, // tp_members
    Dtool_Properties_EggCompositePrimitive,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggCompositePrimitive,
    PyType_GenericAlloc,
    Dtool_new_EggCompositePrimitive,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggCompositePrimitive,
  Dtool_UpcastInterface_EggCompositePrimitive,
  Dtool_DowncastInterface_EggCompositePrimitive,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggCompositePrimitive(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggPrimitive(nullptr);
    Dtool_EggCompositePrimitive._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggPrimitive);
    Dtool_EggCompositePrimitive._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggCompositePrimitive._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggCompositePrimitive) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggCompositePrimitive)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggCompositePrimitive);
  }
}

/**
 * Python method tables for EggData (EggData)
 */
static PyMethodDef Dtool_Methods_EggData[] = {
  {"assign", &Dtool_EggData_operator_937, METH_O, (const char *)Dtool_EggData_operator_937_comment},
  {"resolve_egg_filename", (PyCFunction) &Dtool_EggData_resolve_egg_filename_938, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_EggData_resolve_egg_filename_938_comment},
  {"resolveEggFilename", (PyCFunction) &Dtool_EggData_resolve_egg_filename_938, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_EggData_resolve_egg_filename_938_comment},
  {"read", (PyCFunction) &Dtool_EggData_read_939, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggData_read_939_comment},
  {"merge", &Dtool_EggData_merge_940, METH_O, (const char *)Dtool_EggData_merge_940_comment},
  {"load_externals", (PyCFunction) &Dtool_EggData_load_externals_941, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggData_load_externals_941_comment},
  {"loadExternals", (PyCFunction) &Dtool_EggData_load_externals_941, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggData_load_externals_941_comment},
  {"collapse_equivalent_textures", &Dtool_EggData_collapse_equivalent_textures_942, METH_NOARGS, (const char *)Dtool_EggData_collapse_equivalent_textures_942_comment},
  {"collapseEquivalentTextures", &Dtool_EggData_collapse_equivalent_textures_942, METH_NOARGS, (const char *)Dtool_EggData_collapse_equivalent_textures_942_comment},
  {"collapse_equivalent_materials", &Dtool_EggData_collapse_equivalent_materials_943, METH_NOARGS, (const char *)Dtool_EggData_collapse_equivalent_materials_943_comment},
  {"collapseEquivalentMaterials", &Dtool_EggData_collapse_equivalent_materials_943, METH_NOARGS, (const char *)Dtool_EggData_collapse_equivalent_materials_943_comment},
  {"write_egg", &Dtool_EggData_write_egg_944, METH_O, (const char *)Dtool_EggData_write_egg_944_comment},
  {"writeEgg", &Dtool_EggData_write_egg_944, METH_O, (const char *)Dtool_EggData_write_egg_944_comment},
  {"set_auto_resolve_externals", &Dtool_EggData_set_auto_resolve_externals_945, METH_O, (const char *)Dtool_EggData_set_auto_resolve_externals_945_comment},
  {"setAutoResolveExternals", &Dtool_EggData_set_auto_resolve_externals_945, METH_O, (const char *)Dtool_EggData_set_auto_resolve_externals_945_comment},
  {"get_auto_resolve_externals", &Dtool_EggData_get_auto_resolve_externals_946, METH_NOARGS, (const char *)Dtool_EggData_get_auto_resolve_externals_946_comment},
  {"getAutoResolveExternals", &Dtool_EggData_get_auto_resolve_externals_946, METH_NOARGS, (const char *)Dtool_EggData_get_auto_resolve_externals_946_comment},
  {"original_had_absolute_pathnames", &Dtool_EggData_original_had_absolute_pathnames_947, METH_NOARGS, (const char *)Dtool_EggData_original_had_absolute_pathnames_947_comment},
  {"originalHadAbsolutePathnames", &Dtool_EggData_original_had_absolute_pathnames_947, METH_NOARGS, (const char *)Dtool_EggData_original_had_absolute_pathnames_947_comment},
  {"set_coordinate_system", &Dtool_EggData_set_coordinate_system_948, METH_O, (const char *)Dtool_EggData_set_coordinate_system_948_comment},
  {"setCoordinateSystem", &Dtool_EggData_set_coordinate_system_948, METH_O, (const char *)Dtool_EggData_set_coordinate_system_948_comment},
  {"get_coordinate_system", &Dtool_EggData_get_coordinate_system_949, METH_NOARGS, (const char *)Dtool_EggData_get_coordinate_system_949_comment},
  {"getCoordinateSystem", &Dtool_EggData_get_coordinate_system_949, METH_NOARGS, (const char *)Dtool_EggData_get_coordinate_system_949_comment},
  {"set_egg_filename", &Dtool_EggData_set_egg_filename_950, METH_O, (const char *)Dtool_EggData_set_egg_filename_950_comment},
  {"setEggFilename", &Dtool_EggData_set_egg_filename_950, METH_O, (const char *)Dtool_EggData_set_egg_filename_950_comment},
  {"get_egg_filename", &Dtool_EggData_get_egg_filename_951, METH_NOARGS, (const char *)Dtool_EggData_get_egg_filename_951_comment},
  {"getEggFilename", &Dtool_EggData_get_egg_filename_951, METH_NOARGS, (const char *)Dtool_EggData_get_egg_filename_951_comment},
  {"set_egg_timestamp", &Dtool_EggData_set_egg_timestamp_952, METH_O, (const char *)Dtool_EggData_set_egg_timestamp_952_comment},
  {"setEggTimestamp", &Dtool_EggData_set_egg_timestamp_952, METH_O, (const char *)Dtool_EggData_set_egg_timestamp_952_comment},
  {"get_egg_timestamp", &Dtool_EggData_get_egg_timestamp_953, METH_NOARGS, (const char *)Dtool_EggData_get_egg_timestamp_953_comment},
  {"getEggTimestamp", &Dtool_EggData_get_egg_timestamp_953, METH_NOARGS, (const char *)Dtool_EggData_get_egg_timestamp_953_comment},
  {"recompute_vertex_normals", &Dtool_EggData_recompute_vertex_normals_961, METH_O, (const char *)Dtool_EggData_recompute_vertex_normals_961_comment},
  {"recomputeVertexNormals", &Dtool_EggData_recompute_vertex_normals_961, METH_O, (const char *)Dtool_EggData_recompute_vertex_normals_961_comment},
  {"recompute_polygon_normals", &Dtool_EggData_recompute_polygon_normals_962, METH_NOARGS, (const char *)Dtool_EggData_recompute_polygon_normals_962_comment},
  {"recomputePolygonNormals", &Dtool_EggData_recompute_polygon_normals_962, METH_NOARGS, (const char *)Dtool_EggData_recompute_polygon_normals_962_comment},
  {"strip_normals", &Dtool_EggData_strip_normals_963, METH_NOARGS, (const char *)Dtool_EggData_strip_normals_963_comment},
  {"stripNormals", &Dtool_EggData_strip_normals_963, METH_NOARGS, (const char *)Dtool_EggData_strip_normals_963_comment},
  {"get_class_type", &Dtool_EggData_get_class_type_964, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggData_get_class_type_964_comment},
  {"getClassType", &Dtool_EggData_get_class_type_964, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggData_get_class_type_964_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_EggData[] = {
  {(char *)"auto_resolve_externals", &Dtool_EggData_auto_resolve_externals_Getter, &Dtool_EggData_auto_resolve_externals_Setter, nullptr, nullptr},
  {(char *)"coordinate_system", &Dtool_EggData_coordinate_system_Getter, &Dtool_EggData_coordinate_system_Setter, nullptr, nullptr},
  {(char *)"egg_filename", &Dtool_EggData_egg_filename_Getter, &Dtool_EggData_egg_filename_Setter, nullptr, nullptr},
  {(char *)"egg_timestamp", &Dtool_EggData_egg_timestamp_Getter, &Dtool_EggData_egg_timestamp_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_EggData = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggData = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggData = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggData = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggData = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggData = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggData",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggData,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggData,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggData,
    &Dtool_SequenceMethods_EggData,
    &Dtool_MappingMethods_EggData,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggData,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the primary interface into all the egg data, and the root of the\n"
    " * egg file structure.  An EggData structure corresponds exactly with an egg\n"
    " * file on the disk.\n"
    " *\n"
    " * The EggData class inherits from EggGroupNode its collection of children,\n"
    " * which are accessed by using the EggData itself as an STL container with\n"
    " * begin() and end() calls.  The children of the EggData class are the\n"
    " * toplevel nodes in the egg file.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggData,
    nullptr, // tp_members
    Dtool_Properties_EggData,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggData,
    PyType_GenericAlloc,
    Dtool_new_EggData,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggData,
  Dtool_UpcastInterface_EggData,
  Dtool_DowncastInterface_EggData,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggGroupNode(nullptr);
    Dtool_EggData._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggGroupNode);
    Dtool_EggData._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggData);
  }
}

/**
 * Python method tables for EggCoordinateSystem (EggCoordinateSystem)
 */
static PyMethodDef Dtool_Methods_EggCoordinateSystem[] = {
  {"set_value", &Dtool_EggCoordinateSystem_set_value_968, METH_O, (const char *)Dtool_EggCoordinateSystem_set_value_968_comment},
  {"setValue", &Dtool_EggCoordinateSystem_set_value_968, METH_O, (const char *)Dtool_EggCoordinateSystem_set_value_968_comment},
  {"get_value", &Dtool_EggCoordinateSystem_get_value_969, METH_NOARGS, (const char *)Dtool_EggCoordinateSystem_get_value_969_comment},
  {"getValue", &Dtool_EggCoordinateSystem_get_value_969, METH_NOARGS, (const char *)Dtool_EggCoordinateSystem_get_value_969_comment},
  {"get_class_type", &Dtool_EggCoordinateSystem_get_class_type_970, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggCoordinateSystem_get_class_type_970_comment},
  {"getClassType", &Dtool_EggCoordinateSystem_get_class_type_970, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggCoordinateSystem_get_class_type_970_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EggCoordinateSystem = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggCoordinateSystem = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggCoordinateSystem = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggCoordinateSystem = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggCoordinateSystem = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggCoordinateSystem = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggCoordinateSystem",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggCoordinateSystem,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggCoordinateSystem,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggCoordinateSystem,
    &Dtool_SequenceMethods_EggCoordinateSystem,
    &Dtool_MappingMethods_EggCoordinateSystem,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggCoordinateSystem,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The <CoordinateSystem> entry at the top of an egg file.  Don't confuse this\n"
    " * with the enum EggData::CoordinateSystem, which is the value contained by\n"
    " * this entry.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggCoordinateSystem,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggCoordinateSystem,
    PyType_GenericAlloc,
    Dtool_new_EggCoordinateSystem,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggCoordinateSystem,
  Dtool_UpcastInterface_EggCoordinateSystem,
  Dtool_DowncastInterface_EggCoordinateSystem,
  (CoerceFunction)Dtool_ConstCoerce_EggCoordinateSystem,
  (CoerceFunction)Dtool_Coerce_EggCoordinateSystem,
};

static void Dtool_PyModuleClassInit_EggCoordinateSystem(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggNode(nullptr);
    Dtool_EggCoordinateSystem._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggNode);
    Dtool_EggCoordinateSystem._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggCoordinateSystem._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggCoordinateSystem) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggCoordinateSystem)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggCoordinateSystem);
  }
}

/**
 * Python method tables for EggCurve (EggCurve)
 */
static PyMethodDef Dtool_Methods_EggCurve[] = {
  {"assign", &Dtool_EggCurve_operator_973, METH_O, (const char *)Dtool_EggCurve_operator_973_comment},
  {"set_subdiv", &Dtool_EggCurve_set_subdiv_975, METH_O, (const char *)Dtool_EggCurve_set_subdiv_975_comment},
  {"setSubdiv", &Dtool_EggCurve_set_subdiv_975, METH_O, (const char *)Dtool_EggCurve_set_subdiv_975_comment},
  {"get_subdiv", &Dtool_EggCurve_get_subdiv_976, METH_NOARGS, (const char *)Dtool_EggCurve_get_subdiv_976_comment},
  {"getSubdiv", &Dtool_EggCurve_get_subdiv_976, METH_NOARGS, (const char *)Dtool_EggCurve_get_subdiv_976_comment},
  {"set_curve_type", &Dtool_EggCurve_set_curve_type_977, METH_O, (const char *)Dtool_EggCurve_set_curve_type_977_comment},
  {"setCurveType", &Dtool_EggCurve_set_curve_type_977, METH_O, (const char *)Dtool_EggCurve_set_curve_type_977_comment},
  {"get_curve_type", &Dtool_EggCurve_get_curve_type_978, METH_NOARGS, (const char *)Dtool_EggCurve_get_curve_type_978_comment},
  {"getCurveType", &Dtool_EggCurve_get_curve_type_978, METH_NOARGS, (const char *)Dtool_EggCurve_get_curve_type_978_comment},
  {"string_curve_type", &Dtool_EggCurve_string_curve_type_979, METH_O | METH_STATIC, (const char *)Dtool_EggCurve_string_curve_type_979_comment},
  {"stringCurveType", &Dtool_EggCurve_string_curve_type_979, METH_O | METH_STATIC, (const char *)Dtool_EggCurve_string_curve_type_979_comment},
  {"get_class_type", &Dtool_EggCurve_get_class_type_980, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggCurve_get_class_type_980_comment},
  {"getClassType", &Dtool_EggCurve_get_class_type_980, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggCurve_get_class_type_980_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EggCurve = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggCurve = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggCurve = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggCurve = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggCurve = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggCurve = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggCurve",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggCurve,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggCurve,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggCurve,
    &Dtool_SequenceMethods_EggCurve,
    &Dtool_MappingMethods_EggCurve,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggCurve,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A parametric curve of some kind.  See EggNurbsCurve.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggCurve,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggCurve,
    PyType_GenericAlloc,
    Dtool_new_EggCurve,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggCurve,
  Dtool_UpcastInterface_EggCurve,
  Dtool_DowncastInterface_EggCurve,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggCurve(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggPrimitive(nullptr);
    Dtool_EggCurve._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggPrimitive);
    Dtool_EggCurve._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(9);
    Dtool_EggCurve._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum EggCurve::CurveType;
    PyDict_SetItemString(dict, "CT_none", Dtool_WrapValue(EggCurve::CT_none));
    PyDict_SetItemString(dict, "CTNone", Dtool_WrapValue(EggCurve::CT_none));
    PyDict_SetItemString(dict, "CT_xyz", Dtool_WrapValue(EggCurve::CT_xyz));
    PyDict_SetItemString(dict, "CTXyz", Dtool_WrapValue(EggCurve::CT_xyz));
    PyDict_SetItemString(dict, "CT_hpr", Dtool_WrapValue(EggCurve::CT_hpr));
    PyDict_SetItemString(dict, "CTHpr", Dtool_WrapValue(EggCurve::CT_hpr));
    PyDict_SetItemString(dict, "CT_t", Dtool_WrapValue(EggCurve::CT_t));
    PyDict_SetItemString(dict, "CTT", Dtool_WrapValue(EggCurve::CT_t));
    if (PyType_Ready((PyTypeObject *)&Dtool_EggCurve) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggCurve)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggCurve);
  }
}

/**
 * Python method tables for EggExternalReference (EggExternalReference)
 */
static PyMethodDef Dtool_Methods_EggExternalReference[] = {
  {"assign", &Dtool_EggExternalReference_operator_984, METH_O, (const char *)Dtool_EggExternalReference_operator_984_comment},
  {"get_class_type", &Dtool_EggExternalReference_get_class_type_985, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggExternalReference_get_class_type_985_comment},
  {"getClassType", &Dtool_EggExternalReference_get_class_type_985, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggExternalReference_get_class_type_985_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EggExternalReference = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggExternalReference = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggExternalReference = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggExternalReference = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggExternalReference = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggExternalReference = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggExternalReference",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggExternalReference,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggExternalReference,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggExternalReference,
    &Dtool_SequenceMethods_EggExternalReference,
    &Dtool_MappingMethods_EggExternalReference,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggExternalReference,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Defines a reference to another egg file which should be inserted at this\n"
    " * point.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggExternalReference,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggExternalReference,
    PyType_GenericAlloc,
    Dtool_new_EggExternalReference,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggExternalReference,
  Dtool_UpcastInterface_EggExternalReference,
  Dtool_DowncastInterface_EggExternalReference,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggExternalReference(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggFilenameNode(nullptr);
    Dtool_EggExternalReference._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggFilenameNode);
    Dtool_EggExternalReference._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggExternalReference._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggExternalReference) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggExternalReference)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggExternalReference);
  }
}

/**
 * Python method tables for EggNameUniquifier (EggNameUniquifier)
 */
static PyMethodDef Dtool_Methods_EggNameUniquifier[] = {
  {"clear", &Dtool_EggNameUniquifier_clear_988, METH_NOARGS, (const char *)Dtool_EggNameUniquifier_clear_988_comment},
  {"uniquify", &Dtool_EggNameUniquifier_uniquify_989, METH_O, (const char *)Dtool_EggNameUniquifier_uniquify_989_comment},
  {"get_node", (PyCFunction) &Dtool_EggNameUniquifier_get_node_990, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNameUniquifier_get_node_990_comment},
  {"getNode", (PyCFunction) &Dtool_EggNameUniquifier_get_node_990, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNameUniquifier_get_node_990_comment},
  {"has_name", (PyCFunction) &Dtool_EggNameUniquifier_has_name_991, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNameUniquifier_has_name_991_comment},
  {"hasName", (PyCFunction) &Dtool_EggNameUniquifier_has_name_991, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNameUniquifier_has_name_991_comment},
  {"add_name", (PyCFunction) &Dtool_EggNameUniquifier_add_name_992, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNameUniquifier_add_name_992_comment},
  {"addName", (PyCFunction) &Dtool_EggNameUniquifier_add_name_992, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNameUniquifier_add_name_992_comment},
  {"get_category", &Dtool_EggNameUniquifier_get_category_993, METH_O, (const char *)Dtool_EggNameUniquifier_get_category_993_comment},
  {"getCategory", &Dtool_EggNameUniquifier_get_category_993, METH_O, (const char *)Dtool_EggNameUniquifier_get_category_993_comment},
  {"filter_name", &Dtool_EggNameUniquifier_filter_name_994, METH_O, (const char *)Dtool_EggNameUniquifier_filter_name_994_comment},
  {"filterName", &Dtool_EggNameUniquifier_filter_name_994, METH_O, (const char *)Dtool_EggNameUniquifier_filter_name_994_comment},
  {"generate_name", (PyCFunction) &Dtool_EggNameUniquifier_generate_name_995, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNameUniquifier_generate_name_995_comment},
  {"generateName", (PyCFunction) &Dtool_EggNameUniquifier_generate_name_995, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNameUniquifier_generate_name_995_comment},
  {"get_class_type", &Dtool_EggNameUniquifier_get_class_type_996, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggNameUniquifier_get_class_type_996_comment},
  {"getClassType", &Dtool_EggNameUniquifier_get_class_type_996, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggNameUniquifier_get_class_type_996_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EggNameUniquifier = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggNameUniquifier = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggNameUniquifier = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggNameUniquifier = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggNameUniquifier = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggNameUniquifier = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggNameUniquifier",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggNameUniquifier,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggNameUniquifier,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggNameUniquifier,
    &Dtool_SequenceMethods_EggNameUniquifier,
    &Dtool_MappingMethods_EggNameUniquifier,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggNameUniquifier,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a handy class for guaranteeing unique node names in an egg\n"
    " * hierarchy.  It is an abstract class; to use it you must subclass off of it.\n"
    " * See the comment above.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggNameUniquifier,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggNameUniquifier,
    PyType_GenericAlloc,
    Dtool_new_EggNameUniquifier,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggNameUniquifier,
  Dtool_UpcastInterface_EggNameUniquifier,
  Dtool_DowncastInterface_EggNameUniquifier,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggNameUniquifier(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggObject(nullptr);
    Dtool_EggNameUniquifier._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggObject);
    Dtool_EggNameUniquifier._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggNameUniquifier._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggNameUniquifier) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggNameUniquifier)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggNameUniquifier);
  }
}

/**
 * Python method tables for EggGroupUniquifier (EggGroupUniquifier)
 */
static PyMethodDef Dtool_Methods_EggGroupUniquifier[] = {
  {"get_class_type", &Dtool_EggGroupUniquifier_get_class_type_999, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggGroupUniquifier_get_class_type_999_comment},
  {"getClassType", &Dtool_EggGroupUniquifier_get_class_type_999, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggGroupUniquifier_get_class_type_999_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EggGroupUniquifier = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggGroupUniquifier = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggGroupUniquifier = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggGroupUniquifier = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggGroupUniquifier = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggGroupUniquifier = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggGroupUniquifier",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggGroupUniquifier,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggGroupUniquifier,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggGroupUniquifier,
    &Dtool_SequenceMethods_EggGroupUniquifier,
    &Dtool_MappingMethods_EggGroupUniquifier,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggGroupUniquifier,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a specialization of EggNameUniquifier to generate unique names for\n"
    " * EggGroup nodes.  It's not called automatically; you must invoke it yourself\n"
    " * if you want it.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggGroupUniquifier,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggGroupUniquifier,
    PyType_GenericAlloc,
    Dtool_new_EggGroupUniquifier,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggGroupUniquifier,
  Dtool_UpcastInterface_EggGroupUniquifier,
  Dtool_DowncastInterface_EggGroupUniquifier,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggGroupUniquifier(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggNameUniquifier(nullptr);
    Dtool_EggGroupUniquifier._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggNameUniquifier);
    Dtool_EggGroupUniquifier._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggGroupUniquifier._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggGroupUniquifier) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggGroupUniquifier)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggGroupUniquifier);
  }
}

/**
 * Python method tables for EggLine (EggLine)
 */
static PyMethodDef Dtool_Methods_EggLine[] = {
  {"assign", &Dtool_EggLine_operator_1003, METH_O, (const char *)Dtool_EggLine_operator_1003_comment},
  {"has_thick", &Dtool_EggLine_has_thick_1004, METH_NOARGS, (const char *)Dtool_EggLine_has_thick_1004_comment},
  {"hasThick", &Dtool_EggLine_has_thick_1004, METH_NOARGS, (const char *)Dtool_EggLine_has_thick_1004_comment},
  {"get_thick", &Dtool_EggLine_get_thick_1005, METH_NOARGS, (const char *)Dtool_EggLine_get_thick_1005_comment},
  {"getThick", &Dtool_EggLine_get_thick_1005, METH_NOARGS, (const char *)Dtool_EggLine_get_thick_1005_comment},
  {"set_thick", &Dtool_EggLine_set_thick_1006, METH_O, (const char *)Dtool_EggLine_set_thick_1006_comment},
  {"setThick", &Dtool_EggLine_set_thick_1006, METH_O, (const char *)Dtool_EggLine_set_thick_1006_comment},
  {"clear_thick", &Dtool_EggLine_clear_thick_1007, METH_NOARGS, (const char *)Dtool_EggLine_clear_thick_1007_comment},
  {"clearThick", &Dtool_EggLine_clear_thick_1007, METH_NOARGS, (const char *)Dtool_EggLine_clear_thick_1007_comment},
  {"get_class_type", &Dtool_EggLine_get_class_type_1008, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggLine_get_class_type_1008_comment},
  {"getClassType", &Dtool_EggLine_get_class_type_1008, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggLine_get_class_type_1008_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EggLine = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggLine = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggLine = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggLine = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggLine = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggLine = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggLine",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggLine,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggLine,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggLine,
    &Dtool_SequenceMethods_EggLine,
    &Dtool_MappingMethods_EggLine,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggLine,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A line segment, or a series of connected line segments, defined by a <Line>\n"
    " * entry.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggLine,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggLine,
    PyType_GenericAlloc,
    Dtool_new_EggLine,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggLine,
  Dtool_UpcastInterface_EggLine,
  Dtool_DowncastInterface_EggLine,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggLine(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggCompositePrimitive(nullptr);
    Dtool_EggLine._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggCompositePrimitive);
    Dtool_EggLine._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggLine._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggLine) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggLine)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggLine);
  }
}

/**
 * Python method tables for EggMaterialCollection (EggMaterialCollection)
 */
static PyMethodDef Dtool_Methods_EggMaterialCollection[] = {
  {"assign", &Dtool_EggMaterialCollection_operator_1011, METH_O, (const char *)Dtool_EggMaterialCollection_operator_1011_comment},
  {"clear", &Dtool_EggMaterialCollection_clear_1013, METH_NOARGS, (const char *)Dtool_EggMaterialCollection_clear_1013_comment},
  {"extract_materials", &Dtool_EggMaterialCollection_extract_materials_1014, METH_O, (const char *)Dtool_EggMaterialCollection_extract_materials_1014_comment},
  {"extractMaterials", &Dtool_EggMaterialCollection_extract_materials_1014, METH_O, (const char *)Dtool_EggMaterialCollection_extract_materials_1014_comment},
  {"find_used_materials", &Dtool_EggMaterialCollection_find_used_materials_1015, METH_O, (const char *)Dtool_EggMaterialCollection_find_used_materials_1015_comment},
  {"findUsedMaterials", &Dtool_EggMaterialCollection_find_used_materials_1015, METH_O, (const char *)Dtool_EggMaterialCollection_find_used_materials_1015_comment},
  {"remove_unused_materials", &Dtool_EggMaterialCollection_remove_unused_materials_1016, METH_O, (const char *)Dtool_EggMaterialCollection_remove_unused_materials_1016_comment},
  {"removeUnusedMaterials", &Dtool_EggMaterialCollection_remove_unused_materials_1016, METH_O, (const char *)Dtool_EggMaterialCollection_remove_unused_materials_1016_comment},
  {"collapse_equivalent_materials", (PyCFunction) &Dtool_EggMaterialCollection_collapse_equivalent_materials_1017, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggMaterialCollection_collapse_equivalent_materials_1017_comment},
  {"collapseEquivalentMaterials", (PyCFunction) &Dtool_EggMaterialCollection_collapse_equivalent_materials_1017, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggMaterialCollection_collapse_equivalent_materials_1017_comment},
  {"uniquify_mrefs", &Dtool_EggMaterialCollection_uniquify_mrefs_1019, METH_NOARGS, (const char *)Dtool_EggMaterialCollection_uniquify_mrefs_1019_comment},
  {"uniquifyMrefs", &Dtool_EggMaterialCollection_uniquify_mrefs_1019, METH_NOARGS, (const char *)Dtool_EggMaterialCollection_uniquify_mrefs_1019_comment},
  {"sort_by_mref", &Dtool_EggMaterialCollection_sort_by_mref_1020, METH_NOARGS, (const char *)Dtool_EggMaterialCollection_sort_by_mref_1020_comment},
  {"sortByMref", &Dtool_EggMaterialCollection_sort_by_mref_1020, METH_NOARGS, (const char *)Dtool_EggMaterialCollection_sort_by_mref_1020_comment},
  {"add_material", &Dtool_EggMaterialCollection_add_material_1021, METH_O, (const char *)Dtool_EggMaterialCollection_add_material_1021_comment},
  {"addMaterial", &Dtool_EggMaterialCollection_add_material_1021, METH_O, (const char *)Dtool_EggMaterialCollection_add_material_1021_comment},
  {"remove_material", &Dtool_EggMaterialCollection_remove_material_1022, METH_O, (const char *)Dtool_EggMaterialCollection_remove_material_1022_comment},
  {"removeMaterial", &Dtool_EggMaterialCollection_remove_material_1022, METH_O, (const char *)Dtool_EggMaterialCollection_remove_material_1022_comment},
  {"create_unique_material", (PyCFunction) &Dtool_EggMaterialCollection_create_unique_material_1023, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggMaterialCollection_create_unique_material_1023_comment},
  {"createUniqueMaterial", (PyCFunction) &Dtool_EggMaterialCollection_create_unique_material_1023, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggMaterialCollection_create_unique_material_1023_comment},
  {"find_mref", &Dtool_EggMaterialCollection_find_mref_1024, METH_O, (const char *)Dtool_EggMaterialCollection_find_mref_1024_comment},
  {"findMref", &Dtool_EggMaterialCollection_find_mref_1024, METH_O, (const char *)Dtool_EggMaterialCollection_find_mref_1024_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EggMaterialCollection = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_EggMaterialCollection = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggMaterialCollection",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggMaterialCollection,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggMaterialCollection,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a collection of materials by MRef name.  It can extract the\n"
    " * materials from an egg file and sort them all together; it can also manage\n"
    " * the creation of unique materials and the assignment of unique MRef names.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggMaterialCollection,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggMaterialCollection,
    PyType_GenericAlloc,
    Dtool_new_EggMaterialCollection,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggMaterialCollection,
  Dtool_UpcastInterface_EggMaterialCollection,
  Dtool_DowncastInterface_EggMaterialCollection,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggMaterialCollection(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_EggMaterialCollection._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggMaterialCollection._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggMaterialCollection) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggMaterialCollection)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggMaterialCollection);
  }
}

/**
 * Python method tables for EggPolygon (EggPolygon)
 */
static PyMethodDef Dtool_Methods_EggPolygon[] = {
  {"assign", &Dtool_EggPolygon_operator_1027, METH_O, (const char *)Dtool_EggPolygon_operator_1027_comment},
  {"calculate_normal", (PyCFunction) &Dtool_EggPolygon_calculate_normal_1028, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggPolygon_calculate_normal_1028_comment},
  {"calculateNormal", (PyCFunction) &Dtool_EggPolygon_calculate_normal_1028, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggPolygon_calculate_normal_1028_comment},
  {"is_planar", &Dtool_EggPolygon_is_planar_1029, METH_NOARGS, (const char *)Dtool_EggPolygon_is_planar_1029_comment},
  {"isPlanar", &Dtool_EggPolygon_is_planar_1029, METH_NOARGS, (const char *)Dtool_EggPolygon_is_planar_1029_comment},
  {"recompute_polygon_normal", (PyCFunction) &Dtool_EggPolygon_recompute_polygon_normal_1030, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggPolygon_recompute_polygon_normal_1030_comment},
  {"recomputePolygonNormal", (PyCFunction) &Dtool_EggPolygon_recompute_polygon_normal_1030, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggPolygon_recompute_polygon_normal_1030_comment},
  {"triangulate_into", (PyCFunction) &Dtool_EggPolygon_triangulate_into_1031, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggPolygon_triangulate_into_1031_comment},
  {"triangulateInto", (PyCFunction) &Dtool_EggPolygon_triangulate_into_1031, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggPolygon_triangulate_into_1031_comment},
  {"triangulate_in_place", &Dtool_EggPolygon_triangulate_in_place_1032, METH_O, (const char *)Dtool_EggPolygon_triangulate_in_place_1032_comment},
  {"triangulateInPlace", &Dtool_EggPolygon_triangulate_in_place_1032, METH_O, (const char *)Dtool_EggPolygon_triangulate_in_place_1032_comment},
  {"get_class_type", &Dtool_EggPolygon_get_class_type_1033, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggPolygon_get_class_type_1033_comment},
  {"getClassType", &Dtool_EggPolygon_get_class_type_1033, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggPolygon_get_class_type_1033_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EggPolygon = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggPolygon = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggPolygon = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggPolygon = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggPolygon = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggPolygon = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggPolygon",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggPolygon,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggPolygon,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggPolygon,
    &Dtool_SequenceMethods_EggPolygon,
    &Dtool_MappingMethods_EggPolygon,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggPolygon,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A single polygon.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggPolygon,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggPolygon,
    PyType_GenericAlloc,
    Dtool_new_EggPolygon,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggPolygon,
  Dtool_UpcastInterface_EggPolygon,
  Dtool_DowncastInterface_EggPolygon,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggPolygon(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggPrimitive(nullptr);
    Dtool_EggPolygon._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggPrimitive);
    Dtool_EggPolygon._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggPolygon._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggPolygon) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggPolygon)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggPolygon);
  }
}

/**
 * Python method tables for EggNurbsCurve (EggNurbsCurve)
 */
static PyMethodDef Dtool_Methods_EggNurbsCurve[] = {
  {"assign", &Dtool_EggNurbsCurve_operator_1037, METH_O, (const char *)Dtool_EggNurbsCurve_operator_1037_comment},
  {"setup", (PyCFunction) &Dtool_EggNurbsCurve_setup_1038, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNurbsCurve_setup_1038_comment},
  {"set_order", &Dtool_EggNurbsCurve_set_order_1039, METH_O, (const char *)Dtool_EggNurbsCurve_set_order_1039_comment},
  {"setOrder", &Dtool_EggNurbsCurve_set_order_1039, METH_O, (const char *)Dtool_EggNurbsCurve_set_order_1039_comment},
  {"set_num_knots", &Dtool_EggNurbsCurve_set_num_knots_1040, METH_O, (const char *)Dtool_EggNurbsCurve_set_num_knots_1040_comment},
  {"setNumKnots", &Dtool_EggNurbsCurve_set_num_knots_1040, METH_O, (const char *)Dtool_EggNurbsCurve_set_num_knots_1040_comment},
  {"set_knot", (PyCFunction) &Dtool_EggNurbsCurve_set_knot_1041, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNurbsCurve_set_knot_1041_comment},
  {"setKnot", (PyCFunction) &Dtool_EggNurbsCurve_set_knot_1041, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNurbsCurve_set_knot_1041_comment},
  {"is_valid", &Dtool_EggNurbsCurve_is_valid_1042, METH_NOARGS, (const char *)Dtool_EggNurbsCurve_is_valid_1042_comment},
  {"isValid", &Dtool_EggNurbsCurve_is_valid_1042, METH_NOARGS, (const char *)Dtool_EggNurbsCurve_is_valid_1042_comment},
  {"get_order", &Dtool_EggNurbsCurve_get_order_1043, METH_NOARGS, (const char *)Dtool_EggNurbsCurve_get_order_1043_comment},
  {"getOrder", &Dtool_EggNurbsCurve_get_order_1043, METH_NOARGS, (const char *)Dtool_EggNurbsCurve_get_order_1043_comment},
  {"get_degree", &Dtool_EggNurbsCurve_get_degree_1044, METH_NOARGS, (const char *)Dtool_EggNurbsCurve_get_degree_1044_comment},
  {"getDegree", &Dtool_EggNurbsCurve_get_degree_1044, METH_NOARGS, (const char *)Dtool_EggNurbsCurve_get_degree_1044_comment},
  {"get_num_knots", &Dtool_EggNurbsCurve_get_num_knots_1045, METH_NOARGS, (const char *)Dtool_EggNurbsCurve_get_num_knots_1045_comment},
  {"getNumKnots", &Dtool_EggNurbsCurve_get_num_knots_1045, METH_NOARGS, (const char *)Dtool_EggNurbsCurve_get_num_knots_1045_comment},
  {"get_num_cvs", &Dtool_EggNurbsCurve_get_num_cvs_1046, METH_NOARGS, (const char *)Dtool_EggNurbsCurve_get_num_cvs_1046_comment},
  {"getNumCvs", &Dtool_EggNurbsCurve_get_num_cvs_1046, METH_NOARGS, (const char *)Dtool_EggNurbsCurve_get_num_cvs_1046_comment},
  {"is_closed", &Dtool_EggNurbsCurve_is_closed_1047, METH_NOARGS, (const char *)Dtool_EggNurbsCurve_is_closed_1047_comment},
  {"isClosed", &Dtool_EggNurbsCurve_is_closed_1047, METH_NOARGS, (const char *)Dtool_EggNurbsCurve_is_closed_1047_comment},
  {"get_knot", &Dtool_EggNurbsCurve_get_knot_1048, METH_O, (const char *)Dtool_EggNurbsCurve_get_knot_1048_comment},
  {"getKnot", &Dtool_EggNurbsCurve_get_knot_1048, METH_O, (const char *)Dtool_EggNurbsCurve_get_knot_1048_comment},
  {"get_class_type", &Dtool_EggNurbsCurve_get_class_type_1054, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggNurbsCurve_get_class_type_1054_comment},
  {"getClassType", &Dtool_EggNurbsCurve_get_class_type_1054, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggNurbsCurve_get_class_type_1054_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_knots", (PyCFunction) &MakeSeq_EggNurbsCurve_get_knots, METH_NOARGS, nullptr},
  { "getKnots", (PyCFunction) &MakeSeq_EggNurbsCurve_get_knots, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_EggNurbsCurve[] = {
  {(char *)"order", &Dtool_EggNurbsCurve_order_Getter, &Dtool_EggNurbsCurve_order_Setter, nullptr, nullptr},
  {(char *)"degree", &Dtool_EggNurbsCurve_degree_Getter, nullptr, nullptr, nullptr},
  {(char *)"closed", &Dtool_EggNurbsCurve_closed_Getter, nullptr, nullptr, nullptr},
  {(char *)"knots", &Dtool_EggNurbsCurve_knots_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_EggNurbsCurve = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggNurbsCurve = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggNurbsCurve = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggNurbsCurve = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggNurbsCurve = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggNurbsCurve = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggNurbsCurve",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggNurbsCurve,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggNurbsCurve,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggNurbsCurve,
    &Dtool_SequenceMethods_EggNurbsCurve,
    &Dtool_MappingMethods_EggNurbsCurve,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggNurbsCurve,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A parametric NURBS curve.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggNurbsCurve,
    nullptr, // tp_members
    Dtool_Properties_EggNurbsCurve,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggNurbsCurve,
    PyType_GenericAlloc,
    Dtool_new_EggNurbsCurve,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggNurbsCurve,
  Dtool_UpcastInterface_EggNurbsCurve,
  Dtool_DowncastInterface_EggNurbsCurve,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggNurbsCurve(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggCurve(nullptr);
    Dtool_EggNurbsCurve._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggCurve);
    Dtool_EggNurbsCurve._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggNurbsCurve._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggNurbsCurve) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggNurbsCurve)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggNurbsCurve);
  }
}

/**
 * Python method tables for EggSurface (EggSurface)
 */
static PyMethodDef Dtool_Methods_EggSurface[] = {
  {"assign", &Dtool_EggSurface_operator_1057, METH_O, (const char *)Dtool_EggSurface_operator_1057_comment},
  {"set_u_subdiv", &Dtool_EggSurface_set_u_subdiv_1058, METH_O, (const char *)Dtool_EggSurface_set_u_subdiv_1058_comment},
  {"setUSubdiv", &Dtool_EggSurface_set_u_subdiv_1058, METH_O, (const char *)Dtool_EggSurface_set_u_subdiv_1058_comment},
  {"get_u_subdiv", &Dtool_EggSurface_get_u_subdiv_1059, METH_NOARGS, (const char *)Dtool_EggSurface_get_u_subdiv_1059_comment},
  {"getUSubdiv", &Dtool_EggSurface_get_u_subdiv_1059, METH_NOARGS, (const char *)Dtool_EggSurface_get_u_subdiv_1059_comment},
  {"set_v_subdiv", &Dtool_EggSurface_set_v_subdiv_1060, METH_O, (const char *)Dtool_EggSurface_set_v_subdiv_1060_comment},
  {"setVSubdiv", &Dtool_EggSurface_set_v_subdiv_1060, METH_O, (const char *)Dtool_EggSurface_set_v_subdiv_1060_comment},
  {"get_v_subdiv", &Dtool_EggSurface_get_v_subdiv_1061, METH_NOARGS, (const char *)Dtool_EggSurface_get_v_subdiv_1061_comment},
  {"getVSubdiv", &Dtool_EggSurface_get_v_subdiv_1061, METH_NOARGS, (const char *)Dtool_EggSurface_get_v_subdiv_1061_comment},
  {"get_class_type", &Dtool_EggSurface_get_class_type_1062, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggSurface_get_class_type_1062_comment},
  {"getClassType", &Dtool_EggSurface_get_class_type_1062, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggSurface_get_class_type_1062_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EggSurface = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggSurface = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggSurface = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggSurface = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggSurface = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggSurface = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggSurface",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggSurface,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggSurface,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggSurface,
    &Dtool_SequenceMethods_EggSurface,
    &Dtool_MappingMethods_EggSurface,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggSurface,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A parametric surface of some kind.  See EggNurbsSurface.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggSurface,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggSurface,
    PyType_GenericAlloc,
    Dtool_new_EggSurface,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggSurface,
  Dtool_UpcastInterface_EggSurface,
  Dtool_DowncastInterface_EggSurface,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggSurface(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggPrimitive(nullptr);
    Dtool_EggSurface._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggPrimitive);
    Dtool_EggSurface._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggSurface._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggSurface) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggSurface)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggSurface);
  }
}

/**
 * Python method tables for EggNurbsSurface (EggNurbsSurface)
 */
static PyMethodDef Dtool_Methods_EggNurbsSurface[] = {
  {"assign", &Dtool_EggNurbsSurface_operator_1074, METH_O, (const char *)Dtool_EggNurbsSurface_operator_1074_comment},
  {"setup", (PyCFunction) &Dtool_EggNurbsSurface_setup_1075, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNurbsSurface_setup_1075_comment},
  {"set_u_order", &Dtool_EggNurbsSurface_set_u_order_1076, METH_O, (const char *)Dtool_EggNurbsSurface_set_u_order_1076_comment},
  {"setUOrder", &Dtool_EggNurbsSurface_set_u_order_1076, METH_O, (const char *)Dtool_EggNurbsSurface_set_u_order_1076_comment},
  {"set_v_order", &Dtool_EggNurbsSurface_set_v_order_1077, METH_O, (const char *)Dtool_EggNurbsSurface_set_v_order_1077_comment},
  {"setVOrder", &Dtool_EggNurbsSurface_set_v_order_1077, METH_O, (const char *)Dtool_EggNurbsSurface_set_v_order_1077_comment},
  {"set_num_u_knots", &Dtool_EggNurbsSurface_set_num_u_knots_1078, METH_O, (const char *)Dtool_EggNurbsSurface_set_num_u_knots_1078_comment},
  {"setNumUKnots", &Dtool_EggNurbsSurface_set_num_u_knots_1078, METH_O, (const char *)Dtool_EggNurbsSurface_set_num_u_knots_1078_comment},
  {"set_num_v_knots", &Dtool_EggNurbsSurface_set_num_v_knots_1079, METH_O, (const char *)Dtool_EggNurbsSurface_set_num_v_knots_1079_comment},
  {"setNumVKnots", &Dtool_EggNurbsSurface_set_num_v_knots_1079, METH_O, (const char *)Dtool_EggNurbsSurface_set_num_v_knots_1079_comment},
  {"set_u_knot", (PyCFunction) &Dtool_EggNurbsSurface_set_u_knot_1080, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNurbsSurface_set_u_knot_1080_comment},
  {"setUKnot", (PyCFunction) &Dtool_EggNurbsSurface_set_u_knot_1080, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNurbsSurface_set_u_knot_1080_comment},
  {"set_v_knot", (PyCFunction) &Dtool_EggNurbsSurface_set_v_knot_1081, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNurbsSurface_set_v_knot_1081_comment},
  {"setVKnot", (PyCFunction) &Dtool_EggNurbsSurface_set_v_knot_1081, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNurbsSurface_set_v_knot_1081_comment},
  {"set_cv", (PyCFunction) &Dtool_EggNurbsSurface_set_cv_1082, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNurbsSurface_set_cv_1082_comment},
  {"setCv", (PyCFunction) &Dtool_EggNurbsSurface_set_cv_1082, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNurbsSurface_set_cv_1082_comment},
  {"is_valid", &Dtool_EggNurbsSurface_is_valid_1083, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_is_valid_1083_comment},
  {"isValid", &Dtool_EggNurbsSurface_is_valid_1083, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_is_valid_1083_comment},
  {"get_u_order", &Dtool_EggNurbsSurface_get_u_order_1084, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_u_order_1084_comment},
  {"getUOrder", &Dtool_EggNurbsSurface_get_u_order_1084, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_u_order_1084_comment},
  {"get_v_order", &Dtool_EggNurbsSurface_get_v_order_1085, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_v_order_1085_comment},
  {"getVOrder", &Dtool_EggNurbsSurface_get_v_order_1085, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_v_order_1085_comment},
  {"get_u_degree", &Dtool_EggNurbsSurface_get_u_degree_1086, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_u_degree_1086_comment},
  {"getUDegree", &Dtool_EggNurbsSurface_get_u_degree_1086, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_u_degree_1086_comment},
  {"get_v_degree", &Dtool_EggNurbsSurface_get_v_degree_1087, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_v_degree_1087_comment},
  {"getVDegree", &Dtool_EggNurbsSurface_get_v_degree_1087, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_v_degree_1087_comment},
  {"get_num_u_knots", &Dtool_EggNurbsSurface_get_num_u_knots_1088, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_num_u_knots_1088_comment},
  {"getNumUKnots", &Dtool_EggNurbsSurface_get_num_u_knots_1088, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_num_u_knots_1088_comment},
  {"get_num_v_knots", &Dtool_EggNurbsSurface_get_num_v_knots_1089, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_num_v_knots_1089_comment},
  {"getNumVKnots", &Dtool_EggNurbsSurface_get_num_v_knots_1089, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_num_v_knots_1089_comment},
  {"get_num_u_cvs", &Dtool_EggNurbsSurface_get_num_u_cvs_1090, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_num_u_cvs_1090_comment},
  {"getNumUCvs", &Dtool_EggNurbsSurface_get_num_u_cvs_1090, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_num_u_cvs_1090_comment},
  {"get_num_v_cvs", &Dtool_EggNurbsSurface_get_num_v_cvs_1091, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_num_v_cvs_1091_comment},
  {"getNumVCvs", &Dtool_EggNurbsSurface_get_num_v_cvs_1091, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_num_v_cvs_1091_comment},
  {"get_num_cvs", &Dtool_EggNurbsSurface_get_num_cvs_1092, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_num_cvs_1092_comment},
  {"getNumCvs", &Dtool_EggNurbsSurface_get_num_cvs_1092, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_get_num_cvs_1092_comment},
  {"get_u_index", &Dtool_EggNurbsSurface_get_u_index_1093, METH_O, (const char *)Dtool_EggNurbsSurface_get_u_index_1093_comment},
  {"getUIndex", &Dtool_EggNurbsSurface_get_u_index_1093, METH_O, (const char *)Dtool_EggNurbsSurface_get_u_index_1093_comment},
  {"get_v_index", &Dtool_EggNurbsSurface_get_v_index_1094, METH_O, (const char *)Dtool_EggNurbsSurface_get_v_index_1094_comment},
  {"getVIndex", &Dtool_EggNurbsSurface_get_v_index_1094, METH_O, (const char *)Dtool_EggNurbsSurface_get_v_index_1094_comment},
  {"get_vertex_index", (PyCFunction) &Dtool_EggNurbsSurface_get_vertex_index_1095, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNurbsSurface_get_vertex_index_1095_comment},
  {"getVertexIndex", (PyCFunction) &Dtool_EggNurbsSurface_get_vertex_index_1095, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNurbsSurface_get_vertex_index_1095_comment},
  {"is_closed_u", &Dtool_EggNurbsSurface_is_closed_u_1096, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_is_closed_u_1096_comment},
  {"isClosedU", &Dtool_EggNurbsSurface_is_closed_u_1096, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_is_closed_u_1096_comment},
  {"is_closed_v", &Dtool_EggNurbsSurface_is_closed_v_1097, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_is_closed_v_1097_comment},
  {"isClosedV", &Dtool_EggNurbsSurface_is_closed_v_1097, METH_NOARGS, (const char *)Dtool_EggNurbsSurface_is_closed_v_1097_comment},
  {"get_u_knot", &Dtool_EggNurbsSurface_get_u_knot_1098, METH_O, (const char *)Dtool_EggNurbsSurface_get_u_knot_1098_comment},
  {"getUKnot", &Dtool_EggNurbsSurface_get_u_knot_1098, METH_O, (const char *)Dtool_EggNurbsSurface_get_u_knot_1098_comment},
  {"get_v_knot", &Dtool_EggNurbsSurface_get_v_knot_1100, METH_O, (const char *)Dtool_EggNurbsSurface_get_v_knot_1100_comment},
  {"getVKnot", &Dtool_EggNurbsSurface_get_v_knot_1100, METH_O, (const char *)Dtool_EggNurbsSurface_get_v_knot_1100_comment},
  {"get_cv", (PyCFunction) &Dtool_EggNurbsSurface_get_cv_1102, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNurbsSurface_get_cv_1102_comment},
  {"getCv", (PyCFunction) &Dtool_EggNurbsSurface_get_cv_1102, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggNurbsSurface_get_cv_1102_comment},
  {"get_class_type", &Dtool_EggNurbsSurface_get_class_type_1103, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggNurbsSurface_get_class_type_1103_comment},
  {"getClassType", &Dtool_EggNurbsSurface_get_class_type_1103, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggNurbsSurface_get_class_type_1103_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_u_knots", (PyCFunction) &MakeSeq_EggNurbsSurface_get_u_knots, METH_NOARGS, nullptr},
  { "getUKnots", (PyCFunction) &MakeSeq_EggNurbsSurface_get_u_knots, METH_NOARGS, nullptr},
  {"get_v_knots", (PyCFunction) &MakeSeq_EggNurbsSurface_get_v_knots, METH_NOARGS, nullptr},
  { "getVKnots", (PyCFunction) &MakeSeq_EggNurbsSurface_get_v_knots, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EggNurbsSurface = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggNurbsSurface = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggNurbsSurface = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggNurbsSurface = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggNurbsSurface = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggNurbsSurface = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggNurbsSurface",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggNurbsSurface,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggNurbsSurface,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggNurbsSurface,
    &Dtool_SequenceMethods_EggNurbsSurface,
    &Dtool_MappingMethods_EggNurbsSurface,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggNurbsSurface,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A parametric NURBS surface.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggNurbsSurface,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggNurbsSurface,
    PyType_GenericAlloc,
    Dtool_new_EggNurbsSurface,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggNurbsSurface,
  Dtool_UpcastInterface_EggNurbsSurface,
  Dtool_DowncastInterface_EggNurbsSurface,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggNurbsSurface(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggSurface(nullptr);
    Dtool_EggNurbsSurface._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggSurface);
    Dtool_EggNurbsSurface._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggNurbsSurface._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggNurbsSurface) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggNurbsSurface)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggNurbsSurface);
  }
}

/**
 * Python method tables for EggPatch (EggPatch)
 */
static PyMethodDef Dtool_Methods_EggPatch[] = {
  {"assign", &Dtool_EggPatch_operator_1107, METH_O, (const char *)Dtool_EggPatch_operator_1107_comment},
  {"get_class_type", &Dtool_EggPatch_get_class_type_1108, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggPatch_get_class_type_1108_comment},
  {"getClassType", &Dtool_EggPatch_get_class_type_1108, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggPatch_get_class_type_1108_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EggPatch = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggPatch = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggPatch = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggPatch = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggPatch = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggPatch = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggPatch",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggPatch,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggPatch,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggPatch,
    &Dtool_SequenceMethods_EggPatch,
    &Dtool_MappingMethods_EggPatch,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggPatch,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A single \"patch\", a special primitive to be rendered only with a\n"
    " * tessellation shader.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggPatch,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggPatch,
    PyType_GenericAlloc,
    Dtool_new_EggPatch,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggPatch,
  Dtool_UpcastInterface_EggPatch,
  Dtool_DowncastInterface_EggPatch,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggPatch(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggPrimitive(nullptr);
    Dtool_EggPatch._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggPrimitive);
    Dtool_EggPatch._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggPatch._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggPatch) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggPatch)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggPatch);
  }
}

/**
 * Python method tables for EggPoint (EggPoint)
 */
static PyMethodDef Dtool_Methods_EggPoint[] = {
  {"assign", &Dtool_EggPoint_operator_1112, METH_O, (const char *)Dtool_EggPoint_operator_1112_comment},
  {"has_thick", &Dtool_EggPoint_has_thick_1113, METH_NOARGS, (const char *)Dtool_EggPoint_has_thick_1113_comment},
  {"hasThick", &Dtool_EggPoint_has_thick_1113, METH_NOARGS, (const char *)Dtool_EggPoint_has_thick_1113_comment},
  {"get_thick", &Dtool_EggPoint_get_thick_1114, METH_NOARGS, (const char *)Dtool_EggPoint_get_thick_1114_comment},
  {"getThick", &Dtool_EggPoint_get_thick_1114, METH_NOARGS, (const char *)Dtool_EggPoint_get_thick_1114_comment},
  {"set_thick", &Dtool_EggPoint_set_thick_1115, METH_O, (const char *)Dtool_EggPoint_set_thick_1115_comment},
  {"setThick", &Dtool_EggPoint_set_thick_1115, METH_O, (const char *)Dtool_EggPoint_set_thick_1115_comment},
  {"clear_thick", &Dtool_EggPoint_clear_thick_1116, METH_NOARGS, (const char *)Dtool_EggPoint_clear_thick_1116_comment},
  {"clearThick", &Dtool_EggPoint_clear_thick_1116, METH_NOARGS, (const char *)Dtool_EggPoint_clear_thick_1116_comment},
  {"has_perspective", &Dtool_EggPoint_has_perspective_1117, METH_NOARGS, (const char *)Dtool_EggPoint_has_perspective_1117_comment},
  {"hasPerspective", &Dtool_EggPoint_has_perspective_1117, METH_NOARGS, (const char *)Dtool_EggPoint_has_perspective_1117_comment},
  {"get_perspective", &Dtool_EggPoint_get_perspective_1118, METH_NOARGS, (const char *)Dtool_EggPoint_get_perspective_1118_comment},
  {"getPerspective", &Dtool_EggPoint_get_perspective_1118, METH_NOARGS, (const char *)Dtool_EggPoint_get_perspective_1118_comment},
  {"set_perspective", &Dtool_EggPoint_set_perspective_1119, METH_O, (const char *)Dtool_EggPoint_set_perspective_1119_comment},
  {"setPerspective", &Dtool_EggPoint_set_perspective_1119, METH_O, (const char *)Dtool_EggPoint_set_perspective_1119_comment},
  {"clear_perspective", &Dtool_EggPoint_clear_perspective_1120, METH_NOARGS, (const char *)Dtool_EggPoint_clear_perspective_1120_comment},
  {"clearPerspective", &Dtool_EggPoint_clear_perspective_1120, METH_NOARGS, (const char *)Dtool_EggPoint_clear_perspective_1120_comment},
  {"get_class_type", &Dtool_EggPoint_get_class_type_1121, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggPoint_get_class_type_1121_comment},
  {"getClassType", &Dtool_EggPoint_get_class_type_1121, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggPoint_get_class_type_1121_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EggPoint = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggPoint = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggPoint = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggPoint = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggPoint = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggPoint = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggPoint",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggPoint,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggPoint,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggPoint,
    &Dtool_SequenceMethods_EggPoint,
    &Dtool_MappingMethods_EggPoint,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggPoint,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A single point, or a collection of points as defined by a single\n"
    " * <PointLight> entry.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggPoint,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggPoint,
    PyType_GenericAlloc,
    Dtool_new_EggPoint,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggPoint,
  Dtool_UpcastInterface_EggPoint,
  Dtool_DowncastInterface_EggPoint,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggPoint(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggPrimitive(nullptr);
    Dtool_EggPoint._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggPrimitive);
    Dtool_EggPoint._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggPoint._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggPoint) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggPoint)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggPoint);
  }
}

/**
 * Python method tables for EggPolysetMaker (EggPolysetMaker)
 */
static PyMethodDef Dtool_Methods_EggPolysetMaker[] = {
  {"set_properties", &Dtool_EggPolysetMaker_set_properties_1127, METH_O, (const char *)Dtool_EggPolysetMaker_set_properties_1127_comment},
  {"setProperties", &Dtool_EggPolysetMaker_set_properties_1127, METH_O, (const char *)Dtool_EggPolysetMaker_set_properties_1127_comment},
  {"get_class_type", &Dtool_EggPolysetMaker_get_class_type_1128, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggPolysetMaker_get_class_type_1128_comment},
  {"getClassType", &Dtool_EggPolysetMaker_get_class_type_1128, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggPolysetMaker_get_class_type_1128_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EggPolysetMaker = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggPolysetMaker = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggPolysetMaker = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggPolysetMaker = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggPolysetMaker = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggPolysetMaker = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggPolysetMaker",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggPolysetMaker,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggPolysetMaker,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggPolysetMaker,
    &Dtool_SequenceMethods_EggPolysetMaker,
    &Dtool_MappingMethods_EggPolysetMaker,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggPolysetMaker,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A specialization on EggBinMaker for making polysets that share the same\n"
    " * basic rendering characteristic.  This really just defines the example\n"
    " * functions described in the leading comment to EggBinMaker.\n"
    " *\n"
    " * It makes some common assumptions about how polysets should be grouped; if\n"
    " * these are not sufficient, you can always rederive your own further\n"
    " * specialization of this class.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggPolysetMaker,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggPolysetMaker,
    PyType_GenericAlloc,
    Dtool_new_EggPolysetMaker,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggPolysetMaker,
  Dtool_UpcastInterface_EggPolysetMaker,
  Dtool_DowncastInterface_EggPolysetMaker,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggPolysetMaker(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggBinMaker(nullptr);
    Dtool_EggPolysetMaker._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggBinMaker);
    Dtool_EggPolysetMaker._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(25);
    Dtool_EggPolysetMaker._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum EggPolysetMaker::BinNumber;
    PyDict_SetItemString(dict, "BN_none", Dtool_WrapValue(EggPolysetMaker::BN_none));
    PyDict_SetItemString(dict, "BNNone", Dtool_WrapValue(EggPolysetMaker::BN_none));
    PyDict_SetItemString(dict, "BN_polyset", Dtool_WrapValue(EggPolysetMaker::BN_polyset));
    PyDict_SetItemString(dict, "BNPolyset", Dtool_WrapValue(EggPolysetMaker::BN_polyset));
    // enum EggPolysetMaker::Properties;
    PyDict_SetItemString(dict, "P_has_texture", Dtool_WrapValue(EggPolysetMaker::P_has_texture));
    PyDict_SetItemString(dict, "PHasTexture", Dtool_WrapValue(EggPolysetMaker::P_has_texture));
    PyDict_SetItemString(dict, "P_texture", Dtool_WrapValue(EggPolysetMaker::P_texture));
    PyDict_SetItemString(dict, "PTexture", Dtool_WrapValue(EggPolysetMaker::P_texture));
    PyDict_SetItemString(dict, "P_has_material", Dtool_WrapValue(EggPolysetMaker::P_has_material));
    PyDict_SetItemString(dict, "PHasMaterial", Dtool_WrapValue(EggPolysetMaker::P_has_material));
    PyDict_SetItemString(dict, "P_material", Dtool_WrapValue(EggPolysetMaker::P_material));
    PyDict_SetItemString(dict, "PMaterial", Dtool_WrapValue(EggPolysetMaker::P_material));
    PyDict_SetItemString(dict, "P_has_poly_color", Dtool_WrapValue(EggPolysetMaker::P_has_poly_color));
    PyDict_SetItemString(dict, "PHasPolyColor", Dtool_WrapValue(EggPolysetMaker::P_has_poly_color));
    PyDict_SetItemString(dict, "P_poly_color", Dtool_WrapValue(EggPolysetMaker::P_poly_color));
    PyDict_SetItemString(dict, "PPolyColor", Dtool_WrapValue(EggPolysetMaker::P_poly_color));
    PyDict_SetItemString(dict, "P_has_poly_normal", Dtool_WrapValue(EggPolysetMaker::P_has_poly_normal));
    PyDict_SetItemString(dict, "PHasPolyNormal", Dtool_WrapValue(EggPolysetMaker::P_has_poly_normal));
    PyDict_SetItemString(dict, "P_has_vertex_normal", Dtool_WrapValue(EggPolysetMaker::P_has_vertex_normal));
    PyDict_SetItemString(dict, "PHasVertexNormal", Dtool_WrapValue(EggPolysetMaker::P_has_vertex_normal));
    PyDict_SetItemString(dict, "P_has_vertex_color", Dtool_WrapValue(EggPolysetMaker::P_has_vertex_color));
    PyDict_SetItemString(dict, "PHasVertexColor", Dtool_WrapValue(EggPolysetMaker::P_has_vertex_color));
    PyDict_SetItemString(dict, "P_bface", Dtool_WrapValue(EggPolysetMaker::P_bface));
    PyDict_SetItemString(dict, "PBface", Dtool_WrapValue(EggPolysetMaker::P_bface));
    if (PyType_Ready((PyTypeObject *)&Dtool_EggPolysetMaker) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggPolysetMaker)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggPolysetMaker);
  }
}

/**
 * Python method tables for EggPoolUniquifier (EggPoolUniquifier)
 */
static PyMethodDef Dtool_Methods_EggPoolUniquifier[] = {
  {"get_class_type", &Dtool_EggPoolUniquifier_get_class_type_1132, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggPoolUniquifier_get_class_type_1132_comment},
  {"getClassType", &Dtool_EggPoolUniquifier_get_class_type_1132, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggPoolUniquifier_get_class_type_1132_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EggPoolUniquifier = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggPoolUniquifier = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggPoolUniquifier = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggPoolUniquifier = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggPoolUniquifier = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggPoolUniquifier = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggPoolUniquifier",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggPoolUniquifier,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggPoolUniquifier,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggPoolUniquifier,
    &Dtool_SequenceMethods_EggPoolUniquifier,
    &Dtool_MappingMethods_EggPoolUniquifier,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggPoolUniquifier,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a specialization of EggNameUniquifier to generate unique names for\n"
    " * textures, materials, and vertex pools prior to writing out an egg file.\n"
    " * It's automatically called by EggData prior to writing out an egg file.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggPoolUniquifier,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggPoolUniquifier,
    PyType_GenericAlloc,
    Dtool_new_EggPoolUniquifier,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggPoolUniquifier,
  Dtool_UpcastInterface_EggPoolUniquifier,
  Dtool_DowncastInterface_EggPoolUniquifier,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggPoolUniquifier(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggNameUniquifier(nullptr);
    Dtool_EggPoolUniquifier._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggNameUniquifier);
    Dtool_EggPoolUniquifier._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggPoolUniquifier._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggPoolUniquifier) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggPoolUniquifier)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggPoolUniquifier);
  }
}

/**
 * Python method tables for EggSAnimData (EggSAnimData)
 */
static PyMethodDef Dtool_Methods_EggSAnimData[] = {
  {"assign", &Dtool_EggSAnimData_operator_1136, METH_O, (const char *)Dtool_EggSAnimData_operator_1136_comment},
  {"get_num_rows", &Dtool_EggSAnimData_get_num_rows_1137, METH_NOARGS, (const char *)Dtool_EggSAnimData_get_num_rows_1137_comment},
  {"getNumRows", &Dtool_EggSAnimData_get_num_rows_1137, METH_NOARGS, (const char *)Dtool_EggSAnimData_get_num_rows_1137_comment},
  {"get_value", &Dtool_EggSAnimData_get_value_1138, METH_O, (const char *)Dtool_EggSAnimData_get_value_1138_comment},
  {"getValue", &Dtool_EggSAnimData_get_value_1138, METH_O, (const char *)Dtool_EggSAnimData_get_value_1138_comment},
  {"set_value", (PyCFunction) &Dtool_EggSAnimData_set_value_1139, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggSAnimData_set_value_1139_comment},
  {"setValue", (PyCFunction) &Dtool_EggSAnimData_set_value_1139, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggSAnimData_set_value_1139_comment},
  {"optimize", &Dtool_EggSAnimData_optimize_1140, METH_NOARGS, (const char *)Dtool_EggSAnimData_optimize_1140_comment},
  {"get_class_type", &Dtool_EggSAnimData_get_class_type_1141, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggSAnimData_get_class_type_1141_comment},
  {"getClassType", &Dtool_EggSAnimData_get_class_type_1141, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggSAnimData_get_class_type_1141_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EggSAnimData = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggSAnimData = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggSAnimData = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggSAnimData = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggSAnimData = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggSAnimData = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggSAnimData",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggSAnimData,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggSAnimData,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggSAnimData,
    &Dtool_SequenceMethods_EggSAnimData,
    &Dtool_MappingMethods_EggSAnimData,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggSAnimData,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Corresponding to an <S$Anim> entry, this stores a single column of numbers,\n"
    " * for instance for a morph target, or as one column in an EggXfmSAnim.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggSAnimData,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggSAnimData,
    PyType_GenericAlloc,
    Dtool_new_EggSAnimData,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggSAnimData,
  Dtool_UpcastInterface_EggSAnimData,
  Dtool_DowncastInterface_EggSAnimData,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggSAnimData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggAnimData(nullptr);
    Dtool_EggSAnimData._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggAnimData);
    Dtool_EggSAnimData._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggSAnimData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggSAnimData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggSAnimData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggSAnimData);
  }
}

/**
 * Python method tables for EggTable (EggTable)
 */
static PyMethodDef Dtool_Methods_EggTable[] = {
  {"assign", &Dtool_EggTable_operator_1146, METH_O, (const char *)Dtool_EggTable_operator_1146_comment},
  {"set_table_type", &Dtool_EggTable_set_table_type_1147, METH_O, (const char *)Dtool_EggTable_set_table_type_1147_comment},
  {"setTableType", &Dtool_EggTable_set_table_type_1147, METH_O, (const char *)Dtool_EggTable_set_table_type_1147_comment},
  {"get_table_type", &Dtool_EggTable_get_table_type_1148, METH_NOARGS, (const char *)Dtool_EggTable_get_table_type_1148_comment},
  {"getTableType", &Dtool_EggTable_get_table_type_1148, METH_NOARGS, (const char *)Dtool_EggTable_get_table_type_1148_comment},
  {"has_transform", &Dtool_EggTable_has_transform_1149, METH_NOARGS, (const char *)Dtool_EggTable_has_transform_1149_comment},
  {"hasTransform", &Dtool_EggTable_has_transform_1149, METH_NOARGS, (const char *)Dtool_EggTable_has_transform_1149_comment},
  {"string_table_type", &Dtool_EggTable_string_table_type_1150, METH_O | METH_STATIC, (const char *)Dtool_EggTable_string_table_type_1150_comment},
  {"stringTableType", &Dtool_EggTable_string_table_type_1150, METH_O | METH_STATIC, (const char *)Dtool_EggTable_string_table_type_1150_comment},
  {"get_class_type", &Dtool_EggTable_get_class_type_1151, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggTable_get_class_type_1151_comment},
  {"getClassType", &Dtool_EggTable_get_class_type_1151, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggTable_get_class_type_1151_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EggTable = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggTable = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggTable = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggTable = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggTable = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggTable = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggTable",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggTable,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggTable,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggTable,
    &Dtool_SequenceMethods_EggTable,
    &Dtool_MappingMethods_EggTable,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggTable,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This corresponds to a <Table> or a <Bundle> entry.  As such, it doesn't\n"
    " * actually contain a table of numbers, but it may be a parent to an\n"
    " * EggSAnimData or an EggXfmAnimData, which do.  It may also be a parent to\n"
    " * another <Table> or <Bundle>, establishing a hierarchy of tables.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggTable,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggTable,
    PyType_GenericAlloc,
    Dtool_new_EggTable,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggTable,
  Dtool_UpcastInterface_EggTable,
  Dtool_DowncastInterface_EggTable,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggTable(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggGroupNode(nullptr);
    Dtool_EggTable._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggGroupNode);
    Dtool_EggTable._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(7);
    Dtool_EggTable._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum EggTable::TableType;
    PyDict_SetItemString(dict, "TT_invalid", Dtool_WrapValue(EggTable::TT_invalid));
    PyDict_SetItemString(dict, "TTInvalid", Dtool_WrapValue(EggTable::TT_invalid));
    PyDict_SetItemString(dict, "TT_table", Dtool_WrapValue(EggTable::TT_table));
    PyDict_SetItemString(dict, "TTTable", Dtool_WrapValue(EggTable::TT_table));
    PyDict_SetItemString(dict, "TT_bundle", Dtool_WrapValue(EggTable::TT_bundle));
    PyDict_SetItemString(dict, "TTBundle", Dtool_WrapValue(EggTable::TT_bundle));
    if (PyType_Ready((PyTypeObject *)&Dtool_EggTable) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggTable)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggTable);
  }
}

/**
 * Python method tables for EggTextureCollection (EggTextureCollection)
 */
static PyMethodDef Dtool_Methods_EggTextureCollection[] = {
  {"assign", &Dtool_EggTextureCollection_operator_1155, METH_O, (const char *)Dtool_EggTextureCollection_operator_1155_comment},
  {"clear", &Dtool_EggTextureCollection_clear_1157, METH_NOARGS, (const char *)Dtool_EggTextureCollection_clear_1157_comment},
  {"extract_textures", &Dtool_EggTextureCollection_extract_textures_1158, METH_O, (const char *)Dtool_EggTextureCollection_extract_textures_1158_comment},
  {"extractTextures", &Dtool_EggTextureCollection_extract_textures_1158, METH_O, (const char *)Dtool_EggTextureCollection_extract_textures_1158_comment},
  {"is_empty", &Dtool_EggTextureCollection_is_empty_1159, METH_NOARGS, (const char *)Dtool_EggTextureCollection_is_empty_1159_comment},
  {"isEmpty", &Dtool_EggTextureCollection_is_empty_1159, METH_NOARGS, (const char *)Dtool_EggTextureCollection_is_empty_1159_comment},
  {"get_num_textures", &Dtool_EggTextureCollection_get_num_textures_1160, METH_NOARGS, (const char *)Dtool_EggTextureCollection_get_num_textures_1160_comment},
  {"getNumTextures", &Dtool_EggTextureCollection_get_num_textures_1160, METH_NOARGS, (const char *)Dtool_EggTextureCollection_get_num_textures_1160_comment},
  {"get_texture", &Dtool_EggTextureCollection_get_texture_1161, METH_O, (const char *)Dtool_EggTextureCollection_get_texture_1161_comment},
  {"getTexture", &Dtool_EggTextureCollection_get_texture_1161, METH_O, (const char *)Dtool_EggTextureCollection_get_texture_1161_comment},
  {"find_used_textures", &Dtool_EggTextureCollection_find_used_textures_1163, METH_O, (const char *)Dtool_EggTextureCollection_find_used_textures_1163_comment},
  {"findUsedTextures", &Dtool_EggTextureCollection_find_used_textures_1163, METH_O, (const char *)Dtool_EggTextureCollection_find_used_textures_1163_comment},
  {"remove_unused_textures", &Dtool_EggTextureCollection_remove_unused_textures_1164, METH_O, (const char *)Dtool_EggTextureCollection_remove_unused_textures_1164_comment},
  {"removeUnusedTextures", &Dtool_EggTextureCollection_remove_unused_textures_1164, METH_O, (const char *)Dtool_EggTextureCollection_remove_unused_textures_1164_comment},
  {"collapse_equivalent_textures", (PyCFunction) &Dtool_EggTextureCollection_collapse_equivalent_textures_1165, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTextureCollection_collapse_equivalent_textures_1165_comment},
  {"collapseEquivalentTextures", (PyCFunction) &Dtool_EggTextureCollection_collapse_equivalent_textures_1165, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTextureCollection_collapse_equivalent_textures_1165_comment},
  {"uniquify_trefs", &Dtool_EggTextureCollection_uniquify_trefs_1167, METH_NOARGS, (const char *)Dtool_EggTextureCollection_uniquify_trefs_1167_comment},
  {"uniquifyTrefs", &Dtool_EggTextureCollection_uniquify_trefs_1167, METH_NOARGS, (const char *)Dtool_EggTextureCollection_uniquify_trefs_1167_comment},
  {"sort_by_tref", &Dtool_EggTextureCollection_sort_by_tref_1168, METH_NOARGS, (const char *)Dtool_EggTextureCollection_sort_by_tref_1168_comment},
  {"sortByTref", &Dtool_EggTextureCollection_sort_by_tref_1168, METH_NOARGS, (const char *)Dtool_EggTextureCollection_sort_by_tref_1168_comment},
  {"sort_by_basename", &Dtool_EggTextureCollection_sort_by_basename_1169, METH_NOARGS, (const char *)Dtool_EggTextureCollection_sort_by_basename_1169_comment},
  {"sortByBasename", &Dtool_EggTextureCollection_sort_by_basename_1169, METH_NOARGS, (const char *)Dtool_EggTextureCollection_sort_by_basename_1169_comment},
  {"add_texture", &Dtool_EggTextureCollection_add_texture_1172, METH_O, (const char *)Dtool_EggTextureCollection_add_texture_1172_comment},
  {"addTexture", &Dtool_EggTextureCollection_add_texture_1172, METH_O, (const char *)Dtool_EggTextureCollection_add_texture_1172_comment},
  {"remove_texture", &Dtool_EggTextureCollection_remove_texture_1173, METH_O, (const char *)Dtool_EggTextureCollection_remove_texture_1173_comment},
  {"removeTexture", &Dtool_EggTextureCollection_remove_texture_1173, METH_O, (const char *)Dtool_EggTextureCollection_remove_texture_1173_comment},
  {"create_unique_texture", (PyCFunction) &Dtool_EggTextureCollection_create_unique_texture_1174, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTextureCollection_create_unique_texture_1174_comment},
  {"createUniqueTexture", (PyCFunction) &Dtool_EggTextureCollection_create_unique_texture_1174, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggTextureCollection_create_unique_texture_1174_comment},
  {"find_tref", &Dtool_EggTextureCollection_find_tref_1175, METH_O, (const char *)Dtool_EggTextureCollection_find_tref_1175_comment},
  {"findTref", &Dtool_EggTextureCollection_find_tref_1175, METH_O, (const char *)Dtool_EggTextureCollection_find_tref_1175_comment},
  {"find_filename", &Dtool_EggTextureCollection_find_filename_1176, METH_O, (const char *)Dtool_EggTextureCollection_find_filename_1176_comment},
  {"findFilename", &Dtool_EggTextureCollection_find_filename_1176, METH_O, (const char *)Dtool_EggTextureCollection_find_filename_1176_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_textures", (PyCFunction) &MakeSeq_EggTextureCollection_get_textures, METH_NOARGS, nullptr},
  { "getTextures", (PyCFunction) &MakeSeq_EggTextureCollection_get_textures, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// EggTextureCollection slot sq_item -> operator []
//////////////////
static PyObject *Dtool_EggTextureCollection_operator_1170_sq_item(PyObject *self, Py_ssize_t index) {
  EggTextureCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTextureCollection, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "EggTextureCollection index out of range");
    return nullptr;
  }
  // 1-inline EggTexture *EggTextureCollection::operator [](EggTextureCollection::size_type n) const
  EggTexture *return_value = ((*(const EggTextureCollection*)local_this).operator [])(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EggTexture, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(EggTextureCollection self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// EggTextureCollection slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_EggTextureCollection_size_1171_sq_length(PyObject *self) {
  EggTextureCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EggTextureCollection, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_EggTextureCollection = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggTextureCollection = {
  &Dtool_EggTextureCollection_size_1171_sq_length,
  nullptr,
  nullptr,
  &Dtool_EggTextureCollection_operator_1170_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

struct Dtool_PyTypedObject Dtool_EggTextureCollection = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggTextureCollection",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggTextureCollection,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggTextureCollection,
    &Dtool_SequenceMethods_EggTextureCollection,
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a collection of textures by TRef name.  It can extract the textures\n"
    " * from an egg file and sort them all together; it can also manage the\n"
    " * creation of unique textures and the assignment of unique TRef names.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggTextureCollection,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggTextureCollection,
    PyType_GenericAlloc,
    Dtool_new_EggTextureCollection,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggTextureCollection,
  Dtool_UpcastInterface_EggTextureCollection,
  Dtool_DowncastInterface_EggTextureCollection,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggTextureCollection(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_EggTextureCollection._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggTextureCollection._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggTextureCollection) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggTextureCollection)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggTextureCollection);
  }
}

/**
 * Python method tables for EggTriangleFan (EggTriangleFan)
 */
static PyMethodDef Dtool_Methods_EggTriangleFan[] = {
  {"assign", &Dtool_EggTriangleFan_operator_1179, METH_O, (const char *)Dtool_EggTriangleFan_operator_1179_comment},
  {"get_class_type", &Dtool_EggTriangleFan_get_class_type_1180, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggTriangleFan_get_class_type_1180_comment},
  {"getClassType", &Dtool_EggTriangleFan_get_class_type_1180, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggTriangleFan_get_class_type_1180_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EggTriangleFan = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggTriangleFan = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggTriangleFan = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggTriangleFan = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggTriangleFan = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggTriangleFan = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggTriangleFan",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggTriangleFan,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggTriangleFan,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggTriangleFan,
    &Dtool_SequenceMethods_EggTriangleFan,
    &Dtool_MappingMethods_EggTriangleFan,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggTriangleFan,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A connected fan of triangles.  This does not normally appear in an egg\n"
    " * file; it is typically generated as a result of meshing.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggTriangleFan,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggTriangleFan,
    PyType_GenericAlloc,
    Dtool_new_EggTriangleFan,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggTriangleFan,
  Dtool_UpcastInterface_EggTriangleFan,
  Dtool_DowncastInterface_EggTriangleFan,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggTriangleFan(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggCompositePrimitive(nullptr);
    Dtool_EggTriangleFan._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggCompositePrimitive);
    Dtool_EggTriangleFan._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggTriangleFan._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggTriangleFan) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggTriangleFan)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggTriangleFan);
  }
}

/**
 * Python method tables for EggTriangleStrip (EggTriangleStrip)
 */
static PyMethodDef Dtool_Methods_EggTriangleStrip[] = {
  {"assign", &Dtool_EggTriangleStrip_operator_1183, METH_O, (const char *)Dtool_EggTriangleStrip_operator_1183_comment},
  {"get_class_type", &Dtool_EggTriangleStrip_get_class_type_1184, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggTriangleStrip_get_class_type_1184_comment},
  {"getClassType", &Dtool_EggTriangleStrip_get_class_type_1184, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggTriangleStrip_get_class_type_1184_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EggTriangleStrip = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggTriangleStrip = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggTriangleStrip = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggTriangleStrip = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggTriangleStrip = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggTriangleStrip = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggTriangleStrip",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggTriangleStrip,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggTriangleStrip,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggTriangleStrip,
    &Dtool_SequenceMethods_EggTriangleStrip,
    &Dtool_MappingMethods_EggTriangleStrip,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggTriangleStrip,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A connected strip of triangles.  This does not normally appear in an egg\n"
    " * file; it is typically generated as a result of meshing.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggTriangleStrip,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggTriangleStrip,
    PyType_GenericAlloc,
    Dtool_new_EggTriangleStrip,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggTriangleStrip,
  Dtool_UpcastInterface_EggTriangleStrip,
  Dtool_DowncastInterface_EggTriangleStrip,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EggTriangleStrip(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggCompositePrimitive(nullptr);
    Dtool_EggTriangleStrip._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggCompositePrimitive);
    Dtool_EggTriangleStrip._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggTriangleStrip._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggTriangleStrip) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggTriangleStrip)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggTriangleStrip);
  }
}

/**
 * Python method tables for EggXfmSAnim (EggXfmSAnim)
 */
static PyMethodDef Dtool_Methods_EggXfmSAnim[] = {
  {"assign", &Dtool_EggXfmSAnim_operator_1187, METH_O, (const char *)Dtool_EggXfmSAnim_operator_1187_comment},
  {"set_fps", &Dtool_EggXfmSAnim_set_fps_1188, METH_O, (const char *)Dtool_EggXfmSAnim_set_fps_1188_comment},
  {"setFps", &Dtool_EggXfmSAnim_set_fps_1188, METH_O, (const char *)Dtool_EggXfmSAnim_set_fps_1188_comment},
  {"clear_fps", &Dtool_EggXfmSAnim_clear_fps_1189, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_clear_fps_1189_comment},
  {"clearFps", &Dtool_EggXfmSAnim_clear_fps_1189, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_clear_fps_1189_comment},
  {"has_fps", &Dtool_EggXfmSAnim_has_fps_1190, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_has_fps_1190_comment},
  {"hasFps", &Dtool_EggXfmSAnim_has_fps_1190, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_has_fps_1190_comment},
  {"get_fps", &Dtool_EggXfmSAnim_get_fps_1191, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_get_fps_1191_comment},
  {"getFps", &Dtool_EggXfmSAnim_get_fps_1191, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_get_fps_1191_comment},
  {"set_order", &Dtool_EggXfmSAnim_set_order_1192, METH_O, (const char *)Dtool_EggXfmSAnim_set_order_1192_comment},
  {"setOrder", &Dtool_EggXfmSAnim_set_order_1192, METH_O, (const char *)Dtool_EggXfmSAnim_set_order_1192_comment},
  {"clear_order", &Dtool_EggXfmSAnim_clear_order_1193, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_clear_order_1193_comment},
  {"clearOrder", &Dtool_EggXfmSAnim_clear_order_1193, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_clear_order_1193_comment},
  {"has_order", &Dtool_EggXfmSAnim_has_order_1194, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_has_order_1194_comment},
  {"hasOrder", &Dtool_EggXfmSAnim_has_order_1194, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_has_order_1194_comment},
  {"get_order", &Dtool_EggXfmSAnim_get_order_1195, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_get_order_1195_comment},
  {"getOrder", &Dtool_EggXfmSAnim_get_order_1195, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_get_order_1195_comment},
  {"get_standard_order", &Dtool_EggXfmSAnim_get_standard_order_1196, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggXfmSAnim_get_standard_order_1196_comment},
  {"getStandardOrder", &Dtool_EggXfmSAnim_get_standard_order_1196, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggXfmSAnim_get_standard_order_1196_comment},
  {"get_coordinate_system", &Dtool_EggXfmSAnim_get_coordinate_system_1197, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_get_coordinate_system_1197_comment},
  {"getCoordinateSystem", &Dtool_EggXfmSAnim_get_coordinate_system_1197, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_get_coordinate_system_1197_comment},
  {"optimize", &Dtool_EggXfmSAnim_optimize_1198, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_optimize_1198_comment},
  {"optimize_to_standard_order", &Dtool_EggXfmSAnim_optimize_to_standard_order_1199, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_optimize_to_standard_order_1199_comment},
  {"optimizeToStandardOrder", &Dtool_EggXfmSAnim_optimize_to_standard_order_1199, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_optimize_to_standard_order_1199_comment},
  {"normalize", &Dtool_EggXfmSAnim_normalize_1200, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_normalize_1200_comment},
  {"get_num_rows", &Dtool_EggXfmSAnim_get_num_rows_1201, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_get_num_rows_1201_comment},
  {"getNumRows", &Dtool_EggXfmSAnim_get_num_rows_1201, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_get_num_rows_1201_comment},
  {"get_value", (PyCFunction) &Dtool_EggXfmSAnim_get_value_1202, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggXfmSAnim_get_value_1202_comment},
  {"getValue", (PyCFunction) &Dtool_EggXfmSAnim_get_value_1202, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggXfmSAnim_get_value_1202_comment},
  {"set_value", (PyCFunction) &Dtool_EggXfmSAnim_set_value_1203, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggXfmSAnim_set_value_1203_comment},
  {"setValue", (PyCFunction) &Dtool_EggXfmSAnim_set_value_1203, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggXfmSAnim_set_value_1203_comment},
  {"clear_data", &Dtool_EggXfmSAnim_clear_data_1204, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_clear_data_1204_comment},
  {"clearData", &Dtool_EggXfmSAnim_clear_data_1204, METH_NOARGS, (const char *)Dtool_EggXfmSAnim_clear_data_1204_comment},
  {"add_data", &Dtool_EggXfmSAnim_add_data_1205, METH_O, (const char *)Dtool_EggXfmSAnim_add_data_1205_comment},
  {"addData", &Dtool_EggXfmSAnim_add_data_1205, METH_O, (const char *)Dtool_EggXfmSAnim_add_data_1205_comment},
  {"add_component_data", (PyCFunction) &Dtool_EggXfmSAnim_add_component_data_1206, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggXfmSAnim_add_component_data_1206_comment},
  {"addComponentData", (PyCFunction) &Dtool_EggXfmSAnim_add_component_data_1206, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggXfmSAnim_add_component_data_1206_comment},
  {"compose_with_order", (PyCFunction) &Dtool_EggXfmSAnim_compose_with_order_1207, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_EggXfmSAnim_compose_with_order_1207_comment},
  {"composeWithOrder", (PyCFunction) &Dtool_EggXfmSAnim_compose_with_order_1207, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_EggXfmSAnim_compose_with_order_1207_comment},
  {"get_class_type", &Dtool_EggXfmSAnim_get_class_type_1208, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggXfmSAnim_get_class_type_1208_comment},
  {"getClassType", &Dtool_EggXfmSAnim_get_class_type_1208, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggXfmSAnim_get_class_type_1208_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EggXfmSAnim = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggXfmSAnim = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggXfmSAnim = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggXfmSAnim = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggXfmSAnim = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggXfmSAnim = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggXfmSAnim",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggXfmSAnim,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggXfmSAnim,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggXfmSAnim,
    &Dtool_SequenceMethods_EggXfmSAnim,
    &Dtool_MappingMethods_EggXfmSAnim,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggXfmSAnim,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This corresponds to an <Xfm$Anim_S$> entry, which is a collection of up to\n"
    " * nine <S$Anim> entries that specify the nine components of a transformation.\n"
    " * It's implemented as a group that can contain any number of EggSAnimData\n"
    " * children.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggXfmSAnim,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggXfmSAnim,
    PyType_GenericAlloc,
    Dtool_new_EggXfmSAnim,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggXfmSAnim,
  Dtool_UpcastInterface_EggXfmSAnim,
  Dtool_DowncastInterface_EggXfmSAnim,
  (CoerceFunction)Dtool_ConstCoerce_EggXfmSAnim,
  (CoerceFunction)Dtool_Coerce_EggXfmSAnim,
};

static void Dtool_PyModuleClassInit_EggXfmSAnim(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggGroupNode(nullptr);
    Dtool_EggXfmSAnim._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggGroupNode);
    Dtool_EggXfmSAnim._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggXfmSAnim._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggXfmSAnim) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggXfmSAnim)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggXfmSAnim);
  }
}

/**
 * Python method tables for EggXfmAnimData (EggXfmAnimData)
 */
static PyMethodDef Dtool_Methods_EggXfmAnimData[] = {
  {"assign", &Dtool_EggXfmAnimData_operator_1212, METH_O, (const char *)Dtool_EggXfmAnimData_operator_1212_comment},
  {"set_order", &Dtool_EggXfmAnimData_set_order_1213, METH_O, (const char *)Dtool_EggXfmAnimData_set_order_1213_comment},
  {"setOrder", &Dtool_EggXfmAnimData_set_order_1213, METH_O, (const char *)Dtool_EggXfmAnimData_set_order_1213_comment},
  {"clear_order", &Dtool_EggXfmAnimData_clear_order_1214, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_clear_order_1214_comment},
  {"clearOrder", &Dtool_EggXfmAnimData_clear_order_1214, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_clear_order_1214_comment},
  {"has_order", &Dtool_EggXfmAnimData_has_order_1215, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_has_order_1215_comment},
  {"hasOrder", &Dtool_EggXfmAnimData_has_order_1215, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_has_order_1215_comment},
  {"get_order", &Dtool_EggXfmAnimData_get_order_1216, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_get_order_1216_comment},
  {"getOrder", &Dtool_EggXfmAnimData_get_order_1216, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_get_order_1216_comment},
  {"get_standard_order", &Dtool_EggXfmAnimData_get_standard_order_1217, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggXfmAnimData_get_standard_order_1217_comment},
  {"getStandardOrder", &Dtool_EggXfmAnimData_get_standard_order_1217, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggXfmAnimData_get_standard_order_1217_comment},
  {"set_contents", &Dtool_EggXfmAnimData_set_contents_1218, METH_O, (const char *)Dtool_EggXfmAnimData_set_contents_1218_comment},
  {"setContents", &Dtool_EggXfmAnimData_set_contents_1218, METH_O, (const char *)Dtool_EggXfmAnimData_set_contents_1218_comment},
  {"clear_contents", &Dtool_EggXfmAnimData_clear_contents_1219, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_clear_contents_1219_comment},
  {"clearContents", &Dtool_EggXfmAnimData_clear_contents_1219, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_clear_contents_1219_comment},
  {"has_contents", &Dtool_EggXfmAnimData_has_contents_1220, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_has_contents_1220_comment},
  {"hasContents", &Dtool_EggXfmAnimData_has_contents_1220, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_has_contents_1220_comment},
  {"get_contents", &Dtool_EggXfmAnimData_get_contents_1221, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_get_contents_1221_comment},
  {"getContents", &Dtool_EggXfmAnimData_get_contents_1221, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_get_contents_1221_comment},
  {"get_coordinate_system", &Dtool_EggXfmAnimData_get_coordinate_system_1222, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_get_coordinate_system_1222_comment},
  {"getCoordinateSystem", &Dtool_EggXfmAnimData_get_coordinate_system_1222, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_get_coordinate_system_1222_comment},
  {"get_num_rows", &Dtool_EggXfmAnimData_get_num_rows_1223, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_get_num_rows_1223_comment},
  {"getNumRows", &Dtool_EggXfmAnimData_get_num_rows_1223, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_get_num_rows_1223_comment},
  {"get_num_cols", &Dtool_EggXfmAnimData_get_num_cols_1224, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_get_num_cols_1224_comment},
  {"getNumCols", &Dtool_EggXfmAnimData_get_num_cols_1224, METH_NOARGS, (const char *)Dtool_EggXfmAnimData_get_num_cols_1224_comment},
  {"get_value", (PyCFunction) &Dtool_EggXfmAnimData_get_value_1225, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggXfmAnimData_get_value_1225_comment},
  {"getValue", (PyCFunction) &Dtool_EggXfmAnimData_get_value_1225, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_EggXfmAnimData_get_value_1225_comment},
  {"get_class_type", &Dtool_EggXfmAnimData_get_class_type_1226, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggXfmAnimData_get_class_type_1226_comment},
  {"getClassType", &Dtool_EggXfmAnimData_get_class_type_1226, METH_NOARGS | METH_STATIC, (const char *)Dtool_EggXfmAnimData_get_class_type_1226_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EggXfmAnimData = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EggXfmAnimData = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EggXfmAnimData = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EggXfmAnimData = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EggXfmAnimData = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EggXfmAnimData = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.egg.EggXfmAnimData",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EggXfmAnimData,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EggXfmAnimData,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EggXfmAnimData,
    &Dtool_SequenceMethods_EggXfmAnimData,
    &Dtool_MappingMethods_EggXfmAnimData,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EggXfmAnimData,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Corresponding to an <Xfm$Anim> entry, this stores a two-dimensional table\n"
    " * with up to nine columns, one for each component of a transformation.  This\n"
    " * is an older syntax of egg anim table, not often used currently--it's\n"
    " * replaced by EggXfmSAnim.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EggXfmAnimData,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EggXfmAnimData,
    PyType_GenericAlloc,
    Dtool_new_EggXfmAnimData,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EggXfmAnimData,
  Dtool_UpcastInterface_EggXfmAnimData,
  Dtool_DowncastInterface_EggXfmAnimData,
  (CoerceFunction)Dtool_ConstCoerce_EggXfmAnimData,
  (CoerceFunction)Dtool_Coerce_EggXfmAnimData,
};

static void Dtool_PyModuleClassInit_EggXfmAnimData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_EggAnimData(nullptr);
    Dtool_EggXfmAnimData._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_EggAnimData);
    Dtool_EggXfmAnimData._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EggXfmAnimData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EggXfmAnimData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EggXfmAnimData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EggXfmAnimData);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3egg_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    EggUserData::init_type();
    TypeHandle handle = EggUserData::get_class_type();
    Dtool_EggUserData._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggUserData);
  }
  {
    EggObject::init_type();
    TypeHandle handle = EggObject::get_class_type();
    Dtool_EggObject._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggObject);
  }
  {
    EggNamedObject::init_type();
    TypeHandle handle = EggNamedObject::get_class_type();
    Dtool_EggNamedObject._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggNamedObject);
  }
  {
    EggNode::init_type();
    TypeHandle handle = EggNode::get_class_type();
    Dtool_EggNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggNode);
  }
  {
    EggGroupNode::init_type();
    TypeHandle handle = EggGroupNode::get_class_type();
    Dtool_EggGroupNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggGroupNode);
  }
  {
    EggAnimData::init_type();
    TypeHandle handle = EggAnimData::get_class_type();
    Dtool_EggAnimData._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggAnimData);
  }
  {
    EggAnimPreload::init_type();
    TypeHandle handle = EggAnimPreload::get_class_type();
    Dtool_EggAnimPreload._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggAnimPreload);
  }
  {
    EggAttributes::init_type();
    TypeHandle handle = EggAttributes::get_class_type();
    Dtool_EggAttributes._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggAttributes);
  }
  {
    EggVertexUV::init_type();
    TypeHandle handle = EggVertexUV::get_class_type();
    Dtool_EggVertexUV._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggVertexUV);
  }
  {
    EggVertexAux::init_type();
    TypeHandle handle = EggVertexAux::get_class_type();
    Dtool_EggVertexAux._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggVertexAux);
  }
  {
    EggVertex::init_type();
    TypeHandle handle = EggVertex::get_class_type();
    Dtool_EggVertex._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggVertex);
  }
  {
    EggVertexPool::init_type();
    TypeHandle handle = EggVertexPool::get_class_type();
    Dtool_EggVertexPool._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggVertexPool);
  }
  {
    EggRenderMode::init_type();
    TypeHandle handle = EggRenderMode::get_class_type();
    Dtool_EggRenderMode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggRenderMode);
  }
  {
    EggSwitchCondition::init_type();
    TypeHandle handle = EggSwitchCondition::get_class_type();
    Dtool_EggSwitchCondition._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggSwitchCondition);
  }
  {
    EggSwitchConditionDistance::init_type();
    TypeHandle handle = EggSwitchConditionDistance::get_class_type();
    Dtool_EggSwitchConditionDistance._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggSwitchConditionDistance);
  }
  {
    EggGroup::init_type();
    TypeHandle handle = EggGroup::get_class_type();
    Dtool_EggGroup._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggGroup);
  }
  {
    EggBin::init_type();
    TypeHandle handle = EggBin::get_class_type();
    Dtool_EggBin._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggBin);
  }
  {
    EggBinMaker::init_type();
    TypeHandle handle = EggBinMaker::get_class_type();
    Dtool_EggBinMaker._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggBinMaker);
  }
  {
    EggComment::init_type();
    TypeHandle handle = EggComment::get_class_type();
    Dtool_EggComment._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggComment);
  }
  {
    EggFilenameNode::init_type();
    TypeHandle handle = EggFilenameNode::get_class_type();
    Dtool_EggFilenameNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggFilenameNode);
  }
  {
    EggTexture::init_type();
    TypeHandle handle = EggTexture::get_class_type();
    Dtool_EggTexture._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggTexture);
  }
  {
    EggMaterial::init_type();
    TypeHandle handle = EggMaterial::get_class_type();
    Dtool_EggMaterial._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggMaterial);
  }
  {
    EggPrimitive::init_type();
    TypeHandle handle = EggPrimitive::get_class_type();
    Dtool_EggPrimitive._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggPrimitive);
  }
  {
    EggCompositePrimitive::init_type();
    TypeHandle handle = EggCompositePrimitive::get_class_type();
    Dtool_EggCompositePrimitive._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggCompositePrimitive);
  }
  {
    EggData::init_type();
    TypeHandle handle = EggData::get_class_type();
    Dtool_EggData._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggData);
  }
  {
    EggCoordinateSystem::init_type();
    TypeHandle handle = EggCoordinateSystem::get_class_type();
    Dtool_EggCoordinateSystem._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggCoordinateSystem);
  }
  {
    EggCurve::init_type();
    TypeHandle handle = EggCurve::get_class_type();
    Dtool_EggCurve._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggCurve);
  }
  {
    EggExternalReference::init_type();
    TypeHandle handle = EggExternalReference::get_class_type();
    Dtool_EggExternalReference._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggExternalReference);
  }
  {
    EggNameUniquifier::init_type();
    TypeHandle handle = EggNameUniquifier::get_class_type();
    Dtool_EggNameUniquifier._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggNameUniquifier);
  }
  {
    EggGroupUniquifier::init_type();
    TypeHandle handle = EggGroupUniquifier::get_class_type();
    Dtool_EggGroupUniquifier._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggGroupUniquifier);
  }
  {
    EggLine::init_type();
    TypeHandle handle = EggLine::get_class_type();
    Dtool_EggLine._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggLine);
  }
  {
    EggPolygon::init_type();
    TypeHandle handle = EggPolygon::get_class_type();
    Dtool_EggPolygon._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggPolygon);
  }
  {
    EggNurbsCurve::init_type();
    TypeHandle handle = EggNurbsCurve::get_class_type();
    Dtool_EggNurbsCurve._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggNurbsCurve);
  }
  {
    EggSurface::init_type();
    TypeHandle handle = EggSurface::get_class_type();
    Dtool_EggSurface._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggSurface);
  }
  {
    EggNurbsSurface::init_type();
    TypeHandle handle = EggNurbsSurface::get_class_type();
    Dtool_EggNurbsSurface._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggNurbsSurface);
  }
  {
    EggPatch::init_type();
    TypeHandle handle = EggPatch::get_class_type();
    Dtool_EggPatch._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggPatch);
  }
  {
    EggPoint::init_type();
    TypeHandle handle = EggPoint::get_class_type();
    Dtool_EggPoint._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggPoint);
  }
  {
    EggPolysetMaker::init_type();
    TypeHandle handle = EggPolysetMaker::get_class_type();
    Dtool_EggPolysetMaker._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggPolysetMaker);
  }
  {
    EggPoolUniquifier::init_type();
    TypeHandle handle = EggPoolUniquifier::get_class_type();
    Dtool_EggPoolUniquifier._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggPoolUniquifier);
  }
  {
    EggSAnimData::init_type();
    TypeHandle handle = EggSAnimData::get_class_type();
    Dtool_EggSAnimData._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggSAnimData);
  }
  {
    EggTable::init_type();
    TypeHandle handle = EggTable::get_class_type();
    Dtool_EggTable._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggTable);
  }
  {
    EggTriangleFan::init_type();
    TypeHandle handle = EggTriangleFan::get_class_type();
    Dtool_EggTriangleFan._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggTriangleFan);
  }
  {
    EggTriangleStrip::init_type();
    TypeHandle handle = EggTriangleStrip::get_class_type();
    Dtool_EggTriangleStrip._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggTriangleStrip);
  }
  {
    EggXfmSAnim::init_type();
    TypeHandle handle = EggXfmSAnim::get_class_type();
    Dtool_EggXfmSAnim._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggXfmSAnim);
  }
  {
    EggXfmAnimData::init_type();
    TypeHandle handle = EggXfmAnimData::get_class_type();
    Dtool_EggXfmAnimData._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EggXfmAnimData);
  }
}

void Dtool_libp3egg_BuildInstants(PyObject *module) {
  (void) module;
  // EggUserData
  Dtool_PyModuleClassInit_EggUserData(module);
  PyModule_AddObject(module, "EggUserData", (PyObject *)&Dtool_EggUserData);
  // EggObject
  Dtool_PyModuleClassInit_EggObject(module);
  PyModule_AddObject(module, "EggObject", (PyObject *)&Dtool_EggObject);
  // EggNamedObject
  Dtool_PyModuleClassInit_EggNamedObject(module);
  PyModule_AddObject(module, "EggNamedObject", (PyObject *)&Dtool_EggNamedObject);
  // EggNode
  Dtool_PyModuleClassInit_EggNode(module);
  PyModule_AddObject(module, "EggNode", (PyObject *)&Dtool_EggNode);
  // EggGroupNode
  Dtool_PyModuleClassInit_EggGroupNode(module);
  PyModule_AddObject(module, "EggGroupNode", (PyObject *)&Dtool_EggGroupNode);
  // EggAnimData
  Dtool_PyModuleClassInit_EggAnimData(module);
  PyModule_AddObject(module, "EggAnimData", (PyObject *)&Dtool_EggAnimData);
  // EggAnimPreload
  Dtool_PyModuleClassInit_EggAnimPreload(module);
  PyModule_AddObject(module, "EggAnimPreload", (PyObject *)&Dtool_EggAnimPreload);
  // EggAttributes
  Dtool_PyModuleClassInit_EggAttributes(module);
  PyModule_AddObject(module, "EggAttributes", (PyObject *)&Dtool_EggAttributes);
  // EggVertexUV
  Dtool_PyModuleClassInit_EggVertexUV(module);
  PyModule_AddObject(module, "EggVertexUV", (PyObject *)&Dtool_EggVertexUV);
  // EggVertexAux
  Dtool_PyModuleClassInit_EggVertexAux(module);
  PyModule_AddObject(module, "EggVertexAux", (PyObject *)&Dtool_EggVertexAux);
  // EggVertex
  Dtool_PyModuleClassInit_EggVertex(module);
  PyModule_AddObject(module, "EggVertex", (PyObject *)&Dtool_EggVertex);
  // EggVertexPool
  Dtool_PyModuleClassInit_EggVertexPool(module);
  PyModule_AddObject(module, "EggVertexPool", (PyObject *)&Dtool_EggVertexPool);
  // EggRenderMode
  Dtool_PyModuleClassInit_EggRenderMode(module);
  PyModule_AddObject(module, "EggRenderMode", (PyObject *)&Dtool_EggRenderMode);
  // EggTransform
  Dtool_PyModuleClassInit_EggTransform(module);
  PyModule_AddObject(module, "EggTransform", (PyObject *)&Dtool_EggTransform);
  // EggSwitchCondition
  Dtool_PyModuleClassInit_EggSwitchCondition(module);
  PyModule_AddObject(module, "EggSwitchCondition", (PyObject *)&Dtool_EggSwitchCondition);
  // EggSwitchConditionDistance
  Dtool_PyModuleClassInit_EggSwitchConditionDistance(module);
  PyModule_AddObject(module, "EggSwitchConditionDistance", (PyObject *)&Dtool_EggSwitchConditionDistance);
  // EggGroup
  Dtool_PyModuleClassInit_EggGroup(module);
  PyModule_AddObject(module, "EggGroup", (PyObject *)&Dtool_EggGroup);
  // EggBin
  Dtool_PyModuleClassInit_EggBin(module);
  PyModule_AddObject(module, "EggBin", (PyObject *)&Dtool_EggBin);
  // EggBinMaker
  Dtool_PyModuleClassInit_EggBinMaker(module);
  PyModule_AddObject(module, "EggBinMaker", (PyObject *)&Dtool_EggBinMaker);
  // EggComment
  Dtool_PyModuleClassInit_EggComment(module);
  PyModule_AddObject(module, "EggComment", (PyObject *)&Dtool_EggComment);
  // EggFilenameNode
  Dtool_PyModuleClassInit_EggFilenameNode(module);
  PyModule_AddObject(module, "EggFilenameNode", (PyObject *)&Dtool_EggFilenameNode);
  // EggTexture
  Dtool_PyModuleClassInit_EggTexture(module);
  PyModule_AddObject(module, "EggTexture", (PyObject *)&Dtool_EggTexture);
  // EggMaterial
  Dtool_PyModuleClassInit_EggMaterial(module);
  PyModule_AddObject(module, "EggMaterial", (PyObject *)&Dtool_EggMaterial);
  // EggPrimitive
  Dtool_PyModuleClassInit_EggPrimitive(module);
  PyModule_AddObject(module, "EggPrimitive", (PyObject *)&Dtool_EggPrimitive);
  // EggCompositePrimitive
  Dtool_PyModuleClassInit_EggCompositePrimitive(module);
  PyModule_AddObject(module, "EggCompositePrimitive", (PyObject *)&Dtool_EggCompositePrimitive);
  // EggData
  Dtool_PyModuleClassInit_EggData(module);
  PyModule_AddObject(module, "EggData", (PyObject *)&Dtool_EggData);
  // EggCoordinateSystem
  Dtool_PyModuleClassInit_EggCoordinateSystem(module);
  PyModule_AddObject(module, "EggCoordinateSystem", (PyObject *)&Dtool_EggCoordinateSystem);
  // EggCurve
  Dtool_PyModuleClassInit_EggCurve(module);
  PyModule_AddObject(module, "EggCurve", (PyObject *)&Dtool_EggCurve);
  // EggExternalReference
  Dtool_PyModuleClassInit_EggExternalReference(module);
  PyModule_AddObject(module, "EggExternalReference", (PyObject *)&Dtool_EggExternalReference);
  // EggNameUniquifier
  Dtool_PyModuleClassInit_EggNameUniquifier(module);
  PyModule_AddObject(module, "EggNameUniquifier", (PyObject *)&Dtool_EggNameUniquifier);
  // EggGroupUniquifier
  Dtool_PyModuleClassInit_EggGroupUniquifier(module);
  PyModule_AddObject(module, "EggGroupUniquifier", (PyObject *)&Dtool_EggGroupUniquifier);
  // EggLine
  Dtool_PyModuleClassInit_EggLine(module);
  PyModule_AddObject(module, "EggLine", (PyObject *)&Dtool_EggLine);
  // EggMaterialCollection
  Dtool_PyModuleClassInit_EggMaterialCollection(module);
  PyModule_AddObject(module, "EggMaterialCollection", (PyObject *)&Dtool_EggMaterialCollection);
  // EggPolygon
  Dtool_PyModuleClassInit_EggPolygon(module);
  PyModule_AddObject(module, "EggPolygon", (PyObject *)&Dtool_EggPolygon);
  // EggNurbsCurve
  Dtool_PyModuleClassInit_EggNurbsCurve(module);
  PyModule_AddObject(module, "EggNurbsCurve", (PyObject *)&Dtool_EggNurbsCurve);
  // EggSurface
  Dtool_PyModuleClassInit_EggSurface(module);
  PyModule_AddObject(module, "EggSurface", (PyObject *)&Dtool_EggSurface);
  // EggNurbsSurface
  Dtool_PyModuleClassInit_EggNurbsSurface(module);
  PyModule_AddObject(module, "EggNurbsSurface", (PyObject *)&Dtool_EggNurbsSurface);
  // EggPatch
  Dtool_PyModuleClassInit_EggPatch(module);
  PyModule_AddObject(module, "EggPatch", (PyObject *)&Dtool_EggPatch);
  // EggPoint
  Dtool_PyModuleClassInit_EggPoint(module);
  PyModule_AddObject(module, "EggPoint", (PyObject *)&Dtool_EggPoint);
  // EggPolysetMaker
  Dtool_PyModuleClassInit_EggPolysetMaker(module);
  PyModule_AddObject(module, "EggPolysetMaker", (PyObject *)&Dtool_EggPolysetMaker);
  // EggPoolUniquifier
  Dtool_PyModuleClassInit_EggPoolUniquifier(module);
  PyModule_AddObject(module, "EggPoolUniquifier", (PyObject *)&Dtool_EggPoolUniquifier);
  // EggSAnimData
  Dtool_PyModuleClassInit_EggSAnimData(module);
  PyModule_AddObject(module, "EggSAnimData", (PyObject *)&Dtool_EggSAnimData);
  // EggTable
  Dtool_PyModuleClassInit_EggTable(module);
  PyModule_AddObject(module, "EggTable", (PyObject *)&Dtool_EggTable);
  // EggTextureCollection
  Dtool_PyModuleClassInit_EggTextureCollection(module);
  PyModule_AddObject(module, "EggTextureCollection", (PyObject *)&Dtool_EggTextureCollection);
  // EggTriangleFan
  Dtool_PyModuleClassInit_EggTriangleFan(module);
  PyModule_AddObject(module, "EggTriangleFan", (PyObject *)&Dtool_EggTriangleFan);
  // EggTriangleStrip
  Dtool_PyModuleClassInit_EggTriangleStrip(module);
  PyModule_AddObject(module, "EggTriangleStrip", (PyObject *)&Dtool_EggTriangleStrip);
  // EggXfmSAnim
  Dtool_PyModuleClassInit_EggXfmSAnim(module);
  PyModule_AddObject(module, "EggXfmSAnim", (PyObject *)&Dtool_EggXfmSAnim);
  // EggXfmAnimData
  Dtool_PyModuleClassInit_EggXfmAnimData(module);
  PyModule_AddObject(module, "EggXfmAnimData", (PyObject *)&Dtool_EggXfmAnimData);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3egg_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3egg_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583614083,  /* file_identifier */
  "libp3egg",  /* library_name */
  "hhEq",  /* library_hash_name */
  "panda3d.egg",  /* module_name */
  "libp3egg.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  2446  /* next_index */
};

Configure(_in_configure_libp3egg);
ConfigureFn(_in_configure_libp3egg) {
  interrogate_request_module(&_in_module_def);
}

