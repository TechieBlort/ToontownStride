/*
 * This file was generated by:
 * built/bin/interrogate -srcdir direct/src/deadrec -Idirect/src/deadrec -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3deadrec_igate.cxx -od built/pandac/input/libp3deadrec.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Idirect/src/deadrec -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.direct -library libp3deadrec config_deadrec.h p3deadrec_composite1.cxx smoothMover.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "configVariableBool.h"
#include "config_deadrec.h"
#include "directbase.h"
#include "notifyCategoryProxy.h"
#include "smoothMover.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class SmoothMover
 */
typedef SmoothMover SmoothMover_localtype;
Define_Module_Class(panda3d.direct, SmoothMover, SmoothMover_localtype, SmoothMover);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SmoothMover = &Dtool_SmoothMover;
static void Dtool_PyModuleClassInit_SmoothMover(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"SmoothMover", &Dtool_SmoothMover},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"std::ostream", nullptr},
#define Dtool_Ptr_std_ostream (imports[0].type)
  {"LVecBase3f", nullptr},
#define Dtool_Ptr_LVecBase3f (imports[1].type)
  {"LPoint3f", nullptr},
#define Dtool_Ptr_LPoint3f (imports[2].type)
  {"NodePath", nullptr},
#define Dtool_Ptr_NodePath (imports[3].type)
  {nullptr, nullptr},
};
#endif

// std::ostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
#endif
// LVecBase3f
#ifndef LINK_ALL_STATIC
inline static LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  nassertr(Dtool_Ptr_LVecBase3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase3f *(*)(PyObject *, LVecBase3f &))Dtool_Ptr_LVecBase3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
extern LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);
#endif
// LPoint3f
#ifndef LINK_ALL_STATIC
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif
// NodePath
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class SmoothMover
 */
/**
 * Python function wrapper for:
 * inline bool SmoothMover::set_pos(LVecBase3 const &pos)
 * inline bool SmoothMover::set_pos(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_SmoothMover_set_pos_4(PyObject *self, PyObject *args, PyObject *kwds) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.set_pos")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "pos")) {
        // 1-inline bool SmoothMover::set_pos(LVecBase3 const &pos)
        LVecBase3f arg_local;
        LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "SmoothMover.set_pos", "LVecBase3f");
        }
        bool return_value = ((*local_this).set_pos)(*arg_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 3:
    {
      // 1-inline bool SmoothMover::set_pos(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_pos", (char **)keyword_list, &param1, &param2, &param3)) {
        bool return_value = ((*local_this).set_pos)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_pos() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pos(const SmoothMover self, const LVecBase3f pos)\n"
      "set_pos(const SmoothMover self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_set_pos_4_comment =
  "C++ Interface:\n"
  "set_pos(const SmoothMover self, const LVecBase3f pos)\n"
  "set_pos(const SmoothMover self, float x, float y, float z)\n"
  "\n"
  "// These methods are used to specify each position update.  Call the\n"
  "// appropriate set_* function(s), as needed, and then call mark_position().\n"
  "// The return value of each function is true if the parameter value has\n"
  "// changed, or false if it remains the same as last time.\n"
  "\n"
  "/**\n"
  " * Specifies the position of the SmoothMover at a particular time in the past.\n"
  " * When mark_position() is called, this will be recorded (along with hpr and\n"
  " * timestamp) in a position report, which will then be used along with all\n"
  " * other position reports to determine the smooth position at any particular\n"
  " * instant.\n"
  " *\n"
  " * The return value is true if any parameter has changed since the last call\n"
  " * to set_pos(), or false if they are the same.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Specifies the position of the SmoothMover at a particular time in the past.\n"
  " * When mark_position() is called, this will be recorded (along with hpr and\n"
  " * timestamp) in a position report, which will then be used along with all\n"
  " * other position reports to determine the smooth position at any particular\n"
  " * instant.\n"
  " *\n"
  " * The return value is true if any parameter has changed since the last call\n"
  " * to set_pos(), or false if they are the same.\n"
  " */";
#else
static const char *Dtool_SmoothMover_set_pos_4_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SmoothMover::set_x(PN_stdfloat x)
 */
static PyObject *Dtool_SmoothMover_set_x_5(PyObject *self, PyObject *arg) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.set_x")) {
    return nullptr;
  }
  // 1-inline bool SmoothMover::set_x(PN_stdfloat x)
  if (PyNumber_Check(arg)) {
    bool return_value = ((*local_this).set_x)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_x(const SmoothMover self, float x)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_set_x_5_comment =
  "C++ Interface:\n"
  "set_x(const SmoothMover self, float x)\n"
  "\n"
  "/**\n"
  " * Sets the X position only.  See set_pos().\n"
  " */";
#else
static const char *Dtool_SmoothMover_set_x_5_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SmoothMover::set_y(PN_stdfloat y)
 */
static PyObject *Dtool_SmoothMover_set_y_6(PyObject *self, PyObject *arg) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.set_y")) {
    return nullptr;
  }
  // 1-inline bool SmoothMover::set_y(PN_stdfloat y)
  if (PyNumber_Check(arg)) {
    bool return_value = ((*local_this).set_y)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_y(const SmoothMover self, float y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_set_y_6_comment =
  "C++ Interface:\n"
  "set_y(const SmoothMover self, float y)\n"
  "\n"
  "/**\n"
  " * Sets the Y position only.  See set_pos().\n"
  " */";
#else
static const char *Dtool_SmoothMover_set_y_6_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SmoothMover::set_z(PN_stdfloat z)
 */
static PyObject *Dtool_SmoothMover_set_z_7(PyObject *self, PyObject *arg) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.set_z")) {
    return nullptr;
  }
  // 1-inline bool SmoothMover::set_z(PN_stdfloat z)
  if (PyNumber_Check(arg)) {
    bool return_value = ((*local_this).set_z)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_z(const SmoothMover self, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_set_z_7_comment =
  "C++ Interface:\n"
  "set_z(const SmoothMover self, float z)\n"
  "\n"
  "/**\n"
  " * Sets the Z position only.  See set_pos().\n"
  " */";
#else
static const char *Dtool_SmoothMover_set_z_7_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SmoothMover::set_hpr(LVecBase3 const &hpr)
 * inline bool SmoothMover::set_hpr(PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
 */
static PyObject *Dtool_SmoothMover_set_hpr_8(PyObject *self, PyObject *args, PyObject *kwds) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.set_hpr")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "hpr")) {
        // 1-inline bool SmoothMover::set_hpr(LVecBase3 const &hpr)
        LVecBase3f arg_local;
        LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "SmoothMover.set_hpr", "LVecBase3f");
        }
        bool return_value = ((*local_this).set_hpr)(*arg_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 3:
    {
      // 1-inline bool SmoothMover::set_hpr(PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"h", "p", "r", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_hpr", (char **)keyword_list, &param1, &param2, &param3)) {
        bool return_value = ((*local_this).set_hpr)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_hpr() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_hpr(const SmoothMover self, const LVecBase3f hpr)\n"
      "set_hpr(const SmoothMover self, float h, float p, float r)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_set_hpr_8_comment =
  "C++ Interface:\n"
  "set_hpr(const SmoothMover self, const LVecBase3f hpr)\n"
  "set_hpr(const SmoothMover self, float h, float p, float r)\n"
  "\n"
  "/**\n"
  " * Specifies the orientation of the SmoothMover at a particular time in the\n"
  " * past.  When mark_position() is called, this will be recorded (along with\n"
  " * hpr and timestamp) in a position report, which will then be used along with\n"
  " * all other position reports to determine the smooth position at any\n"
  " * particular instant.\n"
  " *\n"
  " * The return value is true if any parameter has changed since the last call\n"
  " * to set_hpr(), or false if they are the same.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Specifies the orientation of the SmoothMover at a particular time in the\n"
  " * past.  When mark_position() is called, this will be recorded (along with\n"
  " * hpr and timestamp) in a position report, which will then be used along with\n"
  " * all other position reports to determine the smooth position at any\n"
  " * particular instant.\n"
  " *\n"
  " * The return value is true if any parameter has changed since the last call\n"
  " * to set_hpr(), or false if they are the same.\n"
  " */";
#else
static const char *Dtool_SmoothMover_set_hpr_8_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SmoothMover::set_h(PN_stdfloat h)
 */
static PyObject *Dtool_SmoothMover_set_h_9(PyObject *self, PyObject *arg) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.set_h")) {
    return nullptr;
  }
  // 1-inline bool SmoothMover::set_h(PN_stdfloat h)
  if (PyNumber_Check(arg)) {
    bool return_value = ((*local_this).set_h)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_h(const SmoothMover self, float h)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_set_h_9_comment =
  "C++ Interface:\n"
  "set_h(const SmoothMover self, float h)\n"
  "\n"
  "/**\n"
  " * Sets the heading only.  See set_hpr().\n"
  " */";
#else
static const char *Dtool_SmoothMover_set_h_9_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SmoothMover::set_p(PN_stdfloat p)
 */
static PyObject *Dtool_SmoothMover_set_p_10(PyObject *self, PyObject *arg) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.set_p")) {
    return nullptr;
  }
  // 1-inline bool SmoothMover::set_p(PN_stdfloat p)
  if (PyNumber_Check(arg)) {
    bool return_value = ((*local_this).set_p)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_p(const SmoothMover self, float p)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_set_p_10_comment =
  "C++ Interface:\n"
  "set_p(const SmoothMover self, float p)\n"
  "\n"
  "/**\n"
  " * Sets the pitch only.  See set_hpr().\n"
  " */";
#else
static const char *Dtool_SmoothMover_set_p_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SmoothMover::set_r(PN_stdfloat r)
 */
static PyObject *Dtool_SmoothMover_set_r_11(PyObject *self, PyObject *arg) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.set_r")) {
    return nullptr;
  }
  // 1-inline bool SmoothMover::set_r(PN_stdfloat r)
  if (PyNumber_Check(arg)) {
    bool return_value = ((*local_this).set_r)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_r(const SmoothMover self, float r)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_set_r_11_comment =
  "C++ Interface:\n"
  "set_r(const SmoothMover self, float r)\n"
  "\n"
  "/**\n"
  " * Sets the roll only.  See set_hpr().\n"
  " */";
#else
static const char *Dtool_SmoothMover_set_r_11_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SmoothMover::set_pos_hpr(LVecBase3 const &pos, LVecBase3 const &hpr)
 * inline bool SmoothMover::set_pos_hpr(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
 */
static PyObject *Dtool_SmoothMover_set_pos_hpr_12(PyObject *self, PyObject *args, PyObject *kwds) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.set_pos_hpr")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline bool SmoothMover::set_pos_hpr(LVecBase3 const &pos, LVecBase3 const &hpr)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"pos", "hpr", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_pos_hpr", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param1_local;
        LVecBase3 const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "SmoothMover.set_pos_hpr", "LVecBase3f");
        }
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "SmoothMover.set_pos_hpr", "LVecBase3f");
        }
        bool return_value = ((*local_this).set_pos_hpr)(*param1_this, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 6:
    {
      // 1-inline bool SmoothMover::set_pos_hpr(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      static const char *keyword_list[] = {"x", "y", "z", "h", "p", "r", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffff:set_pos_hpr", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        bool return_value = ((*local_this).set_pos_hpr)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_pos_hpr() takes 3 or 7 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pos_hpr(const SmoothMover self, const LVecBase3f pos, const LVecBase3f hpr)\n"
      "set_pos_hpr(const SmoothMover self, float x, float y, float z, float h, float p, float r)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_set_pos_hpr_12_comment =
  "C++ Interface:\n"
  "set_pos_hpr(const SmoothMover self, const LVecBase3f pos, const LVecBase3f hpr)\n"
  "set_pos_hpr(const SmoothMover self, float x, float y, float z, float h, float p, float r)\n"
  "\n"
  "/**\n"
  " * Specifies the position and orientation of the SmoothMover at a particular\n"
  " * time in the past.  When mark_position() is called, this will be recorded\n"
  " * (along with timestamp) in a position report, which will then be used along\n"
  " * with all other position reports to determine the smooth position at any\n"
  " * particular instant.\n"
  " *\n"
  " * The return value is true if any parameter has changed since the last call\n"
  " * to set_pos_hpr(), or false if they are the same.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Specifies the position of the SmoothMover at a particular time in the past.\n"
  " * When mark_position() is called, this will be recorded (along with\n"
  " * timestamp) in a position report, which will then be used along with all\n"
  " * other position reports to determine the smooth position at any particular\n"
  " * instant.\n"
  " *\n"
  " * The return value is true if any parameter has changed since the last call\n"
  " * to set_pos_hpr(), or false if they are the same.\n"
  " */";
#else
static const char *Dtool_SmoothMover_set_pos_hpr_12_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &SmoothMover::get_sample_pos(void) const
 */
static PyObject *Dtool_SmoothMover_get_sample_pos_13(PyObject *self, PyObject *) {
  SmoothMover *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SmoothMover)) {
    return nullptr;
  }
  // 1-inline LPoint3 const &SmoothMover::get_sample_pos(void) const
  LPoint3 const *return_value = &(((*(const SmoothMover*)local_this).get_sample_pos)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_get_sample_pos_13_comment =
  "C++ Interface:\n"
  "get_sample_pos(SmoothMover self)\n"
  "\n"
  "/**\n"
  " * Returns the current position of the working sample point.  This position is\n"
  " * updated periodically by set_x(), set_y(), etc., and its current value is\n"
  " * copied to the sample point table when mark_position() is called.\n"
  " */";
#else
static const char *Dtool_SmoothMover_get_sample_pos_13_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3 const &SmoothMover::get_sample_hpr(void) const
 */
static PyObject *Dtool_SmoothMover_get_sample_hpr_14(PyObject *self, PyObject *) {
  SmoothMover *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SmoothMover)) {
    return nullptr;
  }
  // 1-inline LVecBase3 const &SmoothMover::get_sample_hpr(void) const
  LVecBase3 const *return_value = &(((*(const SmoothMover*)local_this).get_sample_hpr)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_get_sample_hpr_14_comment =
  "C++ Interface:\n"
  "get_sample_hpr(SmoothMover self)\n"
  "\n"
  "/**\n"
  " * Returns the current orientation of the working sample point.  This\n"
  " * orientation is updated periodically by set_h(), set_p(), etc., and its\n"
  " * current value is copied to the sample point table when mark_position() is\n"
  " * called.\n"
  " */";
#else
static const char *Dtool_SmoothMover_get_sample_hpr_14_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SmoothMover::set_phony_timestamp(double timestamp = 0.0, bool period_adjust = false)
 */
static PyObject *Dtool_SmoothMover_set_phony_timestamp_15(PyObject *self, PyObject *args, PyObject *kwds) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.set_phony_timestamp")) {
    return nullptr;
  }
  // 1-inline void SmoothMover::set_phony_timestamp(double timestamp = 0.0, bool period_adjust = false)
  double param1 = 0.0;
  PyObject *param2 = Py_False;
  static const char *keyword_list[] = {"timestamp", "period_adjust", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|dO:set_phony_timestamp", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_phony_timestamp)((double)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_phony_timestamp(const SmoothMover self, double timestamp, bool period_adjust)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_set_phony_timestamp_15_comment =
  "C++ Interface:\n"
  "set_phony_timestamp(const SmoothMover self, double timestamp, bool period_adjust)\n"
  "\n"
  "/**\n"
  " * Lies and specifies that the current position report was received now.  This\n"
  " * is usually used for very old position reports for which we're not sure of\n"
  " * the actual receipt time.\n"
  " */";
#else
static const char *Dtool_SmoothMover_set_phony_timestamp_15_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SmoothMover::set_timestamp(double timestamp)
 */
static PyObject *Dtool_SmoothMover_set_timestamp_16(PyObject *self, PyObject *arg) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.set_timestamp")) {
    return nullptr;
  }
  // 1-inline void SmoothMover::set_timestamp(double timestamp)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_timestamp)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_timestamp(const SmoothMover self, double timestamp)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_set_timestamp_16_comment =
  "C++ Interface:\n"
  "set_timestamp(const SmoothMover self, double timestamp)\n"
  "\n"
  "/**\n"
  " * Specifies the time that the current position report applies.  This should\n"
  " * be called, along with set_pos() and set_hpr(), before a call to\n"
  " * mark_position().\n"
  " */";
#else
static const char *Dtool_SmoothMover_set_timestamp_16_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SmoothMover::has_most_recent_timestamp(void) const
 */
static PyObject *Dtool_SmoothMover_has_most_recent_timestamp_17(PyObject *self, PyObject *) {
  SmoothMover *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SmoothMover)) {
    return nullptr;
  }
  // 1-inline bool SmoothMover::has_most_recent_timestamp(void) const
  bool return_value = ((*(const SmoothMover*)local_this).has_most_recent_timestamp)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_has_most_recent_timestamp_17_comment =
  "C++ Interface:\n"
  "has_most_recent_timestamp(SmoothMover self)\n"
  "\n"
  "/**\n"
  " * Returns true if we have most recently recorded timestamp\n"
  " */";
#else
static const char *Dtool_SmoothMover_has_most_recent_timestamp_17_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double SmoothMover::get_most_recent_timestamp(void) const
 */
static PyObject *Dtool_SmoothMover_get_most_recent_timestamp_18(PyObject *self, PyObject *) {
  SmoothMover *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SmoothMover)) {
    return nullptr;
  }
  // 1-inline double SmoothMover::get_most_recent_timestamp(void) const
  double return_value = ((*(const SmoothMover*)local_this).get_most_recent_timestamp)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_get_most_recent_timestamp_18_comment =
  "C++ Interface:\n"
  "get_most_recent_timestamp(SmoothMover self)\n"
  "\n"
  "/**\n"
  " * Returns most recently recorded timestamp\n"
  " */";
#else
static const char *Dtool_SmoothMover_get_most_recent_timestamp_18_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void SmoothMover::mark_position(void)
 */
static PyObject *Dtool_SmoothMover_mark_position_19(PyObject *self, PyObject *) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.mark_position")) {
    return nullptr;
  }
  // 1-void SmoothMover::mark_position(void)
  ((*local_this).mark_position)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_mark_position_19_comment =
  "C++ Interface:\n"
  "mark_position(const SmoothMover self)\n"
  "\n"
  "/**\n"
  " * Stores the position, orientation, and timestamp (if relevant) indicated by\n"
  " * previous calls to set_pos(), set_hpr(), and set_timestamp() in a new\n"
  " * position report.\n"
  " *\n"
  " * When compute_smooth_position() is called, it uses these stored position\n"
  " * reports to base its computation of the known position.\n"
  " */";
#else
static const char *Dtool_SmoothMover_mark_position_19_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void SmoothMover::clear_positions(bool reset_velocity)
 */
static PyObject *Dtool_SmoothMover_clear_positions_20(PyObject *self, PyObject *arg) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.clear_positions")) {
    return nullptr;
  }
  // 1-void SmoothMover::clear_positions(bool reset_velocity)
  ((*local_this).clear_positions)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_positions(const SmoothMover self, bool reset_velocity)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_clear_positions_20_comment =
  "C++ Interface:\n"
  "clear_positions(const SmoothMover self, bool reset_velocity)\n"
  "\n"
  "/**\n"
  " * Erases all the old position reports.  This should be done, for instance,\n"
  " * prior to teleporting the avatar to a new position; otherwise, the smoother\n"
  " * might try to lerp the avatar there.  If reset_velocity is true, the\n"
  " * velocity is also reset to 0.\n"
  " */";
#else
static const char *Dtool_SmoothMover_clear_positions_20_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SmoothMover::compute_smooth_position(void)
 * bool SmoothMover::compute_smooth_position(double timestamp)
 */
static PyObject *Dtool_SmoothMover_compute_smooth_position_21(PyObject *self, PyObject *args) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.compute_smooth_position")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline bool SmoothMover::compute_smooth_position(void)
      bool return_value = ((*local_this).compute_smooth_position)();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-bool SmoothMover::compute_smooth_position(double timestamp)
      if (PyNumber_Check(arg)) {
        bool return_value = ((*local_this).compute_smooth_position)(PyFloat_AsDouble(arg));
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "compute_smooth_position() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compute_smooth_position(const SmoothMover self)\n"
      "compute_smooth_position(const SmoothMover self, double timestamp)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_compute_smooth_position_21_comment =
  "C++ Interface:\n"
  "compute_smooth_position(const SmoothMover self)\n"
  "compute_smooth_position(const SmoothMover self, double timestamp)\n"
  "\n"
  "/**\n"
  " * Computes the smoothed position (and orientation) of the mover at the\n"
  " * indicated point in time, based on the previous position reports.  After\n"
  " * this call has been made, get_smooth_pos() etc.  may be called to retrieve\n"
  " * the smoothed position.\n"
  " *\n"
  " * With no parameter, the function uses ClockObject::get_frame_time() as the\n"
  " * default time.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Computes the smoothed position (and orientation) of the mover at the\n"
  " * indicated point in time, based on the previous position reports.  After\n"
  " * this call has been made, get_smooth_pos() etc.  may be called to retrieve\n"
  " * the smoothed position.\n"
  " *\n"
  " * The return value is true if the value has changed (or might have changed)\n"
  " * since the last call to compute_smooth_position(), or false if it remains\n"
  " * the same.\n"
  " */";
#else
static const char *Dtool_SmoothMover_compute_smooth_position_21_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool SmoothMover::get_latest_position(void)
 */
static PyObject *Dtool_SmoothMover_get_latest_position_22(PyObject *self, PyObject *) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.get_latest_position")) {
    return nullptr;
  }
  // 1-bool SmoothMover::get_latest_position(void)
  bool return_value = ((*local_this).get_latest_position)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_get_latest_position_22_comment =
  "C++ Interface:\n"
  "get_latest_position(const SmoothMover self)\n"
  "\n"
  "/**\n"
  " * Updates the smooth_pos (and smooth_hpr, etc.) members to reflect the\n"
  " * absolute latest position known for this avatar.  This may result in a pop\n"
  " * to the most recent position.\n"
  " *\n"
  " * Returns true if the latest position is known, false otherwise.\n"
  " */";
#else
static const char *Dtool_SmoothMover_get_latest_position_22_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &SmoothMover::get_smooth_pos(void) const
 */
static PyObject *Dtool_SmoothMover_get_smooth_pos_23(PyObject *self, PyObject *) {
  SmoothMover *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SmoothMover)) {
    return nullptr;
  }
  // 1-inline LPoint3 const &SmoothMover::get_smooth_pos(void) const
  LPoint3 const *return_value = &(((*(const SmoothMover*)local_this).get_smooth_pos)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_get_smooth_pos_23_comment =
  "C++ Interface:\n"
  "get_smooth_pos(SmoothMover self)\n"
  "\n"
  "/**\n"
  " * Returns the smoothed position as computed by a previous call to\n"
  " * compute_smooth_position().\n"
  " */";
#else
static const char *Dtool_SmoothMover_get_smooth_pos_23_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3 const &SmoothMover::get_smooth_hpr(void) const
 */
static PyObject *Dtool_SmoothMover_get_smooth_hpr_24(PyObject *self, PyObject *) {
  SmoothMover *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SmoothMover)) {
    return nullptr;
  }
  // 1-inline LVecBase3 const &SmoothMover::get_smooth_hpr(void) const
  LVecBase3 const *return_value = &(((*(const SmoothMover*)local_this).get_smooth_hpr)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_get_smooth_hpr_24_comment =
  "C++ Interface:\n"
  "get_smooth_hpr(SmoothMover self)\n"
  "\n"
  "/**\n"
  " * Returns the smoothed orientation as computed by a previous call to\n"
  " * compute_smooth_position().\n"
  " */";
#else
static const char *Dtool_SmoothMover_get_smooth_hpr_24_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SmoothMover::apply_smooth_pos(NodePath &node) const
 */
static PyObject *Dtool_SmoothMover_apply_smooth_pos_25(PyObject *self, PyObject *arg) {
  SmoothMover *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SmoothMover)) {
    return nullptr;
  }
  // 1-inline void SmoothMover::apply_smooth_pos(NodePath &node) const
  NodePath *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "SmoothMover.apply_smooth_pos", false, true);
  if (arg_this != nullptr) {
    ((*(const SmoothMover*)local_this).apply_smooth_pos)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_smooth_pos(SmoothMover self, NodePath node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_apply_smooth_pos_25_comment =
  "C++ Interface:\n"
  "apply_smooth_pos(SmoothMover self, NodePath node)\n"
  "\n"
  "/**\n"
  " * Applies the smoothed position to the indicated NodePath.  This is\n"
  " * equivalent to calling node.set_pos(smooth_mover->get_smooth_pos()).  It\n"
  " * exists as an optimization only, to avoid the overhead of passing the return\n"
  " * value through Python.\n"
  " */";
#else
static const char *Dtool_SmoothMover_apply_smooth_pos_25_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SmoothMover::apply_smooth_pos_hpr(NodePath &pos_node, NodePath &hpr_node) const
 */
static PyObject *Dtool_SmoothMover_apply_smooth_pos_hpr_26(PyObject *self, PyObject *args, PyObject *kwds) {
  SmoothMover *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SmoothMover)) {
    return nullptr;
  }
  // 1-inline void SmoothMover::apply_smooth_pos_hpr(NodePath &pos_node, NodePath &hpr_node) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"pos_node", "hpr_node", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:apply_smooth_pos_hpr", (char **)keyword_list, &param1, &param2)) {
    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "SmoothMover.apply_smooth_pos_hpr", false, true);
    NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "SmoothMover.apply_smooth_pos_hpr", false, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      ((*(const SmoothMover*)local_this).apply_smooth_pos_hpr)(*param1_this, *param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_smooth_pos_hpr(SmoothMover self, NodePath pos_node, NodePath hpr_node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_apply_smooth_pos_hpr_26_comment =
  "C++ Interface:\n"
  "apply_smooth_pos_hpr(SmoothMover self, NodePath pos_node, NodePath hpr_node)\n"
  "\n"
  "/**\n"
  " * Applies the smoothed position and orientation to the indicated NodePath.\n"
  " * This is equivalent to calling\n"
  " * node.set_pos_hpr(smooth_mover->get_smooth_pos(),\n"
  " * smooth_mover->get_smooth_hpr()).  It exists as an optimization only, to\n"
  " * avoid the overhead of passing the return value through Python.\n"
  " */";
#else
static const char *Dtool_SmoothMover_apply_smooth_pos_hpr_26_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SmoothMover::apply_smooth_hpr(NodePath &node) const
 */
static PyObject *Dtool_SmoothMover_apply_smooth_hpr_27(PyObject *self, PyObject *arg) {
  SmoothMover *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SmoothMover)) {
    return nullptr;
  }
  // 1-inline void SmoothMover::apply_smooth_hpr(NodePath &node) const
  NodePath *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "SmoothMover.apply_smooth_hpr", false, true);
  if (arg_this != nullptr) {
    ((*(const SmoothMover*)local_this).apply_smooth_hpr)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_smooth_hpr(SmoothMover self, NodePath node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_apply_smooth_hpr_27_comment =
  "C++ Interface:\n"
  "apply_smooth_hpr(SmoothMover self, NodePath node)\n"
  "\n"
  "/**\n"
  " * Applies the smoothed orientation to the indicated NodePath.  This is\n"
  " * equivalent to calling node.set_hpr(smooth_mover->get_smooth_hpr()).  It\n"
  " * exists as an optimization only, to avoid the overhead of passing the return\n"
  " * value through Python.\n"
  " */";
#else
static const char *Dtool_SmoothMover_apply_smooth_hpr_27_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SmoothMover::compute_and_apply_smooth_pos(NodePath &node)
 */
static PyObject *Dtool_SmoothMover_compute_and_apply_smooth_pos_28(PyObject *self, PyObject *arg) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.compute_and_apply_smooth_pos")) {
    return nullptr;
  }
  // 1-inline void SmoothMover::compute_and_apply_smooth_pos(NodePath &node)
  NodePath *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "SmoothMover.compute_and_apply_smooth_pos", false, true);
  if (arg_this != nullptr) {
    ((*local_this).compute_and_apply_smooth_pos)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compute_and_apply_smooth_pos(const SmoothMover self, NodePath node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_compute_and_apply_smooth_pos_28_comment =
  "C++ Interface:\n"
  "compute_and_apply_smooth_pos(const SmoothMover self, NodePath node)\n"
  "\n"
  "/**\n"
  " * A further optimization to reduce Python calls.  This computes the smooth\n"
  " * position and applies it to the indicated node in one call.\n"
  " */";
#else
static const char *Dtool_SmoothMover_compute_and_apply_smooth_pos_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SmoothMover::compute_and_apply_smooth_pos_hpr(NodePath &pos_node, NodePath &hpr_node)
 */
static PyObject *Dtool_SmoothMover_compute_and_apply_smooth_pos_hpr_29(PyObject *self, PyObject *args, PyObject *kwds) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.compute_and_apply_smooth_pos_hpr")) {
    return nullptr;
  }
  // 1-inline void SmoothMover::compute_and_apply_smooth_pos_hpr(NodePath &pos_node, NodePath &hpr_node)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"pos_node", "hpr_node", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:compute_and_apply_smooth_pos_hpr", (char **)keyword_list, &param1, &param2)) {
    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "SmoothMover.compute_and_apply_smooth_pos_hpr", false, true);
    NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "SmoothMover.compute_and_apply_smooth_pos_hpr", false, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      ((*local_this).compute_and_apply_smooth_pos_hpr)(*param1_this, *param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compute_and_apply_smooth_pos_hpr(const SmoothMover self, NodePath pos_node, NodePath hpr_node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_compute_and_apply_smooth_pos_hpr_29_comment =
  "C++ Interface:\n"
  "compute_and_apply_smooth_pos_hpr(const SmoothMover self, NodePath pos_node, NodePath hpr_node)\n"
  "\n"
  "/**\n"
  " * A further optimization to reduce Python calls.  This computes the smooth\n"
  " * position and applies it to the indicated node or nodes in one call.  The\n"
  " * pos_node and hpr_node might be the same NodePath.\n"
  " */";
#else
static const char *Dtool_SmoothMover_compute_and_apply_smooth_pos_hpr_29_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SmoothMover::compute_and_apply_smooth_hpr(NodePath &hpr_node)
 */
static PyObject *Dtool_SmoothMover_compute_and_apply_smooth_hpr_30(PyObject *self, PyObject *arg) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.compute_and_apply_smooth_hpr")) {
    return nullptr;
  }
  // 1-inline void SmoothMover::compute_and_apply_smooth_hpr(NodePath &hpr_node)
  NodePath *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "SmoothMover.compute_and_apply_smooth_hpr", false, true);
  if (arg_this != nullptr) {
    ((*local_this).compute_and_apply_smooth_hpr)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compute_and_apply_smooth_hpr(const SmoothMover self, NodePath hpr_node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_compute_and_apply_smooth_hpr_30_comment =
  "C++ Interface:\n"
  "compute_and_apply_smooth_hpr(const SmoothMover self, NodePath hpr_node)\n"
  "\n"
  "/**\n"
  " * A further optimization to reduce Python calls.  This computes the smooth\n"
  " * position and applies it to the indicated node or nodes in one call.  The\n"
  " * pos_node and hpr_node might be the same NodePath.\n"
  " */";
#else
static const char *Dtool_SmoothMover_compute_and_apply_smooth_hpr_30_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat SmoothMover::get_smooth_forward_velocity(void) const
 */
static PyObject *Dtool_SmoothMover_get_smooth_forward_velocity_31(PyObject *self, PyObject *) {
  SmoothMover *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SmoothMover)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat SmoothMover::get_smooth_forward_velocity(void) const
  PN_stdfloat return_value = ((*(const SmoothMover*)local_this).get_smooth_forward_velocity)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_get_smooth_forward_velocity_31_comment =
  "C++ Interface:\n"
  "get_smooth_forward_velocity(SmoothMover self)\n"
  "\n"
  "/**\n"
  " * Returns the speed at which the avatar is moving, in feet per second, along\n"
  " * its own forward axis (after applying the avatar's hpr).  This will be a\n"
  " * positive number if the avatar is moving forward, and a negative number if\n"
  " * it is moving backward.\n"
  " */";
#else
static const char *Dtool_SmoothMover_get_smooth_forward_velocity_31_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat SmoothMover::get_smooth_lateral_velocity(void) const
 */
static PyObject *Dtool_SmoothMover_get_smooth_lateral_velocity_32(PyObject *self, PyObject *) {
  SmoothMover *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SmoothMover)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat SmoothMover::get_smooth_lateral_velocity(void) const
  PN_stdfloat return_value = ((*(const SmoothMover*)local_this).get_smooth_lateral_velocity)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_get_smooth_lateral_velocity_32_comment =
  "C++ Interface:\n"
  "get_smooth_lateral_velocity(SmoothMover self)\n"
  "\n"
  "/**\n"
  " * Returns the speed at which the avatar is moving, in feet per second, along\n"
  " * its own lateral axis (after applying the avatar's hpr).  This will be a\n"
  " * positive number if the avatar is moving right, and a negative number if it\n"
  " * is moving left.\n"
  " */";
#else
static const char *Dtool_SmoothMover_get_smooth_lateral_velocity_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat SmoothMover::get_smooth_rotational_velocity(void) const
 */
static PyObject *Dtool_SmoothMover_get_smooth_rotational_velocity_33(PyObject *self, PyObject *) {
  SmoothMover *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SmoothMover)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat SmoothMover::get_smooth_rotational_velocity(void) const
  PN_stdfloat return_value = ((*(const SmoothMover*)local_this).get_smooth_rotational_velocity)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_get_smooth_rotational_velocity_33_comment =
  "C++ Interface:\n"
  "get_smooth_rotational_velocity(SmoothMover self)\n"
  "\n"
  "/**\n"
  " * Returns the speed at which the avatar is rotating in the horizontal plane\n"
  " * (i.e.  heading), in degrees per second.  This may be positive or negative,\n"
  " * according to the direction of rotation.\n"
  " */";
#else
static const char *Dtool_SmoothMover_get_smooth_rotational_velocity_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3 const &SmoothMover::get_forward_axis(void) const
 */
static PyObject *Dtool_SmoothMover_get_forward_axis_34(PyObject *self, PyObject *) {
  SmoothMover *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SmoothMover)) {
    return nullptr;
  }
  // 1-inline LVecBase3 const &SmoothMover::get_forward_axis(void) const
  LVecBase3 const *return_value = &(((*(const SmoothMover*)local_this).get_forward_axis)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_get_forward_axis_34_comment =
  "C++ Interface:\n"
  "get_forward_axis(SmoothMover self)\n"
  "\n"
  "/**\n"
  " * Returns the smoothed position as computed by a previous call to\n"
  " * compute_smooth_position().\n"
  " */";
#else
static const char *Dtool_SmoothMover_get_forward_axis_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void SmoothMover::handle_wrt_reparent(NodePath &old_parent, NodePath &new_parent)
 */
static PyObject *Dtool_SmoothMover_handle_wrt_reparent_35(PyObject *self, PyObject *args, PyObject *kwds) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.handle_wrt_reparent")) {
    return nullptr;
  }
  // 1-void SmoothMover::handle_wrt_reparent(NodePath &old_parent, NodePath &new_parent)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"old_parent", "new_parent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:handle_wrt_reparent", (char **)keyword_list, &param1, &param2)) {
    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "SmoothMover.handle_wrt_reparent", false, true);
    NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "SmoothMover.handle_wrt_reparent", false, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      ((*local_this).handle_wrt_reparent)(*param1_this, *param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "handle_wrt_reparent(const SmoothMover self, NodePath old_parent, NodePath new_parent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_handle_wrt_reparent_35_comment =
  "C++ Interface:\n"
  "handle_wrt_reparent(const SmoothMover self, NodePath old_parent, NodePath new_parent)\n"
  "\n"
  "/**\n"
  " * Node is being wrtReparented, update recorded sample positions to reflect\n"
  " * new parent\n"
  " */";
#else
static const char *Dtool_SmoothMover_handle_wrt_reparent_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SmoothMover::set_smooth_mode(SmoothMover::SmoothMode mode)
 */
static PyObject *Dtool_SmoothMover_set_smooth_mode_38(PyObject *self, PyObject *arg) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.set_smooth_mode")) {
    return nullptr;
  }
  // 1-inline void SmoothMover::set_smooth_mode(SmoothMover::SmoothMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_smooth_mode)((SmoothMover::SmoothMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_smooth_mode(const SmoothMover self, int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_set_smooth_mode_38_comment =
  "C++ Interface:\n"
  "set_smooth_mode(const SmoothMover self, int mode)\n"
  "\n"
  "/**\n"
  " * Sets the smoothing mode of all SmoothMovers in the world.  If this is\n"
  " * SM_off, no smoothing or prediction will be performed, and get_smooth_pos()\n"
  " * will simply return the position last set by mark_position().\n"
  " */";
#else
static const char *Dtool_SmoothMover_set_smooth_mode_38_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SmoothMover::SmoothMode SmoothMover::get_smooth_mode(void)
 */
static PyObject *Dtool_SmoothMover_get_smooth_mode_39(PyObject *self, PyObject *) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.get_smooth_mode")) {
    return nullptr;
  }
  // 1-inline SmoothMover::SmoothMode SmoothMover::get_smooth_mode(void)
  SmoothMover::SmoothMode return_value = ((*local_this).get_smooth_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_get_smooth_mode_39_comment =
  "C++ Interface:\n"
  "get_smooth_mode(const SmoothMover self)\n"
  "\n"
  "/**\n"
  " * Returns the smoothing mode of all SmoothMovers in the world.  See\n"
  " * set_smooth_mode().\n"
  " */";
#else
static const char *Dtool_SmoothMover_get_smooth_mode_39_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SmoothMover::set_prediction_mode(SmoothMover::PredictionMode mode)
 */
static PyObject *Dtool_SmoothMover_set_prediction_mode_40(PyObject *self, PyObject *arg) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.set_prediction_mode")) {
    return nullptr;
  }
  // 1-inline void SmoothMover::set_prediction_mode(SmoothMover::PredictionMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_prediction_mode)((SmoothMover::PredictionMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_prediction_mode(const SmoothMover self, int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_set_prediction_mode_40_comment =
  "C++ Interface:\n"
  "set_prediction_mode(const SmoothMover self, int mode)\n"
  "\n"
  "/**\n"
  " * Sets the predictioning mode of all SmoothMovers in the world.  If this is\n"
  " * PM_off, no prediction will be performed, but smoothing might still be\n"
  " * performed.\n"
  " */";
#else
static const char *Dtool_SmoothMover_set_prediction_mode_40_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SmoothMover::PredictionMode SmoothMover::get_prediction_mode(void)
 */
static PyObject *Dtool_SmoothMover_get_prediction_mode_41(PyObject *self, PyObject *) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.get_prediction_mode")) {
    return nullptr;
  }
  // 1-inline SmoothMover::PredictionMode SmoothMover::get_prediction_mode(void)
  SmoothMover::PredictionMode return_value = ((*local_this).get_prediction_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_get_prediction_mode_41_comment =
  "C++ Interface:\n"
  "get_prediction_mode(const SmoothMover self)\n"
  "\n"
  "/**\n"
  " * Returns the predictioning mode of all SmoothMovers in the world.  See\n"
  " * set_prediction_mode().\n"
  " */";
#else
static const char *Dtool_SmoothMover_get_prediction_mode_41_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SmoothMover::set_delay(double delay)
 */
static PyObject *Dtool_SmoothMover_set_delay_42(PyObject *self, PyObject *arg) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.set_delay")) {
    return nullptr;
  }
  // 1-inline void SmoothMover::set_delay(double delay)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_delay)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_delay(const SmoothMover self, double delay)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_set_delay_42_comment =
  "C++ Interface:\n"
  "set_delay(const SmoothMover self, double delay)\n"
  "\n"
  "/**\n"
  " * Sets the amount of time, in seconds, to delay the computed position of a\n"
  " * SmoothMover.  This is particularly useful when the prediction mode is off,\n"
  " * because it can allow the apparent motion of an avatar to appear smooth\n"
  " * without relying on prediction, at the cost of introducing additional lag in\n"
  " * the avatar's apparent position.\n"
  " */";
#else
static const char *Dtool_SmoothMover_set_delay_42_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double SmoothMover::get_delay(void)
 */
static PyObject *Dtool_SmoothMover_get_delay_43(PyObject *self, PyObject *) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.get_delay")) {
    return nullptr;
  }
  // 1-inline double SmoothMover::get_delay(void)
  double return_value = ((*local_this).get_delay)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_get_delay_43_comment =
  "C++ Interface:\n"
  "get_delay(const SmoothMover self)\n"
  "\n"
  "/**\n"
  " * Returns the amount of time, in seconds, to delay the computed position of a\n"
  " * SmoothMover.  See set_delay().\n"
  " */";
#else
static const char *Dtool_SmoothMover_get_delay_43_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SmoothMover::set_accept_clock_skew(bool flag)
 */
static PyObject *Dtool_SmoothMover_set_accept_clock_skew_44(PyObject *self, PyObject *arg) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.set_accept_clock_skew")) {
    return nullptr;
  }
  // 1-inline void SmoothMover::set_accept_clock_skew(bool flag)
  ((*local_this).set_accept_clock_skew)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_accept_clock_skew(const SmoothMover self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_set_accept_clock_skew_44_comment =
  "C++ Interface:\n"
  "set_accept_clock_skew(const SmoothMover self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets the 'accept clock skew' flag.  When this flag is true, clock skew from\n"
  " * the other clients will be tolerated by delaying each smooth mover's\n"
  " * position an additional amount, on top of that specified by set_delay(),\n"
  " * based on the measured average latency for timestamp messages received by\n"
  " * the client.\n"
  " *\n"
  " * In this way, if the other client has significant clock skew with respect to\n"
  " * our clock, it will be evident as a large positive or negative average\n"
  " * latency for timestamps.  By subtracting out this average latency, we\n"
  " * compensate for poor clock sync.\n"
  " */";
#else
static const char *Dtool_SmoothMover_set_accept_clock_skew_44_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SmoothMover::get_accept_clock_skew(void)
 */
static PyObject *Dtool_SmoothMover_get_accept_clock_skew_45(PyObject *self, PyObject *) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.get_accept_clock_skew")) {
    return nullptr;
  }
  // 1-inline bool SmoothMover::get_accept_clock_skew(void)
  bool return_value = ((*local_this).get_accept_clock_skew)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_get_accept_clock_skew_45_comment =
  "C++ Interface:\n"
  "get_accept_clock_skew(const SmoothMover self)\n"
  "\n"
  "/**\n"
  " * Returns the current state of the 'accept clock skew' flag.  See\n"
  " * set_accept_clock_skew().\n"
  " */";
#else
static const char *Dtool_SmoothMover_get_accept_clock_skew_45_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SmoothMover::set_max_position_age(double age)
 */
static PyObject *Dtool_SmoothMover_set_max_position_age_46(PyObject *self, PyObject *arg) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.set_max_position_age")) {
    return nullptr;
  }
  // 1-inline void SmoothMover::set_max_position_age(double age)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_max_position_age)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_position_age(const SmoothMover self, double age)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_set_max_position_age_46_comment =
  "C++ Interface:\n"
  "set_max_position_age(const SmoothMover self, double age)\n"
  "\n"
  "/**\n"
  " * Sets the maximum amount of time a position is allowed to remain unchanged\n"
  " * before assuming it represents the avatar actually standing still.\n"
  " */";
#else
static const char *Dtool_SmoothMover_set_max_position_age_46_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double SmoothMover::get_max_position_age(void)
 */
static PyObject *Dtool_SmoothMover_get_max_position_age_47(PyObject *self, PyObject *) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.get_max_position_age")) {
    return nullptr;
  }
  // 1-inline double SmoothMover::get_max_position_age(void)
  double return_value = ((*local_this).get_max_position_age)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_get_max_position_age_47_comment =
  "C++ Interface:\n"
  "get_max_position_age(const SmoothMover self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum amount of time a position is allowed to remain\n"
  " * unchanged before assuming it represents the avatar actually standing still.\n"
  " */";
#else
static const char *Dtool_SmoothMover_get_max_position_age_47_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SmoothMover::set_expected_broadcast_period(double period)
 */
static PyObject *Dtool_SmoothMover_set_expected_broadcast_period_48(PyObject *self, PyObject *arg) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.set_expected_broadcast_period")) {
    return nullptr;
  }
  // 1-inline void SmoothMover::set_expected_broadcast_period(double period)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_expected_broadcast_period)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_expected_broadcast_period(const SmoothMover self, double period)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_set_expected_broadcast_period_48_comment =
  "C++ Interface:\n"
  "set_expected_broadcast_period(const SmoothMover self, double period)\n"
  "\n"
  "/**\n"
  " * Sets the interval at which we expect the SmoothNodes to broadcast their\n"
  " * position, in elapsed seconds.  This controls the length of time we assume\n"
  " * the object has truly stopped, when we receive a long sequence of no\n"
  " * updates.\n"
  " */";
#else
static const char *Dtool_SmoothMover_set_expected_broadcast_period_48_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double SmoothMover::get_expected_broadcast_period(void)
 */
static PyObject *Dtool_SmoothMover_get_expected_broadcast_period_49(PyObject *self, PyObject *) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.get_expected_broadcast_period")) {
    return nullptr;
  }
  // 1-inline double SmoothMover::get_expected_broadcast_period(void)
  double return_value = ((*local_this).get_expected_broadcast_period)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_get_expected_broadcast_period_49_comment =
  "C++ Interface:\n"
  "get_expected_broadcast_period(const SmoothMover self)\n"
  "\n"
  "/**\n"
  " * Returns the interval at which we expect the SmoothNodes to broadcast their\n"
  " * position, in elapsed seconds.  See set_expected_broadcast_period().\n"
  " */";
#else
static const char *Dtool_SmoothMover_get_expected_broadcast_period_49_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SmoothMover::set_reset_velocity_age(double age)
 */
static PyObject *Dtool_SmoothMover_set_reset_velocity_age_50(PyObject *self, PyObject *arg) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.set_reset_velocity_age")) {
    return nullptr;
  }
  // 1-inline void SmoothMover::set_reset_velocity_age(double age)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_reset_velocity_age)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_reset_velocity_age(const SmoothMover self, double age)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_set_reset_velocity_age_50_comment =
  "C++ Interface:\n"
  "set_reset_velocity_age(const SmoothMover self, double age)\n"
  "\n"
  "/**\n"
  " * Sets the amount of time that should elapse after the last position report\n"
  " * before the velocity is reset to 0.  This is similar to max_position_age,\n"
  " * but it is only used to determine the resetting of the reported velocity.\n"
  " * It should always be greater than or equal to max_position_age.\n"
  " */";
#else
static const char *Dtool_SmoothMover_set_reset_velocity_age_50_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double SmoothMover::get_reset_velocity_age(void)
 */
static PyObject *Dtool_SmoothMover_get_reset_velocity_age_51(PyObject *self, PyObject *) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.get_reset_velocity_age")) {
    return nullptr;
  }
  // 1-inline double SmoothMover::get_reset_velocity_age(void)
  double return_value = ((*local_this).get_reset_velocity_age)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_get_reset_velocity_age_51_comment =
  "C++ Interface:\n"
  "get_reset_velocity_age(const SmoothMover self)\n"
  "\n"
  "/**\n"
  " * Returns the amount of time that should elapse after the last position\n"
  " * report before the velocity is reset to 0.  See set_reset_velocity_age().\n"
  " */";
#else
static const char *Dtool_SmoothMover_get_reset_velocity_age_51_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SmoothMover::set_directional_velocity(bool flag)
 */
static PyObject *Dtool_SmoothMover_set_directional_velocity_52(PyObject *self, PyObject *arg) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.set_directional_velocity")) {
    return nullptr;
  }
  // 1-inline void SmoothMover::set_directional_velocity(bool flag)
  ((*local_this).set_directional_velocity)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_directional_velocity(const SmoothMover self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_set_directional_velocity_52_comment =
  "C++ Interface:\n"
  "set_directional_velocity(const SmoothMover self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets the flag that indicates whether the avatar's direction is considered\n"
  " * in computing the velocity.  When this is true, velocity is automatically\n"
  " * decomposed into a forward and a lateral velocity (and both may be positive\n"
  " * or negative); when it is false, all velocity is always returned as forward\n"
  " * velocity (and it is always positive).\n"
  " */";
#else
static const char *Dtool_SmoothMover_set_directional_velocity_52_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SmoothMover::get_directional_velocity(void)
 */
static PyObject *Dtool_SmoothMover_get_directional_velocity_53(PyObject *self, PyObject *) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.get_directional_velocity")) {
    return nullptr;
  }
  // 1-inline bool SmoothMover::get_directional_velocity(void)
  bool return_value = ((*local_this).get_directional_velocity)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_get_directional_velocity_53_comment =
  "C++ Interface:\n"
  "get_directional_velocity(const SmoothMover self)\n"
  "\n"
  "/**\n"
  " * Returns the current state of the 'directional velocity' flag.  See\n"
  " * set_directional_velocity().\n"
  " */";
#else
static const char *Dtool_SmoothMover_get_directional_velocity_53_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SmoothMover::set_default_to_standing_still(bool flag)
 */
static PyObject *Dtool_SmoothMover_set_default_to_standing_still_54(PyObject *self, PyObject *arg) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.set_default_to_standing_still")) {
    return nullptr;
  }
  // 1-inline void SmoothMover::set_default_to_standing_still(bool flag)
  ((*local_this).set_default_to_standing_still)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_default_to_standing_still(const SmoothMover self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_set_default_to_standing_still_54_comment =
  "C++ Interface:\n"
  "set_default_to_standing_still(const SmoothMover self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets the flag that indicates whether to assume that the node stopped moving\n"
  " * during periods when we don't get enough position updates.  If true, the\n"
  " * object will stand still momentarily.  If false, the object will\n"
  " * continuously lerp between the position updates that we did get.\n"
  " */";
#else
static const char *Dtool_SmoothMover_set_default_to_standing_still_54_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SmoothMover::get_default_to_standing_still(void)
 */
static PyObject *Dtool_SmoothMover_get_default_to_standing_still_55(PyObject *self, PyObject *) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SmoothMover, (void **)&local_this, "SmoothMover.get_default_to_standing_still")) {
    return nullptr;
  }
  // 1-inline bool SmoothMover::get_default_to_standing_still(void)
  bool return_value = ((*local_this).get_default_to_standing_still)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_get_default_to_standing_still_55_comment =
  "C++ Interface:\n"
  "get_default_to_standing_still(const SmoothMover self)\n"
  "\n"
  "/**\n"
  " * Returns the current state of the 'default to standing still' flag.  See\n"
  " * set_default_to_standing_still().\n"
  " */";
#else
static const char *Dtool_SmoothMover_get_default_to_standing_still_55_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void SmoothMover::output(std::ostream &out) const
 */
static PyObject *Dtool_SmoothMover_output_56(PyObject *self, PyObject *arg) {
  SmoothMover *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SmoothMover)) {
    return nullptr;
  }
  // 1-void SmoothMover::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "SmoothMover.output", false, true);
  if (arg_this != nullptr) {
    ((*(const SmoothMover*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(SmoothMover self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_output_56_comment =
  "C++ Interface:\n"
  "output(SmoothMover self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SmoothMover_output_56_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void SmoothMover::write(std::ostream &out) const
 */
static PyObject *Dtool_SmoothMover_write_57(PyObject *self, PyObject *arg) {
  SmoothMover *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SmoothMover)) {
    return nullptr;
  }
  // 1-void SmoothMover::write(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "SmoothMover.write", false, true);
  if (arg_this != nullptr) {
    ((*(const SmoothMover*)local_this).write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(SmoothMover self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SmoothMover_write_57_comment =
  "C++ Interface:\n"
  "write(SmoothMover self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SmoothMover_write_57_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * SmoothMover::SmoothMover(void)
 * inline SmoothMover::SmoothMover(SmoothMover const &) = default
 */
static int Dtool_Init_SmoothMover(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("SmoothMover() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-SmoothMover::SmoothMover(void)
      SmoothMover *return_value = new SmoothMover();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SmoothMover, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline SmoothMover::SmoothMover(SmoothMover const &) = default
      SmoothMover const *arg_this = (SmoothMover *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_SmoothMover, 0, "SmoothMover.SmoothMover", true, true);
      if (arg_this != nullptr) {
        SmoothMover *return_value = new SmoothMover(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SmoothMover, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "SmoothMover() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SmoothMover()\n"
      "SmoothMover(const SmoothMover param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_SmoothMover(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_SmoothMover) {
    printf("SmoothMover ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  SmoothMover *local_this = (SmoothMover *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_SmoothMover) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_SmoothMover(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_SmoothMover) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python method tables for SmoothMover (SmoothMover)
 */
static PyMethodDef Dtool_Methods_SmoothMover[] = {
  {"set_pos", (PyCFunction) &Dtool_SmoothMover_set_pos_4, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SmoothMover_set_pos_4_comment},
  {"setPos", (PyCFunction) &Dtool_SmoothMover_set_pos_4, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SmoothMover_set_pos_4_comment},
  {"set_x", &Dtool_SmoothMover_set_x_5, METH_O, (const char *)Dtool_SmoothMover_set_x_5_comment},
  {"setX", &Dtool_SmoothMover_set_x_5, METH_O, (const char *)Dtool_SmoothMover_set_x_5_comment},
  {"set_y", &Dtool_SmoothMover_set_y_6, METH_O, (const char *)Dtool_SmoothMover_set_y_6_comment},
  {"setY", &Dtool_SmoothMover_set_y_6, METH_O, (const char *)Dtool_SmoothMover_set_y_6_comment},
  {"set_z", &Dtool_SmoothMover_set_z_7, METH_O, (const char *)Dtool_SmoothMover_set_z_7_comment},
  {"setZ", &Dtool_SmoothMover_set_z_7, METH_O, (const char *)Dtool_SmoothMover_set_z_7_comment},
  {"set_hpr", (PyCFunction) &Dtool_SmoothMover_set_hpr_8, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SmoothMover_set_hpr_8_comment},
  {"setHpr", (PyCFunction) &Dtool_SmoothMover_set_hpr_8, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SmoothMover_set_hpr_8_comment},
  {"set_h", &Dtool_SmoothMover_set_h_9, METH_O, (const char *)Dtool_SmoothMover_set_h_9_comment},
  {"setH", &Dtool_SmoothMover_set_h_9, METH_O, (const char *)Dtool_SmoothMover_set_h_9_comment},
  {"set_p", &Dtool_SmoothMover_set_p_10, METH_O, (const char *)Dtool_SmoothMover_set_p_10_comment},
  {"setP", &Dtool_SmoothMover_set_p_10, METH_O, (const char *)Dtool_SmoothMover_set_p_10_comment},
  {"set_r", &Dtool_SmoothMover_set_r_11, METH_O, (const char *)Dtool_SmoothMover_set_r_11_comment},
  {"setR", &Dtool_SmoothMover_set_r_11, METH_O, (const char *)Dtool_SmoothMover_set_r_11_comment},
  {"set_pos_hpr", (PyCFunction) &Dtool_SmoothMover_set_pos_hpr_12, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SmoothMover_set_pos_hpr_12_comment},
  {"setPosHpr", (PyCFunction) &Dtool_SmoothMover_set_pos_hpr_12, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SmoothMover_set_pos_hpr_12_comment},
  {"get_sample_pos", &Dtool_SmoothMover_get_sample_pos_13, METH_NOARGS, (const char *)Dtool_SmoothMover_get_sample_pos_13_comment},
  {"getSamplePos", &Dtool_SmoothMover_get_sample_pos_13, METH_NOARGS, (const char *)Dtool_SmoothMover_get_sample_pos_13_comment},
  {"get_sample_hpr", &Dtool_SmoothMover_get_sample_hpr_14, METH_NOARGS, (const char *)Dtool_SmoothMover_get_sample_hpr_14_comment},
  {"getSampleHpr", &Dtool_SmoothMover_get_sample_hpr_14, METH_NOARGS, (const char *)Dtool_SmoothMover_get_sample_hpr_14_comment},
  {"set_phony_timestamp", (PyCFunction) &Dtool_SmoothMover_set_phony_timestamp_15, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SmoothMover_set_phony_timestamp_15_comment},
  {"setPhonyTimestamp", (PyCFunction) &Dtool_SmoothMover_set_phony_timestamp_15, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SmoothMover_set_phony_timestamp_15_comment},
  {"set_timestamp", &Dtool_SmoothMover_set_timestamp_16, METH_O, (const char *)Dtool_SmoothMover_set_timestamp_16_comment},
  {"setTimestamp", &Dtool_SmoothMover_set_timestamp_16, METH_O, (const char *)Dtool_SmoothMover_set_timestamp_16_comment},
  {"has_most_recent_timestamp", &Dtool_SmoothMover_has_most_recent_timestamp_17, METH_NOARGS, (const char *)Dtool_SmoothMover_has_most_recent_timestamp_17_comment},
  {"hasMostRecentTimestamp", &Dtool_SmoothMover_has_most_recent_timestamp_17, METH_NOARGS, (const char *)Dtool_SmoothMover_has_most_recent_timestamp_17_comment},
  {"get_most_recent_timestamp", &Dtool_SmoothMover_get_most_recent_timestamp_18, METH_NOARGS, (const char *)Dtool_SmoothMover_get_most_recent_timestamp_18_comment},
  {"getMostRecentTimestamp", &Dtool_SmoothMover_get_most_recent_timestamp_18, METH_NOARGS, (const char *)Dtool_SmoothMover_get_most_recent_timestamp_18_comment},
  {"mark_position", &Dtool_SmoothMover_mark_position_19, METH_NOARGS, (const char *)Dtool_SmoothMover_mark_position_19_comment},
  {"markPosition", &Dtool_SmoothMover_mark_position_19, METH_NOARGS, (const char *)Dtool_SmoothMover_mark_position_19_comment},
  {"clear_positions", &Dtool_SmoothMover_clear_positions_20, METH_O, (const char *)Dtool_SmoothMover_clear_positions_20_comment},
  {"clearPositions", &Dtool_SmoothMover_clear_positions_20, METH_O, (const char *)Dtool_SmoothMover_clear_positions_20_comment},
  {"compute_smooth_position", &Dtool_SmoothMover_compute_smooth_position_21, METH_VARARGS, (const char *)Dtool_SmoothMover_compute_smooth_position_21_comment},
  {"computeSmoothPosition", &Dtool_SmoothMover_compute_smooth_position_21, METH_VARARGS, (const char *)Dtool_SmoothMover_compute_smooth_position_21_comment},
  {"get_latest_position", &Dtool_SmoothMover_get_latest_position_22, METH_NOARGS, (const char *)Dtool_SmoothMover_get_latest_position_22_comment},
  {"getLatestPosition", &Dtool_SmoothMover_get_latest_position_22, METH_NOARGS, (const char *)Dtool_SmoothMover_get_latest_position_22_comment},
  {"get_smooth_pos", &Dtool_SmoothMover_get_smooth_pos_23, METH_NOARGS, (const char *)Dtool_SmoothMover_get_smooth_pos_23_comment},
  {"getSmoothPos", &Dtool_SmoothMover_get_smooth_pos_23, METH_NOARGS, (const char *)Dtool_SmoothMover_get_smooth_pos_23_comment},
  {"get_smooth_hpr", &Dtool_SmoothMover_get_smooth_hpr_24, METH_NOARGS, (const char *)Dtool_SmoothMover_get_smooth_hpr_24_comment},
  {"getSmoothHpr", &Dtool_SmoothMover_get_smooth_hpr_24, METH_NOARGS, (const char *)Dtool_SmoothMover_get_smooth_hpr_24_comment},
  {"apply_smooth_pos", &Dtool_SmoothMover_apply_smooth_pos_25, METH_O, (const char *)Dtool_SmoothMover_apply_smooth_pos_25_comment},
  {"applySmoothPos", &Dtool_SmoothMover_apply_smooth_pos_25, METH_O, (const char *)Dtool_SmoothMover_apply_smooth_pos_25_comment},
  {"apply_smooth_pos_hpr", (PyCFunction) &Dtool_SmoothMover_apply_smooth_pos_hpr_26, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SmoothMover_apply_smooth_pos_hpr_26_comment},
  {"applySmoothPosHpr", (PyCFunction) &Dtool_SmoothMover_apply_smooth_pos_hpr_26, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SmoothMover_apply_smooth_pos_hpr_26_comment},
  {"apply_smooth_hpr", &Dtool_SmoothMover_apply_smooth_hpr_27, METH_O, (const char *)Dtool_SmoothMover_apply_smooth_hpr_27_comment},
  {"applySmoothHpr", &Dtool_SmoothMover_apply_smooth_hpr_27, METH_O, (const char *)Dtool_SmoothMover_apply_smooth_hpr_27_comment},
  {"compute_and_apply_smooth_pos", &Dtool_SmoothMover_compute_and_apply_smooth_pos_28, METH_O, (const char *)Dtool_SmoothMover_compute_and_apply_smooth_pos_28_comment},
  {"computeAndApplySmoothPos", &Dtool_SmoothMover_compute_and_apply_smooth_pos_28, METH_O, (const char *)Dtool_SmoothMover_compute_and_apply_smooth_pos_28_comment},
  {"compute_and_apply_smooth_pos_hpr", (PyCFunction) &Dtool_SmoothMover_compute_and_apply_smooth_pos_hpr_29, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SmoothMover_compute_and_apply_smooth_pos_hpr_29_comment},
  {"computeAndApplySmoothPosHpr", (PyCFunction) &Dtool_SmoothMover_compute_and_apply_smooth_pos_hpr_29, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SmoothMover_compute_and_apply_smooth_pos_hpr_29_comment},
  {"compute_and_apply_smooth_hpr", &Dtool_SmoothMover_compute_and_apply_smooth_hpr_30, METH_O, (const char *)Dtool_SmoothMover_compute_and_apply_smooth_hpr_30_comment},
  {"computeAndApplySmoothHpr", &Dtool_SmoothMover_compute_and_apply_smooth_hpr_30, METH_O, (const char *)Dtool_SmoothMover_compute_and_apply_smooth_hpr_30_comment},
  {"get_smooth_forward_velocity", &Dtool_SmoothMover_get_smooth_forward_velocity_31, METH_NOARGS, (const char *)Dtool_SmoothMover_get_smooth_forward_velocity_31_comment},
  {"getSmoothForwardVelocity", &Dtool_SmoothMover_get_smooth_forward_velocity_31, METH_NOARGS, (const char *)Dtool_SmoothMover_get_smooth_forward_velocity_31_comment},
  {"get_smooth_lateral_velocity", &Dtool_SmoothMover_get_smooth_lateral_velocity_32, METH_NOARGS, (const char *)Dtool_SmoothMover_get_smooth_lateral_velocity_32_comment},
  {"getSmoothLateralVelocity", &Dtool_SmoothMover_get_smooth_lateral_velocity_32, METH_NOARGS, (const char *)Dtool_SmoothMover_get_smooth_lateral_velocity_32_comment},
  {"get_smooth_rotational_velocity", &Dtool_SmoothMover_get_smooth_rotational_velocity_33, METH_NOARGS, (const char *)Dtool_SmoothMover_get_smooth_rotational_velocity_33_comment},
  {"getSmoothRotationalVelocity", &Dtool_SmoothMover_get_smooth_rotational_velocity_33, METH_NOARGS, (const char *)Dtool_SmoothMover_get_smooth_rotational_velocity_33_comment},
  {"get_forward_axis", &Dtool_SmoothMover_get_forward_axis_34, METH_NOARGS, (const char *)Dtool_SmoothMover_get_forward_axis_34_comment},
  {"getForwardAxis", &Dtool_SmoothMover_get_forward_axis_34, METH_NOARGS, (const char *)Dtool_SmoothMover_get_forward_axis_34_comment},
  {"handle_wrt_reparent", (PyCFunction) &Dtool_SmoothMover_handle_wrt_reparent_35, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SmoothMover_handle_wrt_reparent_35_comment},
  {"handleWrtReparent", (PyCFunction) &Dtool_SmoothMover_handle_wrt_reparent_35, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SmoothMover_handle_wrt_reparent_35_comment},
  {"set_smooth_mode", &Dtool_SmoothMover_set_smooth_mode_38, METH_O, (const char *)Dtool_SmoothMover_set_smooth_mode_38_comment},
  {"setSmoothMode", &Dtool_SmoothMover_set_smooth_mode_38, METH_O, (const char *)Dtool_SmoothMover_set_smooth_mode_38_comment},
  {"get_smooth_mode", &Dtool_SmoothMover_get_smooth_mode_39, METH_NOARGS, (const char *)Dtool_SmoothMover_get_smooth_mode_39_comment},
  {"getSmoothMode", &Dtool_SmoothMover_get_smooth_mode_39, METH_NOARGS, (const char *)Dtool_SmoothMover_get_smooth_mode_39_comment},
  {"set_prediction_mode", &Dtool_SmoothMover_set_prediction_mode_40, METH_O, (const char *)Dtool_SmoothMover_set_prediction_mode_40_comment},
  {"setPredictionMode", &Dtool_SmoothMover_set_prediction_mode_40, METH_O, (const char *)Dtool_SmoothMover_set_prediction_mode_40_comment},
  {"get_prediction_mode", &Dtool_SmoothMover_get_prediction_mode_41, METH_NOARGS, (const char *)Dtool_SmoothMover_get_prediction_mode_41_comment},
  {"getPredictionMode", &Dtool_SmoothMover_get_prediction_mode_41, METH_NOARGS, (const char *)Dtool_SmoothMover_get_prediction_mode_41_comment},
  {"set_delay", &Dtool_SmoothMover_set_delay_42, METH_O, (const char *)Dtool_SmoothMover_set_delay_42_comment},
  {"setDelay", &Dtool_SmoothMover_set_delay_42, METH_O, (const char *)Dtool_SmoothMover_set_delay_42_comment},
  {"get_delay", &Dtool_SmoothMover_get_delay_43, METH_NOARGS, (const char *)Dtool_SmoothMover_get_delay_43_comment},
  {"getDelay", &Dtool_SmoothMover_get_delay_43, METH_NOARGS, (const char *)Dtool_SmoothMover_get_delay_43_comment},
  {"set_accept_clock_skew", &Dtool_SmoothMover_set_accept_clock_skew_44, METH_O, (const char *)Dtool_SmoothMover_set_accept_clock_skew_44_comment},
  {"setAcceptClockSkew", &Dtool_SmoothMover_set_accept_clock_skew_44, METH_O, (const char *)Dtool_SmoothMover_set_accept_clock_skew_44_comment},
  {"get_accept_clock_skew", &Dtool_SmoothMover_get_accept_clock_skew_45, METH_NOARGS, (const char *)Dtool_SmoothMover_get_accept_clock_skew_45_comment},
  {"getAcceptClockSkew", &Dtool_SmoothMover_get_accept_clock_skew_45, METH_NOARGS, (const char *)Dtool_SmoothMover_get_accept_clock_skew_45_comment},
  {"set_max_position_age", &Dtool_SmoothMover_set_max_position_age_46, METH_O, (const char *)Dtool_SmoothMover_set_max_position_age_46_comment},
  {"setMaxPositionAge", &Dtool_SmoothMover_set_max_position_age_46, METH_O, (const char *)Dtool_SmoothMover_set_max_position_age_46_comment},
  {"get_max_position_age", &Dtool_SmoothMover_get_max_position_age_47, METH_NOARGS, (const char *)Dtool_SmoothMover_get_max_position_age_47_comment},
  {"getMaxPositionAge", &Dtool_SmoothMover_get_max_position_age_47, METH_NOARGS, (const char *)Dtool_SmoothMover_get_max_position_age_47_comment},
  {"set_expected_broadcast_period", &Dtool_SmoothMover_set_expected_broadcast_period_48, METH_O, (const char *)Dtool_SmoothMover_set_expected_broadcast_period_48_comment},
  {"setExpectedBroadcastPeriod", &Dtool_SmoothMover_set_expected_broadcast_period_48, METH_O, (const char *)Dtool_SmoothMover_set_expected_broadcast_period_48_comment},
  {"get_expected_broadcast_period", &Dtool_SmoothMover_get_expected_broadcast_period_49, METH_NOARGS, (const char *)Dtool_SmoothMover_get_expected_broadcast_period_49_comment},
  {"getExpectedBroadcastPeriod", &Dtool_SmoothMover_get_expected_broadcast_period_49, METH_NOARGS, (const char *)Dtool_SmoothMover_get_expected_broadcast_period_49_comment},
  {"set_reset_velocity_age", &Dtool_SmoothMover_set_reset_velocity_age_50, METH_O, (const char *)Dtool_SmoothMover_set_reset_velocity_age_50_comment},
  {"setResetVelocityAge", &Dtool_SmoothMover_set_reset_velocity_age_50, METH_O, (const char *)Dtool_SmoothMover_set_reset_velocity_age_50_comment},
  {"get_reset_velocity_age", &Dtool_SmoothMover_get_reset_velocity_age_51, METH_NOARGS, (const char *)Dtool_SmoothMover_get_reset_velocity_age_51_comment},
  {"getResetVelocityAge", &Dtool_SmoothMover_get_reset_velocity_age_51, METH_NOARGS, (const char *)Dtool_SmoothMover_get_reset_velocity_age_51_comment},
  {"set_directional_velocity", &Dtool_SmoothMover_set_directional_velocity_52, METH_O, (const char *)Dtool_SmoothMover_set_directional_velocity_52_comment},
  {"setDirectionalVelocity", &Dtool_SmoothMover_set_directional_velocity_52, METH_O, (const char *)Dtool_SmoothMover_set_directional_velocity_52_comment},
  {"get_directional_velocity", &Dtool_SmoothMover_get_directional_velocity_53, METH_NOARGS, (const char *)Dtool_SmoothMover_get_directional_velocity_53_comment},
  {"getDirectionalVelocity", &Dtool_SmoothMover_get_directional_velocity_53, METH_NOARGS, (const char *)Dtool_SmoothMover_get_directional_velocity_53_comment},
  {"set_default_to_standing_still", &Dtool_SmoothMover_set_default_to_standing_still_54, METH_O, (const char *)Dtool_SmoothMover_set_default_to_standing_still_54_comment},
  {"setDefaultToStandingStill", &Dtool_SmoothMover_set_default_to_standing_still_54, METH_O, (const char *)Dtool_SmoothMover_set_default_to_standing_still_54_comment},
  {"get_default_to_standing_still", &Dtool_SmoothMover_get_default_to_standing_still_55, METH_NOARGS, (const char *)Dtool_SmoothMover_get_default_to_standing_still_55_comment},
  {"getDefaultToStandingStill", &Dtool_SmoothMover_get_default_to_standing_still_55, METH_NOARGS, (const char *)Dtool_SmoothMover_get_default_to_standing_still_55_comment},
  {"output", &Dtool_SmoothMover_output_56, METH_O, (const char *)Dtool_SmoothMover_output_56_comment},
  {"write", &Dtool_SmoothMover_write_57, METH_O, (const char *)Dtool_SmoothMover_write_57_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     SmoothMover
//////////////////
static PyObject *Dtool_Repr_SmoothMover(PyObject *self) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SmoothMover, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     SmoothMover
//////////////////
static PyObject *Dtool_Str_SmoothMover(PyObject *self) {
  SmoothMover *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SmoothMover, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_SmoothMover = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_SmoothMover = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.SmoothMover",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_SmoothMover,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_SmoothMover,
    &Dtool_NumberMethods_SmoothMover,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_SmoothMover,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class handles smoothing of sampled motion points over time, e.g.  for\n"
    " * smoothing the apparent movement of remote avatars, whose positions are sent\n"
    " * via occasional telemetry updates.\n"
    " *\n"
    " * It can operate in any of three modes: off, in which it does not smooth any\n"
    " * motion but provides the last position it was told; smoothing only, in which\n"
    " * it smooths motion information but never tries to anticipate where the\n"
    " * avatar might be going; or full prediction, in which it smooths motion as\n"
    " * well as tries to predict the avatar's position in lead of the last position\n"
    " * update.  The assumption is that all SmoothMovers in the world will be\n"
    " * operating in the same mode together.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_SmoothMover,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_SmoothMover,
    PyType_GenericAlloc,
    Dtool_new_SmoothMover,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SmoothMover,
  Dtool_UpcastInterface_SmoothMover,
  Dtool_DowncastInterface_SmoothMover,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_SmoothMover(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_SmoothMover._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(9);
    Dtool_SmoothMover._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum SmoothMover::SmoothMode;
    PyDict_SetItemString(dict, "SM_off", Dtool_WrapValue(SmoothMover::SM_off));
    PyDict_SetItemString(dict, "SMOff", Dtool_WrapValue(SmoothMover::SM_off));
    PyDict_SetItemString(dict, "SM_on", Dtool_WrapValue(SmoothMover::SM_on));
    PyDict_SetItemString(dict, "SMOn", Dtool_WrapValue(SmoothMover::SM_on));
    // enum SmoothMover::PredictionMode;
    PyDict_SetItemString(dict, "PM_off", Dtool_WrapValue(SmoothMover::PM_off));
    PyDict_SetItemString(dict, "PMOff", Dtool_WrapValue(SmoothMover::PM_off));
    PyDict_SetItemString(dict, "PM_on", Dtool_WrapValue(SmoothMover::PM_on));
    PyDict_SetItemString(dict, "PMOn", Dtool_WrapValue(SmoothMover::PM_on));
    if (PyType_Ready((PyTypeObject *)&Dtool_SmoothMover) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SmoothMover)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SmoothMover);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3deadrec_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
}

void Dtool_libp3deadrec_BuildInstants(PyObject *module) {
  (void) module;
  // SmoothMover
  Dtool_PyModuleClassInit_SmoothMover(module);
  PyModule_AddObject(module, "SmoothMover", (PyObject *)&Dtool_SmoothMover);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3deadrec_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3deadrec_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583614771,  /* file_identifier */
  "libp3deadrec",  /* library_name */
  "FP4V",  /* library_hash_name */
  "panda3d.direct",  /* module_name */
  "libp3deadrec.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  136  /* next_index */
};

Configure(_in_configure_libp3deadrec);
ConfigureFn(_in_configure_libp3deadrec) {
  interrogate_request_module(&_in_module_def);
}

