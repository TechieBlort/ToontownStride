/*
 * This file was generated by:
 * built/bin/interrogate -srcdir panda/src/mathutil -Ipanda/src/mathutil -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3mathutil_igate.cxx -od built/pandac/input/libp3mathutil.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/mathutil -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.core -library libp3mathutil boundingBox.h boundingHexahedron.h boundingLine.h boundingPlane.h boundingSphere.h boundingVolume.h config_mathutil.h fftCompressor.h finiteBoundingVolume.h frustum.h geometricBoundingVolume.h intersectionBoundingVolume.h linmath_events.h look_at.h mersenne.h omniBoundingVolume.h p3mathutil_composite1.cxx p3mathutil_composite2.cxx parabola.h perlinNoise.h perlinNoise2.h perlinNoise3.h plane.h pta_LMatrix3.h pta_LMatrix3_ext.h pta_LMatrix4.h pta_LMatrix4_ext.h pta_LVecBase2.h pta_LVecBase2_ext.h pta_LVecBase3.h pta_LVecBase3_ext.h pta_LVecBase4.h pta_LVecBase4_ext.h randomizer.h rotate_to.h stackedPerlinNoise2.h stackedPerlinNoise3.h triangulator.h triangulator3.h unionBoundingVolume.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "boundingBox.h"
#include "boundingHexahedron.h"
#include "boundingLine.h"
#include "boundingPlane.h"
#include "boundingSphere.h"
#include "boundingVolume.h"
#include "cmath.h"
#include "config_mathutil.h"
#include "coordinateSystem.h"
#include "dblnames.h"
#include "fftCompressor.h"
#include "finiteBoundingVolume.h"
#include "fltnames.h"
#include "frustum.h"
#include "geometricBoundingVolume.h"
#include "intersectionBoundingVolume.h"
#include "linmath_events.h"
#include "look_at.h"
#include "luse.h"
#include "mersenne.h"
#include "omniBoundingVolume.h"
#include "pandabase.h"
#include "parabola.h"
#include "paramValue.h"
#include "perlinNoise.h"
#include "perlinNoise2.h"
#include "perlinNoise3.h"
#include "plane.h"
#include "pointerToArray.h"
#include "pointerToArray_ext.h"
#include "pta_LMatrix3.h"
#include "pta_LMatrix3_ext.h"
#include "pta_LMatrix4.h"
#include "pta_LMatrix4_ext.h"
#include "pta_LVecBase2.h"
#include "pta_LVecBase2_ext.h"
#include "pta_LVecBase3.h"
#include "pta_LVecBase3_ext.h"
#include "pta_LVecBase4.h"
#include "pta_LVecBase4_ext.h"
#include "pvector.h"
#include "randomizer.h"
#include "rotate_to.h"
#include "stackedPerlinNoise2.h"
#include "stackedPerlinNoise3.h"
#include "triangulator.h"
#include "triangulator3.h"
#include "unionBoundingVolume.h"
#include "vector_double.h"
#include "vector_stdfloat.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class ConstPointerToArray_LMatrix3d
 */
typedef ConstPointerToArray< LMatrix3d > ConstPointerToArray_LMatrix3d_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_LMatrix3d, ConstPointerToArray_LMatrix3d_localtype, ConstPointerToArray_LMatrix3d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_LMatrix3d = &Dtool_ConstPointerToArray_LMatrix3d;
static void Dtool_PyModuleClassInit_ConstPointerToArray_LMatrix3d(PyObject *module);
ConstPointerToArray< LMatrix3d > *Dtool_Coerce_ConstPointerToArray_LMatrix3d(PyObject *args, ConstPointerToArray< LMatrix3d > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_LMatrix3d
 */
typedef PointerToArrayBase< LMatrix3d > PointerToArrayBase_LMatrix3d_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_LMatrix3d, PointerToArrayBase_LMatrix3d_localtype, PointerToArrayBase_LMatrix3d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_LMatrix3d = &Dtool_PointerToArrayBase_LMatrix3d;
static void Dtool_PyModuleClassInit_PointerToArrayBase_LMatrix3d(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_LMatrix3d
 */
typedef PointerToBase< ReferenceCountedVector< LMatrix3d > > PointerToBase_ReferenceCountedVector_LMatrix3d_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_LMatrix3d, PointerToBase_ReferenceCountedVector_LMatrix3d_localtype, PointerToBase_ReferenceCountedVector_LMatrix3d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3d = &Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LMatrix3d(PyObject *module);

/**
 * Forward declarations for top-level class ConstPointerToArray_LMatrix3f
 */
typedef ConstPointerToArray< LMatrix3f > ConstPointerToArray_LMatrix3f_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_LMatrix3f, ConstPointerToArray_LMatrix3f_localtype, ConstPointerToArray_LMatrix3f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_LMatrix3f = &Dtool_ConstPointerToArray_LMatrix3f;
static void Dtool_PyModuleClassInit_ConstPointerToArray_LMatrix3f(PyObject *module);
ConstPointerToArray< LMatrix3f > *Dtool_Coerce_ConstPointerToArray_LMatrix3f(PyObject *args, ConstPointerToArray< LMatrix3f > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_LMatrix3f
 */
typedef PointerToArrayBase< LMatrix3f > PointerToArrayBase_LMatrix3f_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_LMatrix3f, PointerToArrayBase_LMatrix3f_localtype, PointerToArrayBase_LMatrix3f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_LMatrix3f = &Dtool_PointerToArrayBase_LMatrix3f;
static void Dtool_PyModuleClassInit_PointerToArrayBase_LMatrix3f(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_LMatrix3f
 */
typedef PointerToBase< ReferenceCountedVector< LMatrix3f > > PointerToBase_ReferenceCountedVector_LMatrix3f_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_LMatrix3f, PointerToBase_ReferenceCountedVector_LMatrix3f_localtype, PointerToBase_ReferenceCountedVector_LMatrix3f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3f = &Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LMatrix3f(PyObject *module);

/**
 * Forward declarations for top-level class ConstPointerToArray_LVecBase2d
 */
typedef ConstPointerToArray< LVecBase2d > ConstPointerToArray_LVecBase2d_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_LVecBase2d, ConstPointerToArray_LVecBase2d_localtype, ConstPointerToArray_LVecBase2d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_LVecBase2d = &Dtool_ConstPointerToArray_LVecBase2d;
static void Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2d(PyObject *module);
ConstPointerToArray< LVecBase2d > *Dtool_Coerce_ConstPointerToArray_LVecBase2d(PyObject *args, ConstPointerToArray< LVecBase2d > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_LVecBase2d
 */
typedef PointerToArrayBase< LVecBase2d > PointerToArrayBase_LVecBase2d_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_LVecBase2d, PointerToArrayBase_LVecBase2d_localtype, PointerToArrayBase_LVecBase2d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_LVecBase2d = &Dtool_PointerToArrayBase_LVecBase2d;
static void Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2d(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_LVecBase2d
 */
typedef PointerToBase< ReferenceCountedVector< LVecBase2d > > PointerToBase_ReferenceCountedVector_LVecBase2d_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_LVecBase2d, PointerToBase_ReferenceCountedVector_LVecBase2d_localtype, PointerToBase_ReferenceCountedVector_LVecBase2d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2d = &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2d(PyObject *module);

/**
 * Forward declarations for top-level class ConstPointerToArray_LVecBase2f
 */
typedef ConstPointerToArray< LVecBase2f > ConstPointerToArray_LVecBase2f_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_LVecBase2f, ConstPointerToArray_LVecBase2f_localtype, ConstPointerToArray_LVecBase2f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_LVecBase2f = &Dtool_ConstPointerToArray_LVecBase2f;
static void Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2f(PyObject *module);
ConstPointerToArray< LVecBase2f > *Dtool_Coerce_ConstPointerToArray_LVecBase2f(PyObject *args, ConstPointerToArray< LVecBase2f > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_LVecBase2f
 */
typedef PointerToArrayBase< LVecBase2f > PointerToArrayBase_LVecBase2f_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_LVecBase2f, PointerToArrayBase_LVecBase2f_localtype, PointerToArrayBase_LVecBase2f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_LVecBase2f = &Dtool_PointerToArrayBase_LVecBase2f;
static void Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2f(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_LVecBase2f
 */
typedef PointerToBase< ReferenceCountedVector< LVecBase2f > > PointerToBase_ReferenceCountedVector_LVecBase2f_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_LVecBase2f, PointerToBase_ReferenceCountedVector_LVecBase2f_localtype, PointerToBase_ReferenceCountedVector_LVecBase2f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2f = &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2f(PyObject *module);

/**
 * Forward declarations for top-level class ConstPointerToArray_LVecBase2i
 */
typedef ConstPointerToArray< LVecBase2i > ConstPointerToArray_LVecBase2i_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_LVecBase2i, ConstPointerToArray_LVecBase2i_localtype, ConstPointerToArray_LVecBase2i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_LVecBase2i = &Dtool_ConstPointerToArray_LVecBase2i;
static void Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2i(PyObject *module);
ConstPointerToArray< LVecBase2i > *Dtool_Coerce_ConstPointerToArray_LVecBase2i(PyObject *args, ConstPointerToArray< LVecBase2i > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_LVecBase2i
 */
typedef PointerToArrayBase< LVecBase2i > PointerToArrayBase_LVecBase2i_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_LVecBase2i, PointerToArrayBase_LVecBase2i_localtype, PointerToArrayBase_LVecBase2i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_LVecBase2i = &Dtool_PointerToArrayBase_LVecBase2i;
static void Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2i(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_LVecBase2i
 */
typedef PointerToBase< ReferenceCountedVector< LVecBase2i > > PointerToBase_ReferenceCountedVector_LVecBase2i_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_LVecBase2i, PointerToBase_ReferenceCountedVector_LVecBase2i_localtype, PointerToBase_ReferenceCountedVector_LVecBase2i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2i = &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2i(PyObject *module);

/**
 * Forward declarations for top-level class ConstPointerToArray_LVecBase3d
 */
typedef ConstPointerToArray< LVecBase3d > ConstPointerToArray_LVecBase3d_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_LVecBase3d, ConstPointerToArray_LVecBase3d_localtype, ConstPointerToArray_LVecBase3d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_LVecBase3d = &Dtool_ConstPointerToArray_LVecBase3d;
static void Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3d(PyObject *module);
ConstPointerToArray< LVecBase3d > *Dtool_Coerce_ConstPointerToArray_LVecBase3d(PyObject *args, ConstPointerToArray< LVecBase3d > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_LVecBase3d
 */
typedef PointerToArrayBase< LVecBase3d > PointerToArrayBase_LVecBase3d_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_LVecBase3d, PointerToArrayBase_LVecBase3d_localtype, PointerToArrayBase_LVecBase3d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_LVecBase3d = &Dtool_PointerToArrayBase_LVecBase3d;
static void Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3d(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_LVecBase3d
 */
typedef PointerToBase< ReferenceCountedVector< LVecBase3d > > PointerToBase_ReferenceCountedVector_LVecBase3d_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_LVecBase3d, PointerToBase_ReferenceCountedVector_LVecBase3d_localtype, PointerToBase_ReferenceCountedVector_LVecBase3d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3d = &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3d(PyObject *module);

/**
 * Forward declarations for top-level class ConstPointerToArray_LVecBase3f
 */
typedef ConstPointerToArray< LVecBase3f > ConstPointerToArray_LVecBase3f_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_LVecBase3f, ConstPointerToArray_LVecBase3f_localtype, ConstPointerToArray_LVecBase3f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_LVecBase3f = &Dtool_ConstPointerToArray_LVecBase3f;
static void Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3f(PyObject *module);
ConstPointerToArray< LVecBase3f > *Dtool_Coerce_ConstPointerToArray_LVecBase3f(PyObject *args, ConstPointerToArray< LVecBase3f > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_LVecBase3f
 */
typedef PointerToArrayBase< LVecBase3f > PointerToArrayBase_LVecBase3f_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_LVecBase3f, PointerToArrayBase_LVecBase3f_localtype, PointerToArrayBase_LVecBase3f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_LVecBase3f = &Dtool_PointerToArrayBase_LVecBase3f;
static void Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3f(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_LVecBase3f
 */
typedef PointerToBase< ReferenceCountedVector< LVecBase3f > > PointerToBase_ReferenceCountedVector_LVecBase3f_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_LVecBase3f, PointerToBase_ReferenceCountedVector_LVecBase3f_localtype, PointerToBase_ReferenceCountedVector_LVecBase3f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3f = &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3f(PyObject *module);

/**
 * Forward declarations for top-level class ConstPointerToArray_LVecBase3i
 */
typedef ConstPointerToArray< LVecBase3i > ConstPointerToArray_LVecBase3i_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_LVecBase3i, ConstPointerToArray_LVecBase3i_localtype, ConstPointerToArray_LVecBase3i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_LVecBase3i = &Dtool_ConstPointerToArray_LVecBase3i;
static void Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3i(PyObject *module);
ConstPointerToArray< LVecBase3i > *Dtool_Coerce_ConstPointerToArray_LVecBase3i(PyObject *args, ConstPointerToArray< LVecBase3i > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_LVecBase3i
 */
typedef PointerToArrayBase< LVecBase3i > PointerToArrayBase_LVecBase3i_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_LVecBase3i, PointerToArrayBase_LVecBase3i_localtype, PointerToArrayBase_LVecBase3i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_LVecBase3i = &Dtool_PointerToArrayBase_LVecBase3i;
static void Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3i(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_LVecBase3i
 */
typedef PointerToBase< ReferenceCountedVector< LVecBase3i > > PointerToBase_ReferenceCountedVector_LVecBase3i_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_LVecBase3i, PointerToBase_ReferenceCountedVector_LVecBase3i_localtype, PointerToBase_ReferenceCountedVector_LVecBase3i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3i = &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3i(PyObject *module);

/**
 * Forward declarations for top-level class ConstPointerToArray_UnalignedLMatrix4d
 */
typedef ConstPointerToArray< UnalignedLMatrix4d > ConstPointerToArray_UnalignedLMatrix4d_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_UnalignedLMatrix4d, ConstPointerToArray_UnalignedLMatrix4d_localtype, ConstPointerToArray_UnalignedLMatrix4d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_UnalignedLMatrix4d = &Dtool_ConstPointerToArray_UnalignedLMatrix4d;
static void Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLMatrix4d(PyObject *module);
ConstPointerToArray< UnalignedLMatrix4d > *Dtool_Coerce_ConstPointerToArray_UnalignedLMatrix4d(PyObject *args, ConstPointerToArray< UnalignedLMatrix4d > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_UnalignedLMatrix4d
 */
typedef PointerToArrayBase< UnalignedLMatrix4d > PointerToArrayBase_UnalignedLMatrix4d_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_UnalignedLMatrix4d, PointerToArrayBase_UnalignedLMatrix4d_localtype, PointerToArrayBase_UnalignedLMatrix4d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4d = &Dtool_PointerToArrayBase_UnalignedLMatrix4d;
static void Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLMatrix4d(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d
 */
typedef PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > > PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d, PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d_localtype, PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d = &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d(PyObject *module);

/**
 * Forward declarations for top-level class ConstPointerToArray_UnalignedLMatrix4f
 */
typedef ConstPointerToArray< UnalignedLMatrix4f > ConstPointerToArray_UnalignedLMatrix4f_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_UnalignedLMatrix4f, ConstPointerToArray_UnalignedLMatrix4f_localtype, ConstPointerToArray_UnalignedLMatrix4f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_UnalignedLMatrix4f = &Dtool_ConstPointerToArray_UnalignedLMatrix4f;
static void Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLMatrix4f(PyObject *module);
ConstPointerToArray< UnalignedLMatrix4f > *Dtool_Coerce_ConstPointerToArray_UnalignedLMatrix4f(PyObject *args, ConstPointerToArray< UnalignedLMatrix4f > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_UnalignedLMatrix4f
 */
typedef PointerToArrayBase< UnalignedLMatrix4f > PointerToArrayBase_UnalignedLMatrix4f_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_UnalignedLMatrix4f, PointerToArrayBase_UnalignedLMatrix4f_localtype, PointerToArrayBase_UnalignedLMatrix4f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4f = &Dtool_PointerToArrayBase_UnalignedLMatrix4f;
static void Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLMatrix4f(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f
 */
typedef PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > > PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f, PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f_localtype, PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f = &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f(PyObject *module);

/**
 * Forward declarations for top-level class ConstPointerToArray_UnalignedLVecBase4d
 */
typedef ConstPointerToArray< UnalignedLVecBase4d > ConstPointerToArray_UnalignedLVecBase4d_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_UnalignedLVecBase4d, ConstPointerToArray_UnalignedLVecBase4d_localtype, ConstPointerToArray_UnalignedLVecBase4d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4d = &Dtool_ConstPointerToArray_UnalignedLVecBase4d;
static void Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4d(PyObject *module);
ConstPointerToArray< UnalignedLVecBase4d > *Dtool_Coerce_ConstPointerToArray_UnalignedLVecBase4d(PyObject *args, ConstPointerToArray< UnalignedLVecBase4d > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_UnalignedLVecBase4d
 */
typedef PointerToArrayBase< UnalignedLVecBase4d > PointerToArrayBase_UnalignedLVecBase4d_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_UnalignedLVecBase4d, PointerToArrayBase_UnalignedLVecBase4d_localtype, PointerToArrayBase_UnalignedLVecBase4d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4d = &Dtool_PointerToArrayBase_UnalignedLVecBase4d;
static void Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4d(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d
 */
typedef PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > > PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d, PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d_localtype, PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d = &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d(PyObject *module);

/**
 * Forward declarations for top-level class ConstPointerToArray_UnalignedLVecBase4f
 */
typedef ConstPointerToArray< UnalignedLVecBase4f > ConstPointerToArray_UnalignedLVecBase4f_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_UnalignedLVecBase4f, ConstPointerToArray_UnalignedLVecBase4f_localtype, ConstPointerToArray_UnalignedLVecBase4f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4f = &Dtool_ConstPointerToArray_UnalignedLVecBase4f;
static void Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4f(PyObject *module);
ConstPointerToArray< UnalignedLVecBase4f > *Dtool_Coerce_ConstPointerToArray_UnalignedLVecBase4f(PyObject *args, ConstPointerToArray< UnalignedLVecBase4f > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_UnalignedLVecBase4f
 */
typedef PointerToArrayBase< UnalignedLVecBase4f > PointerToArrayBase_UnalignedLVecBase4f_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_UnalignedLVecBase4f, PointerToArrayBase_UnalignedLVecBase4f_localtype, PointerToArrayBase_UnalignedLVecBase4f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4f = &Dtool_PointerToArrayBase_UnalignedLVecBase4f;
static void Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4f(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f
 */
typedef PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > > PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f, PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f_localtype, PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f = &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f(PyObject *module);

/**
 * Forward declarations for top-level class ConstPointerToArray_UnalignedLVecBase4i
 */
typedef ConstPointerToArray< UnalignedLVecBase4i > ConstPointerToArray_UnalignedLVecBase4i_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_UnalignedLVecBase4i, ConstPointerToArray_UnalignedLVecBase4i_localtype, ConstPointerToArray_UnalignedLVecBase4i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4i = &Dtool_ConstPointerToArray_UnalignedLVecBase4i;
static void Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4i(PyObject *module);
ConstPointerToArray< UnalignedLVecBase4i > *Dtool_Coerce_ConstPointerToArray_UnalignedLVecBase4i(PyObject *args, ConstPointerToArray< UnalignedLVecBase4i > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_UnalignedLVecBase4i
 */
typedef PointerToArrayBase< UnalignedLVecBase4i > PointerToArrayBase_UnalignedLVecBase4i_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_UnalignedLVecBase4i, PointerToArrayBase_UnalignedLVecBase4i_localtype, PointerToArrayBase_UnalignedLVecBase4i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4i = &Dtool_PointerToArrayBase_UnalignedLVecBase4i;
static void Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4i(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i
 */
typedef PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > > PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i, PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i_localtype, PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i = &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i(PyObject *module);

/**
 * Forward declarations for top-level class PointerToArray_LMatrix3d
 */
typedef PointerToArray< LMatrix3d > PointerToArray_LMatrix3d_localtype;
Define_Module_Class(panda3d.core, PointerToArray_LMatrix3d, PointerToArray_LMatrix3d_localtype, PointerToArray_LMatrix3d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_LMatrix3d = &Dtool_PointerToArray_LMatrix3d;
static void Dtool_PyModuleClassInit_PointerToArray_LMatrix3d(PyObject *module);
PointerToArray< LMatrix3d > *Dtool_Coerce_PointerToArray_LMatrix3d(PyObject *args, PointerToArray< LMatrix3d > &coerced);

/**
 * Forward declarations for top-level class PointerToArray_LMatrix3f
 */
typedef PointerToArray< LMatrix3f > PointerToArray_LMatrix3f_localtype;
Define_Module_Class(panda3d.core, PointerToArray_LMatrix3f, PointerToArray_LMatrix3f_localtype, PointerToArray_LMatrix3f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_LMatrix3f = &Dtool_PointerToArray_LMatrix3f;
static void Dtool_PyModuleClassInit_PointerToArray_LMatrix3f(PyObject *module);
PointerToArray< LMatrix3f > *Dtool_Coerce_PointerToArray_LMatrix3f(PyObject *args, PointerToArray< LMatrix3f > &coerced);

/**
 * Forward declarations for top-level class PointerToArray_LVecBase2d
 */
typedef PointerToArray< LVecBase2d > PointerToArray_LVecBase2d_localtype;
Define_Module_Class(panda3d.core, PointerToArray_LVecBase2d, PointerToArray_LVecBase2d_localtype, PointerToArray_LVecBase2d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_LVecBase2d = &Dtool_PointerToArray_LVecBase2d;
static void Dtool_PyModuleClassInit_PointerToArray_LVecBase2d(PyObject *module);
PointerToArray< LVecBase2d > *Dtool_Coerce_PointerToArray_LVecBase2d(PyObject *args, PointerToArray< LVecBase2d > &coerced);

/**
 * Forward declarations for top-level class PointerToArray_LVecBase2f
 */
typedef PointerToArray< LVecBase2f > PointerToArray_LVecBase2f_localtype;
Define_Module_Class(panda3d.core, PointerToArray_LVecBase2f, PointerToArray_LVecBase2f_localtype, PointerToArray_LVecBase2f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_LVecBase2f = &Dtool_PointerToArray_LVecBase2f;
static void Dtool_PyModuleClassInit_PointerToArray_LVecBase2f(PyObject *module);
PointerToArray< LVecBase2f > *Dtool_Coerce_PointerToArray_LVecBase2f(PyObject *args, PointerToArray< LVecBase2f > &coerced);

/**
 * Forward declarations for top-level class PointerToArray_LVecBase2i
 */
typedef PointerToArray< LVecBase2i > PointerToArray_LVecBase2i_localtype;
Define_Module_Class(panda3d.core, PointerToArray_LVecBase2i, PointerToArray_LVecBase2i_localtype, PointerToArray_LVecBase2i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_LVecBase2i = &Dtool_PointerToArray_LVecBase2i;
static void Dtool_PyModuleClassInit_PointerToArray_LVecBase2i(PyObject *module);
PointerToArray< LVecBase2i > *Dtool_Coerce_PointerToArray_LVecBase2i(PyObject *args, PointerToArray< LVecBase2i > &coerced);

/**
 * Forward declarations for top-level class PointerToArray_LVecBase3d
 */
typedef PointerToArray< LVecBase3d > PointerToArray_LVecBase3d_localtype;
Define_Module_Class(panda3d.core, PointerToArray_LVecBase3d, PointerToArray_LVecBase3d_localtype, PointerToArray_LVecBase3d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_LVecBase3d = &Dtool_PointerToArray_LVecBase3d;
static void Dtool_PyModuleClassInit_PointerToArray_LVecBase3d(PyObject *module);
PointerToArray< LVecBase3d > *Dtool_Coerce_PointerToArray_LVecBase3d(PyObject *args, PointerToArray< LVecBase3d > &coerced);

/**
 * Forward declarations for top-level class PointerToArray_LVecBase3f
 */
typedef PointerToArray< LVecBase3f > PointerToArray_LVecBase3f_localtype;
Define_Module_Class(panda3d.core, PointerToArray_LVecBase3f, PointerToArray_LVecBase3f_localtype, PointerToArray_LVecBase3f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_LVecBase3f = &Dtool_PointerToArray_LVecBase3f;
static void Dtool_PyModuleClassInit_PointerToArray_LVecBase3f(PyObject *module);
PointerToArray< LVecBase3f > *Dtool_Coerce_PointerToArray_LVecBase3f(PyObject *args, PointerToArray< LVecBase3f > &coerced);

/**
 * Forward declarations for top-level class PointerToArray_LVecBase3i
 */
typedef PointerToArray< LVecBase3i > PointerToArray_LVecBase3i_localtype;
Define_Module_Class(panda3d.core, PointerToArray_LVecBase3i, PointerToArray_LVecBase3i_localtype, PointerToArray_LVecBase3i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_LVecBase3i = &Dtool_PointerToArray_LVecBase3i;
static void Dtool_PyModuleClassInit_PointerToArray_LVecBase3i(PyObject *module);
PointerToArray< LVecBase3i > *Dtool_Coerce_PointerToArray_LVecBase3i(PyObject *args, PointerToArray< LVecBase3i > &coerced);

/**
 * Forward declarations for top-level class PointerToArray_UnalignedLMatrix4d
 */
typedef PointerToArray< UnalignedLMatrix4d > PointerToArray_UnalignedLMatrix4d_localtype;
Define_Module_Class(panda3d.core, PointerToArray_UnalignedLMatrix4d, PointerToArray_UnalignedLMatrix4d_localtype, PointerToArray_UnalignedLMatrix4d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_UnalignedLMatrix4d = &Dtool_PointerToArray_UnalignedLMatrix4d;
static void Dtool_PyModuleClassInit_PointerToArray_UnalignedLMatrix4d(PyObject *module);
PointerToArray< UnalignedLMatrix4d > *Dtool_Coerce_PointerToArray_UnalignedLMatrix4d(PyObject *args, PointerToArray< UnalignedLMatrix4d > &coerced);

/**
 * Forward declarations for top-level class PointerToArray_UnalignedLMatrix4f
 */
typedef PointerToArray< UnalignedLMatrix4f > PointerToArray_UnalignedLMatrix4f_localtype;
Define_Module_Class(panda3d.core, PointerToArray_UnalignedLMatrix4f, PointerToArray_UnalignedLMatrix4f_localtype, PointerToArray_UnalignedLMatrix4f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_UnalignedLMatrix4f = &Dtool_PointerToArray_UnalignedLMatrix4f;
static void Dtool_PyModuleClassInit_PointerToArray_UnalignedLMatrix4f(PyObject *module);
PointerToArray< UnalignedLMatrix4f > *Dtool_Coerce_PointerToArray_UnalignedLMatrix4f(PyObject *args, PointerToArray< UnalignedLMatrix4f > &coerced);

/**
 * Forward declarations for top-level class PointerToArray_UnalignedLVecBase4d
 */
typedef PointerToArray< UnalignedLVecBase4d > PointerToArray_UnalignedLVecBase4d_localtype;
Define_Module_Class(panda3d.core, PointerToArray_UnalignedLVecBase4d, PointerToArray_UnalignedLVecBase4d_localtype, PointerToArray_UnalignedLVecBase4d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_UnalignedLVecBase4d = &Dtool_PointerToArray_UnalignedLVecBase4d;
static void Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4d(PyObject *module);
PointerToArray< UnalignedLVecBase4d > *Dtool_Coerce_PointerToArray_UnalignedLVecBase4d(PyObject *args, PointerToArray< UnalignedLVecBase4d > &coerced);

/**
 * Forward declarations for top-level class PointerToArray_UnalignedLVecBase4f
 */
typedef PointerToArray< UnalignedLVecBase4f > PointerToArray_UnalignedLVecBase4f_localtype;
Define_Module_Class(panda3d.core, PointerToArray_UnalignedLVecBase4f, PointerToArray_UnalignedLVecBase4f_localtype, PointerToArray_UnalignedLVecBase4f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_UnalignedLVecBase4f = &Dtool_PointerToArray_UnalignedLVecBase4f;
static void Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4f(PyObject *module);
PointerToArray< UnalignedLVecBase4f > *Dtool_Coerce_PointerToArray_UnalignedLVecBase4f(PyObject *args, PointerToArray< UnalignedLVecBase4f > &coerced);

/**
 * Forward declarations for top-level class PointerToArray_UnalignedLVecBase4i
 */
typedef PointerToArray< UnalignedLVecBase4i > PointerToArray_UnalignedLVecBase4i_localtype;
Define_Module_Class(panda3d.core, PointerToArray_UnalignedLVecBase4i, PointerToArray_UnalignedLVecBase4i_localtype, PointerToArray_UnalignedLVecBase4i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_UnalignedLVecBase4i = &Dtool_PointerToArray_UnalignedLVecBase4i;
static void Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4i(PyObject *module);
PointerToArray< UnalignedLVecBase4i > *Dtool_Coerce_PointerToArray_UnalignedLVecBase4i(PyObject *args, PointerToArray< UnalignedLVecBase4i > &coerced);

/**
 * Forward declarations for top-level class BoundingVolume
 */
typedef BoundingVolume BoundingVolume_localtype;
Define_Module_ClassRef(panda3d.core, BoundingVolume, BoundingVolume_localtype, BoundingVolume);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BoundingVolume = &Dtool_BoundingVolume;
static void Dtool_PyModuleClassInit_BoundingVolume(PyObject *module);

/**
 * Forward declarations for top-level class GeometricBoundingVolume
 */
typedef GeometricBoundingVolume GeometricBoundingVolume_localtype;
Define_Module_ClassRef(panda3d.core, GeometricBoundingVolume, GeometricBoundingVolume_localtype, GeometricBoundingVolume);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeometricBoundingVolume = &Dtool_GeometricBoundingVolume;
static void Dtool_PyModuleClassInit_GeometricBoundingVolume(PyObject *module);

/**
 * Forward declarations for top-level class FiniteBoundingVolume
 */
typedef FiniteBoundingVolume FiniteBoundingVolume_localtype;
Define_Module_ClassRef(panda3d.core, FiniteBoundingVolume, FiniteBoundingVolume_localtype, FiniteBoundingVolume);
static struct Dtool_PyTypedObject *const Dtool_Ptr_FiniteBoundingVolume = &Dtool_FiniteBoundingVolume;
static void Dtool_PyModuleClassInit_FiniteBoundingVolume(PyObject *module);

/**
 * Forward declarations for top-level class LParabolaf
 */
typedef LParabolaf LParabolaf_localtype;
Define_Module_Class(panda3d.core, LParabolaf, LParabolaf_localtype, LParabolaf);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LParabolaf = &Dtool_LParabolaf;
static void Dtool_PyModuleClassInit_LParabolaf(PyObject *module);
LParabolaf *Dtool_Coerce_LParabolaf(PyObject *args, LParabolaf &coerced);

/**
 * Forward declarations for top-level class LParabolad
 */
typedef LParabolad LParabolad_localtype;
Define_Module_Class(panda3d.core, LParabolad, LParabolad_localtype, LParabolad);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LParabolad = &Dtool_LParabolad;
static void Dtool_PyModuleClassInit_LParabolad(PyObject *module);
LParabolad *Dtool_Coerce_LParabolad(PyObject *args, LParabolad &coerced);

/**
 * Forward declarations for top-level class LPlanef
 */
typedef LPlanef LPlanef_localtype;
Define_Module_Class(panda3d.core, LPlanef, LPlanef_localtype, LPlanef);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPlanef = &Dtool_LPlanef;
static void Dtool_PyModuleClassInit_LPlanef(PyObject *module);
LPlanef *Dtool_Coerce_LPlanef(PyObject *args, LPlanef &coerced);

/**
 * Forward declarations for top-level class LPlaned
 */
typedef LPlaned LPlaned_localtype;
Define_Module_Class(panda3d.core, LPlaned, LPlaned_localtype, LPlaned);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPlaned = &Dtool_LPlaned;
static void Dtool_PyModuleClassInit_LPlaned(PyObject *module);
LPlaned *Dtool_Coerce_LPlaned(PyObject *args, LPlaned &coerced);

/**
 * Forward declarations for top-level class BoundingBox
 */
typedef BoundingBox BoundingBox_localtype;
Define_Module_ClassRef(panda3d.core, BoundingBox, BoundingBox_localtype, BoundingBox);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BoundingBox = &Dtool_BoundingBox;
static void Dtool_PyModuleClassInit_BoundingBox(PyObject *module);

/**
 * Forward declarations for top-level class LFrustumf
 */
typedef LFrustumf LFrustumf_localtype;
Define_Module_Class(panda3d.core, LFrustumf, LFrustumf_localtype, LFrustumf);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LFrustumf = &Dtool_LFrustumf;
static void Dtool_PyModuleClassInit_LFrustumf(PyObject *module);

/**
 * Forward declarations for top-level class LFrustumd
 */
typedef LFrustumd LFrustumd_localtype;
Define_Module_Class(panda3d.core, LFrustumd, LFrustumd_localtype, LFrustumd);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LFrustumd = &Dtool_LFrustumd;
static void Dtool_PyModuleClassInit_LFrustumd(PyObject *module);

/**
 * Forward declarations for top-level class BoundingHexahedron
 */
typedef BoundingHexahedron BoundingHexahedron_localtype;
Define_Module_ClassRef(panda3d.core, BoundingHexahedron, BoundingHexahedron_localtype, BoundingHexahedron);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BoundingHexahedron = &Dtool_BoundingHexahedron;
static void Dtool_PyModuleClassInit_BoundingHexahedron(PyObject *module);
bool Dtool_ConstCoerce_BoundingHexahedron(PyObject *args, CPT(BoundingHexahedron) &coerced);
bool Dtool_Coerce_BoundingHexahedron(PyObject *args, PT(BoundingHexahedron) &coerced);

/**
 * Forward declarations for top-level class BoundingLine
 */
typedef BoundingLine BoundingLine_localtype;
Define_Module_ClassRef(panda3d.core, BoundingLine, BoundingLine_localtype, BoundingLine);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BoundingLine = &Dtool_BoundingLine;
static void Dtool_PyModuleClassInit_BoundingLine(PyObject *module);

/**
 * Forward declarations for top-level class BoundingPlane
 */
typedef BoundingPlane BoundingPlane_localtype;
Define_Module_ClassRef(panda3d.core, BoundingPlane, BoundingPlane_localtype, BoundingPlane);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BoundingPlane = &Dtool_BoundingPlane;
static void Dtool_PyModuleClassInit_BoundingPlane(PyObject *module);
bool Dtool_ConstCoerce_BoundingPlane(PyObject *args, CPT(BoundingPlane) &coerced);
bool Dtool_Coerce_BoundingPlane(PyObject *args, PT(BoundingPlane) &coerced);

/**
 * Forward declarations for top-level class BoundingSphere
 */
typedef BoundingSphere BoundingSphere_localtype;
Define_Module_ClassRef(panda3d.core, BoundingSphere, BoundingSphere_localtype, BoundingSphere);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BoundingSphere = &Dtool_BoundingSphere;
static void Dtool_PyModuleClassInit_BoundingSphere(PyObject *module);

/**
 * Forward declarations for top-level class IntersectionBoundingVolume
 */
typedef IntersectionBoundingVolume IntersectionBoundingVolume_localtype;
Define_Module_ClassRef(panda3d.core, IntersectionBoundingVolume, IntersectionBoundingVolume_localtype, IntersectionBoundingVolume);
static struct Dtool_PyTypedObject *const Dtool_Ptr_IntersectionBoundingVolume = &Dtool_IntersectionBoundingVolume;
static void Dtool_PyModuleClassInit_IntersectionBoundingVolume(PyObject *module);

/**
 * Forward declarations for top-level class Mersenne
 */
typedef Mersenne Mersenne_localtype;
Define_Module_Class(panda3d.core, Mersenne, Mersenne_localtype, Mersenne);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Mersenne = &Dtool_Mersenne;
static void Dtool_PyModuleClassInit_Mersenne(PyObject *module);

/**
 * Forward declarations for top-level class OmniBoundingVolume
 */
typedef OmniBoundingVolume OmniBoundingVolume_localtype;
Define_Module_ClassRef(panda3d.core, OmniBoundingVolume, OmniBoundingVolume_localtype, OmniBoundingVolume);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OmniBoundingVolume = &Dtool_OmniBoundingVolume;
static void Dtool_PyModuleClassInit_OmniBoundingVolume(PyObject *module);

/**
 * Forward declarations for top-level class UnionBoundingVolume
 */
typedef UnionBoundingVolume UnionBoundingVolume_localtype;
Define_Module_ClassRef(panda3d.core, UnionBoundingVolume, UnionBoundingVolume_localtype, UnionBoundingVolume);
static struct Dtool_PyTypedObject *const Dtool_Ptr_UnionBoundingVolume = &Dtool_UnionBoundingVolume;
static void Dtool_PyModuleClassInit_UnionBoundingVolume(PyObject *module);

/**
 * Forward declarations for top-level class Randomizer
 */
typedef Randomizer Randomizer_localtype;
Define_Module_Class(panda3d.core, Randomizer, Randomizer_localtype, Randomizer);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Randomizer = &Dtool_Randomizer;
static void Dtool_PyModuleClassInit_Randomizer(PyObject *module);

/**
 * Forward declarations for top-level class PerlinNoise
 */
typedef PerlinNoise PerlinNoise_localtype;
Define_Module_Class(panda3d.core, PerlinNoise, PerlinNoise_localtype, PerlinNoise);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PerlinNoise = &Dtool_PerlinNoise;
static void Dtool_PyModuleClassInit_PerlinNoise(PyObject *module);

/**
 * Forward declarations for top-level class PerlinNoise2
 */
typedef PerlinNoise2 PerlinNoise2_localtype;
Define_Module_Class(panda3d.core, PerlinNoise2, PerlinNoise2_localtype, PerlinNoise2);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PerlinNoise2 = &Dtool_PerlinNoise2;
static void Dtool_PyModuleClassInit_PerlinNoise2(PyObject *module);

/**
 * Forward declarations for top-level class PerlinNoise3
 */
typedef PerlinNoise3 PerlinNoise3_localtype;
Define_Module_Class(panda3d.core, PerlinNoise3, PerlinNoise3_localtype, PerlinNoise3);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PerlinNoise3 = &Dtool_PerlinNoise3;
static void Dtool_PyModuleClassInit_PerlinNoise3(PyObject *module);

/**
 * Forward declarations for top-level class StackedPerlinNoise2
 */
typedef StackedPerlinNoise2 StackedPerlinNoise2_localtype;
Define_Module_Class(panda3d.core, StackedPerlinNoise2, StackedPerlinNoise2_localtype, StackedPerlinNoise2);
static struct Dtool_PyTypedObject *const Dtool_Ptr_StackedPerlinNoise2 = &Dtool_StackedPerlinNoise2;
static void Dtool_PyModuleClassInit_StackedPerlinNoise2(PyObject *module);

/**
 * Forward declarations for top-level class StackedPerlinNoise3
 */
typedef StackedPerlinNoise3 StackedPerlinNoise3_localtype;
Define_Module_Class(panda3d.core, StackedPerlinNoise3, StackedPerlinNoise3_localtype, StackedPerlinNoise3);
static struct Dtool_PyTypedObject *const Dtool_Ptr_StackedPerlinNoise3 = &Dtool_StackedPerlinNoise3;
static void Dtool_PyModuleClassInit_StackedPerlinNoise3(PyObject *module);

/**
 * Forward declarations for top-level class Triangulator
 */
typedef Triangulator Triangulator_localtype;
Define_Module_Class(panda3d.core, Triangulator, Triangulator_localtype, Triangulator);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Triangulator = &Dtool_Triangulator;
static void Dtool_PyModuleClassInit_Triangulator(PyObject *module);

/**
 * Forward declarations for top-level class Triangulator3
 */
typedef Triangulator3 Triangulator3_localtype;
Define_Module_Class(panda3d.core, Triangulator3, Triangulator3_localtype, Triangulator3);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Triangulator3 = &Dtool_Triangulator3;
static void Dtool_PyModuleClassInit_Triangulator3(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"ConstPointerToArray< LMatrix3d >", &Dtool_ConstPointerToArray_LMatrix3d},
  {"PointerToArrayBase< LMatrix3d >", &Dtool_PointerToArrayBase_LMatrix3d},
  {"PointerToBase< ReferenceCountedVector< LMatrix3d > >", &Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d},
  {"ConstPointerToArray< LMatrix3f >", &Dtool_ConstPointerToArray_LMatrix3f},
  {"PointerToArrayBase< LMatrix3f >", &Dtool_PointerToArrayBase_LMatrix3f},
  {"PointerToBase< ReferenceCountedVector< LMatrix3f > >", &Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f},
  {"ConstPointerToArray< LVecBase2d >", &Dtool_ConstPointerToArray_LVecBase2d},
  {"PointerToArrayBase< LVecBase2d >", &Dtool_PointerToArrayBase_LVecBase2d},
  {"PointerToBase< ReferenceCountedVector< LVecBase2d > >", &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d},
  {"ConstPointerToArray< LVecBase2f >", &Dtool_ConstPointerToArray_LVecBase2f},
  {"PointerToArrayBase< LVecBase2f >", &Dtool_PointerToArrayBase_LVecBase2f},
  {"PointerToBase< ReferenceCountedVector< LVecBase2f > >", &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f},
  {"ConstPointerToArray< LVecBase2i >", &Dtool_ConstPointerToArray_LVecBase2i},
  {"PointerToArrayBase< LVecBase2i >", &Dtool_PointerToArrayBase_LVecBase2i},
  {"PointerToBase< ReferenceCountedVector< LVecBase2i > >", &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i},
  {"ConstPointerToArray< LVecBase3d >", &Dtool_ConstPointerToArray_LVecBase3d},
  {"PointerToArrayBase< LVecBase3d >", &Dtool_PointerToArrayBase_LVecBase3d},
  {"PointerToBase< ReferenceCountedVector< LVecBase3d > >", &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d},
  {"ConstPointerToArray< LVecBase3f >", &Dtool_ConstPointerToArray_LVecBase3f},
  {"PointerToArrayBase< LVecBase3f >", &Dtool_PointerToArrayBase_LVecBase3f},
  {"PointerToBase< ReferenceCountedVector< LVecBase3f > >", &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f},
  {"ConstPointerToArray< LVecBase3i >", &Dtool_ConstPointerToArray_LVecBase3i},
  {"PointerToArrayBase< LVecBase3i >", &Dtool_PointerToArrayBase_LVecBase3i},
  {"PointerToBase< ReferenceCountedVector< LVecBase3i > >", &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i},
  {"ConstPointerToArray< UnalignedLMatrix4d >", &Dtool_ConstPointerToArray_UnalignedLMatrix4d},
  {"PointerToArrayBase< UnalignedLMatrix4d >", &Dtool_PointerToArrayBase_UnalignedLMatrix4d},
  {"PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > >", &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d},
  {"ConstPointerToArray< UnalignedLMatrix4f >", &Dtool_ConstPointerToArray_UnalignedLMatrix4f},
  {"PointerToArrayBase< UnalignedLMatrix4f >", &Dtool_PointerToArrayBase_UnalignedLMatrix4f},
  {"PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > >", &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f},
  {"ConstPointerToArray< UnalignedLVecBase4d >", &Dtool_ConstPointerToArray_UnalignedLVecBase4d},
  {"PointerToArrayBase< UnalignedLVecBase4d >", &Dtool_PointerToArrayBase_UnalignedLVecBase4d},
  {"PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > >", &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d},
  {"ConstPointerToArray< UnalignedLVecBase4f >", &Dtool_ConstPointerToArray_UnalignedLVecBase4f},
  {"PointerToArrayBase< UnalignedLVecBase4f >", &Dtool_PointerToArrayBase_UnalignedLVecBase4f},
  {"PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > >", &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f},
  {"ConstPointerToArray< UnalignedLVecBase4i >", &Dtool_ConstPointerToArray_UnalignedLVecBase4i},
  {"PointerToArrayBase< UnalignedLVecBase4i >", &Dtool_PointerToArrayBase_UnalignedLVecBase4i},
  {"PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > >", &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i},
  {"PointerToArray< LMatrix3d >", &Dtool_PointerToArray_LMatrix3d},
  {"PointerToArray< LMatrix3f >", &Dtool_PointerToArray_LMatrix3f},
  {"PointerToArray< LVecBase2d >", &Dtool_PointerToArray_LVecBase2d},
  {"PointerToArray< LVecBase2f >", &Dtool_PointerToArray_LVecBase2f},
  {"PointerToArray< LVecBase2i >", &Dtool_PointerToArray_LVecBase2i},
  {"PointerToArray< LVecBase3d >", &Dtool_PointerToArray_LVecBase3d},
  {"PointerToArray< LVecBase3f >", &Dtool_PointerToArray_LVecBase3f},
  {"PointerToArray< LVecBase3i >", &Dtool_PointerToArray_LVecBase3i},
  {"PointerToArray< UnalignedLMatrix4d >", &Dtool_PointerToArray_UnalignedLMatrix4d},
  {"PointerToArray< UnalignedLMatrix4f >", &Dtool_PointerToArray_UnalignedLMatrix4f},
  {"PointerToArray< UnalignedLVecBase4d >", &Dtool_PointerToArray_UnalignedLVecBase4d},
  {"PointerToArray< UnalignedLVecBase4f >", &Dtool_PointerToArray_UnalignedLVecBase4f},
  {"PointerToArray< UnalignedLVecBase4i >", &Dtool_PointerToArray_UnalignedLVecBase4i},
  {"BoundingVolume", &Dtool_BoundingVolume},
  {"GeometricBoundingVolume", &Dtool_GeometricBoundingVolume},
  {"FiniteBoundingVolume", &Dtool_FiniteBoundingVolume},
  {"LParabolaf", &Dtool_LParabolaf},
  {"LParabolad", &Dtool_LParabolad},
  {"LPlanef", &Dtool_LPlanef},
  {"LPlaned", &Dtool_LPlaned},
  {"BoundingBox", &Dtool_BoundingBox},
  {"LFrustumf", &Dtool_LFrustumf},
  {"LFrustumd", &Dtool_LFrustumd},
  {"BoundingHexahedron", &Dtool_BoundingHexahedron},
  {"BoundingLine", &Dtool_BoundingLine},
  {"BoundingPlane", &Dtool_BoundingPlane},
  {"BoundingSphere", &Dtool_BoundingSphere},
  {"IntersectionBoundingVolume", &Dtool_IntersectionBoundingVolume},
  {"Mersenne", &Dtool_Mersenne},
  {"OmniBoundingVolume", &Dtool_OmniBoundingVolume},
  {"UnionBoundingVolume", &Dtool_UnionBoundingVolume},
  {"Randomizer", &Dtool_Randomizer},
  {"PerlinNoise", &Dtool_PerlinNoise},
  {"PerlinNoise2", &Dtool_PerlinNoise2},
  {"PerlinNoise3", &Dtool_PerlinNoise3},
  {"StackedPerlinNoise2", &Dtool_StackedPerlinNoise2},
  {"StackedPerlinNoise3", &Dtool_StackedPerlinNoise3},
  {"Triangulator", &Dtool_Triangulator},
  {"Triangulator3", &Dtool_Triangulator3},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"std::ostream", nullptr},
#define Dtool_Ptr_std_ostream (imports[0].type)
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[1].type)
  {"TypedObject", nullptr},
#define Dtool_Ptr_TypedObject (imports[2].type)
  {"ReferenceCount", nullptr},
#define Dtool_Ptr_ReferenceCount (imports[3].type)
  {"TypedReferenceCount", nullptr},
#define Dtool_Ptr_TypedReferenceCount (imports[4].type)
  {"PointerToVoid", nullptr},
#define Dtool_Ptr_PointerToVoid (imports[5].type)
  {"Datagram", nullptr},
#define Dtool_Ptr_Datagram (imports[6].type)
  {"DatagramIterator", nullptr},
#define Dtool_Ptr_DatagramIterator (imports[7].type)
  {"LVecBase2f", nullptr},
#define Dtool_Ptr_LVecBase2f (imports[8].type)
  {"LVecBase2d", nullptr},
#define Dtool_Ptr_LVecBase2d (imports[9].type)
  {"LVecBase2i", nullptr},
#define Dtool_Ptr_LVecBase2i (imports[10].type)
  {"LPoint2d", nullptr},
#define Dtool_Ptr_LPoint2d (imports[11].type)
  {"LVecBase3f", nullptr},
#define Dtool_Ptr_LVecBase3f (imports[12].type)
  {"LVecBase3d", nullptr},
#define Dtool_Ptr_LVecBase3d (imports[13].type)
  {"LVecBase3i", nullptr},
#define Dtool_Ptr_LVecBase3i (imports[14].type)
  {"LVector3f", nullptr},
#define Dtool_Ptr_LVector3f (imports[15].type)
  {"LVector3d", nullptr},
#define Dtool_Ptr_LVector3d (imports[16].type)
  {"LPoint3f", nullptr},
#define Dtool_Ptr_LPoint3f (imports[17].type)
  {"LPoint3d", nullptr},
#define Dtool_Ptr_LPoint3d (imports[18].type)
  {"LVecBase4f", nullptr},
#define Dtool_Ptr_LVecBase4f (imports[19].type)
  {"UnalignedLVecBase4f", nullptr},
#define Dtool_Ptr_UnalignedLVecBase4f (imports[20].type)
  {"LVecBase4d", nullptr},
#define Dtool_Ptr_LVecBase4d (imports[21].type)
  {"UnalignedLVecBase4d", nullptr},
#define Dtool_Ptr_UnalignedLVecBase4d (imports[22].type)
  {"UnalignedLVecBase4i", nullptr},
#define Dtool_Ptr_UnalignedLVecBase4i (imports[23].type)
  {"LMatrix3f", nullptr},
#define Dtool_Ptr_LMatrix3f (imports[24].type)
  {"LMatrix4f", nullptr},
#define Dtool_Ptr_LMatrix4f (imports[25].type)
  {"UnalignedLMatrix4f", nullptr},
#define Dtool_Ptr_UnalignedLMatrix4f (imports[26].type)
  {"LMatrix3d", nullptr},
#define Dtool_Ptr_LMatrix3d (imports[27].type)
  {"LMatrix4d", nullptr},
#define Dtool_Ptr_LMatrix4d (imports[28].type)
  {"UnalignedLMatrix4d", nullptr},
#define Dtool_Ptr_UnalignedLMatrix4d (imports[29].type)
  {"LQuaternionf", nullptr},
#define Dtool_Ptr_LQuaternionf (imports[30].type)
  {"LQuaterniond", nullptr},
#define Dtool_Ptr_LQuaterniond (imports[31].type)
  {nullptr, nullptr},
};
#endif

// std::ostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// PointerToVoid
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_PointerToVoid;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToVoid = &Dtool_PointerToVoid;
#endif
// Datagram
#ifndef LINK_ALL_STATIC
inline static Datagram *Dtool_Coerce_Datagram(PyObject *args, Datagram &coerced) {
  nassertr(Dtool_Ptr_Datagram != nullptr, nullptr);
  nassertr(Dtool_Ptr_Datagram->_Dtool_Coerce != nullptr, nullptr);
  return ((Datagram *(*)(PyObject *, Datagram &))Dtool_Ptr_Datagram->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Datagram;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Datagram = &Dtool_Datagram;
extern Datagram *Dtool_Coerce_Datagram(PyObject *args, Datagram &coerced);
#endif
// DatagramIterator
#ifndef LINK_ALL_STATIC
inline static DatagramIterator *Dtool_Coerce_DatagramIterator(PyObject *args, DatagramIterator &coerced) {
  nassertr(Dtool_Ptr_DatagramIterator != nullptr, nullptr);
  nassertr(Dtool_Ptr_DatagramIterator->_Dtool_Coerce != nullptr, nullptr);
  return ((DatagramIterator *(*)(PyObject *, DatagramIterator &))Dtool_Ptr_DatagramIterator->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_DatagramIterator;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramIterator = &Dtool_DatagramIterator;
extern DatagramIterator *Dtool_Coerce_DatagramIterator(PyObject *args, DatagramIterator &coerced);
#endif
// LVecBase2f
#ifndef LINK_ALL_STATIC
inline static LVecBase2f *Dtool_Coerce_LVecBase2f(PyObject *args, LVecBase2f &coerced) {
  nassertr(Dtool_Ptr_LVecBase2f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase2f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase2f *(*)(PyObject *, LVecBase2f &))Dtool_Ptr_LVecBase2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2f = &Dtool_LVecBase2f;
extern LVecBase2f *Dtool_Coerce_LVecBase2f(PyObject *args, LVecBase2f &coerced);
#endif
// LVecBase2d
#ifndef LINK_ALL_STATIC
inline static LVecBase2d *Dtool_Coerce_LVecBase2d(PyObject *args, LVecBase2d &coerced) {
  nassertr(Dtool_Ptr_LVecBase2d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase2d->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase2d *(*)(PyObject *, LVecBase2d &))Dtool_Ptr_LVecBase2d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2d = &Dtool_LVecBase2d;
extern LVecBase2d *Dtool_Coerce_LVecBase2d(PyObject *args, LVecBase2d &coerced);
#endif
// LVecBase2i
#ifndef LINK_ALL_STATIC
inline static LVecBase2i *Dtool_Coerce_LVecBase2i(PyObject *args, LVecBase2i &coerced) {
  nassertr(Dtool_Ptr_LVecBase2i != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase2i->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase2i *(*)(PyObject *, LVecBase2i &))Dtool_Ptr_LVecBase2i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2i = &Dtool_LVecBase2i;
extern LVecBase2i *Dtool_Coerce_LVecBase2i(PyObject *args, LVecBase2i &coerced);
#endif
// LPoint2d
#ifndef LINK_ALL_STATIC
inline static LPoint2d *Dtool_Coerce_LPoint2d(PyObject *args, LPoint2d &coerced) {
  nassertr(Dtool_Ptr_LPoint2d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint2d->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint2d *(*)(PyObject *, LPoint2d &))Dtool_Ptr_LPoint2d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint2d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint2d = &Dtool_LPoint2d;
extern LPoint2d *Dtool_Coerce_LPoint2d(PyObject *args, LPoint2d &coerced);
#endif
// LVecBase3f
#ifndef LINK_ALL_STATIC
inline static LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  nassertr(Dtool_Ptr_LVecBase3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase3f *(*)(PyObject *, LVecBase3f &))Dtool_Ptr_LVecBase3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
extern LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);
#endif
// LVecBase3d
#ifndef LINK_ALL_STATIC
inline static LVecBase3d *Dtool_Coerce_LVecBase3d(PyObject *args, LVecBase3d &coerced) {
  nassertr(Dtool_Ptr_LVecBase3d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase3d->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase3d *(*)(PyObject *, LVecBase3d &))Dtool_Ptr_LVecBase3d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3d = &Dtool_LVecBase3d;
extern LVecBase3d *Dtool_Coerce_LVecBase3d(PyObject *args, LVecBase3d &coerced);
#endif
// LVecBase3i
#ifndef LINK_ALL_STATIC
inline static LVecBase3i *Dtool_Coerce_LVecBase3i(PyObject *args, LVecBase3i &coerced) {
  nassertr(Dtool_Ptr_LVecBase3i != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase3i->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase3i *(*)(PyObject *, LVecBase3i &))Dtool_Ptr_LVecBase3i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3i = &Dtool_LVecBase3i;
extern LVecBase3i *Dtool_Coerce_LVecBase3i(PyObject *args, LVecBase3i &coerced);
#endif
// LVector3f
#ifndef LINK_ALL_STATIC
inline static LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced) {
  nassertr(Dtool_Ptr_LVector3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVector3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVector3f *(*)(PyObject *, LVector3f &))Dtool_Ptr_LVector3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector3f = &Dtool_LVector3f;
extern LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced);
#endif
// LVector3d
#ifndef LINK_ALL_STATIC
inline static LVector3d *Dtool_Coerce_LVector3d(PyObject *args, LVector3d &coerced) {
  nassertr(Dtool_Ptr_LVector3d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVector3d->_Dtool_Coerce != nullptr, nullptr);
  return ((LVector3d *(*)(PyObject *, LVector3d &))Dtool_Ptr_LVector3d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector3d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector3d = &Dtool_LVector3d;
extern LVector3d *Dtool_Coerce_LVector3d(PyObject *args, LVector3d &coerced);
#endif
// LPoint3f
#ifndef LINK_ALL_STATIC
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif
// LPoint3d
#ifndef LINK_ALL_STATIC
inline static LPoint3d *Dtool_Coerce_LPoint3d(PyObject *args, LPoint3d &coerced) {
  nassertr(Dtool_Ptr_LPoint3d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint3d->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint3d *(*)(PyObject *, LPoint3d &))Dtool_Ptr_LPoint3d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3d = &Dtool_LPoint3d;
extern LPoint3d *Dtool_Coerce_LPoint3d(PyObject *args, LPoint3d &coerced);
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// UnalignedLVecBase4f
#ifndef LINK_ALL_STATIC
inline static UnalignedLVecBase4f *Dtool_Coerce_UnalignedLVecBase4f(PyObject *args, UnalignedLVecBase4f &coerced) {
  nassertr(Dtool_Ptr_UnalignedLVecBase4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_UnalignedLVecBase4f->_Dtool_Coerce != nullptr, nullptr);
  return ((UnalignedLVecBase4f *(*)(PyObject *, UnalignedLVecBase4f &))Dtool_Ptr_UnalignedLVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_UnalignedLVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_UnalignedLVecBase4f = &Dtool_UnalignedLVecBase4f;
extern UnalignedLVecBase4f *Dtool_Coerce_UnalignedLVecBase4f(PyObject *args, UnalignedLVecBase4f &coerced);
#endif
// LVecBase4d
#ifndef LINK_ALL_STATIC
inline static LVecBase4d *Dtool_Coerce_LVecBase4d(PyObject *args, LVecBase4d &coerced) {
  nassertr(Dtool_Ptr_LVecBase4d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase4d->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase4d *(*)(PyObject *, LVecBase4d &))Dtool_Ptr_LVecBase4d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4d = &Dtool_LVecBase4d;
extern LVecBase4d *Dtool_Coerce_LVecBase4d(PyObject *args, LVecBase4d &coerced);
#endif
// UnalignedLVecBase4d
#ifndef LINK_ALL_STATIC
inline static UnalignedLVecBase4d *Dtool_Coerce_UnalignedLVecBase4d(PyObject *args, UnalignedLVecBase4d &coerced) {
  nassertr(Dtool_Ptr_UnalignedLVecBase4d != nullptr, nullptr);
  nassertr(Dtool_Ptr_UnalignedLVecBase4d->_Dtool_Coerce != nullptr, nullptr);
  return ((UnalignedLVecBase4d *(*)(PyObject *, UnalignedLVecBase4d &))Dtool_Ptr_UnalignedLVecBase4d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_UnalignedLVecBase4d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_UnalignedLVecBase4d = &Dtool_UnalignedLVecBase4d;
extern UnalignedLVecBase4d *Dtool_Coerce_UnalignedLVecBase4d(PyObject *args, UnalignedLVecBase4d &coerced);
#endif
// UnalignedLVecBase4i
#ifndef LINK_ALL_STATIC
inline static UnalignedLVecBase4i *Dtool_Coerce_UnalignedLVecBase4i(PyObject *args, UnalignedLVecBase4i &coerced) {
  nassertr(Dtool_Ptr_UnalignedLVecBase4i != nullptr, nullptr);
  nassertr(Dtool_Ptr_UnalignedLVecBase4i->_Dtool_Coerce != nullptr, nullptr);
  return ((UnalignedLVecBase4i *(*)(PyObject *, UnalignedLVecBase4i &))Dtool_Ptr_UnalignedLVecBase4i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_UnalignedLVecBase4i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_UnalignedLVecBase4i = &Dtool_UnalignedLVecBase4i;
extern UnalignedLVecBase4i *Dtool_Coerce_UnalignedLVecBase4i(PyObject *args, UnalignedLVecBase4i &coerced);
#endif
// LMatrix3f
#ifndef LINK_ALL_STATIC
inline static LMatrix3f *Dtool_Coerce_LMatrix3f(PyObject *args, LMatrix3f &coerced) {
  nassertr(Dtool_Ptr_LMatrix3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LMatrix3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LMatrix3f *(*)(PyObject *, LMatrix3f &))Dtool_Ptr_LMatrix3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix3f = &Dtool_LMatrix3f;
extern LMatrix3f *Dtool_Coerce_LMatrix3f(PyObject *args, LMatrix3f &coerced);
#endif
// LMatrix4f
#ifndef LINK_ALL_STATIC
inline static LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced) {
  nassertr(Dtool_Ptr_LMatrix4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LMatrix4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LMatrix4f *(*)(PyObject *, LMatrix4f &))Dtool_Ptr_LMatrix4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4f = &Dtool_LMatrix4f;
extern LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced);
#endif
// UnalignedLMatrix4f
#ifndef LINK_ALL_STATIC
inline static UnalignedLMatrix4f *Dtool_Coerce_UnalignedLMatrix4f(PyObject *args, UnalignedLMatrix4f &coerced) {
  nassertr(Dtool_Ptr_UnalignedLMatrix4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_UnalignedLMatrix4f->_Dtool_Coerce != nullptr, nullptr);
  return ((UnalignedLMatrix4f *(*)(PyObject *, UnalignedLMatrix4f &))Dtool_Ptr_UnalignedLMatrix4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_UnalignedLMatrix4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_UnalignedLMatrix4f = &Dtool_UnalignedLMatrix4f;
extern UnalignedLMatrix4f *Dtool_Coerce_UnalignedLMatrix4f(PyObject *args, UnalignedLMatrix4f &coerced);
#endif
// LMatrix3d
#ifndef LINK_ALL_STATIC
inline static LMatrix3d *Dtool_Coerce_LMatrix3d(PyObject *args, LMatrix3d &coerced) {
  nassertr(Dtool_Ptr_LMatrix3d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LMatrix3d->_Dtool_Coerce != nullptr, nullptr);
  return ((LMatrix3d *(*)(PyObject *, LMatrix3d &))Dtool_Ptr_LMatrix3d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix3d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix3d = &Dtool_LMatrix3d;
extern LMatrix3d *Dtool_Coerce_LMatrix3d(PyObject *args, LMatrix3d &coerced);
#endif
// LMatrix4d
#ifndef LINK_ALL_STATIC
inline static LMatrix4d *Dtool_Coerce_LMatrix4d(PyObject *args, LMatrix4d &coerced) {
  nassertr(Dtool_Ptr_LMatrix4d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LMatrix4d->_Dtool_Coerce != nullptr, nullptr);
  return ((LMatrix4d *(*)(PyObject *, LMatrix4d &))Dtool_Ptr_LMatrix4d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4d = &Dtool_LMatrix4d;
extern LMatrix4d *Dtool_Coerce_LMatrix4d(PyObject *args, LMatrix4d &coerced);
#endif
// UnalignedLMatrix4d
#ifndef LINK_ALL_STATIC
inline static UnalignedLMatrix4d *Dtool_Coerce_UnalignedLMatrix4d(PyObject *args, UnalignedLMatrix4d &coerced) {
  nassertr(Dtool_Ptr_UnalignedLMatrix4d != nullptr, nullptr);
  nassertr(Dtool_Ptr_UnalignedLMatrix4d->_Dtool_Coerce != nullptr, nullptr);
  return ((UnalignedLMatrix4d *(*)(PyObject *, UnalignedLMatrix4d &))Dtool_Ptr_UnalignedLMatrix4d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_UnalignedLMatrix4d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_UnalignedLMatrix4d = &Dtool_UnalignedLMatrix4d;
extern UnalignedLMatrix4d *Dtool_Coerce_UnalignedLMatrix4d(PyObject *args, UnalignedLMatrix4d &coerced);
#endif
// LQuaternionf
#ifndef LINK_ALL_STATIC
inline static LQuaternionf *Dtool_Coerce_LQuaternionf(PyObject *args, LQuaternionf &coerced) {
  nassertr(Dtool_Ptr_LQuaternionf != nullptr, nullptr);
  nassertr(Dtool_Ptr_LQuaternionf->_Dtool_Coerce != nullptr, nullptr);
  return ((LQuaternionf *(*)(PyObject *, LQuaternionf &))Dtool_Ptr_LQuaternionf->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LQuaternionf;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LQuaternionf = &Dtool_LQuaternionf;
extern LQuaternionf *Dtool_Coerce_LQuaternionf(PyObject *args, LQuaternionf &coerced);
#endif
// LQuaterniond
#ifndef LINK_ALL_STATIC
inline static LQuaterniond *Dtool_Coerce_LQuaterniond(PyObject *args, LQuaterniond &coerced) {
  nassertr(Dtool_Ptr_LQuaterniond != nullptr, nullptr);
  nassertr(Dtool_Ptr_LQuaterniond->_Dtool_Coerce != nullptr, nullptr);
  return ((LQuaterniond *(*)(PyObject *, LQuaterniond &))Dtool_Ptr_LQuaterniond->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LQuaterniond;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LQuaterniond = &Dtool_LQuaterniond;
extern LQuaterniond *Dtool_Coerce_LQuaterniond(PyObject *args, LQuaterniond &coerced);
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python function wrapper for:
 * inline void heads_up(LMatrix3d &mat, LVector3d const &fwd, CoordinateSystem cs)
 * void heads_up(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up = LVector3d::up(), CoordinateSystem cs = ::CS_default)
 * inline void heads_up(LMatrix3f &mat, LVector3f const &fwd, CoordinateSystem cs)
 * void heads_up(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up = LVector3f::up(), CoordinateSystem cs = ::CS_default)
 * inline void heads_up(LMatrix4d &mat, LVector3d const &fwd, CoordinateSystem cs)
 * inline void heads_up(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up = LVector3d::up(), CoordinateSystem cs = ::CS_default)
 * inline void heads_up(LMatrix4f &mat, LVector3f const &fwd, CoordinateSystem cs)
 * inline void heads_up(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up = LVector3f::up(), CoordinateSystem cs = ::CS_default)
 * inline void heads_up(LQuaterniond &quat, LVector3d const &fwd, CoordinateSystem cs)
 * inline void heads_up(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up = LVector3d::up(), CoordinateSystem cs = ::CS_default)
 * inline void heads_up(LQuaternionf &quat, LVector3f const &fwd, CoordinateSystem cs)
 * inline void heads_up(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up = LVector3f::up(), CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_heads_up_730(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      {
        // -2 void heads_up(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:heads_up", (char **)keyword_list, &param0, &param1)) {
          LMatrix3d *param0_this = (LMatrix3d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3d, 0, "heads_up", false, false);
          LVector3d const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3d);
          if (param0_this != nullptr && param1_this != nullptr) {
            (::heads_up)(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void heads_up(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:heads_up", (char **)keyword_list, &param0, &param1)) {
          LMatrix3f *param0_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3f, 0, "heads_up", false, false);
          LVector3f const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3f);
          if (param0_this != nullptr && param1_this != nullptr) {
            (::heads_up)(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:heads_up", (char **)keyword_list, &param0, &param1)) {
          LMatrix4d *param0_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4d, 0, "heads_up", false, false);
          LVector3d const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3d);
          if (param0_this != nullptr && param1_this != nullptr) {
            (::heads_up)(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:heads_up", (char **)keyword_list, &param0, &param1)) {
          LMatrix4f *param0_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4f, 0, "heads_up", false, false);
          LVector3f const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3f);
          if (param0_this != nullptr && param1_this != nullptr) {
            (::heads_up)(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"quat", "fwd", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:heads_up", (char **)keyword_list, &param0, &param1)) {
          LQuaterniond *param0_this = (LQuaterniond *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LQuaterniond, 0, "heads_up", false, false);
          LVector3d const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3d);
          if (param0_this != nullptr && param1_this != nullptr) {
            (::heads_up)(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"quat", "fwd", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:heads_up", (char **)keyword_list, &param0, &param1)) {
          LQuaternionf *param0_this = (LQuaternionf *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LQuaternionf, 0, "heads_up", false, false);
          LVector3f const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3f);
          if (param0_this != nullptr && param1_this != nullptr) {
            (::heads_up)(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void heads_up(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:heads_up", (char **)keyword_list, &param0, &param1)) {
          LMatrix3d param0_local;
          LMatrix3d *param0_this = Dtool_Coerce_LMatrix3d(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          if ((param0_this != nullptr) && (param1_this != nullptr)) {
            (::heads_up)(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void heads_up(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:heads_up", (char **)keyword_list, &param0, &param1)) {
          LMatrix3f param0_local;
          LMatrix3f *param0_this = Dtool_Coerce_LMatrix3f(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          if ((param0_this != nullptr) && (param1_this != nullptr)) {
            (::heads_up)(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:heads_up", (char **)keyword_list, &param0, &param1)) {
          LMatrix4d param0_local;
          LMatrix4d *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          if ((param0_this != nullptr) && (param1_this != nullptr)) {
            (::heads_up)(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:heads_up", (char **)keyword_list, &param0, &param1)) {
          LMatrix4f param0_local;
          LMatrix4f *param0_this = Dtool_Coerce_LMatrix4f(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          if ((param0_this != nullptr) && (param1_this != nullptr)) {
            (::heads_up)(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"quat", "fwd", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:heads_up", (char **)keyword_list, &param0, &param1)) {
          LQuaterniond param0_local;
          LQuaterniond *param0_this = Dtool_Coerce_LQuaterniond(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          if ((param0_this != nullptr) && (param1_this != nullptr)) {
            (::heads_up)(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"quat", "fwd", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:heads_up", (char **)keyword_list, &param0, &param1)) {
          LQuaternionf param0_local;
          LQuaternionf *param0_this = Dtool_Coerce_LQuaternionf(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          if ((param0_this != nullptr) && (param1_this != nullptr)) {
            (::heads_up)(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 3:
  case 4:
    {
      {
        // -2 void heads_up(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:heads_up", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3d *param0_this = (LMatrix3d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3d, 0, "heads_up", false, false);
          LVector3d const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3d);
          LVector3d const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVector3d);
          if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
            (::heads_up)(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void heads_up(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:heads_up", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3f *param0_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3f, 0, "heads_up", false, false);
          LVector3f const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3f);
          LVector3f const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVector3f);
          if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
            (::heads_up)(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:heads_up", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix4d *param0_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4d, 0, "heads_up", false, false);
          LVector3d const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3d);
          LVector3d const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVector3d);
          if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
            (::heads_up)(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:heads_up", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix4f *param0_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4f, 0, "heads_up", false, false);
          LVector3f const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3f);
          LVector3f const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVector3f);
          if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
            (::heads_up)(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"quat", "fwd", "up", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:heads_up", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LQuaterniond *param0_this = (LQuaterniond *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LQuaterniond, 0, "heads_up", false, false);
          LVector3d const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3d);
          LVector3d const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVector3d);
          if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
            (::heads_up)(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"quat", "fwd", "up", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:heads_up", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LQuaternionf *param0_this = (LQuaternionf *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LQuaternionf, 0, "heads_up", false, false);
          LVector3f const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3f);
          LVector3f const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVector3f);
          if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
            (::heads_up)(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix3d &mat, LVector3d const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:heads_up", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix3d *param0_this = (LMatrix3d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3d, 0, "heads_up", false, false);
          LVector3d const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3d);
          if (param0_this != nullptr && param1_this != nullptr) {
            (::heads_up)(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix3f &mat, LVector3f const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:heads_up", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix3f *param0_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3f, 0, "heads_up", false, false);
          LVector3f const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3f);
          if (param0_this != nullptr && param1_this != nullptr) {
            (::heads_up)(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix4d &mat, LVector3d const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:heads_up", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix4d *param0_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4d, 0, "heads_up", false, false);
          LVector3d const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3d);
          if (param0_this != nullptr && param1_this != nullptr) {
            (::heads_up)(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix4f &mat, LVector3f const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:heads_up", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix4f *param0_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4f, 0, "heads_up", false, false);
          LVector3f const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3f);
          if (param0_this != nullptr && param1_this != nullptr) {
            (::heads_up)(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LQuaterniond &quat, LVector3d const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"quat", "fwd", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:heads_up", (char **)keyword_list, &param0, &param1, &param2)) {
          LQuaterniond *param0_this = (LQuaterniond *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LQuaterniond, 0, "heads_up", false, false);
          LVector3d const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3d);
          if (param0_this != nullptr && param1_this != nullptr) {
            (::heads_up)(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LQuaternionf &quat, LVector3f const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"quat", "fwd", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:heads_up", (char **)keyword_list, &param0, &param1, &param2)) {
          LQuaternionf *param0_this = (LQuaternionf *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LQuaternionf, 0, "heads_up", false, false);
          LVector3f const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3f);
          if (param0_this != nullptr && param1_this != nullptr) {
            (::heads_up)(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void heads_up(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:heads_up", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3d param0_local;
          LMatrix3d *param0_this = Dtool_Coerce_LMatrix3d(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          LVector3d param2_local;
          LVector3d const *param2_this = Dtool_Coerce_LVector3d(param2, param2_local);
          if ((param0_this != nullptr) && (param1_this != nullptr) && (param2_this != nullptr)) {
            (::heads_up)(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void heads_up(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:heads_up", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3f param0_local;
          LMatrix3f *param0_this = Dtool_Coerce_LMatrix3f(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          LVector3f param2_local;
          LVector3f const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
          if ((param0_this != nullptr) && (param1_this != nullptr) && (param2_this != nullptr)) {
            (::heads_up)(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:heads_up", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix4d param0_local;
          LMatrix4d *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          LVector3d param2_local;
          LVector3d const *param2_this = Dtool_Coerce_LVector3d(param2, param2_local);
          if ((param0_this != nullptr) && (param1_this != nullptr) && (param2_this != nullptr)) {
            (::heads_up)(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:heads_up", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix4f param0_local;
          LMatrix4f *param0_this = Dtool_Coerce_LMatrix4f(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          LVector3f param2_local;
          LVector3f const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
          if ((param0_this != nullptr) && (param1_this != nullptr) && (param2_this != nullptr)) {
            (::heads_up)(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"quat", "fwd", "up", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:heads_up", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LQuaterniond param0_local;
          LQuaterniond *param0_this = Dtool_Coerce_LQuaterniond(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          LVector3d param2_local;
          LVector3d const *param2_this = Dtool_Coerce_LVector3d(param2, param2_local);
          if ((param0_this != nullptr) && (param1_this != nullptr) && (param2_this != nullptr)) {
            (::heads_up)(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"quat", "fwd", "up", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:heads_up", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LQuaternionf param0_local;
          LQuaternionf *param0_this = Dtool_Coerce_LQuaternionf(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          LVector3f param2_local;
          LVector3f const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
          if ((param0_this != nullptr) && (param1_this != nullptr) && (param2_this != nullptr)) {
            (::heads_up)(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix3d &mat, LVector3d const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:heads_up", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix3d param0_local;
          LMatrix3d *param0_this = Dtool_Coerce_LMatrix3d(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          if ((param0_this != nullptr) && (param1_this != nullptr)) {
            (::heads_up)(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix3f &mat, LVector3f const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:heads_up", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix3f param0_local;
          LMatrix3f *param0_this = Dtool_Coerce_LMatrix3f(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          if ((param0_this != nullptr) && (param1_this != nullptr)) {
            (::heads_up)(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix4d &mat, LVector3d const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:heads_up", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix4d param0_local;
          LMatrix4d *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          if ((param0_this != nullptr) && (param1_this != nullptr)) {
            (::heads_up)(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LMatrix4f &mat, LVector3f const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:heads_up", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix4f param0_local;
          LMatrix4f *param0_this = Dtool_Coerce_LMatrix4f(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          if ((param0_this != nullptr) && (param1_this != nullptr)) {
            (::heads_up)(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LQuaterniond &quat, LVector3d const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"quat", "fwd", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:heads_up", (char **)keyword_list, &param0, &param1, &param2)) {
          LQuaterniond param0_local;
          LQuaterniond *param0_this = Dtool_Coerce_LQuaterniond(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          if ((param0_this != nullptr) && (param1_this != nullptr)) {
            (::heads_up)(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void heads_up(LQuaternionf &quat, LVector3f const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"quat", "fwd", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:heads_up", (char **)keyword_list, &param0, &param1, &param2)) {
          LQuaternionf param0_local;
          LQuaternionf *param0_this = Dtool_Coerce_LQuaternionf(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          if ((param0_this != nullptr) && (param1_this != nullptr)) {
            (::heads_up)(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "heads_up() takes 2, 3 or 4 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "heads_up(LMatrix3d mat, const LVector3d fwd)\n"
      "heads_up(LMatrix3f mat, const LVector3f fwd)\n"
      "heads_up(LMatrix4d mat, const LVector3d fwd)\n"
      "heads_up(LMatrix4f mat, const LVector3f fwd)\n"
      "heads_up(LQuaterniond quat, const LVector3d fwd)\n"
      "heads_up(LQuaternionf quat, const LVector3f fwd)\n"
      "heads_up(LMatrix3d mat, const LVector3d fwd, const LVector3d up, int cs)\n"
      "heads_up(LMatrix3f mat, const LVector3f fwd, const LVector3f up, int cs)\n"
      "heads_up(LMatrix4d mat, const LVector3d fwd, const LVector3d up, int cs)\n"
      "heads_up(LMatrix4f mat, const LVector3f fwd, const LVector3f up, int cs)\n"
      "heads_up(LQuaterniond quat, const LVector3d fwd, const LVector3d up, int cs)\n"
      "heads_up(LQuaternionf quat, const LVector3f fwd, const LVector3f up, int cs)\n"
      "heads_up(LMatrix3d mat, const LVector3d fwd, int cs)\n"
      "heads_up(LMatrix3f mat, const LVector3f fwd, int cs)\n"
      "heads_up(LMatrix4d mat, const LVector3d fwd, int cs)\n"
      "heads_up(LMatrix4f mat, const LVector3f fwd, int cs)\n"
      "heads_up(LQuaterniond quat, const LVector3d fwd, int cs)\n"
      "heads_up(LQuaternionf quat, const LVector3f fwd, int cs)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_heads_up_730_comment =
  "C++ Interface:\n"
  "heads_up(LMatrix3d mat, const LVector3d fwd)\n"
  "heads_up(LMatrix3f mat, const LVector3f fwd)\n"
  "heads_up(LMatrix4d mat, const LVector3d fwd)\n"
  "heads_up(LMatrix4f mat, const LVector3f fwd)\n"
  "heads_up(LQuaterniond quat, const LVector3d fwd)\n"
  "heads_up(LQuaternionf quat, const LVector3f fwd)\n"
  "heads_up(LMatrix3d mat, const LVector3d fwd, const LVector3d up, int cs)\n"
  "heads_up(LMatrix3f mat, const LVector3f fwd, const LVector3f up, int cs)\n"
  "heads_up(LMatrix4d mat, const LVector3d fwd, const LVector3d up, int cs)\n"
  "heads_up(LMatrix4f mat, const LVector3f fwd, const LVector3f up, int cs)\n"
  "heads_up(LQuaterniond quat, const LVector3d fwd, const LVector3d up, int cs)\n"
  "heads_up(LQuaternionf quat, const LVector3f fwd, const LVector3f up, int cs)\n"
  "heads_up(LMatrix3d mat, const LVector3d fwd, int cs)\n"
  "heads_up(LMatrix3f mat, const LVector3f fwd, int cs)\n"
  "heads_up(LMatrix4d mat, const LVector3d fwd, int cs)\n"
  "heads_up(LMatrix4f mat, const LVector3f fwd, int cs)\n"
  "heads_up(LQuaterniond quat, const LVector3d fwd, int cs)\n"
  "heads_up(LQuaternionf quat, const LVector3f fwd, int cs)\n";
#else
static const char *Dtool_heads_up_730_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void look_at(LMatrix3d &mat, LVector3d const &fwd, CoordinateSystem cs)
 * void look_at(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up = LVector3d::up(), CoordinateSystem cs = ::CS_default)
 * inline void look_at(LMatrix3f &mat, LVector3f const &fwd, CoordinateSystem cs)
 * void look_at(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up = LVector3f::up(), CoordinateSystem cs = ::CS_default)
 * inline void look_at(LMatrix4d &mat, LVector3d const &fwd, CoordinateSystem cs)
 * inline void look_at(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up = LVector3d::up(), CoordinateSystem cs = ::CS_default)
 * inline void look_at(LMatrix4f &mat, LVector3f const &fwd, CoordinateSystem cs)
 * inline void look_at(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up = LVector3f::up(), CoordinateSystem cs = ::CS_default)
 * inline void look_at(LQuaterniond &quat, LVector3d const &fwd, CoordinateSystem cs)
 * inline void look_at(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up = LVector3d::up(), CoordinateSystem cs = ::CS_default)
 * inline void look_at(LQuaternionf &quat, LVector3f const &fwd, CoordinateSystem cs)
 * inline void look_at(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up = LVector3f::up(), CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_look_at_731(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      {
        // -2 void look_at(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:look_at", (char **)keyword_list, &param0, &param1)) {
          LMatrix3d *param0_this = (LMatrix3d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3d, 0, "look_at", false, false);
          LVector3d const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3d);
          if (param0_this != nullptr && param1_this != nullptr) {
            (::look_at)(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void look_at(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:look_at", (char **)keyword_list, &param0, &param1)) {
          LMatrix3f *param0_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3f, 0, "look_at", false, false);
          LVector3f const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3f);
          if (param0_this != nullptr && param1_this != nullptr) {
            (::look_at)(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:look_at", (char **)keyword_list, &param0, &param1)) {
          LMatrix4d *param0_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4d, 0, "look_at", false, false);
          LVector3d const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3d);
          if (param0_this != nullptr && param1_this != nullptr) {
            (::look_at)(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:look_at", (char **)keyword_list, &param0, &param1)) {
          LMatrix4f *param0_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4f, 0, "look_at", false, false);
          LVector3f const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3f);
          if (param0_this != nullptr && param1_this != nullptr) {
            (::look_at)(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"quat", "fwd", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:look_at", (char **)keyword_list, &param0, &param1)) {
          LQuaterniond *param0_this = (LQuaterniond *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LQuaterniond, 0, "look_at", false, false);
          LVector3d const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3d);
          if (param0_this != nullptr && param1_this != nullptr) {
            (::look_at)(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"quat", "fwd", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:look_at", (char **)keyword_list, &param0, &param1)) {
          LQuaternionf *param0_this = (LQuaternionf *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LQuaternionf, 0, "look_at", false, false);
          LVector3f const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3f);
          if (param0_this != nullptr && param1_this != nullptr) {
            (::look_at)(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void look_at(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:look_at", (char **)keyword_list, &param0, &param1)) {
          LMatrix3d param0_local;
          LMatrix3d *param0_this = Dtool_Coerce_LMatrix3d(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          if ((param0_this != nullptr) && (param1_this != nullptr)) {
            (::look_at)(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void look_at(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:look_at", (char **)keyword_list, &param0, &param1)) {
          LMatrix3f param0_local;
          LMatrix3f *param0_this = Dtool_Coerce_LMatrix3f(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          if ((param0_this != nullptr) && (param1_this != nullptr)) {
            (::look_at)(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:look_at", (char **)keyword_list, &param0, &param1)) {
          LMatrix4d param0_local;
          LMatrix4d *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          if ((param0_this != nullptr) && (param1_this != nullptr)) {
            (::look_at)(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"mat", "fwd", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:look_at", (char **)keyword_list, &param0, &param1)) {
          LMatrix4f param0_local;
          LMatrix4f *param0_this = Dtool_Coerce_LMatrix4f(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          if ((param0_this != nullptr) && (param1_this != nullptr)) {
            (::look_at)(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"quat", "fwd", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:look_at", (char **)keyword_list, &param0, &param1)) {
          LQuaterniond param0_local;
          LQuaterniond *param0_this = Dtool_Coerce_LQuaterniond(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          if ((param0_this != nullptr) && (param1_this != nullptr)) {
            (::look_at)(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"quat", "fwd", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:look_at", (char **)keyword_list, &param0, &param1)) {
          LQuaternionf param0_local;
          LQuaternionf *param0_this = Dtool_Coerce_LQuaternionf(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          if ((param0_this != nullptr) && (param1_this != nullptr)) {
            (::look_at)(*param0_this, *param1_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 3:
  case 4:
    {
      {
        // -2 void look_at(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:look_at", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3d *param0_this = (LMatrix3d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3d, 0, "look_at", false, false);
          LVector3d const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3d);
          LVector3d const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVector3d);
          if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
            (::look_at)(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void look_at(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:look_at", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3f *param0_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3f, 0, "look_at", false, false);
          LVector3f const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3f);
          LVector3f const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVector3f);
          if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
            (::look_at)(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:look_at", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix4d *param0_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4d, 0, "look_at", false, false);
          LVector3d const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3d);
          LVector3d const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVector3d);
          if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
            (::look_at)(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:look_at", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix4f *param0_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4f, 0, "look_at", false, false);
          LVector3f const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3f);
          LVector3f const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVector3f);
          if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
            (::look_at)(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"quat", "fwd", "up", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:look_at", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LQuaterniond *param0_this = (LQuaterniond *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LQuaterniond, 0, "look_at", false, false);
          LVector3d const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3d);
          LVector3d const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVector3d);
          if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
            (::look_at)(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"quat", "fwd", "up", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:look_at", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LQuaternionf *param0_this = (LQuaternionf *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LQuaternionf, 0, "look_at", false, false);
          LVector3f const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3f);
          LVector3f const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVector3f);
          if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
            (::look_at)(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LMatrix3d &mat, LVector3d const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:look_at", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix3d *param0_this = (LMatrix3d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3d, 0, "look_at", false, false);
          LVector3d const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3d);
          if (param0_this != nullptr && param1_this != nullptr) {
            (::look_at)(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LMatrix3f &mat, LVector3f const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:look_at", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix3f *param0_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3f, 0, "look_at", false, false);
          LVector3f const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3f);
          if (param0_this != nullptr && param1_this != nullptr) {
            (::look_at)(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LMatrix4d &mat, LVector3d const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:look_at", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix4d *param0_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4d, 0, "look_at", false, false);
          LVector3d const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3d);
          if (param0_this != nullptr && param1_this != nullptr) {
            (::look_at)(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LMatrix4f &mat, LVector3f const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:look_at", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix4f *param0_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4f, 0, "look_at", false, false);
          LVector3f const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3f);
          if (param0_this != nullptr && param1_this != nullptr) {
            (::look_at)(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LQuaterniond &quat, LVector3d const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"quat", "fwd", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:look_at", (char **)keyword_list, &param0, &param1, &param2)) {
          LQuaterniond *param0_this = (LQuaterniond *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LQuaterniond, 0, "look_at", false, false);
          LVector3d const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3d);
          if (param0_this != nullptr && param1_this != nullptr) {
            (::look_at)(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LQuaternionf &quat, LVector3f const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"quat", "fwd", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:look_at", (char **)keyword_list, &param0, &param1, &param2)) {
          LQuaternionf *param0_this = (LQuaternionf *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LQuaternionf, 0, "look_at", false, false);
          LVector3f const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3f);
          if (param0_this != nullptr && param1_this != nullptr) {
            (::look_at)(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void look_at(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:look_at", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3d param0_local;
          LMatrix3d *param0_this = Dtool_Coerce_LMatrix3d(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          LVector3d param2_local;
          LVector3d const *param2_this = Dtool_Coerce_LVector3d(param2, param2_local);
          if ((param0_this != nullptr) && (param1_this != nullptr) && (param2_this != nullptr)) {
            (::look_at)(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void look_at(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:look_at", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3f param0_local;
          LMatrix3f *param0_this = Dtool_Coerce_LMatrix3f(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          LVector3f param2_local;
          LVector3f const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
          if ((param0_this != nullptr) && (param1_this != nullptr) && (param2_this != nullptr)) {
            (::look_at)(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:look_at", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix4d param0_local;
          LMatrix4d *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          LVector3d param2_local;
          LVector3d const *param2_this = Dtool_Coerce_LVector3d(param2, param2_local);
          if ((param0_this != nullptr) && (param1_this != nullptr) && (param2_this != nullptr)) {
            (::look_at)(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"mat", "fwd", "up", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:look_at", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix4f param0_local;
          LMatrix4f *param0_this = Dtool_Coerce_LMatrix4f(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          LVector3f param2_local;
          LVector3f const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
          if ((param0_this != nullptr) && (param1_this != nullptr) && (param2_this != nullptr)) {
            (::look_at)(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"quat", "fwd", "up", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:look_at", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LQuaterniond param0_local;
          LQuaterniond *param0_this = Dtool_Coerce_LQuaterniond(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          LVector3d param2_local;
          LVector3d const *param2_this = Dtool_Coerce_LVector3d(param2, param2_local);
          if ((param0_this != nullptr) && (param1_this != nullptr) && (param2_this != nullptr)) {
            (::look_at)(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3 = ::CS_default;
        static const char *keyword_list[] = {"quat", "fwd", "up", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|i:look_at", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LQuaternionf param0_local;
          LQuaternionf *param0_this = Dtool_Coerce_LQuaternionf(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          LVector3f param2_local;
          LVector3f const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
          if ((param0_this != nullptr) && (param1_this != nullptr) && (param2_this != nullptr)) {
            (::look_at)(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LMatrix3d &mat, LVector3d const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:look_at", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix3d param0_local;
          LMatrix3d *param0_this = Dtool_Coerce_LMatrix3d(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          if ((param0_this != nullptr) && (param1_this != nullptr)) {
            (::look_at)(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LMatrix3f &mat, LVector3f const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:look_at", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix3f param0_local;
          LMatrix3f *param0_this = Dtool_Coerce_LMatrix3f(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          if ((param0_this != nullptr) && (param1_this != nullptr)) {
            (::look_at)(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LMatrix4d &mat, LVector3d const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:look_at", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix4d param0_local;
          LMatrix4d *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          if ((param0_this != nullptr) && (param1_this != nullptr)) {
            (::look_at)(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LMatrix4f &mat, LVector3f const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"mat", "fwd", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:look_at", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix4f param0_local;
          LMatrix4f *param0_this = Dtool_Coerce_LMatrix4f(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          if ((param0_this != nullptr) && (param1_this != nullptr)) {
            (::look_at)(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LQuaterniond &quat, LVector3d const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"quat", "fwd", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:look_at", (char **)keyword_list, &param0, &param1, &param2)) {
          LQuaterniond param0_local;
          LQuaterniond *param0_this = Dtool_Coerce_LQuaterniond(param0, param0_local);
          LVector3d param1_local;
          LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
          if ((param0_this != nullptr) && (param1_this != nullptr)) {
            (::look_at)(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void look_at(LQuaternionf &quat, LVector3f const &fwd, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"quat", "fwd", "cs", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:look_at", (char **)keyword_list, &param0, &param1, &param2)) {
          LQuaternionf param0_local;
          LQuaternionf *param0_this = Dtool_Coerce_LQuaternionf(param0, param0_local);
          LVector3f param1_local;
          LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
          if ((param0_this != nullptr) && (param1_this != nullptr)) {
            (::look_at)(*param0_this, *param1_this, (CoordinateSystem)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "look_at() takes 2, 3 or 4 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "look_at(LMatrix3d mat, const LVector3d fwd)\n"
      "look_at(LMatrix3f mat, const LVector3f fwd)\n"
      "look_at(LMatrix4d mat, const LVector3d fwd)\n"
      "look_at(LMatrix4f mat, const LVector3f fwd)\n"
      "look_at(LQuaterniond quat, const LVector3d fwd)\n"
      "look_at(LQuaternionf quat, const LVector3f fwd)\n"
      "look_at(LMatrix3d mat, const LVector3d fwd, const LVector3d up, int cs)\n"
      "look_at(LMatrix3f mat, const LVector3f fwd, const LVector3f up, int cs)\n"
      "look_at(LMatrix4d mat, const LVector3d fwd, const LVector3d up, int cs)\n"
      "look_at(LMatrix4f mat, const LVector3f fwd, const LVector3f up, int cs)\n"
      "look_at(LQuaterniond quat, const LVector3d fwd, const LVector3d up, int cs)\n"
      "look_at(LQuaternionf quat, const LVector3f fwd, const LVector3f up, int cs)\n"
      "look_at(LMatrix3d mat, const LVector3d fwd, int cs)\n"
      "look_at(LMatrix3f mat, const LVector3f fwd, int cs)\n"
      "look_at(LMatrix4d mat, const LVector3d fwd, int cs)\n"
      "look_at(LMatrix4f mat, const LVector3f fwd, int cs)\n"
      "look_at(LQuaterniond quat, const LVector3d fwd, int cs)\n"
      "look_at(LQuaternionf quat, const LVector3f fwd, int cs)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_look_at_731_comment =
  "C++ Interface:\n"
  "look_at(LMatrix3d mat, const LVector3d fwd)\n"
  "look_at(LMatrix3f mat, const LVector3f fwd)\n"
  "look_at(LMatrix4d mat, const LVector3d fwd)\n"
  "look_at(LMatrix4f mat, const LVector3f fwd)\n"
  "look_at(LQuaterniond quat, const LVector3d fwd)\n"
  "look_at(LQuaternionf quat, const LVector3f fwd)\n"
  "look_at(LMatrix3d mat, const LVector3d fwd, const LVector3d up, int cs)\n"
  "look_at(LMatrix3f mat, const LVector3f fwd, const LVector3f up, int cs)\n"
  "look_at(LMatrix4d mat, const LVector3d fwd, const LVector3d up, int cs)\n"
  "look_at(LMatrix4f mat, const LVector3f fwd, const LVector3f up, int cs)\n"
  "look_at(LQuaterniond quat, const LVector3d fwd, const LVector3d up, int cs)\n"
  "look_at(LQuaternionf quat, const LVector3f fwd, const LVector3f up, int cs)\n"
  "look_at(LMatrix3d mat, const LVector3d fwd, int cs)\n"
  "look_at(LMatrix3f mat, const LVector3f fwd, int cs)\n"
  "look_at(LMatrix4d mat, const LVector3d fwd, int cs)\n"
  "look_at(LMatrix4f mat, const LVector3f fwd, int cs)\n"
  "look_at(LQuaterniond quat, const LVector3d fwd, int cs)\n"
  "look_at(LQuaternionf quat, const LVector3f fwd, int cs)\n";
#else
static const char *Dtool_look_at_731_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void rotate_to(LMatrix3d &mat, LVector3d const &a, LVector3d const &b)
 * void rotate_to(LMatrix3f &mat, LVector3f const &a, LVector3f const &b)
 * void rotate_to(LMatrix4d &mat, LVector3d const &a, LVector3d const &b)
 * void rotate_to(LMatrix4f &mat, LVector3f const &a, LVector3f const &b)
 */
static PyObject *Dtool_rotate_to_837(PyObject *, PyObject *args, PyObject *kwds) {
  {
    // -2 void rotate_to(LMatrix3d &mat, LVector3d const &a, LVector3d const &b)
    PyObject *param0;
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"mat", "a", "b", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:rotate_to", (char **)keyword_list, &param0, &param1, &param2)) {
      LMatrix3d *param0_this = (LMatrix3d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3d, 0, "rotate_to", false, false);
      LVector3d const *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3d);
      LVector3d const *param2_this = nullptr;
      DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVector3d);
      if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
        (::rotate_to)(*param0_this, *param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void rotate_to(LMatrix3f &mat, LVector3f const &a, LVector3f const &b)
    PyObject *param0;
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"mat", "a", "b", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:rotate_to", (char **)keyword_list, &param0, &param1, &param2)) {
      LMatrix3f *param0_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3f, 0, "rotate_to", false, false);
      LVector3f const *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3f);
      LVector3f const *param2_this = nullptr;
      DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVector3f);
      if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
        (::rotate_to)(*param0_this, *param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void rotate_to(LMatrix4d &mat, LVector3d const &a, LVector3d const &b)
    PyObject *param0;
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"mat", "a", "b", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:rotate_to", (char **)keyword_list, &param0, &param1, &param2)) {
      LMatrix4d *param0_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4d, 0, "rotate_to", false, false);
      LVector3d const *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3d);
      LVector3d const *param2_this = nullptr;
      DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVector3d);
      if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
        (::rotate_to)(*param0_this, *param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void rotate_to(LMatrix4f &mat, LVector3f const &a, LVector3f const &b)
    PyObject *param0;
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"mat", "a", "b", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:rotate_to", (char **)keyword_list, &param0, &param1, &param2)) {
      LMatrix4f *param0_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4f, 0, "rotate_to", false, false);
      LVector3f const *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVector3f);
      LVector3f const *param2_this = nullptr;
      DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVector3f);
      if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
        (::rotate_to)(*param0_this, *param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void rotate_to(LMatrix3d &mat, LVector3d const &a, LVector3d const &b)
    PyObject *param0;
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"mat", "a", "b", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:rotate_to", (char **)keyword_list, &param0, &param1, &param2)) {
      LMatrix3d param0_local;
      LMatrix3d *param0_this = Dtool_Coerce_LMatrix3d(param0, param0_local);
      LVector3d param1_local;
      LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
      LVector3d param2_local;
      LVector3d const *param2_this = Dtool_Coerce_LVector3d(param2, param2_local);
      if ((param0_this != nullptr) && (param1_this != nullptr) && (param2_this != nullptr)) {
        (::rotate_to)(*param0_this, *param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void rotate_to(LMatrix3f &mat, LVector3f const &a, LVector3f const &b)
    PyObject *param0;
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"mat", "a", "b", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:rotate_to", (char **)keyword_list, &param0, &param1, &param2)) {
      LMatrix3f param0_local;
      LMatrix3f *param0_this = Dtool_Coerce_LMatrix3f(param0, param0_local);
      LVector3f param1_local;
      LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
      LVector3f param2_local;
      LVector3f const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
      if ((param0_this != nullptr) && (param1_this != nullptr) && (param2_this != nullptr)) {
        (::rotate_to)(*param0_this, *param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void rotate_to(LMatrix4d &mat, LVector3d const &a, LVector3d const &b)
    PyObject *param0;
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"mat", "a", "b", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:rotate_to", (char **)keyword_list, &param0, &param1, &param2)) {
      LMatrix4d param0_local;
      LMatrix4d *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
      LVector3d param1_local;
      LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
      LVector3d param2_local;
      LVector3d const *param2_this = Dtool_Coerce_LVector3d(param2, param2_local);
      if ((param0_this != nullptr) && (param1_this != nullptr) && (param2_this != nullptr)) {
        (::rotate_to)(*param0_this, *param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void rotate_to(LMatrix4f &mat, LVector3f const &a, LVector3f const &b)
    PyObject *param0;
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"mat", "a", "b", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:rotate_to", (char **)keyword_list, &param0, &param1, &param2)) {
      LMatrix4f param0_local;
      LMatrix4f *param0_this = Dtool_Coerce_LMatrix4f(param0, param0_local);
      LVector3f param1_local;
      LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
      LVector3f param2_local;
      LVector3f const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
      if ((param0_this != nullptr) && (param1_this != nullptr) && (param2_this != nullptr)) {
        (::rotate_to)(*param0_this, *param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rotate_to(LMatrix3d mat, const LVector3d a, const LVector3d b)\n"
      "rotate_to(LMatrix3f mat, const LVector3f a, const LVector3f b)\n"
      "rotate_to(LMatrix4d mat, const LVector3d a, const LVector3d b)\n"
      "rotate_to(LMatrix4f mat, const LVector3f a, const LVector3f b)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_rotate_to_837_comment =
  "C++ Interface:\n"
  "rotate_to(LMatrix3d mat, const LVector3d a, const LVector3d b)\n"
  "rotate_to(LMatrix3f mat, const LVector3f a, const LVector3f b)\n"
  "rotate_to(LMatrix4d mat, const LVector3d a, const LVector3d b)\n"
  "rotate_to(LMatrix4f mat, const LVector3f a, const LVector3f b)\n";
#else
static const char *Dtool_rotate_to_837_comment = nullptr;
#endif

/**
 * Python wrappers for functions of class ConstPointerToArray< LMatrix3d >
 */
/**
 * Python function wrapper for:
 * inline void ConstPointerToArray< LMatrix3d >::clear(void)
 */
static PyObject *Dtool_ConstPointerToArray_LMatrix3d_clear_9(PyObject *self, PyObject *) {
  ConstPointerToArray< LMatrix3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConstPointerToArray_LMatrix3d, (void **)&local_this, "ConstPointerToArray_LMatrix3d.clear")) {
    return nullptr;
  }
  // 1-inline void ConstPointerToArray< LMatrix3d >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LMatrix3d_clear_9_comment =
  "C++ Interface:\n"
  "clear(const ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LMatrix3d_clear_9_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3d const &ConstPointerToArray< LMatrix3d >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_LMatrix3d_get_element_11(PyObject *self, PyObject *arg) {
  ConstPointerToArray< LMatrix3d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LMatrix3d)) {
    return nullptr;
  }
  // 1-inline LMatrix3d const &ConstPointerToArray< LMatrix3d >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LMatrix3d const *return_value = &(((*(const ConstPointerToArray< LMatrix3d >*)local_this).get_element)((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LMatrix3d_get_element_11_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_LMatrix3d_get_element_11_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< LMatrix3d >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LMatrix3d_get_data_13(PyObject *self, PyObject *) {
  ConstPointerToArray< LMatrix3d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LMatrix3d)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< LMatrix3d >::get_data(void) const
  PyObject *return_value = invoke_extension((const ConstPointerToArray< LMatrix3d >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LMatrix3d_get_data_13_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LMatrix3d_get_data_13_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< LMatrix3d >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_LMatrix3d_get_subdata_14(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< LMatrix3d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LMatrix3d)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< LMatrix3d >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const ConstPointerToArray< LMatrix3d >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LMatrix3d_get_subdata_14_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_LMatrix3d_get_subdata_14_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LMatrix3d >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LMatrix3d_get_ref_count_15(PyObject *self, PyObject *) {
  ConstPointerToArray< LMatrix3d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LMatrix3d)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< LMatrix3d >::get_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< LMatrix3d >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LMatrix3d_get_ref_count_15_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LMatrix3d_get_ref_count_15_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LMatrix3d >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LMatrix3d_get_node_ref_count_16(PyObject *self, PyObject *) {
  ConstPointerToArray< LMatrix3d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LMatrix3d)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< LMatrix3d >::get_node_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< LMatrix3d >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LMatrix3d_get_node_ref_count_16_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LMatrix3d_get_node_ref_count_16_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int ConstPointerToArray< LMatrix3d >::count(LMatrix3d const &) const
 */
static PyObject *Dtool_ConstPointerToArray_LMatrix3d_count_17(PyObject *self, PyObject *arg) {
  ConstPointerToArray< LMatrix3d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LMatrix3d)) {
    return nullptr;
  }
  // 1-inline unsigned long int ConstPointerToArray< LMatrix3d >::count(LMatrix3d const &) const
  LMatrix3d arg_local;
  LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConstPointerToArray.count", "LMatrix3d");
  }
  unsigned long int return_value = ((*(const ConstPointerToArray< LMatrix3d >*)local_this).count)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(ConstPointerToArray self, const LMatrix3d param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LMatrix3d_count_17_comment =
  "C++ Interface:\n"
  "count(ConstPointerToArray self, const LMatrix3d param0)\n";
#else
static const char *Dtool_ConstPointerToArray_LMatrix3d_count_17_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< LMatrix3d >::ConstPointerToArray(ConstPointerToArray< LMatrix3d > const &copy)
 * inline ConstPointerToArray< LMatrix3d >::ConstPointerToArray(PointerToArray< LMatrix3d > const &copy)
 */
static int Dtool_Init_ConstPointerToArray_LMatrix3d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
    {
      // -2 inline ConstPointerToArray< LMatrix3d >::ConstPointerToArray(ConstPointerToArray< LMatrix3d > const &copy)
      ConstPointerToArray< LMatrix3d > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ConstPointerToArray_LMatrix3d);
      if (arg_this != nullptr) {
        ConstPointerToArray< LMatrix3d > *return_value = new ConstPointerToArray< LMatrix3d >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LMatrix3d, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< LMatrix3d >::ConstPointerToArray(PointerToArray< LMatrix3d > const &copy)
      PointerToArray< LMatrix3d > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_LMatrix3d);
      if (arg_this != nullptr) {
        ConstPointerToArray< LMatrix3d > *return_value = new ConstPointerToArray< LMatrix3d >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LMatrix3d, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< LMatrix3d >::ConstPointerToArray(ConstPointerToArray< LMatrix3d > const &copy)
      ConstPointerToArray< LMatrix3d > arg_local;
      ConstPointerToArray< LMatrix3d > const *arg_this = Dtool_Coerce_ConstPointerToArray_LMatrix3d(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< LMatrix3d > *return_value = new ConstPointerToArray< LMatrix3d >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LMatrix3d, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< LMatrix3d >::ConstPointerToArray(PointerToArray< LMatrix3d > const &copy)
      PointerToArray< LMatrix3d > arg_local;
      PointerToArray< LMatrix3d > const *arg_this = Dtool_Coerce_PointerToArray_LMatrix3d(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< LMatrix3d > *return_value = new ConstPointerToArray< LMatrix3d >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LMatrix3d, true, false);
      }
    }

  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(const PointerToArray copy)\n");
  }
  return -1;
}

ConstPointerToArray< LMatrix3d > *Dtool_Coerce_ConstPointerToArray_LMatrix3d(PyObject *args, ConstPointerToArray< LMatrix3d > &coerced) {
  ConstPointerToArray< LMatrix3d > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_ConstPointerToArray_LMatrix3d)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< LMatrix3d > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConstPointerToArray< LMatrix3d >::ConstPointerToArray(PointerToArray< LMatrix3d > const &copy)
    PointerToArray< LMatrix3d > const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_LMatrix3d);
    if (arg_this != nullptr) {
      coerced = ConstPointerToArray< LMatrix3d >(*arg_this);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_LMatrix3d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConstPointerToArray_LMatrix3d) {
    printf("ConstPointerToArray_LMatrix3d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConstPointerToArray< LMatrix3d > *local_this = (ConstPointerToArray< LMatrix3d > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConstPointerToArray_LMatrix3d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LMatrix3d) {
    return (PointerToArrayBase< LMatrix3d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3d) {
    return (PointerToBase< ReferenceCountedVector< LMatrix3d > > *)(PointerToArrayBase< LMatrix3d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LMatrix3d > > *)(PointerToArrayBase< LMatrix3d > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_LMatrix3d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_LMatrix3d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LMatrix3d) {
    PointerToArrayBase< LMatrix3d >* other_this = (PointerToArrayBase< LMatrix3d >*)from_this;
    return (ConstPointerToArray< LMatrix3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3d) {
    PointerToBase< ReferenceCountedVector< LMatrix3d > >* other_this = (PointerToBase< ReferenceCountedVector< LMatrix3d > >*)from_this;
    return (ConstPointerToArray< LMatrix3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< LMatrix3d >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< LMatrix3d >
 */
static int Dtool_Init_PointerToArrayBase_LMatrix3d(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_LMatrix3d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArrayBase_LMatrix3d) {
    printf("PointerToArrayBase_LMatrix3d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArrayBase< LMatrix3d > *local_this = (PointerToArrayBase< LMatrix3d > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArrayBase_LMatrix3d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3d) {
    return (PointerToBase< ReferenceCountedVector< LMatrix3d > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LMatrix3d > > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_LMatrix3d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LMatrix3d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3d) {
    PointerToBase< ReferenceCountedVector< LMatrix3d > >* other_this = (PointerToBase< ReferenceCountedVector< LMatrix3d > >*)from_this;
    return (PointerToArrayBase< LMatrix3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< LMatrix3d >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< LMatrix3d > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< LMatrix3d > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d_clear_5(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< LMatrix3d > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d, (void **)&local_this, "PointerToBase_ReferenceCountedVector_LMatrix3d.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< LMatrix3d > >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d_clear_5_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d_clear_5_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< LMatrix3d > >::output(std::ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d_output_6(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< LMatrix3d > > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d)) {
    return nullptr;
  }
  // 1-void PointerToBase< ReferenceCountedVector< LMatrix3d > >::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PointerToBase< ReferenceCountedVector< LMatrix3d > >*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d_output_6_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d_output_6_comment = nullptr;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_LMatrix3d(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LMatrix3d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d) {
    printf("PointerToBase_ReferenceCountedVector_LMatrix3d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToBase< ReferenceCountedVector< LMatrix3d > > *local_this = (PointerToBase< ReferenceCountedVector< LMatrix3d > > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LMatrix3d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< LMatrix3d > >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConstPointerToArray< LMatrix3f >
 */
/**
 * Python function wrapper for:
 * inline void ConstPointerToArray< LMatrix3f >::clear(void)
 */
static PyObject *Dtool_ConstPointerToArray_LMatrix3f_clear_28(PyObject *self, PyObject *) {
  ConstPointerToArray< LMatrix3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConstPointerToArray_LMatrix3f, (void **)&local_this, "ConstPointerToArray_LMatrix3f.clear")) {
    return nullptr;
  }
  // 1-inline void ConstPointerToArray< LMatrix3f >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LMatrix3f_clear_28_comment =
  "C++ Interface:\n"
  "clear(const ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LMatrix3f_clear_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3f const &ConstPointerToArray< LMatrix3f >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_LMatrix3f_get_element_30(PyObject *self, PyObject *arg) {
  ConstPointerToArray< LMatrix3f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LMatrix3f)) {
    return nullptr;
  }
  // 1-inline LMatrix3f const &ConstPointerToArray< LMatrix3f >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LMatrix3f const *return_value = &(((*(const ConstPointerToArray< LMatrix3f >*)local_this).get_element)((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LMatrix3f_get_element_30_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_LMatrix3f_get_element_30_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< LMatrix3f >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LMatrix3f_get_data_32(PyObject *self, PyObject *) {
  ConstPointerToArray< LMatrix3f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LMatrix3f)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< LMatrix3f >::get_data(void) const
  PyObject *return_value = invoke_extension((const ConstPointerToArray< LMatrix3f >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LMatrix3f_get_data_32_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LMatrix3f_get_data_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< LMatrix3f >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_LMatrix3f_get_subdata_33(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< LMatrix3f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LMatrix3f)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< LMatrix3f >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const ConstPointerToArray< LMatrix3f >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LMatrix3f_get_subdata_33_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_LMatrix3f_get_subdata_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LMatrix3f >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LMatrix3f_get_ref_count_34(PyObject *self, PyObject *) {
  ConstPointerToArray< LMatrix3f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LMatrix3f)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< LMatrix3f >::get_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< LMatrix3f >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LMatrix3f_get_ref_count_34_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LMatrix3f_get_ref_count_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LMatrix3f >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LMatrix3f_get_node_ref_count_35(PyObject *self, PyObject *) {
  ConstPointerToArray< LMatrix3f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LMatrix3f)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< LMatrix3f >::get_node_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< LMatrix3f >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LMatrix3f_get_node_ref_count_35_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LMatrix3f_get_node_ref_count_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int ConstPointerToArray< LMatrix3f >::count(LMatrix3f const &) const
 */
static PyObject *Dtool_ConstPointerToArray_LMatrix3f_count_36(PyObject *self, PyObject *arg) {
  ConstPointerToArray< LMatrix3f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LMatrix3f)) {
    return nullptr;
  }
  // 1-inline unsigned long int ConstPointerToArray< LMatrix3f >::count(LMatrix3f const &) const
  LMatrix3f arg_local;
  LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConstPointerToArray.count", "LMatrix3f");
  }
  unsigned long int return_value = ((*(const ConstPointerToArray< LMatrix3f >*)local_this).count)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(ConstPointerToArray self, const LMatrix3f param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LMatrix3f_count_36_comment =
  "C++ Interface:\n"
  "count(ConstPointerToArray self, const LMatrix3f param0)\n";
#else
static const char *Dtool_ConstPointerToArray_LMatrix3f_count_36_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< LMatrix3f >::ConstPointerToArray(ConstPointerToArray< LMatrix3f > const &copy)
 * inline ConstPointerToArray< LMatrix3f >::ConstPointerToArray(PointerToArray< LMatrix3f > const &copy)
 */
static int Dtool_Init_ConstPointerToArray_LMatrix3f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
    {
      // -2 inline ConstPointerToArray< LMatrix3f >::ConstPointerToArray(ConstPointerToArray< LMatrix3f > const &copy)
      ConstPointerToArray< LMatrix3f > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ConstPointerToArray_LMatrix3f);
      if (arg_this != nullptr) {
        ConstPointerToArray< LMatrix3f > *return_value = new ConstPointerToArray< LMatrix3f >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LMatrix3f, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< LMatrix3f >::ConstPointerToArray(PointerToArray< LMatrix3f > const &copy)
      PointerToArray< LMatrix3f > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_LMatrix3f);
      if (arg_this != nullptr) {
        ConstPointerToArray< LMatrix3f > *return_value = new ConstPointerToArray< LMatrix3f >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LMatrix3f, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< LMatrix3f >::ConstPointerToArray(ConstPointerToArray< LMatrix3f > const &copy)
      ConstPointerToArray< LMatrix3f > arg_local;
      ConstPointerToArray< LMatrix3f > const *arg_this = Dtool_Coerce_ConstPointerToArray_LMatrix3f(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< LMatrix3f > *return_value = new ConstPointerToArray< LMatrix3f >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LMatrix3f, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< LMatrix3f >::ConstPointerToArray(PointerToArray< LMatrix3f > const &copy)
      PointerToArray< LMatrix3f > arg_local;
      PointerToArray< LMatrix3f > const *arg_this = Dtool_Coerce_PointerToArray_LMatrix3f(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< LMatrix3f > *return_value = new ConstPointerToArray< LMatrix3f >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LMatrix3f, true, false);
      }
    }

  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(const PointerToArray copy)\n");
  }
  return -1;
}

ConstPointerToArray< LMatrix3f > *Dtool_Coerce_ConstPointerToArray_LMatrix3f(PyObject *args, ConstPointerToArray< LMatrix3f > &coerced) {
  ConstPointerToArray< LMatrix3f > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_ConstPointerToArray_LMatrix3f)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< LMatrix3f > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConstPointerToArray< LMatrix3f >::ConstPointerToArray(PointerToArray< LMatrix3f > const &copy)
    PointerToArray< LMatrix3f > const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_LMatrix3f);
    if (arg_this != nullptr) {
      coerced = ConstPointerToArray< LMatrix3f >(*arg_this);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_LMatrix3f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConstPointerToArray_LMatrix3f) {
    printf("ConstPointerToArray_LMatrix3f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConstPointerToArray< LMatrix3f > *local_this = (ConstPointerToArray< LMatrix3f > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConstPointerToArray_LMatrix3f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LMatrix3f) {
    return (PointerToArrayBase< LMatrix3f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3f) {
    return (PointerToBase< ReferenceCountedVector< LMatrix3f > > *)(PointerToArrayBase< LMatrix3f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LMatrix3f > > *)(PointerToArrayBase< LMatrix3f > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_LMatrix3f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_LMatrix3f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LMatrix3f) {
    PointerToArrayBase< LMatrix3f >* other_this = (PointerToArrayBase< LMatrix3f >*)from_this;
    return (ConstPointerToArray< LMatrix3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3f) {
    PointerToBase< ReferenceCountedVector< LMatrix3f > >* other_this = (PointerToBase< ReferenceCountedVector< LMatrix3f > >*)from_this;
    return (ConstPointerToArray< LMatrix3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< LMatrix3f >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< LMatrix3f >
 */
static int Dtool_Init_PointerToArrayBase_LMatrix3f(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_LMatrix3f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArrayBase_LMatrix3f) {
    printf("PointerToArrayBase_LMatrix3f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArrayBase< LMatrix3f > *local_this = (PointerToArrayBase< LMatrix3f > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArrayBase_LMatrix3f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3f) {
    return (PointerToBase< ReferenceCountedVector< LMatrix3f > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LMatrix3f > > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_LMatrix3f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LMatrix3f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3f) {
    PointerToBase< ReferenceCountedVector< LMatrix3f > >* other_this = (PointerToBase< ReferenceCountedVector< LMatrix3f > >*)from_this;
    return (PointerToArrayBase< LMatrix3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< LMatrix3f >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< LMatrix3f > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< LMatrix3f > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f_clear_24(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< LMatrix3f > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f, (void **)&local_this, "PointerToBase_ReferenceCountedVector_LMatrix3f.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< LMatrix3f > >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f_clear_24_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f_clear_24_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< LMatrix3f > >::output(std::ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f_output_25(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< LMatrix3f > > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f)) {
    return nullptr;
  }
  // 1-void PointerToBase< ReferenceCountedVector< LMatrix3f > >::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PointerToBase< ReferenceCountedVector< LMatrix3f > >*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f_output_25_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f_output_25_comment = nullptr;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_LMatrix3f(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LMatrix3f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f) {
    printf("PointerToBase_ReferenceCountedVector_LMatrix3f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToBase< ReferenceCountedVector< LMatrix3f > > *local_this = (PointerToBase< ReferenceCountedVector< LMatrix3f > > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LMatrix3f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< LMatrix3f > >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConstPointerToArray< LVecBase2d >
 */
/**
 * Python function wrapper for:
 * inline void ConstPointerToArray< LVecBase2d >::clear(void)
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2d_clear_47(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase2d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConstPointerToArray_LVecBase2d, (void **)&local_this, "ConstPointerToArray_LVecBase2d.clear")) {
    return nullptr;
  }
  // 1-inline void ConstPointerToArray< LVecBase2d >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2d_clear_47_comment =
  "C++ Interface:\n"
  "clear(const ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2d_clear_47_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2d const &ConstPointerToArray< LVecBase2d >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2d_get_element_49(PyObject *self, PyObject *arg) {
  ConstPointerToArray< LVecBase2d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase2d)) {
    return nullptr;
  }
  // 1-inline LVecBase2d const &ConstPointerToArray< LVecBase2d >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LVecBase2d const *return_value = &(((*(const ConstPointerToArray< LVecBase2d >*)local_this).get_element)((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2d_get_element_49_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2d_get_element_49_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< LVecBase2d >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2d_get_data_51(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase2d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase2d)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< LVecBase2d >::get_data(void) const
  PyObject *return_value = invoke_extension((const ConstPointerToArray< LVecBase2d >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2d_get_data_51_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2d_get_data_51_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< LVecBase2d >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2d_get_subdata_52(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< LVecBase2d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase2d)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< LVecBase2d >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const ConstPointerToArray< LVecBase2d >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2d_get_subdata_52_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2d_get_subdata_52_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LVecBase2d >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2d_get_ref_count_53(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase2d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase2d)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< LVecBase2d >::get_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< LVecBase2d >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2d_get_ref_count_53_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2d_get_ref_count_53_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LVecBase2d >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2d_get_node_ref_count_54(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase2d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase2d)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< LVecBase2d >::get_node_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< LVecBase2d >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2d_get_node_ref_count_54_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2d_get_node_ref_count_54_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int ConstPointerToArray< LVecBase2d >::count(LVecBase2d const &) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2d_count_55(PyObject *self, PyObject *arg) {
  ConstPointerToArray< LVecBase2d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase2d)) {
    return nullptr;
  }
  // 1-inline unsigned long int ConstPointerToArray< LVecBase2d >::count(LVecBase2d const &) const
  LVecBase2d arg_local;
  LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConstPointerToArray.count", "LVecBase2d");
  }
  unsigned long int return_value = ((*(const ConstPointerToArray< LVecBase2d >*)local_this).count)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(ConstPointerToArray self, const LVecBase2d param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2d_count_55_comment =
  "C++ Interface:\n"
  "count(ConstPointerToArray self, const LVecBase2d param0)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2d_count_55_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< LVecBase2d >::ConstPointerToArray(ConstPointerToArray< LVecBase2d > const &copy)
 * inline ConstPointerToArray< LVecBase2d >::ConstPointerToArray(PointerToArray< LVecBase2d > const &copy)
 */
static int Dtool_Init_ConstPointerToArray_LVecBase2d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
    {
      // -2 inline ConstPointerToArray< LVecBase2d >::ConstPointerToArray(ConstPointerToArray< LVecBase2d > const &copy)
      ConstPointerToArray< LVecBase2d > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ConstPointerToArray_LVecBase2d);
      if (arg_this != nullptr) {
        ConstPointerToArray< LVecBase2d > *return_value = new ConstPointerToArray< LVecBase2d >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase2d, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< LVecBase2d >::ConstPointerToArray(PointerToArray< LVecBase2d > const &copy)
      PointerToArray< LVecBase2d > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_LVecBase2d);
      if (arg_this != nullptr) {
        ConstPointerToArray< LVecBase2d > *return_value = new ConstPointerToArray< LVecBase2d >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase2d, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< LVecBase2d >::ConstPointerToArray(ConstPointerToArray< LVecBase2d > const &copy)
      ConstPointerToArray< LVecBase2d > arg_local;
      ConstPointerToArray< LVecBase2d > const *arg_this = Dtool_Coerce_ConstPointerToArray_LVecBase2d(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< LVecBase2d > *return_value = new ConstPointerToArray< LVecBase2d >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase2d, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< LVecBase2d >::ConstPointerToArray(PointerToArray< LVecBase2d > const &copy)
      PointerToArray< LVecBase2d > arg_local;
      PointerToArray< LVecBase2d > const *arg_this = Dtool_Coerce_PointerToArray_LVecBase2d(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< LVecBase2d > *return_value = new ConstPointerToArray< LVecBase2d >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase2d, true, false);
      }
    }

  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(const PointerToArray copy)\n");
  }
  return -1;
}

ConstPointerToArray< LVecBase2d > *Dtool_Coerce_ConstPointerToArray_LVecBase2d(PyObject *args, ConstPointerToArray< LVecBase2d > &coerced) {
  ConstPointerToArray< LVecBase2d > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_ConstPointerToArray_LVecBase2d)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< LVecBase2d > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConstPointerToArray< LVecBase2d >::ConstPointerToArray(PointerToArray< LVecBase2d > const &copy)
    PointerToArray< LVecBase2d > const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_LVecBase2d);
    if (arg_this != nullptr) {
      coerced = ConstPointerToArray< LVecBase2d >(*arg_this);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_LVecBase2d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConstPointerToArray_LVecBase2d) {
    printf("ConstPointerToArray_LVecBase2d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConstPointerToArray< LVecBase2d > *local_this = (ConstPointerToArray< LVecBase2d > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConstPointerToArray_LVecBase2d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LVecBase2d) {
    return (PointerToArrayBase< LVecBase2d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2d) {
    return (PointerToBase< ReferenceCountedVector< LVecBase2d > > *)(PointerToArrayBase< LVecBase2d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase2d > > *)(PointerToArrayBase< LVecBase2d > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_LVecBase2d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_LVecBase2d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase2d) {
    PointerToArrayBase< LVecBase2d >* other_this = (PointerToArrayBase< LVecBase2d >*)from_this;
    return (ConstPointerToArray< LVecBase2d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2d) {
    PointerToBase< ReferenceCountedVector< LVecBase2d > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase2d > >*)from_this;
    return (ConstPointerToArray< LVecBase2d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< LVecBase2d >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< LVecBase2d >
 */
static int Dtool_Init_PointerToArrayBase_LVecBase2d(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_LVecBase2d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArrayBase_LVecBase2d) {
    printf("PointerToArrayBase_LVecBase2d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArrayBase< LVecBase2d > *local_this = (PointerToArrayBase< LVecBase2d > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArrayBase_LVecBase2d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2d) {
    return (PointerToBase< ReferenceCountedVector< LVecBase2d > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase2d > > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_LVecBase2d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase2d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2d) {
    PointerToBase< ReferenceCountedVector< LVecBase2d > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase2d > >*)from_this;
    return (PointerToArrayBase< LVecBase2d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< LVecBase2d >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< LVecBase2d > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< LVecBase2d > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d_clear_43(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< LVecBase2d > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d, (void **)&local_this, "PointerToBase_ReferenceCountedVector_LVecBase2d.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< LVecBase2d > >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d_clear_43_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d_clear_43_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< LVecBase2d > >::output(std::ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d_output_44(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< LVecBase2d > > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d)) {
    return nullptr;
  }
  // 1-void PointerToBase< ReferenceCountedVector< LVecBase2d > >::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PointerToBase< ReferenceCountedVector< LVecBase2d > >*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d_output_44_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d_output_44_comment = nullptr;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_LVecBase2d(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LVecBase2d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d) {
    printf("PointerToBase_ReferenceCountedVector_LVecBase2d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToBase< ReferenceCountedVector< LVecBase2d > > *local_this = (PointerToBase< ReferenceCountedVector< LVecBase2d > > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LVecBase2d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< LVecBase2d > >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConstPointerToArray< LVecBase2f >
 */
/**
 * Python function wrapper for:
 * inline void ConstPointerToArray< LVecBase2f >::clear(void)
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2f_clear_66(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase2f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConstPointerToArray_LVecBase2f, (void **)&local_this, "ConstPointerToArray_LVecBase2f.clear")) {
    return nullptr;
  }
  // 1-inline void ConstPointerToArray< LVecBase2f >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2f_clear_66_comment =
  "C++ Interface:\n"
  "clear(const ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2f_clear_66_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2f const &ConstPointerToArray< LVecBase2f >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2f_get_element_68(PyObject *self, PyObject *arg) {
  ConstPointerToArray< LVecBase2f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase2f)) {
    return nullptr;
  }
  // 1-inline LVecBase2f const &ConstPointerToArray< LVecBase2f >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LVecBase2f const *return_value = &(((*(const ConstPointerToArray< LVecBase2f >*)local_this).get_element)((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2f_get_element_68_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2f_get_element_68_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< LVecBase2f >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2f_get_data_70(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase2f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase2f)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< LVecBase2f >::get_data(void) const
  PyObject *return_value = invoke_extension((const ConstPointerToArray< LVecBase2f >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2f_get_data_70_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2f_get_data_70_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< LVecBase2f >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2f_get_subdata_71(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< LVecBase2f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase2f)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< LVecBase2f >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const ConstPointerToArray< LVecBase2f >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2f_get_subdata_71_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2f_get_subdata_71_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LVecBase2f >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2f_get_ref_count_72(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase2f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase2f)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< LVecBase2f >::get_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< LVecBase2f >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2f_get_ref_count_72_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2f_get_ref_count_72_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LVecBase2f >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2f_get_node_ref_count_73(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase2f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase2f)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< LVecBase2f >::get_node_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< LVecBase2f >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2f_get_node_ref_count_73_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2f_get_node_ref_count_73_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int ConstPointerToArray< LVecBase2f >::count(LVecBase2f const &) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2f_count_74(PyObject *self, PyObject *arg) {
  ConstPointerToArray< LVecBase2f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase2f)) {
    return nullptr;
  }
  // 1-inline unsigned long int ConstPointerToArray< LVecBase2f >::count(LVecBase2f const &) const
  LVecBase2f arg_local;
  LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConstPointerToArray.count", "LVecBase2f");
  }
  unsigned long int return_value = ((*(const ConstPointerToArray< LVecBase2f >*)local_this).count)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(ConstPointerToArray self, const LVecBase2f param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2f_count_74_comment =
  "C++ Interface:\n"
  "count(ConstPointerToArray self, const LVecBase2f param0)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2f_count_74_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< LVecBase2f >::ConstPointerToArray(ConstPointerToArray< LVecBase2f > const &copy)
 * inline ConstPointerToArray< LVecBase2f >::ConstPointerToArray(PointerToArray< LVecBase2f > const &copy)
 */
static int Dtool_Init_ConstPointerToArray_LVecBase2f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
    {
      // -2 inline ConstPointerToArray< LVecBase2f >::ConstPointerToArray(ConstPointerToArray< LVecBase2f > const &copy)
      ConstPointerToArray< LVecBase2f > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ConstPointerToArray_LVecBase2f);
      if (arg_this != nullptr) {
        ConstPointerToArray< LVecBase2f > *return_value = new ConstPointerToArray< LVecBase2f >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase2f, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< LVecBase2f >::ConstPointerToArray(PointerToArray< LVecBase2f > const &copy)
      PointerToArray< LVecBase2f > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_LVecBase2f);
      if (arg_this != nullptr) {
        ConstPointerToArray< LVecBase2f > *return_value = new ConstPointerToArray< LVecBase2f >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase2f, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< LVecBase2f >::ConstPointerToArray(ConstPointerToArray< LVecBase2f > const &copy)
      ConstPointerToArray< LVecBase2f > arg_local;
      ConstPointerToArray< LVecBase2f > const *arg_this = Dtool_Coerce_ConstPointerToArray_LVecBase2f(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< LVecBase2f > *return_value = new ConstPointerToArray< LVecBase2f >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase2f, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< LVecBase2f >::ConstPointerToArray(PointerToArray< LVecBase2f > const &copy)
      PointerToArray< LVecBase2f > arg_local;
      PointerToArray< LVecBase2f > const *arg_this = Dtool_Coerce_PointerToArray_LVecBase2f(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< LVecBase2f > *return_value = new ConstPointerToArray< LVecBase2f >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase2f, true, false);
      }
    }

  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(const PointerToArray copy)\n");
  }
  return -1;
}

ConstPointerToArray< LVecBase2f > *Dtool_Coerce_ConstPointerToArray_LVecBase2f(PyObject *args, ConstPointerToArray< LVecBase2f > &coerced) {
  ConstPointerToArray< LVecBase2f > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_ConstPointerToArray_LVecBase2f)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< LVecBase2f > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConstPointerToArray< LVecBase2f >::ConstPointerToArray(PointerToArray< LVecBase2f > const &copy)
    PointerToArray< LVecBase2f > const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_LVecBase2f);
    if (arg_this != nullptr) {
      coerced = ConstPointerToArray< LVecBase2f >(*arg_this);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_LVecBase2f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConstPointerToArray_LVecBase2f) {
    printf("ConstPointerToArray_LVecBase2f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConstPointerToArray< LVecBase2f > *local_this = (ConstPointerToArray< LVecBase2f > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConstPointerToArray_LVecBase2f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LVecBase2f) {
    return (PointerToArrayBase< LVecBase2f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2f) {
    return (PointerToBase< ReferenceCountedVector< LVecBase2f > > *)(PointerToArrayBase< LVecBase2f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase2f > > *)(PointerToArrayBase< LVecBase2f > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_LVecBase2f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_LVecBase2f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase2f) {
    PointerToArrayBase< LVecBase2f >* other_this = (PointerToArrayBase< LVecBase2f >*)from_this;
    return (ConstPointerToArray< LVecBase2f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2f) {
    PointerToBase< ReferenceCountedVector< LVecBase2f > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase2f > >*)from_this;
    return (ConstPointerToArray< LVecBase2f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< LVecBase2f >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< LVecBase2f >
 */
static int Dtool_Init_PointerToArrayBase_LVecBase2f(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_LVecBase2f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArrayBase_LVecBase2f) {
    printf("PointerToArrayBase_LVecBase2f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArrayBase< LVecBase2f > *local_this = (PointerToArrayBase< LVecBase2f > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArrayBase_LVecBase2f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2f) {
    return (PointerToBase< ReferenceCountedVector< LVecBase2f > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase2f > > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_LVecBase2f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase2f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2f) {
    PointerToBase< ReferenceCountedVector< LVecBase2f > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase2f > >*)from_this;
    return (PointerToArrayBase< LVecBase2f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< LVecBase2f >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< LVecBase2f > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< LVecBase2f > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f_clear_62(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< LVecBase2f > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f, (void **)&local_this, "PointerToBase_ReferenceCountedVector_LVecBase2f.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< LVecBase2f > >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f_clear_62_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f_clear_62_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< LVecBase2f > >::output(std::ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f_output_63(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< LVecBase2f > > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f)) {
    return nullptr;
  }
  // 1-void PointerToBase< ReferenceCountedVector< LVecBase2f > >::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PointerToBase< ReferenceCountedVector< LVecBase2f > >*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f_output_63_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f_output_63_comment = nullptr;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_LVecBase2f(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LVecBase2f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f) {
    printf("PointerToBase_ReferenceCountedVector_LVecBase2f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToBase< ReferenceCountedVector< LVecBase2f > > *local_this = (PointerToBase< ReferenceCountedVector< LVecBase2f > > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LVecBase2f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< LVecBase2f > >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConstPointerToArray< LVecBase2i >
 */
/**
 * Python function wrapper for:
 * inline void ConstPointerToArray< LVecBase2i >::clear(void)
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2i_clear_85(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase2i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConstPointerToArray_LVecBase2i, (void **)&local_this, "ConstPointerToArray_LVecBase2i.clear")) {
    return nullptr;
  }
  // 1-inline void ConstPointerToArray< LVecBase2i >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2i_clear_85_comment =
  "C++ Interface:\n"
  "clear(const ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2i_clear_85_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2i const &ConstPointerToArray< LVecBase2i >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2i_get_element_87(PyObject *self, PyObject *arg) {
  ConstPointerToArray< LVecBase2i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase2i)) {
    return nullptr;
  }
  // 1-inline LVecBase2i const &ConstPointerToArray< LVecBase2i >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LVecBase2i const *return_value = &(((*(const ConstPointerToArray< LVecBase2i >*)local_this).get_element)((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2i_get_element_87_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2i_get_element_87_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< LVecBase2i >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2i_get_data_89(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase2i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase2i)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< LVecBase2i >::get_data(void) const
  PyObject *return_value = invoke_extension((const ConstPointerToArray< LVecBase2i >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2i_get_data_89_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2i_get_data_89_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< LVecBase2i >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2i_get_subdata_90(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< LVecBase2i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase2i)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< LVecBase2i >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const ConstPointerToArray< LVecBase2i >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2i_get_subdata_90_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2i_get_subdata_90_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LVecBase2i >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2i_get_ref_count_91(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase2i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase2i)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< LVecBase2i >::get_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< LVecBase2i >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2i_get_ref_count_91_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2i_get_ref_count_91_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LVecBase2i >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2i_get_node_ref_count_92(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase2i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase2i)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< LVecBase2i >::get_node_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< LVecBase2i >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2i_get_node_ref_count_92_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2i_get_node_ref_count_92_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int ConstPointerToArray< LVecBase2i >::count(LVecBase2i const &) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase2i_count_93(PyObject *self, PyObject *arg) {
  ConstPointerToArray< LVecBase2i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase2i)) {
    return nullptr;
  }
  // 1-inline unsigned long int ConstPointerToArray< LVecBase2i >::count(LVecBase2i const &) const
  LVecBase2i arg_local;
  LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConstPointerToArray.count", "LVecBase2i");
  }
  unsigned long int return_value = ((*(const ConstPointerToArray< LVecBase2i >*)local_this).count)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(ConstPointerToArray self, const LVecBase2i param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase2i_count_93_comment =
  "C++ Interface:\n"
  "count(ConstPointerToArray self, const LVecBase2i param0)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase2i_count_93_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< LVecBase2i >::ConstPointerToArray(ConstPointerToArray< LVecBase2i > const &copy)
 * inline ConstPointerToArray< LVecBase2i >::ConstPointerToArray(PointerToArray< LVecBase2i > const &copy)
 */
static int Dtool_Init_ConstPointerToArray_LVecBase2i(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
    {
      // -2 inline ConstPointerToArray< LVecBase2i >::ConstPointerToArray(ConstPointerToArray< LVecBase2i > const &copy)
      ConstPointerToArray< LVecBase2i > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ConstPointerToArray_LVecBase2i);
      if (arg_this != nullptr) {
        ConstPointerToArray< LVecBase2i > *return_value = new ConstPointerToArray< LVecBase2i >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase2i, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< LVecBase2i >::ConstPointerToArray(PointerToArray< LVecBase2i > const &copy)
      PointerToArray< LVecBase2i > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_LVecBase2i);
      if (arg_this != nullptr) {
        ConstPointerToArray< LVecBase2i > *return_value = new ConstPointerToArray< LVecBase2i >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase2i, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< LVecBase2i >::ConstPointerToArray(ConstPointerToArray< LVecBase2i > const &copy)
      ConstPointerToArray< LVecBase2i > arg_local;
      ConstPointerToArray< LVecBase2i > const *arg_this = Dtool_Coerce_ConstPointerToArray_LVecBase2i(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< LVecBase2i > *return_value = new ConstPointerToArray< LVecBase2i >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase2i, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< LVecBase2i >::ConstPointerToArray(PointerToArray< LVecBase2i > const &copy)
      PointerToArray< LVecBase2i > arg_local;
      PointerToArray< LVecBase2i > const *arg_this = Dtool_Coerce_PointerToArray_LVecBase2i(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< LVecBase2i > *return_value = new ConstPointerToArray< LVecBase2i >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase2i, true, false);
      }
    }

  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(const PointerToArray copy)\n");
  }
  return -1;
}

ConstPointerToArray< LVecBase2i > *Dtool_Coerce_ConstPointerToArray_LVecBase2i(PyObject *args, ConstPointerToArray< LVecBase2i > &coerced) {
  ConstPointerToArray< LVecBase2i > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_ConstPointerToArray_LVecBase2i)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< LVecBase2i > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConstPointerToArray< LVecBase2i >::ConstPointerToArray(PointerToArray< LVecBase2i > const &copy)
    PointerToArray< LVecBase2i > const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_LVecBase2i);
    if (arg_this != nullptr) {
      coerced = ConstPointerToArray< LVecBase2i >(*arg_this);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_LVecBase2i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConstPointerToArray_LVecBase2i) {
    printf("ConstPointerToArray_LVecBase2i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConstPointerToArray< LVecBase2i > *local_this = (ConstPointerToArray< LVecBase2i > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConstPointerToArray_LVecBase2i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LVecBase2i) {
    return (PointerToArrayBase< LVecBase2i > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2i) {
    return (PointerToBase< ReferenceCountedVector< LVecBase2i > > *)(PointerToArrayBase< LVecBase2i > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase2i > > *)(PointerToArrayBase< LVecBase2i > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_LVecBase2i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_LVecBase2i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase2i) {
    PointerToArrayBase< LVecBase2i >* other_this = (PointerToArrayBase< LVecBase2i >*)from_this;
    return (ConstPointerToArray< LVecBase2i >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2i) {
    PointerToBase< ReferenceCountedVector< LVecBase2i > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase2i > >*)from_this;
    return (ConstPointerToArray< LVecBase2i >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< LVecBase2i >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< LVecBase2i >
 */
static int Dtool_Init_PointerToArrayBase_LVecBase2i(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_LVecBase2i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArrayBase_LVecBase2i) {
    printf("PointerToArrayBase_LVecBase2i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArrayBase< LVecBase2i > *local_this = (PointerToArrayBase< LVecBase2i > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArrayBase_LVecBase2i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2i) {
    return (PointerToBase< ReferenceCountedVector< LVecBase2i > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase2i > > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_LVecBase2i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase2i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2i) {
    PointerToBase< ReferenceCountedVector< LVecBase2i > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase2i > >*)from_this;
    return (PointerToArrayBase< LVecBase2i >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< LVecBase2i >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< LVecBase2i > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< LVecBase2i > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i_clear_81(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< LVecBase2i > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i, (void **)&local_this, "PointerToBase_ReferenceCountedVector_LVecBase2i.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< LVecBase2i > >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i_clear_81_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i_clear_81_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< LVecBase2i > >::output(std::ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i_output_82(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< LVecBase2i > > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i)) {
    return nullptr;
  }
  // 1-void PointerToBase< ReferenceCountedVector< LVecBase2i > >::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PointerToBase< ReferenceCountedVector< LVecBase2i > >*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i_output_82_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i_output_82_comment = nullptr;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_LVecBase2i(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LVecBase2i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i) {
    printf("PointerToBase_ReferenceCountedVector_LVecBase2i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToBase< ReferenceCountedVector< LVecBase2i > > *local_this = (PointerToBase< ReferenceCountedVector< LVecBase2i > > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LVecBase2i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< LVecBase2i > >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConstPointerToArray< LVecBase3d >
 */
/**
 * Python function wrapper for:
 * inline void ConstPointerToArray< LVecBase3d >::clear(void)
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3d_clear_104(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConstPointerToArray_LVecBase3d, (void **)&local_this, "ConstPointerToArray_LVecBase3d.clear")) {
    return nullptr;
  }
  // 1-inline void ConstPointerToArray< LVecBase3d >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3d_clear_104_comment =
  "C++ Interface:\n"
  "clear(const ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3d_clear_104_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3d const &ConstPointerToArray< LVecBase3d >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3d_get_element_106(PyObject *self, PyObject *arg) {
  ConstPointerToArray< LVecBase3d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase3d)) {
    return nullptr;
  }
  // 1-inline LVecBase3d const &ConstPointerToArray< LVecBase3d >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LVecBase3d const *return_value = &(((*(const ConstPointerToArray< LVecBase3d >*)local_this).get_element)((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3d_get_element_106_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3d_get_element_106_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< LVecBase3d >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3d_get_data_108(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase3d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase3d)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< LVecBase3d >::get_data(void) const
  PyObject *return_value = invoke_extension((const ConstPointerToArray< LVecBase3d >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3d_get_data_108_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3d_get_data_108_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< LVecBase3d >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3d_get_subdata_109(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< LVecBase3d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase3d)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< LVecBase3d >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const ConstPointerToArray< LVecBase3d >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3d_get_subdata_109_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3d_get_subdata_109_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LVecBase3d >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3d_get_ref_count_110(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase3d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase3d)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< LVecBase3d >::get_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< LVecBase3d >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3d_get_ref_count_110_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3d_get_ref_count_110_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LVecBase3d >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3d_get_node_ref_count_111(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase3d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase3d)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< LVecBase3d >::get_node_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< LVecBase3d >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3d_get_node_ref_count_111_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3d_get_node_ref_count_111_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int ConstPointerToArray< LVecBase3d >::count(LVecBase3d const &) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3d_count_112(PyObject *self, PyObject *arg) {
  ConstPointerToArray< LVecBase3d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase3d)) {
    return nullptr;
  }
  // 1-inline unsigned long int ConstPointerToArray< LVecBase3d >::count(LVecBase3d const &) const
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConstPointerToArray.count", "LVecBase3d");
  }
  unsigned long int return_value = ((*(const ConstPointerToArray< LVecBase3d >*)local_this).count)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(ConstPointerToArray self, const LVecBase3d param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3d_count_112_comment =
  "C++ Interface:\n"
  "count(ConstPointerToArray self, const LVecBase3d param0)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3d_count_112_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< LVecBase3d >::ConstPointerToArray(ConstPointerToArray< LVecBase3d > const &copy)
 * inline ConstPointerToArray< LVecBase3d >::ConstPointerToArray(PointerToArray< LVecBase3d > const &copy)
 */
static int Dtool_Init_ConstPointerToArray_LVecBase3d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
    {
      // -2 inline ConstPointerToArray< LVecBase3d >::ConstPointerToArray(ConstPointerToArray< LVecBase3d > const &copy)
      ConstPointerToArray< LVecBase3d > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ConstPointerToArray_LVecBase3d);
      if (arg_this != nullptr) {
        ConstPointerToArray< LVecBase3d > *return_value = new ConstPointerToArray< LVecBase3d >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase3d, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< LVecBase3d >::ConstPointerToArray(PointerToArray< LVecBase3d > const &copy)
      PointerToArray< LVecBase3d > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_LVecBase3d);
      if (arg_this != nullptr) {
        ConstPointerToArray< LVecBase3d > *return_value = new ConstPointerToArray< LVecBase3d >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase3d, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< LVecBase3d >::ConstPointerToArray(ConstPointerToArray< LVecBase3d > const &copy)
      ConstPointerToArray< LVecBase3d > arg_local;
      ConstPointerToArray< LVecBase3d > const *arg_this = Dtool_Coerce_ConstPointerToArray_LVecBase3d(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< LVecBase3d > *return_value = new ConstPointerToArray< LVecBase3d >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase3d, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< LVecBase3d >::ConstPointerToArray(PointerToArray< LVecBase3d > const &copy)
      PointerToArray< LVecBase3d > arg_local;
      PointerToArray< LVecBase3d > const *arg_this = Dtool_Coerce_PointerToArray_LVecBase3d(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< LVecBase3d > *return_value = new ConstPointerToArray< LVecBase3d >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase3d, true, false);
      }
    }

  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(const PointerToArray copy)\n");
  }
  return -1;
}

ConstPointerToArray< LVecBase3d > *Dtool_Coerce_ConstPointerToArray_LVecBase3d(PyObject *args, ConstPointerToArray< LVecBase3d > &coerced) {
  ConstPointerToArray< LVecBase3d > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_ConstPointerToArray_LVecBase3d)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< LVecBase3d > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConstPointerToArray< LVecBase3d >::ConstPointerToArray(PointerToArray< LVecBase3d > const &copy)
    PointerToArray< LVecBase3d > const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_LVecBase3d);
    if (arg_this != nullptr) {
      coerced = ConstPointerToArray< LVecBase3d >(*arg_this);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_LVecBase3d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConstPointerToArray_LVecBase3d) {
    printf("ConstPointerToArray_LVecBase3d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConstPointerToArray< LVecBase3d > *local_this = (ConstPointerToArray< LVecBase3d > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConstPointerToArray_LVecBase3d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LVecBase3d) {
    return (PointerToArrayBase< LVecBase3d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3d) {
    return (PointerToBase< ReferenceCountedVector< LVecBase3d > > *)(PointerToArrayBase< LVecBase3d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase3d > > *)(PointerToArrayBase< LVecBase3d > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_LVecBase3d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_LVecBase3d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase3d) {
    PointerToArrayBase< LVecBase3d >* other_this = (PointerToArrayBase< LVecBase3d >*)from_this;
    return (ConstPointerToArray< LVecBase3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3d) {
    PointerToBase< ReferenceCountedVector< LVecBase3d > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase3d > >*)from_this;
    return (ConstPointerToArray< LVecBase3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< LVecBase3d >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< LVecBase3d >
 */
static int Dtool_Init_PointerToArrayBase_LVecBase3d(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_LVecBase3d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArrayBase_LVecBase3d) {
    printf("PointerToArrayBase_LVecBase3d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArrayBase< LVecBase3d > *local_this = (PointerToArrayBase< LVecBase3d > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArrayBase_LVecBase3d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3d) {
    return (PointerToBase< ReferenceCountedVector< LVecBase3d > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase3d > > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_LVecBase3d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase3d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3d) {
    PointerToBase< ReferenceCountedVector< LVecBase3d > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase3d > >*)from_this;
    return (PointerToArrayBase< LVecBase3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< LVecBase3d >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< LVecBase3d > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< LVecBase3d > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d_clear_100(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< LVecBase3d > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d, (void **)&local_this, "PointerToBase_ReferenceCountedVector_LVecBase3d.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< LVecBase3d > >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d_clear_100_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d_clear_100_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< LVecBase3d > >::output(std::ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d_output_101(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< LVecBase3d > > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d)) {
    return nullptr;
  }
  // 1-void PointerToBase< ReferenceCountedVector< LVecBase3d > >::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PointerToBase< ReferenceCountedVector< LVecBase3d > >*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d_output_101_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d_output_101_comment = nullptr;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_LVecBase3d(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LVecBase3d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d) {
    printf("PointerToBase_ReferenceCountedVector_LVecBase3d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToBase< ReferenceCountedVector< LVecBase3d > > *local_this = (PointerToBase< ReferenceCountedVector< LVecBase3d > > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LVecBase3d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< LVecBase3d > >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConstPointerToArray< LVecBase3f >
 */
/**
 * Python function wrapper for:
 * inline void ConstPointerToArray< LVecBase3f >::clear(void)
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3f_clear_123(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConstPointerToArray_LVecBase3f, (void **)&local_this, "ConstPointerToArray_LVecBase3f.clear")) {
    return nullptr;
  }
  // 1-inline void ConstPointerToArray< LVecBase3f >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3f_clear_123_comment =
  "C++ Interface:\n"
  "clear(const ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3f_clear_123_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f const &ConstPointerToArray< LVecBase3f >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3f_get_element_125(PyObject *self, PyObject *arg) {
  ConstPointerToArray< LVecBase3f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase3f)) {
    return nullptr;
  }
  // 1-inline LVecBase3f const &ConstPointerToArray< LVecBase3f >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LVecBase3f const *return_value = &(((*(const ConstPointerToArray< LVecBase3f >*)local_this).get_element)((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3f_get_element_125_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3f_get_element_125_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< LVecBase3f >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3f_get_data_127(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase3f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase3f)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< LVecBase3f >::get_data(void) const
  PyObject *return_value = invoke_extension((const ConstPointerToArray< LVecBase3f >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3f_get_data_127_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3f_get_data_127_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< LVecBase3f >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3f_get_subdata_128(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< LVecBase3f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase3f)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< LVecBase3f >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const ConstPointerToArray< LVecBase3f >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3f_get_subdata_128_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3f_get_subdata_128_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LVecBase3f >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3f_get_ref_count_129(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase3f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase3f)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< LVecBase3f >::get_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< LVecBase3f >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3f_get_ref_count_129_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3f_get_ref_count_129_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LVecBase3f >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3f_get_node_ref_count_130(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase3f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase3f)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< LVecBase3f >::get_node_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< LVecBase3f >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3f_get_node_ref_count_130_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3f_get_node_ref_count_130_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int ConstPointerToArray< LVecBase3f >::count(LVecBase3f const &) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3f_count_131(PyObject *self, PyObject *arg) {
  ConstPointerToArray< LVecBase3f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase3f)) {
    return nullptr;
  }
  // 1-inline unsigned long int ConstPointerToArray< LVecBase3f >::count(LVecBase3f const &) const
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConstPointerToArray.count", "LVecBase3f");
  }
  unsigned long int return_value = ((*(const ConstPointerToArray< LVecBase3f >*)local_this).count)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(ConstPointerToArray self, const LVecBase3f param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3f_count_131_comment =
  "C++ Interface:\n"
  "count(ConstPointerToArray self, const LVecBase3f param0)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3f_count_131_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< LVecBase3f >::ConstPointerToArray(ConstPointerToArray< LVecBase3f > const &copy)
 * inline ConstPointerToArray< LVecBase3f >::ConstPointerToArray(PointerToArray< LVecBase3f > const &copy)
 */
static int Dtool_Init_ConstPointerToArray_LVecBase3f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
    {
      // -2 inline ConstPointerToArray< LVecBase3f >::ConstPointerToArray(ConstPointerToArray< LVecBase3f > const &copy)
      ConstPointerToArray< LVecBase3f > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ConstPointerToArray_LVecBase3f);
      if (arg_this != nullptr) {
        ConstPointerToArray< LVecBase3f > *return_value = new ConstPointerToArray< LVecBase3f >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase3f, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< LVecBase3f >::ConstPointerToArray(PointerToArray< LVecBase3f > const &copy)
      PointerToArray< LVecBase3f > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_LVecBase3f);
      if (arg_this != nullptr) {
        ConstPointerToArray< LVecBase3f > *return_value = new ConstPointerToArray< LVecBase3f >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase3f, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< LVecBase3f >::ConstPointerToArray(ConstPointerToArray< LVecBase3f > const &copy)
      ConstPointerToArray< LVecBase3f > arg_local;
      ConstPointerToArray< LVecBase3f > const *arg_this = Dtool_Coerce_ConstPointerToArray_LVecBase3f(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< LVecBase3f > *return_value = new ConstPointerToArray< LVecBase3f >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase3f, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< LVecBase3f >::ConstPointerToArray(PointerToArray< LVecBase3f > const &copy)
      PointerToArray< LVecBase3f > arg_local;
      PointerToArray< LVecBase3f > const *arg_this = Dtool_Coerce_PointerToArray_LVecBase3f(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< LVecBase3f > *return_value = new ConstPointerToArray< LVecBase3f >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase3f, true, false);
      }
    }

  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(const PointerToArray copy)\n");
  }
  return -1;
}

ConstPointerToArray< LVecBase3f > *Dtool_Coerce_ConstPointerToArray_LVecBase3f(PyObject *args, ConstPointerToArray< LVecBase3f > &coerced) {
  ConstPointerToArray< LVecBase3f > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_ConstPointerToArray_LVecBase3f)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< LVecBase3f > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConstPointerToArray< LVecBase3f >::ConstPointerToArray(PointerToArray< LVecBase3f > const &copy)
    PointerToArray< LVecBase3f > const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_LVecBase3f);
    if (arg_this != nullptr) {
      coerced = ConstPointerToArray< LVecBase3f >(*arg_this);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_LVecBase3f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConstPointerToArray_LVecBase3f) {
    printf("ConstPointerToArray_LVecBase3f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConstPointerToArray< LVecBase3f > *local_this = (ConstPointerToArray< LVecBase3f > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConstPointerToArray_LVecBase3f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LVecBase3f) {
    return (PointerToArrayBase< LVecBase3f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3f) {
    return (PointerToBase< ReferenceCountedVector< LVecBase3f > > *)(PointerToArrayBase< LVecBase3f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase3f > > *)(PointerToArrayBase< LVecBase3f > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_LVecBase3f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_LVecBase3f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase3f) {
    PointerToArrayBase< LVecBase3f >* other_this = (PointerToArrayBase< LVecBase3f >*)from_this;
    return (ConstPointerToArray< LVecBase3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3f) {
    PointerToBase< ReferenceCountedVector< LVecBase3f > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase3f > >*)from_this;
    return (ConstPointerToArray< LVecBase3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< LVecBase3f >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< LVecBase3f >
 */
static int Dtool_Init_PointerToArrayBase_LVecBase3f(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_LVecBase3f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArrayBase_LVecBase3f) {
    printf("PointerToArrayBase_LVecBase3f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArrayBase< LVecBase3f > *local_this = (PointerToArrayBase< LVecBase3f > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArrayBase_LVecBase3f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3f) {
    return (PointerToBase< ReferenceCountedVector< LVecBase3f > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase3f > > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_LVecBase3f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase3f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3f) {
    PointerToBase< ReferenceCountedVector< LVecBase3f > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase3f > >*)from_this;
    return (PointerToArrayBase< LVecBase3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< LVecBase3f >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< LVecBase3f > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< LVecBase3f > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f_clear_119(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< LVecBase3f > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f, (void **)&local_this, "PointerToBase_ReferenceCountedVector_LVecBase3f.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< LVecBase3f > >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f_clear_119_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f_clear_119_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< LVecBase3f > >::output(std::ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f_output_120(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< LVecBase3f > > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f)) {
    return nullptr;
  }
  // 1-void PointerToBase< ReferenceCountedVector< LVecBase3f > >::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PointerToBase< ReferenceCountedVector< LVecBase3f > >*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f_output_120_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f_output_120_comment = nullptr;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_LVecBase3f(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LVecBase3f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f) {
    printf("PointerToBase_ReferenceCountedVector_LVecBase3f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToBase< ReferenceCountedVector< LVecBase3f > > *local_this = (PointerToBase< ReferenceCountedVector< LVecBase3f > > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LVecBase3f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< LVecBase3f > >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConstPointerToArray< LVecBase3i >
 */
/**
 * Python function wrapper for:
 * inline void ConstPointerToArray< LVecBase3i >::clear(void)
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3i_clear_142(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase3i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConstPointerToArray_LVecBase3i, (void **)&local_this, "ConstPointerToArray_LVecBase3i.clear")) {
    return nullptr;
  }
  // 1-inline void ConstPointerToArray< LVecBase3i >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3i_clear_142_comment =
  "C++ Interface:\n"
  "clear(const ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3i_clear_142_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3i const &ConstPointerToArray< LVecBase3i >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3i_get_element_144(PyObject *self, PyObject *arg) {
  ConstPointerToArray< LVecBase3i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase3i)) {
    return nullptr;
  }
  // 1-inline LVecBase3i const &ConstPointerToArray< LVecBase3i >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LVecBase3i const *return_value = &(((*(const ConstPointerToArray< LVecBase3i >*)local_this).get_element)((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3i_get_element_144_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3i_get_element_144_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< LVecBase3i >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3i_get_data_146(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase3i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase3i)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< LVecBase3i >::get_data(void) const
  PyObject *return_value = invoke_extension((const ConstPointerToArray< LVecBase3i >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3i_get_data_146_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3i_get_data_146_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< LVecBase3i >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3i_get_subdata_147(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< LVecBase3i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase3i)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< LVecBase3i >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const ConstPointerToArray< LVecBase3i >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3i_get_subdata_147_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3i_get_subdata_147_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LVecBase3i >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3i_get_ref_count_148(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase3i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase3i)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< LVecBase3i >::get_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< LVecBase3i >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3i_get_ref_count_148_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3i_get_ref_count_148_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< LVecBase3i >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3i_get_node_ref_count_149(PyObject *self, PyObject *) {
  ConstPointerToArray< LVecBase3i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase3i)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< LVecBase3i >::get_node_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< LVecBase3i >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3i_get_node_ref_count_149_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3i_get_node_ref_count_149_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int ConstPointerToArray< LVecBase3i >::count(LVecBase3i const &) const
 */
static PyObject *Dtool_ConstPointerToArray_LVecBase3i_count_150(PyObject *self, PyObject *arg) {
  ConstPointerToArray< LVecBase3i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_LVecBase3i)) {
    return nullptr;
  }
  // 1-inline unsigned long int ConstPointerToArray< LVecBase3i >::count(LVecBase3i const &) const
  LVecBase3i arg_local;
  LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConstPointerToArray.count", "LVecBase3i");
  }
  unsigned long int return_value = ((*(const ConstPointerToArray< LVecBase3i >*)local_this).count)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(ConstPointerToArray self, const LVecBase3i param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_LVecBase3i_count_150_comment =
  "C++ Interface:\n"
  "count(ConstPointerToArray self, const LVecBase3i param0)\n";
#else
static const char *Dtool_ConstPointerToArray_LVecBase3i_count_150_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< LVecBase3i >::ConstPointerToArray(ConstPointerToArray< LVecBase3i > const &copy)
 * inline ConstPointerToArray< LVecBase3i >::ConstPointerToArray(PointerToArray< LVecBase3i > const &copy)
 */
static int Dtool_Init_ConstPointerToArray_LVecBase3i(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
    {
      // -2 inline ConstPointerToArray< LVecBase3i >::ConstPointerToArray(ConstPointerToArray< LVecBase3i > const &copy)
      ConstPointerToArray< LVecBase3i > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ConstPointerToArray_LVecBase3i);
      if (arg_this != nullptr) {
        ConstPointerToArray< LVecBase3i > *return_value = new ConstPointerToArray< LVecBase3i >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase3i, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< LVecBase3i >::ConstPointerToArray(PointerToArray< LVecBase3i > const &copy)
      PointerToArray< LVecBase3i > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_LVecBase3i);
      if (arg_this != nullptr) {
        ConstPointerToArray< LVecBase3i > *return_value = new ConstPointerToArray< LVecBase3i >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase3i, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< LVecBase3i >::ConstPointerToArray(ConstPointerToArray< LVecBase3i > const &copy)
      ConstPointerToArray< LVecBase3i > arg_local;
      ConstPointerToArray< LVecBase3i > const *arg_this = Dtool_Coerce_ConstPointerToArray_LVecBase3i(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< LVecBase3i > *return_value = new ConstPointerToArray< LVecBase3i >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase3i, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< LVecBase3i >::ConstPointerToArray(PointerToArray< LVecBase3i > const &copy)
      PointerToArray< LVecBase3i > arg_local;
      PointerToArray< LVecBase3i > const *arg_this = Dtool_Coerce_PointerToArray_LVecBase3i(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< LVecBase3i > *return_value = new ConstPointerToArray< LVecBase3i >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_LVecBase3i, true, false);
      }
    }

  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(const PointerToArray copy)\n");
  }
  return -1;
}

ConstPointerToArray< LVecBase3i > *Dtool_Coerce_ConstPointerToArray_LVecBase3i(PyObject *args, ConstPointerToArray< LVecBase3i > &coerced) {
  ConstPointerToArray< LVecBase3i > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_ConstPointerToArray_LVecBase3i)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< LVecBase3i > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConstPointerToArray< LVecBase3i >::ConstPointerToArray(PointerToArray< LVecBase3i > const &copy)
    PointerToArray< LVecBase3i > const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_LVecBase3i);
    if (arg_this != nullptr) {
      coerced = ConstPointerToArray< LVecBase3i >(*arg_this);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_LVecBase3i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConstPointerToArray_LVecBase3i) {
    printf("ConstPointerToArray_LVecBase3i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConstPointerToArray< LVecBase3i > *local_this = (ConstPointerToArray< LVecBase3i > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConstPointerToArray_LVecBase3i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LVecBase3i) {
    return (PointerToArrayBase< LVecBase3i > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3i) {
    return (PointerToBase< ReferenceCountedVector< LVecBase3i > > *)(PointerToArrayBase< LVecBase3i > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase3i > > *)(PointerToArrayBase< LVecBase3i > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_LVecBase3i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_LVecBase3i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase3i) {
    PointerToArrayBase< LVecBase3i >* other_this = (PointerToArrayBase< LVecBase3i >*)from_this;
    return (ConstPointerToArray< LVecBase3i >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3i) {
    PointerToBase< ReferenceCountedVector< LVecBase3i > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase3i > >*)from_this;
    return (ConstPointerToArray< LVecBase3i >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< LVecBase3i >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< LVecBase3i >
 */
static int Dtool_Init_PointerToArrayBase_LVecBase3i(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_LVecBase3i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArrayBase_LVecBase3i) {
    printf("PointerToArrayBase_LVecBase3i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArrayBase< LVecBase3i > *local_this = (PointerToArrayBase< LVecBase3i > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArrayBase_LVecBase3i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3i) {
    return (PointerToBase< ReferenceCountedVector< LVecBase3i > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase3i > > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_LVecBase3i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase3i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3i) {
    PointerToBase< ReferenceCountedVector< LVecBase3i > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase3i > >*)from_this;
    return (PointerToArrayBase< LVecBase3i >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< LVecBase3i >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< LVecBase3i > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< LVecBase3i > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i_clear_138(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< LVecBase3i > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i, (void **)&local_this, "PointerToBase_ReferenceCountedVector_LVecBase3i.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< LVecBase3i > >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i_clear_138_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i_clear_138_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< LVecBase3i > >::output(std::ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i_output_139(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< LVecBase3i > > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i)) {
    return nullptr;
  }
  // 1-void PointerToBase< ReferenceCountedVector< LVecBase3i > >::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PointerToBase< ReferenceCountedVector< LVecBase3i > >*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i_output_139_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i_output_139_comment = nullptr;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_LVecBase3i(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LVecBase3i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i) {
    printf("PointerToBase_ReferenceCountedVector_LVecBase3i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToBase< ReferenceCountedVector< LVecBase3i > > *local_this = (PointerToBase< ReferenceCountedVector< LVecBase3i > > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LVecBase3i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< LVecBase3i > >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConstPointerToArray< UnalignedLMatrix4d >
 */
/**
 * Python function wrapper for:
 * inline void ConstPointerToArray< UnalignedLMatrix4d >::clear(void)
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLMatrix4d_clear_161(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLMatrix4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConstPointerToArray_UnalignedLMatrix4d, (void **)&local_this, "ConstPointerToArray_UnalignedLMatrix4d.clear")) {
    return nullptr;
  }
  // 1-inline void ConstPointerToArray< UnalignedLMatrix4d >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4d_clear_161_comment =
  "C++ Interface:\n"
  "clear(const ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4d_clear_161_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UnalignedLMatrix4d const &ConstPointerToArray< UnalignedLMatrix4d >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_element_163(PyObject *self, PyObject *arg) {
  ConstPointerToArray< UnalignedLMatrix4d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_UnalignedLMatrix4d)) {
    return nullptr;
  }
  // 1-inline UnalignedLMatrix4d const &ConstPointerToArray< UnalignedLMatrix4d >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    UnalignedLMatrix4d const *return_value = &(((*(const ConstPointerToArray< UnalignedLMatrix4d >*)local_this).get_element)((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLMatrix4d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_element_163_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_element_163_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< UnalignedLMatrix4d >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_data_165(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLMatrix4d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_UnalignedLMatrix4d)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< UnalignedLMatrix4d >::get_data(void) const
  PyObject *return_value = invoke_extension((const ConstPointerToArray< UnalignedLMatrix4d >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_data_165_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_data_165_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< UnalignedLMatrix4d >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_subdata_166(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< UnalignedLMatrix4d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_UnalignedLMatrix4d)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< UnalignedLMatrix4d >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const ConstPointerToArray< UnalignedLMatrix4d >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_subdata_166_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_subdata_166_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< UnalignedLMatrix4d >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_ref_count_167(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLMatrix4d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_UnalignedLMatrix4d)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< UnalignedLMatrix4d >::get_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< UnalignedLMatrix4d >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_ref_count_167_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_ref_count_167_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< UnalignedLMatrix4d >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_node_ref_count_168(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLMatrix4d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_UnalignedLMatrix4d)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< UnalignedLMatrix4d >::get_node_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< UnalignedLMatrix4d >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_node_ref_count_168_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_node_ref_count_168_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int ConstPointerToArray< UnalignedLMatrix4d >::count(UnalignedLMatrix4d const &) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLMatrix4d_count_169(PyObject *self, PyObject *arg) {
  ConstPointerToArray< UnalignedLMatrix4d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_UnalignedLMatrix4d)) {
    return nullptr;
  }
  // 1-inline unsigned long int ConstPointerToArray< UnalignedLMatrix4d >::count(UnalignedLMatrix4d const &) const
  UnalignedLMatrix4d arg_local;
  UnalignedLMatrix4d const *arg_this = Dtool_Coerce_UnalignedLMatrix4d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConstPointerToArray.count", "UnalignedLMatrix4d");
  }
  unsigned long int return_value = ((*(const ConstPointerToArray< UnalignedLMatrix4d >*)local_this).count)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(ConstPointerToArray self, const UnalignedLMatrix4d param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4d_count_169_comment =
  "C++ Interface:\n"
  "count(ConstPointerToArray self, const UnalignedLMatrix4d param0)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4d_count_169_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< UnalignedLMatrix4d >::ConstPointerToArray(ConstPointerToArray< UnalignedLMatrix4d > const &copy)
 * inline ConstPointerToArray< UnalignedLMatrix4d >::ConstPointerToArray(PointerToArray< UnalignedLMatrix4d > const &copy)
 */
static int Dtool_Init_ConstPointerToArray_UnalignedLMatrix4d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
    {
      // -2 inline ConstPointerToArray< UnalignedLMatrix4d >::ConstPointerToArray(ConstPointerToArray< UnalignedLMatrix4d > const &copy)
      ConstPointerToArray< UnalignedLMatrix4d > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ConstPointerToArray_UnalignedLMatrix4d);
      if (arg_this != nullptr) {
        ConstPointerToArray< UnalignedLMatrix4d > *return_value = new ConstPointerToArray< UnalignedLMatrix4d >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLMatrix4d, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< UnalignedLMatrix4d >::ConstPointerToArray(PointerToArray< UnalignedLMatrix4d > const &copy)
      PointerToArray< UnalignedLMatrix4d > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_UnalignedLMatrix4d);
      if (arg_this != nullptr) {
        ConstPointerToArray< UnalignedLMatrix4d > *return_value = new ConstPointerToArray< UnalignedLMatrix4d >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLMatrix4d, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< UnalignedLMatrix4d >::ConstPointerToArray(ConstPointerToArray< UnalignedLMatrix4d > const &copy)
      ConstPointerToArray< UnalignedLMatrix4d > arg_local;
      ConstPointerToArray< UnalignedLMatrix4d > const *arg_this = Dtool_Coerce_ConstPointerToArray_UnalignedLMatrix4d(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< UnalignedLMatrix4d > *return_value = new ConstPointerToArray< UnalignedLMatrix4d >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLMatrix4d, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< UnalignedLMatrix4d >::ConstPointerToArray(PointerToArray< UnalignedLMatrix4d > const &copy)
      PointerToArray< UnalignedLMatrix4d > arg_local;
      PointerToArray< UnalignedLMatrix4d > const *arg_this = Dtool_Coerce_PointerToArray_UnalignedLMatrix4d(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< UnalignedLMatrix4d > *return_value = new ConstPointerToArray< UnalignedLMatrix4d >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLMatrix4d, true, false);
      }
    }

  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(const PointerToArray copy)\n");
  }
  return -1;
}

ConstPointerToArray< UnalignedLMatrix4d > *Dtool_Coerce_ConstPointerToArray_UnalignedLMatrix4d(PyObject *args, ConstPointerToArray< UnalignedLMatrix4d > &coerced) {
  ConstPointerToArray< UnalignedLMatrix4d > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_ConstPointerToArray_UnalignedLMatrix4d)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< UnalignedLMatrix4d > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConstPointerToArray< UnalignedLMatrix4d >::ConstPointerToArray(PointerToArray< UnalignedLMatrix4d > const &copy)
    PointerToArray< UnalignedLMatrix4d > const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_UnalignedLMatrix4d);
    if (arg_this != nullptr) {
      coerced = ConstPointerToArray< UnalignedLMatrix4d >(*arg_this);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_UnalignedLMatrix4d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConstPointerToArray_UnalignedLMatrix4d) {
    printf("ConstPointerToArray_UnalignedLMatrix4d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConstPointerToArray< UnalignedLMatrix4d > *local_this = (ConstPointerToArray< UnalignedLMatrix4d > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConstPointerToArray_UnalignedLMatrix4d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4d) {
    return (PointerToArrayBase< UnalignedLMatrix4d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d) {
    return (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > > *)(PointerToArrayBase< UnalignedLMatrix4d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > > *)(PointerToArrayBase< UnalignedLMatrix4d > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_UnalignedLMatrix4d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_UnalignedLMatrix4d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4d) {
    PointerToArrayBase< UnalignedLMatrix4d >* other_this = (PointerToArrayBase< UnalignedLMatrix4d >*)from_this;
    return (ConstPointerToArray< UnalignedLMatrix4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d) {
    PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > >* other_this = (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > >*)from_this;
    return (ConstPointerToArray< UnalignedLMatrix4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< UnalignedLMatrix4d >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< UnalignedLMatrix4d >
 */
static int Dtool_Init_PointerToArrayBase_UnalignedLMatrix4d(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_UnalignedLMatrix4d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArrayBase_UnalignedLMatrix4d) {
    printf("PointerToArrayBase_UnalignedLMatrix4d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArrayBase< UnalignedLMatrix4d > *local_this = (PointerToArrayBase< UnalignedLMatrix4d > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArrayBase_UnalignedLMatrix4d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d) {
    return (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_UnalignedLMatrix4d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d) {
    PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > >* other_this = (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > >*)from_this;
    return (PointerToArrayBase< UnalignedLMatrix4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< UnalignedLMatrix4d >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d_clear_157(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d, (void **)&local_this, "PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d_clear_157_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d_clear_157_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > >::output(std::ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d_output_158(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d)) {
    return nullptr;
  }
  // 1-void PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > >::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > >*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d_output_158_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d_output_158_comment = nullptr;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d) {
    printf("PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > > *local_this = (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConstPointerToArray< UnalignedLMatrix4f >
 */
/**
 * Python function wrapper for:
 * inline void ConstPointerToArray< UnalignedLMatrix4f >::clear(void)
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLMatrix4f_clear_180(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLMatrix4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConstPointerToArray_UnalignedLMatrix4f, (void **)&local_this, "ConstPointerToArray_UnalignedLMatrix4f.clear")) {
    return nullptr;
  }
  // 1-inline void ConstPointerToArray< UnalignedLMatrix4f >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4f_clear_180_comment =
  "C++ Interface:\n"
  "clear(const ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4f_clear_180_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UnalignedLMatrix4f const &ConstPointerToArray< UnalignedLMatrix4f >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_element_182(PyObject *self, PyObject *arg) {
  ConstPointerToArray< UnalignedLMatrix4f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_UnalignedLMatrix4f)) {
    return nullptr;
  }
  // 1-inline UnalignedLMatrix4f const &ConstPointerToArray< UnalignedLMatrix4f >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    UnalignedLMatrix4f const *return_value = &(((*(const ConstPointerToArray< UnalignedLMatrix4f >*)local_this).get_element)((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLMatrix4f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_element_182_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_element_182_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< UnalignedLMatrix4f >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_data_184(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLMatrix4f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_UnalignedLMatrix4f)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< UnalignedLMatrix4f >::get_data(void) const
  PyObject *return_value = invoke_extension((const ConstPointerToArray< UnalignedLMatrix4f >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_data_184_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_data_184_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< UnalignedLMatrix4f >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_subdata_185(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< UnalignedLMatrix4f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_UnalignedLMatrix4f)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< UnalignedLMatrix4f >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const ConstPointerToArray< UnalignedLMatrix4f >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_subdata_185_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_subdata_185_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< UnalignedLMatrix4f >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_ref_count_186(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLMatrix4f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_UnalignedLMatrix4f)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< UnalignedLMatrix4f >::get_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< UnalignedLMatrix4f >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_ref_count_186_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_ref_count_186_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< UnalignedLMatrix4f >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_node_ref_count_187(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLMatrix4f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_UnalignedLMatrix4f)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< UnalignedLMatrix4f >::get_node_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< UnalignedLMatrix4f >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_node_ref_count_187_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_node_ref_count_187_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int ConstPointerToArray< UnalignedLMatrix4f >::count(UnalignedLMatrix4f const &) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLMatrix4f_count_188(PyObject *self, PyObject *arg) {
  ConstPointerToArray< UnalignedLMatrix4f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_UnalignedLMatrix4f)) {
    return nullptr;
  }
  // 1-inline unsigned long int ConstPointerToArray< UnalignedLMatrix4f >::count(UnalignedLMatrix4f const &) const
  UnalignedLMatrix4f arg_local;
  UnalignedLMatrix4f const *arg_this = Dtool_Coerce_UnalignedLMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConstPointerToArray.count", "UnalignedLMatrix4f");
  }
  unsigned long int return_value = ((*(const ConstPointerToArray< UnalignedLMatrix4f >*)local_this).count)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(ConstPointerToArray self, const UnalignedLMatrix4f param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4f_count_188_comment =
  "C++ Interface:\n"
  "count(ConstPointerToArray self, const UnalignedLMatrix4f param0)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLMatrix4f_count_188_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< UnalignedLMatrix4f >::ConstPointerToArray(ConstPointerToArray< UnalignedLMatrix4f > const &copy)
 * inline ConstPointerToArray< UnalignedLMatrix4f >::ConstPointerToArray(PointerToArray< UnalignedLMatrix4f > const &copy)
 */
static int Dtool_Init_ConstPointerToArray_UnalignedLMatrix4f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
    {
      // -2 inline ConstPointerToArray< UnalignedLMatrix4f >::ConstPointerToArray(ConstPointerToArray< UnalignedLMatrix4f > const &copy)
      ConstPointerToArray< UnalignedLMatrix4f > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ConstPointerToArray_UnalignedLMatrix4f);
      if (arg_this != nullptr) {
        ConstPointerToArray< UnalignedLMatrix4f > *return_value = new ConstPointerToArray< UnalignedLMatrix4f >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLMatrix4f, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< UnalignedLMatrix4f >::ConstPointerToArray(PointerToArray< UnalignedLMatrix4f > const &copy)
      PointerToArray< UnalignedLMatrix4f > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_UnalignedLMatrix4f);
      if (arg_this != nullptr) {
        ConstPointerToArray< UnalignedLMatrix4f > *return_value = new ConstPointerToArray< UnalignedLMatrix4f >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLMatrix4f, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< UnalignedLMatrix4f >::ConstPointerToArray(ConstPointerToArray< UnalignedLMatrix4f > const &copy)
      ConstPointerToArray< UnalignedLMatrix4f > arg_local;
      ConstPointerToArray< UnalignedLMatrix4f > const *arg_this = Dtool_Coerce_ConstPointerToArray_UnalignedLMatrix4f(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< UnalignedLMatrix4f > *return_value = new ConstPointerToArray< UnalignedLMatrix4f >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLMatrix4f, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< UnalignedLMatrix4f >::ConstPointerToArray(PointerToArray< UnalignedLMatrix4f > const &copy)
      PointerToArray< UnalignedLMatrix4f > arg_local;
      PointerToArray< UnalignedLMatrix4f > const *arg_this = Dtool_Coerce_PointerToArray_UnalignedLMatrix4f(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< UnalignedLMatrix4f > *return_value = new ConstPointerToArray< UnalignedLMatrix4f >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLMatrix4f, true, false);
      }
    }

  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(const PointerToArray copy)\n");
  }
  return -1;
}

ConstPointerToArray< UnalignedLMatrix4f > *Dtool_Coerce_ConstPointerToArray_UnalignedLMatrix4f(PyObject *args, ConstPointerToArray< UnalignedLMatrix4f > &coerced) {
  ConstPointerToArray< UnalignedLMatrix4f > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_ConstPointerToArray_UnalignedLMatrix4f)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< UnalignedLMatrix4f > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConstPointerToArray< UnalignedLMatrix4f >::ConstPointerToArray(PointerToArray< UnalignedLMatrix4f > const &copy)
    PointerToArray< UnalignedLMatrix4f > const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_UnalignedLMatrix4f);
    if (arg_this != nullptr) {
      coerced = ConstPointerToArray< UnalignedLMatrix4f >(*arg_this);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_UnalignedLMatrix4f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConstPointerToArray_UnalignedLMatrix4f) {
    printf("ConstPointerToArray_UnalignedLMatrix4f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConstPointerToArray< UnalignedLMatrix4f > *local_this = (ConstPointerToArray< UnalignedLMatrix4f > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConstPointerToArray_UnalignedLMatrix4f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4f) {
    return (PointerToArrayBase< UnalignedLMatrix4f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f) {
    return (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > > *)(PointerToArrayBase< UnalignedLMatrix4f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > > *)(PointerToArrayBase< UnalignedLMatrix4f > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_UnalignedLMatrix4f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_UnalignedLMatrix4f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4f) {
    PointerToArrayBase< UnalignedLMatrix4f >* other_this = (PointerToArrayBase< UnalignedLMatrix4f >*)from_this;
    return (ConstPointerToArray< UnalignedLMatrix4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f) {
    PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > >* other_this = (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > >*)from_this;
    return (ConstPointerToArray< UnalignedLMatrix4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< UnalignedLMatrix4f >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< UnalignedLMatrix4f >
 */
static int Dtool_Init_PointerToArrayBase_UnalignedLMatrix4f(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_UnalignedLMatrix4f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArrayBase_UnalignedLMatrix4f) {
    printf("PointerToArrayBase_UnalignedLMatrix4f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArrayBase< UnalignedLMatrix4f > *local_this = (PointerToArrayBase< UnalignedLMatrix4f > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArrayBase_UnalignedLMatrix4f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f) {
    return (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_UnalignedLMatrix4f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f) {
    PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > >* other_this = (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > >*)from_this;
    return (PointerToArrayBase< UnalignedLMatrix4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< UnalignedLMatrix4f >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f_clear_176(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f, (void **)&local_this, "PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f_clear_176_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f_clear_176_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > >::output(std::ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f_output_177(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f)) {
    return nullptr;
  }
  // 1-void PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > >::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > >*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f_output_177_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f_output_177_comment = nullptr;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f) {
    printf("PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > > *local_this = (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConstPointerToArray< UnalignedLVecBase4d >
 */
/**
 * Python function wrapper for:
 * inline void ConstPointerToArray< UnalignedLVecBase4d >::clear(void)
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4d_clear_199(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLVecBase4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConstPointerToArray_UnalignedLVecBase4d, (void **)&local_this, "ConstPointerToArray_UnalignedLVecBase4d.clear")) {
    return nullptr;
  }
  // 1-inline void ConstPointerToArray< UnalignedLVecBase4d >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4d_clear_199_comment =
  "C++ Interface:\n"
  "clear(const ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4d_clear_199_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UnalignedLVecBase4d const &ConstPointerToArray< UnalignedLVecBase4d >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_element_201(PyObject *self, PyObject *arg) {
  ConstPointerToArray< UnalignedLVecBase4d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_UnalignedLVecBase4d)) {
    return nullptr;
  }
  // 1-inline UnalignedLVecBase4d const &ConstPointerToArray< UnalignedLVecBase4d >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    UnalignedLVecBase4d const *return_value = &(((*(const ConstPointerToArray< UnalignedLVecBase4d >*)local_this).get_element)((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLVecBase4d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_element_201_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_element_201_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< UnalignedLVecBase4d >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_data_203(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLVecBase4d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_UnalignedLVecBase4d)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< UnalignedLVecBase4d >::get_data(void) const
  PyObject *return_value = invoke_extension((const ConstPointerToArray< UnalignedLVecBase4d >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_data_203_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_data_203_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< UnalignedLVecBase4d >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_subdata_204(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< UnalignedLVecBase4d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_UnalignedLVecBase4d)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< UnalignedLVecBase4d >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const ConstPointerToArray< UnalignedLVecBase4d >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_subdata_204_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_subdata_204_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< UnalignedLVecBase4d >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_ref_count_205(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLVecBase4d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_UnalignedLVecBase4d)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< UnalignedLVecBase4d >::get_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< UnalignedLVecBase4d >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_ref_count_205_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_ref_count_205_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< UnalignedLVecBase4d >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_node_ref_count_206(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLVecBase4d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_UnalignedLVecBase4d)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< UnalignedLVecBase4d >::get_node_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< UnalignedLVecBase4d >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_node_ref_count_206_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_node_ref_count_206_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int ConstPointerToArray< UnalignedLVecBase4d >::count(UnalignedLVecBase4d const &) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4d_count_207(PyObject *self, PyObject *arg) {
  ConstPointerToArray< UnalignedLVecBase4d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_UnalignedLVecBase4d)) {
    return nullptr;
  }
  // 1-inline unsigned long int ConstPointerToArray< UnalignedLVecBase4d >::count(UnalignedLVecBase4d const &) const
  UnalignedLVecBase4d arg_local;
  UnalignedLVecBase4d const *arg_this = Dtool_Coerce_UnalignedLVecBase4d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConstPointerToArray.count", "UnalignedLVecBase4d");
  }
  unsigned long int return_value = ((*(const ConstPointerToArray< UnalignedLVecBase4d >*)local_this).count)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(ConstPointerToArray self, const UnalignedLVecBase4d param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4d_count_207_comment =
  "C++ Interface:\n"
  "count(ConstPointerToArray self, const UnalignedLVecBase4d param0)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4d_count_207_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< UnalignedLVecBase4d >::ConstPointerToArray(ConstPointerToArray< UnalignedLVecBase4d > const &copy)
 * inline ConstPointerToArray< UnalignedLVecBase4d >::ConstPointerToArray(PointerToArray< UnalignedLVecBase4d > const &copy)
 */
static int Dtool_Init_ConstPointerToArray_UnalignedLVecBase4d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
    {
      // -2 inline ConstPointerToArray< UnalignedLVecBase4d >::ConstPointerToArray(ConstPointerToArray< UnalignedLVecBase4d > const &copy)
      ConstPointerToArray< UnalignedLVecBase4d > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4d);
      if (arg_this != nullptr) {
        ConstPointerToArray< UnalignedLVecBase4d > *return_value = new ConstPointerToArray< UnalignedLVecBase4d >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLVecBase4d, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< UnalignedLVecBase4d >::ConstPointerToArray(PointerToArray< UnalignedLVecBase4d > const &copy)
      PointerToArray< UnalignedLVecBase4d > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_UnalignedLVecBase4d);
      if (arg_this != nullptr) {
        ConstPointerToArray< UnalignedLVecBase4d > *return_value = new ConstPointerToArray< UnalignedLVecBase4d >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLVecBase4d, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< UnalignedLVecBase4d >::ConstPointerToArray(ConstPointerToArray< UnalignedLVecBase4d > const &copy)
      ConstPointerToArray< UnalignedLVecBase4d > arg_local;
      ConstPointerToArray< UnalignedLVecBase4d > const *arg_this = Dtool_Coerce_ConstPointerToArray_UnalignedLVecBase4d(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< UnalignedLVecBase4d > *return_value = new ConstPointerToArray< UnalignedLVecBase4d >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLVecBase4d, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< UnalignedLVecBase4d >::ConstPointerToArray(PointerToArray< UnalignedLVecBase4d > const &copy)
      PointerToArray< UnalignedLVecBase4d > arg_local;
      PointerToArray< UnalignedLVecBase4d > const *arg_this = Dtool_Coerce_PointerToArray_UnalignedLVecBase4d(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< UnalignedLVecBase4d > *return_value = new ConstPointerToArray< UnalignedLVecBase4d >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLVecBase4d, true, false);
      }
    }

  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(const PointerToArray copy)\n");
  }
  return -1;
}

ConstPointerToArray< UnalignedLVecBase4d > *Dtool_Coerce_ConstPointerToArray_UnalignedLVecBase4d(PyObject *args, ConstPointerToArray< UnalignedLVecBase4d > &coerced) {
  ConstPointerToArray< UnalignedLVecBase4d > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_ConstPointerToArray_UnalignedLVecBase4d)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< UnalignedLVecBase4d > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConstPointerToArray< UnalignedLVecBase4d >::ConstPointerToArray(PointerToArray< UnalignedLVecBase4d > const &copy)
    PointerToArray< UnalignedLVecBase4d > const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_UnalignedLVecBase4d);
    if (arg_this != nullptr) {
      coerced = ConstPointerToArray< UnalignedLVecBase4d >(*arg_this);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_UnalignedLVecBase4d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConstPointerToArray_UnalignedLVecBase4d) {
    printf("ConstPointerToArray_UnalignedLVecBase4d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConstPointerToArray< UnalignedLVecBase4d > *local_this = (ConstPointerToArray< UnalignedLVecBase4d > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConstPointerToArray_UnalignedLVecBase4d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4d) {
    return (PointerToArrayBase< UnalignedLVecBase4d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d) {
    return (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > > *)(PointerToArrayBase< UnalignedLVecBase4d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > > *)(PointerToArrayBase< UnalignedLVecBase4d > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_UnalignedLVecBase4d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4d) {
    PointerToArrayBase< UnalignedLVecBase4d >* other_this = (PointerToArrayBase< UnalignedLVecBase4d >*)from_this;
    return (ConstPointerToArray< UnalignedLVecBase4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d) {
    PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > >* other_this = (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > >*)from_this;
    return (ConstPointerToArray< UnalignedLVecBase4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< UnalignedLVecBase4d >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< UnalignedLVecBase4d >
 */
static int Dtool_Init_PointerToArrayBase_UnalignedLVecBase4d(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_UnalignedLVecBase4d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArrayBase_UnalignedLVecBase4d) {
    printf("PointerToArrayBase_UnalignedLVecBase4d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArrayBase< UnalignedLVecBase4d > *local_this = (PointerToArrayBase< UnalignedLVecBase4d > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArrayBase_UnalignedLVecBase4d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d) {
    return (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_UnalignedLVecBase4d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d) {
    PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > >* other_this = (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > >*)from_this;
    return (PointerToArrayBase< UnalignedLVecBase4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< UnalignedLVecBase4d >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d_clear_195(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d, (void **)&local_this, "PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d_clear_195_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d_clear_195_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > >::output(std::ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d_output_196(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d)) {
    return nullptr;
  }
  // 1-void PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > >::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > >*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d_output_196_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d_output_196_comment = nullptr;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d) {
    printf("PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > > *local_this = (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConstPointerToArray< UnalignedLVecBase4f >
 */
/**
 * Python function wrapper for:
 * inline void ConstPointerToArray< UnalignedLVecBase4f >::clear(void)
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4f_clear_218(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLVecBase4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConstPointerToArray_UnalignedLVecBase4f, (void **)&local_this, "ConstPointerToArray_UnalignedLVecBase4f.clear")) {
    return nullptr;
  }
  // 1-inline void ConstPointerToArray< UnalignedLVecBase4f >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4f_clear_218_comment =
  "C++ Interface:\n"
  "clear(const ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4f_clear_218_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UnalignedLVecBase4f const &ConstPointerToArray< UnalignedLVecBase4f >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_element_220(PyObject *self, PyObject *arg) {
  ConstPointerToArray< UnalignedLVecBase4f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_UnalignedLVecBase4f)) {
    return nullptr;
  }
  // 1-inline UnalignedLVecBase4f const &ConstPointerToArray< UnalignedLVecBase4f >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    UnalignedLVecBase4f const *return_value = &(((*(const ConstPointerToArray< UnalignedLVecBase4f >*)local_this).get_element)((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLVecBase4f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_element_220_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_element_220_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< UnalignedLVecBase4f >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_data_222(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLVecBase4f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_UnalignedLVecBase4f)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< UnalignedLVecBase4f >::get_data(void) const
  PyObject *return_value = invoke_extension((const ConstPointerToArray< UnalignedLVecBase4f >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_data_222_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_data_222_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< UnalignedLVecBase4f >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_subdata_223(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< UnalignedLVecBase4f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_UnalignedLVecBase4f)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< UnalignedLVecBase4f >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const ConstPointerToArray< UnalignedLVecBase4f >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_subdata_223_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_subdata_223_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< UnalignedLVecBase4f >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_ref_count_224(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLVecBase4f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_UnalignedLVecBase4f)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< UnalignedLVecBase4f >::get_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< UnalignedLVecBase4f >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_ref_count_224_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_ref_count_224_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< UnalignedLVecBase4f >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_node_ref_count_225(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLVecBase4f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_UnalignedLVecBase4f)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< UnalignedLVecBase4f >::get_node_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< UnalignedLVecBase4f >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_node_ref_count_225_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_node_ref_count_225_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int ConstPointerToArray< UnalignedLVecBase4f >::count(UnalignedLVecBase4f const &) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4f_count_226(PyObject *self, PyObject *arg) {
  ConstPointerToArray< UnalignedLVecBase4f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_UnalignedLVecBase4f)) {
    return nullptr;
  }
  // 1-inline unsigned long int ConstPointerToArray< UnalignedLVecBase4f >::count(UnalignedLVecBase4f const &) const
  UnalignedLVecBase4f arg_local;
  UnalignedLVecBase4f const *arg_this = Dtool_Coerce_UnalignedLVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConstPointerToArray.count", "UnalignedLVecBase4f");
  }
  unsigned long int return_value = ((*(const ConstPointerToArray< UnalignedLVecBase4f >*)local_this).count)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(ConstPointerToArray self, const UnalignedLVecBase4f param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4f_count_226_comment =
  "C++ Interface:\n"
  "count(ConstPointerToArray self, const UnalignedLVecBase4f param0)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4f_count_226_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< UnalignedLVecBase4f >::ConstPointerToArray(ConstPointerToArray< UnalignedLVecBase4f > const &copy)
 * inline ConstPointerToArray< UnalignedLVecBase4f >::ConstPointerToArray(PointerToArray< UnalignedLVecBase4f > const &copy)
 */
static int Dtool_Init_ConstPointerToArray_UnalignedLVecBase4f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
    {
      // -2 inline ConstPointerToArray< UnalignedLVecBase4f >::ConstPointerToArray(ConstPointerToArray< UnalignedLVecBase4f > const &copy)
      ConstPointerToArray< UnalignedLVecBase4f > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4f);
      if (arg_this != nullptr) {
        ConstPointerToArray< UnalignedLVecBase4f > *return_value = new ConstPointerToArray< UnalignedLVecBase4f >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLVecBase4f, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< UnalignedLVecBase4f >::ConstPointerToArray(PointerToArray< UnalignedLVecBase4f > const &copy)
      PointerToArray< UnalignedLVecBase4f > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_UnalignedLVecBase4f);
      if (arg_this != nullptr) {
        ConstPointerToArray< UnalignedLVecBase4f > *return_value = new ConstPointerToArray< UnalignedLVecBase4f >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLVecBase4f, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< UnalignedLVecBase4f >::ConstPointerToArray(ConstPointerToArray< UnalignedLVecBase4f > const &copy)
      ConstPointerToArray< UnalignedLVecBase4f > arg_local;
      ConstPointerToArray< UnalignedLVecBase4f > const *arg_this = Dtool_Coerce_ConstPointerToArray_UnalignedLVecBase4f(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< UnalignedLVecBase4f > *return_value = new ConstPointerToArray< UnalignedLVecBase4f >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLVecBase4f, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< UnalignedLVecBase4f >::ConstPointerToArray(PointerToArray< UnalignedLVecBase4f > const &copy)
      PointerToArray< UnalignedLVecBase4f > arg_local;
      PointerToArray< UnalignedLVecBase4f > const *arg_this = Dtool_Coerce_PointerToArray_UnalignedLVecBase4f(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< UnalignedLVecBase4f > *return_value = new ConstPointerToArray< UnalignedLVecBase4f >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLVecBase4f, true, false);
      }
    }

  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(const PointerToArray copy)\n");
  }
  return -1;
}

ConstPointerToArray< UnalignedLVecBase4f > *Dtool_Coerce_ConstPointerToArray_UnalignedLVecBase4f(PyObject *args, ConstPointerToArray< UnalignedLVecBase4f > &coerced) {
  ConstPointerToArray< UnalignedLVecBase4f > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_ConstPointerToArray_UnalignedLVecBase4f)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< UnalignedLVecBase4f > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConstPointerToArray< UnalignedLVecBase4f >::ConstPointerToArray(PointerToArray< UnalignedLVecBase4f > const &copy)
    PointerToArray< UnalignedLVecBase4f > const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_UnalignedLVecBase4f);
    if (arg_this != nullptr) {
      coerced = ConstPointerToArray< UnalignedLVecBase4f >(*arg_this);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_UnalignedLVecBase4f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConstPointerToArray_UnalignedLVecBase4f) {
    printf("ConstPointerToArray_UnalignedLVecBase4f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConstPointerToArray< UnalignedLVecBase4f > *local_this = (ConstPointerToArray< UnalignedLVecBase4f > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConstPointerToArray_UnalignedLVecBase4f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4f) {
    return (PointerToArrayBase< UnalignedLVecBase4f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f) {
    return (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > > *)(PointerToArrayBase< UnalignedLVecBase4f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > > *)(PointerToArrayBase< UnalignedLVecBase4f > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_UnalignedLVecBase4f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4f) {
    PointerToArrayBase< UnalignedLVecBase4f >* other_this = (PointerToArrayBase< UnalignedLVecBase4f >*)from_this;
    return (ConstPointerToArray< UnalignedLVecBase4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f) {
    PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > >* other_this = (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > >*)from_this;
    return (ConstPointerToArray< UnalignedLVecBase4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< UnalignedLVecBase4f >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< UnalignedLVecBase4f >
 */
static int Dtool_Init_PointerToArrayBase_UnalignedLVecBase4f(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_UnalignedLVecBase4f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArrayBase_UnalignedLVecBase4f) {
    printf("PointerToArrayBase_UnalignedLVecBase4f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArrayBase< UnalignedLVecBase4f > *local_this = (PointerToArrayBase< UnalignedLVecBase4f > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArrayBase_UnalignedLVecBase4f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f) {
    return (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_UnalignedLVecBase4f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f) {
    PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > >* other_this = (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > >*)from_this;
    return (PointerToArrayBase< UnalignedLVecBase4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< UnalignedLVecBase4f >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f_clear_214(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f, (void **)&local_this, "PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f_clear_214_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f_clear_214_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > >::output(std::ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f_output_215(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f)) {
    return nullptr;
  }
  // 1-void PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > >::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > >*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f_output_215_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f_output_215_comment = nullptr;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f) {
    printf("PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > > *local_this = (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConstPointerToArray< UnalignedLVecBase4i >
 */
/**
 * Python function wrapper for:
 * inline void ConstPointerToArray< UnalignedLVecBase4i >::clear(void)
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4i_clear_237(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLVecBase4i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConstPointerToArray_UnalignedLVecBase4i, (void **)&local_this, "ConstPointerToArray_UnalignedLVecBase4i.clear")) {
    return nullptr;
  }
  // 1-inline void ConstPointerToArray< UnalignedLVecBase4i >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4i_clear_237_comment =
  "C++ Interface:\n"
  "clear(const ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4i_clear_237_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UnalignedLVecBase4i const &ConstPointerToArray< UnalignedLVecBase4i >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_element_239(PyObject *self, PyObject *arg) {
  ConstPointerToArray< UnalignedLVecBase4i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_UnalignedLVecBase4i)) {
    return nullptr;
  }
  // 1-inline UnalignedLVecBase4i const &ConstPointerToArray< UnalignedLVecBase4i >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    UnalignedLVecBase4i const *return_value = &(((*(const ConstPointerToArray< UnalignedLVecBase4i >*)local_this).get_element)((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLVecBase4i, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_element_239_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_element_239_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< UnalignedLVecBase4i >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_data_241(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLVecBase4i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_UnalignedLVecBase4i)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< UnalignedLVecBase4i >::get_data(void) const
  PyObject *return_value = invoke_extension((const ConstPointerToArray< UnalignedLVecBase4i >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_data_241_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_data_241_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< UnalignedLVecBase4i >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_subdata_242(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< UnalignedLVecBase4i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_UnalignedLVecBase4i)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< UnalignedLVecBase4i >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const ConstPointerToArray< UnalignedLVecBase4i >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_subdata_242_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_subdata_242_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< UnalignedLVecBase4i >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_ref_count_243(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLVecBase4i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_UnalignedLVecBase4i)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< UnalignedLVecBase4i >::get_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< UnalignedLVecBase4i >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_ref_count_243_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_ref_count_243_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< UnalignedLVecBase4i >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_node_ref_count_244(PyObject *self, PyObject *) {
  ConstPointerToArray< UnalignedLVecBase4i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_UnalignedLVecBase4i)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< UnalignedLVecBase4i >::get_node_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< UnalignedLVecBase4i >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_node_ref_count_244_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_node_ref_count_244_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int ConstPointerToArray< UnalignedLVecBase4i >::count(UnalignedLVecBase4i const &) const
 */
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4i_count_245(PyObject *self, PyObject *arg) {
  ConstPointerToArray< UnalignedLVecBase4i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_UnalignedLVecBase4i)) {
    return nullptr;
  }
  // 1-inline unsigned long int ConstPointerToArray< UnalignedLVecBase4i >::count(UnalignedLVecBase4i const &) const
  UnalignedLVecBase4i arg_local;
  UnalignedLVecBase4i const *arg_this = Dtool_Coerce_UnalignedLVecBase4i(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConstPointerToArray.count", "UnalignedLVecBase4i");
  }
  unsigned long int return_value = ((*(const ConstPointerToArray< UnalignedLVecBase4i >*)local_this).count)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(ConstPointerToArray self, const UnalignedLVecBase4i param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4i_count_245_comment =
  "C++ Interface:\n"
  "count(ConstPointerToArray self, const UnalignedLVecBase4i param0)\n";
#else
static const char *Dtool_ConstPointerToArray_UnalignedLVecBase4i_count_245_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< UnalignedLVecBase4i >::ConstPointerToArray(ConstPointerToArray< UnalignedLVecBase4i > const &copy)
 * inline ConstPointerToArray< UnalignedLVecBase4i >::ConstPointerToArray(PointerToArray< UnalignedLVecBase4i > const &copy)
 */
static int Dtool_Init_ConstPointerToArray_UnalignedLVecBase4i(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
    {
      // -2 inline ConstPointerToArray< UnalignedLVecBase4i >::ConstPointerToArray(ConstPointerToArray< UnalignedLVecBase4i > const &copy)
      ConstPointerToArray< UnalignedLVecBase4i > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4i);
      if (arg_this != nullptr) {
        ConstPointerToArray< UnalignedLVecBase4i > *return_value = new ConstPointerToArray< UnalignedLVecBase4i >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLVecBase4i, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< UnalignedLVecBase4i >::ConstPointerToArray(PointerToArray< UnalignedLVecBase4i > const &copy)
      PointerToArray< UnalignedLVecBase4i > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_UnalignedLVecBase4i);
      if (arg_this != nullptr) {
        ConstPointerToArray< UnalignedLVecBase4i > *return_value = new ConstPointerToArray< UnalignedLVecBase4i >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLVecBase4i, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< UnalignedLVecBase4i >::ConstPointerToArray(ConstPointerToArray< UnalignedLVecBase4i > const &copy)
      ConstPointerToArray< UnalignedLVecBase4i > arg_local;
      ConstPointerToArray< UnalignedLVecBase4i > const *arg_this = Dtool_Coerce_ConstPointerToArray_UnalignedLVecBase4i(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< UnalignedLVecBase4i > *return_value = new ConstPointerToArray< UnalignedLVecBase4i >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLVecBase4i, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< UnalignedLVecBase4i >::ConstPointerToArray(PointerToArray< UnalignedLVecBase4i > const &copy)
      PointerToArray< UnalignedLVecBase4i > arg_local;
      PointerToArray< UnalignedLVecBase4i > const *arg_this = Dtool_Coerce_PointerToArray_UnalignedLVecBase4i(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< UnalignedLVecBase4i > *return_value = new ConstPointerToArray< UnalignedLVecBase4i >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_UnalignedLVecBase4i, true, false);
      }
    }

  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(const PointerToArray copy)\n");
  }
  return -1;
}

ConstPointerToArray< UnalignedLVecBase4i > *Dtool_Coerce_ConstPointerToArray_UnalignedLVecBase4i(PyObject *args, ConstPointerToArray< UnalignedLVecBase4i > &coerced) {
  ConstPointerToArray< UnalignedLVecBase4i > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_ConstPointerToArray_UnalignedLVecBase4i)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< UnalignedLVecBase4i > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConstPointerToArray< UnalignedLVecBase4i >::ConstPointerToArray(PointerToArray< UnalignedLVecBase4i > const &copy)
    PointerToArray< UnalignedLVecBase4i > const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_UnalignedLVecBase4i);
    if (arg_this != nullptr) {
      coerced = ConstPointerToArray< UnalignedLVecBase4i >(*arg_this);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_UnalignedLVecBase4i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConstPointerToArray_UnalignedLVecBase4i) {
    printf("ConstPointerToArray_UnalignedLVecBase4i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConstPointerToArray< UnalignedLVecBase4i > *local_this = (ConstPointerToArray< UnalignedLVecBase4i > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConstPointerToArray_UnalignedLVecBase4i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4i) {
    return (PointerToArrayBase< UnalignedLVecBase4i > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i) {
    return (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > > *)(PointerToArrayBase< UnalignedLVecBase4i > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > > *)(PointerToArrayBase< UnalignedLVecBase4i > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_UnalignedLVecBase4i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4i) {
    PointerToArrayBase< UnalignedLVecBase4i >* other_this = (PointerToArrayBase< UnalignedLVecBase4i >*)from_this;
    return (ConstPointerToArray< UnalignedLVecBase4i >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i) {
    PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > >* other_this = (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > >*)from_this;
    return (ConstPointerToArray< UnalignedLVecBase4i >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< UnalignedLVecBase4i >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< UnalignedLVecBase4i >
 */
static int Dtool_Init_PointerToArrayBase_UnalignedLVecBase4i(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_UnalignedLVecBase4i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArrayBase_UnalignedLVecBase4i) {
    printf("PointerToArrayBase_UnalignedLVecBase4i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArrayBase< UnalignedLVecBase4i > *local_this = (PointerToArrayBase< UnalignedLVecBase4i > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArrayBase_UnalignedLVecBase4i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i) {
    return (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_UnalignedLVecBase4i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i) {
    PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > >* other_this = (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > >*)from_this;
    return (PointerToArrayBase< UnalignedLVecBase4i >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< UnalignedLVecBase4i >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i_clear_233(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i, (void **)&local_this, "PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i_clear_233_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i_clear_233_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > >::output(std::ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i_output_234(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i)) {
    return nullptr;
  }
  // 1-void PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > >::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > >*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i_output_234_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i_output_234_comment = nullptr;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i) {
    printf("PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > > *local_this = (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArray< LMatrix3d >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< LMatrix3d > PointerToArray< LMatrix3d >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((LMatrix3d const *)(0))))
 */
static PyObject *Dtool_PointerToArray_LMatrix3d_empty_array_251(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline PointerToArray< LMatrix3d > PointerToArray< LMatrix3d >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((LMatrix3d const *)(0))))
  unsigned long param0;
  PyObject *param1 = nullptr;
  static const char *keyword_list[] = {"n", "type_handle", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "k|O:empty_array", (char **)keyword_list, &param0, &param1)) {
    TypeHandle param1_local;
    TypeHandle *param1_this;
    if (param1 != nullptr) {
      param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    } else {
      param1_local = (::_get_type_handle((LMatrix3d const *)(0)));
      param1_this = &param1_local;
    }
    if (param1 != nullptr && !(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
    }
    PointerToArray< LMatrix3d > *return_value = new PointerToArray< LMatrix3d >((PointerToArray< LMatrix3d >::empty_array)((unsigned long int)param0, *param1_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_LMatrix3d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3d_empty_array_251_comment =
  "C++ Interface:\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3d_empty_array_251_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LMatrix3d >::clear(void)
 */
static PyObject *Dtool_PointerToArray_LMatrix3d_clear_252(PyObject *self, PyObject *) {
  PointerToArray< LMatrix3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LMatrix3d, (void **)&local_this, "PointerToArray_LMatrix3d.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LMatrix3d >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3d_clear_252_comment =
  "C++ Interface:\n"
  "clear(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3d_clear_252_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LMatrix3d >::push_back(LMatrix3d const &x)
 */
static PyObject *Dtool_PointerToArray_LMatrix3d_push_back_254(PyObject *self, PyObject *arg) {
  PointerToArray< LMatrix3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LMatrix3d, (void **)&local_this, "PointerToArray_LMatrix3d.push_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LMatrix3d >::push_back(LMatrix3d const &x)
  LMatrix3d arg_local;
  LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.push_back", "LMatrix3d");
  }
  ((*local_this).push_back)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, const LMatrix3d x)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3d_push_back_254_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, const LMatrix3d x)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3d_push_back_254_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LMatrix3d >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_LMatrix3d_pop_back_255(PyObject *self, PyObject *) {
  PointerToArray< LMatrix3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LMatrix3d, (void **)&local_this, "PointerToArray_LMatrix3d.pop_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LMatrix3d >::pop_back(void)
  ((*local_this).pop_back)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3d_pop_back_255_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3d_pop_back_255_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3d const &PointerToArray< LMatrix3d >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_LMatrix3d_get_element_256(PyObject *self, PyObject *arg) {
  PointerToArray< LMatrix3d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LMatrix3d)) {
    return nullptr;
  }
  // 1-inline LMatrix3d const &PointerToArray< LMatrix3d >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LMatrix3d const *return_value = &(((*(const PointerToArray< LMatrix3d >*)local_this).get_element)((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3d_get_element_256_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3d_get_element_256_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LMatrix3d >::set_element(unsigned long int n, LMatrix3d const &value)
 */
static PyObject *Dtool_PointerToArray_LMatrix3d_set_element_257(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LMatrix3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LMatrix3d, (void **)&local_this, "PointerToArray_LMatrix3d.set_element")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LMatrix3d >::set_element(unsigned long int n, LMatrix3d const &value)
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:set_element", (char **)keyword_list, &param1, &param2)) {
    LMatrix3d param2_local;
    LMatrix3d const *param2_this = Dtool_Coerce_LMatrix3d(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PointerToArray.set_element", "LMatrix3d");
    }
    ((*local_this).set_element)((unsigned long int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, const LMatrix3d value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3d_set_element_257_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, const LMatrix3d value)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3d_set_element_257_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< LMatrix3d >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_LMatrix3d_get_data_260(PyObject *self, PyObject *) {
  PointerToArray< LMatrix3d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LMatrix3d)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< LMatrix3d >::get_data(void) const
  PyObject *return_value = invoke_extension((const PointerToArray< LMatrix3d >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3d_get_data_260_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3d_get_data_260_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToArray< LMatrix3d >::set_data(PyObject *data)
 */
static PyObject *Dtool_PointerToArray_LMatrix3d_set_data_261(PyObject *self, PyObject *arg) {
  PointerToArray< LMatrix3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LMatrix3d, (void **)&local_this, "PointerToArray_LMatrix3d.set_data")) {
    return nullptr;
  }
  // 1-void PointerToArray< LMatrix3d >::set_data(PyObject *data)
  invoke_extension(local_this).set_data(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, object data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3d_set_data_261_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, object data)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3d_set_data_261_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< LMatrix3d >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_LMatrix3d_get_subdata_262(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LMatrix3d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LMatrix3d)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< LMatrix3d >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const PointerToArray< LMatrix3d >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3d_get_subdata_262_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3d_get_subdata_262_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LMatrix3d >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_LMatrix3d_set_subdata_263(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LMatrix3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LMatrix3d, (void **)&local_this, "PointerToArray_LMatrix3d.set_subdata")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LMatrix3d >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  const char *param3_str = nullptr;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    ((*local_this).set_subdata)((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3d_set_subdata_263_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3d_set_subdata_263_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LMatrix3d >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LMatrix3d_get_ref_count_264(PyObject *self, PyObject *) {
  PointerToArray< LMatrix3d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LMatrix3d)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< LMatrix3d >::get_ref_count(void) const
  int return_value = ((*(const PointerToArray< LMatrix3d >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3d_get_ref_count_264_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3d_get_ref_count_264_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LMatrix3d >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LMatrix3d_get_node_ref_count_265(PyObject *self, PyObject *) {
  PointerToArray< LMatrix3d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LMatrix3d)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< LMatrix3d >::get_node_ref_count(void) const
  int return_value = ((*(const PointerToArray< LMatrix3d >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3d_get_node_ref_count_265_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3d_get_node_ref_count_265_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int PointerToArray< LMatrix3d >::count(LMatrix3d const &) const
 */
static PyObject *Dtool_PointerToArray_LMatrix3d_count_266(PyObject *self, PyObject *arg) {
  PointerToArray< LMatrix3d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LMatrix3d)) {
    return nullptr;
  }
  // 1-inline unsigned long int PointerToArray< LMatrix3d >::count(LMatrix3d const &) const
  LMatrix3d arg_local;
  LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.count", "LMatrix3d");
  }
  unsigned long int return_value = ((*(const PointerToArray< LMatrix3d >*)local_this).count)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(PointerToArray self, const LMatrix3d param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3d_count_266_comment =
  "C++ Interface:\n"
  "count(PointerToArray self, const LMatrix3d param0)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3d_count_266_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< LMatrix3d >::PointerToArray(PointerToArray< LMatrix3d > const &copy)
 * PointerToArray< LMatrix3d >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< LMatrix3d >::PointerToArray(TypeHandle type_handle = (::_get_type_handle((LMatrix3d const *)(0))))
 */
static int Dtool_Init_PointerToArray_LMatrix3d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< LMatrix3d >::PointerToArray(TypeHandle type_handle)
      PointerToArray< LMatrix3d > *return_value = new PointerToArray< LMatrix3d >();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LMatrix3d, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< LMatrix3d >::PointerToArray(PointerToArray< LMatrix3d > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< LMatrix3d > const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_PointerToArray_LMatrix3d);
          if (param0_this != nullptr) {
            PointerToArray< LMatrix3d > *return_value = new PointerToArray< LMatrix3d >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LMatrix3d, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< LMatrix3d >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TypeHandle);
          if (param0_this != nullptr) {
            PointerToArray< LMatrix3d > *return_value = new PointerToArray< LMatrix3d >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LMatrix3d, true, false);
          }
        }
      }

      {
        // -2 PointerToArray< LMatrix3d >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "source")) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, nullptr, &Dtool_PointerToArray_LMatrix3d, false, false);
          PointerToArray< LMatrix3d > *result = new PointerToArray< LMatrix3d >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< LMatrix3d > *return_value = result;
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != nullptr) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (UNLIKELY(notify->has_assert_failed())) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LMatrix3d, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< LMatrix3d >::PointerToArray(PointerToArray< LMatrix3d > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< LMatrix3d > param0_local;
          PointerToArray< LMatrix3d > const *param0_this = Dtool_Coerce_PointerToArray_LMatrix3d(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< LMatrix3d > *return_value = new PointerToArray< LMatrix3d >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LMatrix3d, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< LMatrix3d >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< LMatrix3d > *return_value = new PointerToArray< LMatrix3d >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LMatrix3d, true, false);
          }
        }
      }

      // No coercion possible: PointerToArray< LMatrix3d >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< LMatrix3d > *Dtool_Coerce_PointerToArray_LMatrix3d(PyObject *args, PointerToArray< LMatrix3d > &coerced) {
  PointerToArray< LMatrix3d > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_PointerToArray_LMatrix3d)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< LMatrix3d > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< LMatrix3d >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypeHandle);
      if (arg_this != nullptr) {
        coerced = PointerToArray< LMatrix3d >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< LMatrix3d >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_LMatrix3d(&Dtool_PointerToArray_LMatrix3d._PyType, nullptr, nullptr);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != nullptr) {
        return nullptr;
      } else {
        return &coerced;
      }
    }

  }
  return nullptr;
}

static void *Dtool_UpcastInterface_PointerToArray_LMatrix3d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArray_LMatrix3d) {
    printf("PointerToArray_LMatrix3d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArray< LMatrix3d > *local_this = (PointerToArray< LMatrix3d > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArray_LMatrix3d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LMatrix3d) {
    return (PointerToArrayBase< LMatrix3d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3d) {
    return (PointerToBase< ReferenceCountedVector< LMatrix3d > > *)(PointerToArrayBase< LMatrix3d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LMatrix3d > > *)(PointerToArrayBase< LMatrix3d > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArray_LMatrix3d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArray_LMatrix3d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LMatrix3d) {
    PointerToArrayBase< LMatrix3d >* other_this = (PointerToArrayBase< LMatrix3d >*)from_this;
    return (PointerToArray< LMatrix3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3d) {
    PointerToBase< ReferenceCountedVector< LMatrix3d > >* other_this = (PointerToBase< ReferenceCountedVector< LMatrix3d > >*)from_this;
    return (PointerToArray< LMatrix3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< LMatrix3d >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArray< LMatrix3f >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< LMatrix3f > PointerToArray< LMatrix3f >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((LMatrix3f const *)(0))))
 */
static PyObject *Dtool_PointerToArray_LMatrix3f_empty_array_272(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline PointerToArray< LMatrix3f > PointerToArray< LMatrix3f >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((LMatrix3f const *)(0))))
  unsigned long param0;
  PyObject *param1 = nullptr;
  static const char *keyword_list[] = {"n", "type_handle", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "k|O:empty_array", (char **)keyword_list, &param0, &param1)) {
    TypeHandle param1_local;
    TypeHandle *param1_this;
    if (param1 != nullptr) {
      param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    } else {
      param1_local = (::_get_type_handle((LMatrix3f const *)(0)));
      param1_this = &param1_local;
    }
    if (param1 != nullptr && !(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
    }
    PointerToArray< LMatrix3f > *return_value = new PointerToArray< LMatrix3f >((PointerToArray< LMatrix3f >::empty_array)((unsigned long int)param0, *param1_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_LMatrix3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3f_empty_array_272_comment =
  "C++ Interface:\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3f_empty_array_272_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LMatrix3f >::clear(void)
 */
static PyObject *Dtool_PointerToArray_LMatrix3f_clear_273(PyObject *self, PyObject *) {
  PointerToArray< LMatrix3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LMatrix3f, (void **)&local_this, "PointerToArray_LMatrix3f.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LMatrix3f >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3f_clear_273_comment =
  "C++ Interface:\n"
  "clear(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3f_clear_273_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LMatrix3f >::push_back(LMatrix3f const &x)
 */
static PyObject *Dtool_PointerToArray_LMatrix3f_push_back_275(PyObject *self, PyObject *arg) {
  PointerToArray< LMatrix3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LMatrix3f, (void **)&local_this, "PointerToArray_LMatrix3f.push_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LMatrix3f >::push_back(LMatrix3f const &x)
  LMatrix3f arg_local;
  LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.push_back", "LMatrix3f");
  }
  ((*local_this).push_back)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, const LMatrix3f x)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3f_push_back_275_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, const LMatrix3f x)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3f_push_back_275_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LMatrix3f >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_LMatrix3f_pop_back_276(PyObject *self, PyObject *) {
  PointerToArray< LMatrix3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LMatrix3f, (void **)&local_this, "PointerToArray_LMatrix3f.pop_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LMatrix3f >::pop_back(void)
  ((*local_this).pop_back)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3f_pop_back_276_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3f_pop_back_276_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3f const &PointerToArray< LMatrix3f >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_LMatrix3f_get_element_277(PyObject *self, PyObject *arg) {
  PointerToArray< LMatrix3f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LMatrix3f)) {
    return nullptr;
  }
  // 1-inline LMatrix3f const &PointerToArray< LMatrix3f >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LMatrix3f const *return_value = &(((*(const PointerToArray< LMatrix3f >*)local_this).get_element)((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3f_get_element_277_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3f_get_element_277_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LMatrix3f >::set_element(unsigned long int n, LMatrix3f const &value)
 */
static PyObject *Dtool_PointerToArray_LMatrix3f_set_element_278(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LMatrix3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LMatrix3f, (void **)&local_this, "PointerToArray_LMatrix3f.set_element")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LMatrix3f >::set_element(unsigned long int n, LMatrix3f const &value)
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:set_element", (char **)keyword_list, &param1, &param2)) {
    LMatrix3f param2_local;
    LMatrix3f const *param2_this = Dtool_Coerce_LMatrix3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PointerToArray.set_element", "LMatrix3f");
    }
    ((*local_this).set_element)((unsigned long int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, const LMatrix3f value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3f_set_element_278_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, const LMatrix3f value)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3f_set_element_278_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< LMatrix3f >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_LMatrix3f_get_data_281(PyObject *self, PyObject *) {
  PointerToArray< LMatrix3f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LMatrix3f)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< LMatrix3f >::get_data(void) const
  PyObject *return_value = invoke_extension((const PointerToArray< LMatrix3f >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3f_get_data_281_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3f_get_data_281_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToArray< LMatrix3f >::set_data(PyObject *data)
 */
static PyObject *Dtool_PointerToArray_LMatrix3f_set_data_282(PyObject *self, PyObject *arg) {
  PointerToArray< LMatrix3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LMatrix3f, (void **)&local_this, "PointerToArray_LMatrix3f.set_data")) {
    return nullptr;
  }
  // 1-void PointerToArray< LMatrix3f >::set_data(PyObject *data)
  invoke_extension(local_this).set_data(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, object data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3f_set_data_282_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, object data)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3f_set_data_282_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< LMatrix3f >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_LMatrix3f_get_subdata_283(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LMatrix3f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LMatrix3f)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< LMatrix3f >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const PointerToArray< LMatrix3f >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3f_get_subdata_283_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3f_get_subdata_283_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LMatrix3f >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_LMatrix3f_set_subdata_284(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LMatrix3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LMatrix3f, (void **)&local_this, "PointerToArray_LMatrix3f.set_subdata")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LMatrix3f >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  const char *param3_str = nullptr;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    ((*local_this).set_subdata)((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3f_set_subdata_284_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3f_set_subdata_284_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LMatrix3f >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LMatrix3f_get_ref_count_285(PyObject *self, PyObject *) {
  PointerToArray< LMatrix3f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LMatrix3f)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< LMatrix3f >::get_ref_count(void) const
  int return_value = ((*(const PointerToArray< LMatrix3f >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3f_get_ref_count_285_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3f_get_ref_count_285_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LMatrix3f >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LMatrix3f_get_node_ref_count_286(PyObject *self, PyObject *) {
  PointerToArray< LMatrix3f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LMatrix3f)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< LMatrix3f >::get_node_ref_count(void) const
  int return_value = ((*(const PointerToArray< LMatrix3f >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3f_get_node_ref_count_286_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3f_get_node_ref_count_286_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int PointerToArray< LMatrix3f >::count(LMatrix3f const &) const
 */
static PyObject *Dtool_PointerToArray_LMatrix3f_count_287(PyObject *self, PyObject *arg) {
  PointerToArray< LMatrix3f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LMatrix3f)) {
    return nullptr;
  }
  // 1-inline unsigned long int PointerToArray< LMatrix3f >::count(LMatrix3f const &) const
  LMatrix3f arg_local;
  LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.count", "LMatrix3f");
  }
  unsigned long int return_value = ((*(const PointerToArray< LMatrix3f >*)local_this).count)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(PointerToArray self, const LMatrix3f param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LMatrix3f_count_287_comment =
  "C++ Interface:\n"
  "count(PointerToArray self, const LMatrix3f param0)\n";
#else
static const char *Dtool_PointerToArray_LMatrix3f_count_287_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< LMatrix3f >::PointerToArray(PointerToArray< LMatrix3f > const &copy)
 * PointerToArray< LMatrix3f >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< LMatrix3f >::PointerToArray(TypeHandle type_handle = (::_get_type_handle((LMatrix3f const *)(0))))
 */
static int Dtool_Init_PointerToArray_LMatrix3f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< LMatrix3f >::PointerToArray(TypeHandle type_handle)
      PointerToArray< LMatrix3f > *return_value = new PointerToArray< LMatrix3f >();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LMatrix3f, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< LMatrix3f >::PointerToArray(PointerToArray< LMatrix3f > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< LMatrix3f > const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_PointerToArray_LMatrix3f);
          if (param0_this != nullptr) {
            PointerToArray< LMatrix3f > *return_value = new PointerToArray< LMatrix3f >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LMatrix3f, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< LMatrix3f >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TypeHandle);
          if (param0_this != nullptr) {
            PointerToArray< LMatrix3f > *return_value = new PointerToArray< LMatrix3f >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LMatrix3f, true, false);
          }
        }
      }

      {
        // -2 PointerToArray< LMatrix3f >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "source")) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, nullptr, &Dtool_PointerToArray_LMatrix3f, false, false);
          PointerToArray< LMatrix3f > *result = new PointerToArray< LMatrix3f >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< LMatrix3f > *return_value = result;
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != nullptr) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (UNLIKELY(notify->has_assert_failed())) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LMatrix3f, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< LMatrix3f >::PointerToArray(PointerToArray< LMatrix3f > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< LMatrix3f > param0_local;
          PointerToArray< LMatrix3f > const *param0_this = Dtool_Coerce_PointerToArray_LMatrix3f(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< LMatrix3f > *return_value = new PointerToArray< LMatrix3f >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LMatrix3f, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< LMatrix3f >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< LMatrix3f > *return_value = new PointerToArray< LMatrix3f >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LMatrix3f, true, false);
          }
        }
      }

      // No coercion possible: PointerToArray< LMatrix3f >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< LMatrix3f > *Dtool_Coerce_PointerToArray_LMatrix3f(PyObject *args, PointerToArray< LMatrix3f > &coerced) {
  PointerToArray< LMatrix3f > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_PointerToArray_LMatrix3f)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< LMatrix3f > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< LMatrix3f >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypeHandle);
      if (arg_this != nullptr) {
        coerced = PointerToArray< LMatrix3f >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< LMatrix3f >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_LMatrix3f(&Dtool_PointerToArray_LMatrix3f._PyType, nullptr, nullptr);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != nullptr) {
        return nullptr;
      } else {
        return &coerced;
      }
    }

  }
  return nullptr;
}

static void *Dtool_UpcastInterface_PointerToArray_LMatrix3f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArray_LMatrix3f) {
    printf("PointerToArray_LMatrix3f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArray< LMatrix3f > *local_this = (PointerToArray< LMatrix3f > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArray_LMatrix3f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LMatrix3f) {
    return (PointerToArrayBase< LMatrix3f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3f) {
    return (PointerToBase< ReferenceCountedVector< LMatrix3f > > *)(PointerToArrayBase< LMatrix3f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LMatrix3f > > *)(PointerToArrayBase< LMatrix3f > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArray_LMatrix3f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArray_LMatrix3f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LMatrix3f) {
    PointerToArrayBase< LMatrix3f >* other_this = (PointerToArrayBase< LMatrix3f >*)from_this;
    return (PointerToArray< LMatrix3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3f) {
    PointerToBase< ReferenceCountedVector< LMatrix3f > >* other_this = (PointerToBase< ReferenceCountedVector< LMatrix3f > >*)from_this;
    return (PointerToArray< LMatrix3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< LMatrix3f >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArray< LVecBase2d >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< LVecBase2d > PointerToArray< LVecBase2d >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((LVecBase2d const *)(0))))
 */
static PyObject *Dtool_PointerToArray_LVecBase2d_empty_array_293(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline PointerToArray< LVecBase2d > PointerToArray< LVecBase2d >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((LVecBase2d const *)(0))))
  unsigned long param0;
  PyObject *param1 = nullptr;
  static const char *keyword_list[] = {"n", "type_handle", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "k|O:empty_array", (char **)keyword_list, &param0, &param1)) {
    TypeHandle param1_local;
    TypeHandle *param1_this;
    if (param1 != nullptr) {
      param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    } else {
      param1_local = (::_get_type_handle((LVecBase2d const *)(0)));
      param1_this = &param1_local;
    }
    if (param1 != nullptr && !(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
    }
    PointerToArray< LVecBase2d > *return_value = new PointerToArray< LVecBase2d >((PointerToArray< LVecBase2d >::empty_array)((unsigned long int)param0, *param1_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_LVecBase2d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2d_empty_array_293_comment =
  "C++ Interface:\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2d_empty_array_293_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase2d >::clear(void)
 */
static PyObject *Dtool_PointerToArray_LVecBase2d_clear_294(PyObject *self, PyObject *) {
  PointerToArray< LVecBase2d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2d, (void **)&local_this, "PointerToArray_LVecBase2d.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LVecBase2d >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2d_clear_294_comment =
  "C++ Interface:\n"
  "clear(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2d_clear_294_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase2d >::push_back(LVecBase2d const &x)
 */
static PyObject *Dtool_PointerToArray_LVecBase2d_push_back_296(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase2d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2d, (void **)&local_this, "PointerToArray_LVecBase2d.push_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LVecBase2d >::push_back(LVecBase2d const &x)
  LVecBase2d arg_local;
  LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.push_back", "LVecBase2d");
  }
  ((*local_this).push_back)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, const LVecBase2d x)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2d_push_back_296_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, const LVecBase2d x)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2d_push_back_296_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase2d >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_LVecBase2d_pop_back_297(PyObject *self, PyObject *) {
  PointerToArray< LVecBase2d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2d, (void **)&local_this, "PointerToArray_LVecBase2d.pop_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LVecBase2d >::pop_back(void)
  ((*local_this).pop_back)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2d_pop_back_297_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2d_pop_back_297_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2d const &PointerToArray< LVecBase2d >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2d_get_element_298(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase2d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase2d)) {
    return nullptr;
  }
  // 1-inline LVecBase2d const &PointerToArray< LVecBase2d >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LVecBase2d const *return_value = &(((*(const PointerToArray< LVecBase2d >*)local_this).get_element)((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2d_get_element_298_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2d_get_element_298_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase2d >::set_element(unsigned long int n, LVecBase2d const &value)
 */
static PyObject *Dtool_PointerToArray_LVecBase2d_set_element_299(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase2d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2d, (void **)&local_this, "PointerToArray_LVecBase2d.set_element")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LVecBase2d >::set_element(unsigned long int n, LVecBase2d const &value)
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:set_element", (char **)keyword_list, &param1, &param2)) {
    LVecBase2d param2_local;
    LVecBase2d const *param2_this = Dtool_Coerce_LVecBase2d(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PointerToArray.set_element", "LVecBase2d");
    }
    ((*local_this).set_element)((unsigned long int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, const LVecBase2d value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2d_set_element_299_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, const LVecBase2d value)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2d_set_element_299_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< LVecBase2d >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2d_get_data_302(PyObject *self, PyObject *) {
  PointerToArray< LVecBase2d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase2d)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< LVecBase2d >::get_data(void) const
  PyObject *return_value = invoke_extension((const PointerToArray< LVecBase2d >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2d_get_data_302_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2d_get_data_302_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToArray< LVecBase2d >::set_data(PyObject *data)
 */
static PyObject *Dtool_PointerToArray_LVecBase2d_set_data_303(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase2d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2d, (void **)&local_this, "PointerToArray_LVecBase2d.set_data")) {
    return nullptr;
  }
  // 1-void PointerToArray< LVecBase2d >::set_data(PyObject *data)
  invoke_extension(local_this).set_data(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, object data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2d_set_data_303_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, object data)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2d_set_data_303_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< LVecBase2d >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2d_get_subdata_304(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase2d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase2d)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< LVecBase2d >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const PointerToArray< LVecBase2d >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2d_get_subdata_304_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2d_get_subdata_304_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase2d >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_LVecBase2d_set_subdata_305(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase2d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2d, (void **)&local_this, "PointerToArray_LVecBase2d.set_subdata")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LVecBase2d >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  const char *param3_str = nullptr;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    ((*local_this).set_subdata)((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2d_set_subdata_305_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2d_set_subdata_305_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LVecBase2d >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2d_get_ref_count_306(PyObject *self, PyObject *) {
  PointerToArray< LVecBase2d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase2d)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< LVecBase2d >::get_ref_count(void) const
  int return_value = ((*(const PointerToArray< LVecBase2d >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2d_get_ref_count_306_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2d_get_ref_count_306_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LVecBase2d >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2d_get_node_ref_count_307(PyObject *self, PyObject *) {
  PointerToArray< LVecBase2d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase2d)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< LVecBase2d >::get_node_ref_count(void) const
  int return_value = ((*(const PointerToArray< LVecBase2d >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2d_get_node_ref_count_307_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2d_get_node_ref_count_307_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int PointerToArray< LVecBase2d >::count(LVecBase2d const &) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2d_count_308(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase2d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase2d)) {
    return nullptr;
  }
  // 1-inline unsigned long int PointerToArray< LVecBase2d >::count(LVecBase2d const &) const
  LVecBase2d arg_local;
  LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.count", "LVecBase2d");
  }
  unsigned long int return_value = ((*(const PointerToArray< LVecBase2d >*)local_this).count)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(PointerToArray self, const LVecBase2d param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2d_count_308_comment =
  "C++ Interface:\n"
  "count(PointerToArray self, const LVecBase2d param0)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2d_count_308_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< LVecBase2d >::PointerToArray(PointerToArray< LVecBase2d > const &copy)
 * PointerToArray< LVecBase2d >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< LVecBase2d >::PointerToArray(TypeHandle type_handle = (::_get_type_handle((LVecBase2d const *)(0))))
 */
static int Dtool_Init_PointerToArray_LVecBase2d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< LVecBase2d >::PointerToArray(TypeHandle type_handle)
      PointerToArray< LVecBase2d > *return_value = new PointerToArray< LVecBase2d >();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2d, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< LVecBase2d >::PointerToArray(PointerToArray< LVecBase2d > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< LVecBase2d > const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_PointerToArray_LVecBase2d);
          if (param0_this != nullptr) {
            PointerToArray< LVecBase2d > *return_value = new PointerToArray< LVecBase2d >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2d, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< LVecBase2d >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TypeHandle);
          if (param0_this != nullptr) {
            PointerToArray< LVecBase2d > *return_value = new PointerToArray< LVecBase2d >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2d, true, false);
          }
        }
      }

      {
        // -2 PointerToArray< LVecBase2d >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "source")) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, nullptr, &Dtool_PointerToArray_LVecBase2d, false, false);
          PointerToArray< LVecBase2d > *result = new PointerToArray< LVecBase2d >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< LVecBase2d > *return_value = result;
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != nullptr) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (UNLIKELY(notify->has_assert_failed())) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2d, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< LVecBase2d >::PointerToArray(PointerToArray< LVecBase2d > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< LVecBase2d > param0_local;
          PointerToArray< LVecBase2d > const *param0_this = Dtool_Coerce_PointerToArray_LVecBase2d(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< LVecBase2d > *return_value = new PointerToArray< LVecBase2d >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2d, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< LVecBase2d >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< LVecBase2d > *return_value = new PointerToArray< LVecBase2d >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2d, true, false);
          }
        }
      }

      // No coercion possible: PointerToArray< LVecBase2d >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< LVecBase2d > *Dtool_Coerce_PointerToArray_LVecBase2d(PyObject *args, PointerToArray< LVecBase2d > &coerced) {
  PointerToArray< LVecBase2d > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_PointerToArray_LVecBase2d)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< LVecBase2d > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< LVecBase2d >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypeHandle);
      if (arg_this != nullptr) {
        coerced = PointerToArray< LVecBase2d >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< LVecBase2d >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_LVecBase2d(&Dtool_PointerToArray_LVecBase2d._PyType, nullptr, nullptr);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != nullptr) {
        return nullptr;
      } else {
        return &coerced;
      }
    }

  }
  return nullptr;
}

static void *Dtool_UpcastInterface_PointerToArray_LVecBase2d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArray_LVecBase2d) {
    printf("PointerToArray_LVecBase2d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArray< LVecBase2d > *local_this = (PointerToArray< LVecBase2d > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArray_LVecBase2d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LVecBase2d) {
    return (PointerToArrayBase< LVecBase2d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2d) {
    return (PointerToBase< ReferenceCountedVector< LVecBase2d > > *)(PointerToArrayBase< LVecBase2d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase2d > > *)(PointerToArrayBase< LVecBase2d > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArray_LVecBase2d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArray_LVecBase2d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase2d) {
    PointerToArrayBase< LVecBase2d >* other_this = (PointerToArrayBase< LVecBase2d >*)from_this;
    return (PointerToArray< LVecBase2d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2d) {
    PointerToBase< ReferenceCountedVector< LVecBase2d > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase2d > >*)from_this;
    return (PointerToArray< LVecBase2d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< LVecBase2d >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArray< LVecBase2f >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< LVecBase2f > PointerToArray< LVecBase2f >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((LVecBase2f const *)(0))))
 */
static PyObject *Dtool_PointerToArray_LVecBase2f_empty_array_314(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline PointerToArray< LVecBase2f > PointerToArray< LVecBase2f >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((LVecBase2f const *)(0))))
  unsigned long param0;
  PyObject *param1 = nullptr;
  static const char *keyword_list[] = {"n", "type_handle", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "k|O:empty_array", (char **)keyword_list, &param0, &param1)) {
    TypeHandle param1_local;
    TypeHandle *param1_this;
    if (param1 != nullptr) {
      param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    } else {
      param1_local = (::_get_type_handle((LVecBase2f const *)(0)));
      param1_this = &param1_local;
    }
    if (param1 != nullptr && !(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
    }
    PointerToArray< LVecBase2f > *return_value = new PointerToArray< LVecBase2f >((PointerToArray< LVecBase2f >::empty_array)((unsigned long int)param0, *param1_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_LVecBase2f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2f_empty_array_314_comment =
  "C++ Interface:\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2f_empty_array_314_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase2f >::clear(void)
 */
static PyObject *Dtool_PointerToArray_LVecBase2f_clear_315(PyObject *self, PyObject *) {
  PointerToArray< LVecBase2f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2f, (void **)&local_this, "PointerToArray_LVecBase2f.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LVecBase2f >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2f_clear_315_comment =
  "C++ Interface:\n"
  "clear(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2f_clear_315_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase2f >::push_back(LVecBase2f const &x)
 */
static PyObject *Dtool_PointerToArray_LVecBase2f_push_back_317(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase2f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2f, (void **)&local_this, "PointerToArray_LVecBase2f.push_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LVecBase2f >::push_back(LVecBase2f const &x)
  LVecBase2f arg_local;
  LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.push_back", "LVecBase2f");
  }
  ((*local_this).push_back)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, const LVecBase2f x)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2f_push_back_317_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, const LVecBase2f x)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2f_push_back_317_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase2f >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_LVecBase2f_pop_back_318(PyObject *self, PyObject *) {
  PointerToArray< LVecBase2f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2f, (void **)&local_this, "PointerToArray_LVecBase2f.pop_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LVecBase2f >::pop_back(void)
  ((*local_this).pop_back)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2f_pop_back_318_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2f_pop_back_318_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2f const &PointerToArray< LVecBase2f >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2f_get_element_319(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase2f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase2f)) {
    return nullptr;
  }
  // 1-inline LVecBase2f const &PointerToArray< LVecBase2f >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LVecBase2f const *return_value = &(((*(const PointerToArray< LVecBase2f >*)local_this).get_element)((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2f_get_element_319_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2f_get_element_319_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase2f >::set_element(unsigned long int n, LVecBase2f const &value)
 */
static PyObject *Dtool_PointerToArray_LVecBase2f_set_element_320(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase2f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2f, (void **)&local_this, "PointerToArray_LVecBase2f.set_element")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LVecBase2f >::set_element(unsigned long int n, LVecBase2f const &value)
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:set_element", (char **)keyword_list, &param1, &param2)) {
    LVecBase2f param2_local;
    LVecBase2f const *param2_this = Dtool_Coerce_LVecBase2f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PointerToArray.set_element", "LVecBase2f");
    }
    ((*local_this).set_element)((unsigned long int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, const LVecBase2f value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2f_set_element_320_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, const LVecBase2f value)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2f_set_element_320_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< LVecBase2f >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2f_get_data_323(PyObject *self, PyObject *) {
  PointerToArray< LVecBase2f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase2f)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< LVecBase2f >::get_data(void) const
  PyObject *return_value = invoke_extension((const PointerToArray< LVecBase2f >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2f_get_data_323_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2f_get_data_323_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToArray< LVecBase2f >::set_data(PyObject *data)
 */
static PyObject *Dtool_PointerToArray_LVecBase2f_set_data_324(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase2f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2f, (void **)&local_this, "PointerToArray_LVecBase2f.set_data")) {
    return nullptr;
  }
  // 1-void PointerToArray< LVecBase2f >::set_data(PyObject *data)
  invoke_extension(local_this).set_data(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, object data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2f_set_data_324_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, object data)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2f_set_data_324_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< LVecBase2f >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2f_get_subdata_325(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase2f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase2f)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< LVecBase2f >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const PointerToArray< LVecBase2f >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2f_get_subdata_325_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2f_get_subdata_325_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase2f >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_LVecBase2f_set_subdata_326(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase2f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2f, (void **)&local_this, "PointerToArray_LVecBase2f.set_subdata")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LVecBase2f >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  const char *param3_str = nullptr;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    ((*local_this).set_subdata)((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2f_set_subdata_326_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2f_set_subdata_326_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LVecBase2f >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2f_get_ref_count_327(PyObject *self, PyObject *) {
  PointerToArray< LVecBase2f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase2f)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< LVecBase2f >::get_ref_count(void) const
  int return_value = ((*(const PointerToArray< LVecBase2f >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2f_get_ref_count_327_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2f_get_ref_count_327_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LVecBase2f >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2f_get_node_ref_count_328(PyObject *self, PyObject *) {
  PointerToArray< LVecBase2f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase2f)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< LVecBase2f >::get_node_ref_count(void) const
  int return_value = ((*(const PointerToArray< LVecBase2f >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2f_get_node_ref_count_328_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2f_get_node_ref_count_328_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int PointerToArray< LVecBase2f >::count(LVecBase2f const &) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2f_count_329(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase2f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase2f)) {
    return nullptr;
  }
  // 1-inline unsigned long int PointerToArray< LVecBase2f >::count(LVecBase2f const &) const
  LVecBase2f arg_local;
  LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.count", "LVecBase2f");
  }
  unsigned long int return_value = ((*(const PointerToArray< LVecBase2f >*)local_this).count)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(PointerToArray self, const LVecBase2f param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2f_count_329_comment =
  "C++ Interface:\n"
  "count(PointerToArray self, const LVecBase2f param0)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2f_count_329_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< LVecBase2f >::PointerToArray(PointerToArray< LVecBase2f > const &copy)
 * PointerToArray< LVecBase2f >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< LVecBase2f >::PointerToArray(TypeHandle type_handle = (::_get_type_handle((LVecBase2f const *)(0))))
 */
static int Dtool_Init_PointerToArray_LVecBase2f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< LVecBase2f >::PointerToArray(TypeHandle type_handle)
      PointerToArray< LVecBase2f > *return_value = new PointerToArray< LVecBase2f >();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2f, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< LVecBase2f >::PointerToArray(PointerToArray< LVecBase2f > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< LVecBase2f > const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_PointerToArray_LVecBase2f);
          if (param0_this != nullptr) {
            PointerToArray< LVecBase2f > *return_value = new PointerToArray< LVecBase2f >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2f, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< LVecBase2f >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TypeHandle);
          if (param0_this != nullptr) {
            PointerToArray< LVecBase2f > *return_value = new PointerToArray< LVecBase2f >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2f, true, false);
          }
        }
      }

      {
        // -2 PointerToArray< LVecBase2f >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "source")) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, nullptr, &Dtool_PointerToArray_LVecBase2f, false, false);
          PointerToArray< LVecBase2f > *result = new PointerToArray< LVecBase2f >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< LVecBase2f > *return_value = result;
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != nullptr) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (UNLIKELY(notify->has_assert_failed())) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2f, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< LVecBase2f >::PointerToArray(PointerToArray< LVecBase2f > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< LVecBase2f > param0_local;
          PointerToArray< LVecBase2f > const *param0_this = Dtool_Coerce_PointerToArray_LVecBase2f(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< LVecBase2f > *return_value = new PointerToArray< LVecBase2f >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2f, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< LVecBase2f >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< LVecBase2f > *return_value = new PointerToArray< LVecBase2f >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2f, true, false);
          }
        }
      }

      // No coercion possible: PointerToArray< LVecBase2f >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< LVecBase2f > *Dtool_Coerce_PointerToArray_LVecBase2f(PyObject *args, PointerToArray< LVecBase2f > &coerced) {
  PointerToArray< LVecBase2f > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_PointerToArray_LVecBase2f)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< LVecBase2f > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< LVecBase2f >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypeHandle);
      if (arg_this != nullptr) {
        coerced = PointerToArray< LVecBase2f >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< LVecBase2f >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_LVecBase2f(&Dtool_PointerToArray_LVecBase2f._PyType, nullptr, nullptr);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != nullptr) {
        return nullptr;
      } else {
        return &coerced;
      }
    }

  }
  return nullptr;
}

static void *Dtool_UpcastInterface_PointerToArray_LVecBase2f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArray_LVecBase2f) {
    printf("PointerToArray_LVecBase2f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArray< LVecBase2f > *local_this = (PointerToArray< LVecBase2f > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArray_LVecBase2f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LVecBase2f) {
    return (PointerToArrayBase< LVecBase2f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2f) {
    return (PointerToBase< ReferenceCountedVector< LVecBase2f > > *)(PointerToArrayBase< LVecBase2f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase2f > > *)(PointerToArrayBase< LVecBase2f > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArray_LVecBase2f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArray_LVecBase2f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase2f) {
    PointerToArrayBase< LVecBase2f >* other_this = (PointerToArrayBase< LVecBase2f >*)from_this;
    return (PointerToArray< LVecBase2f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2f) {
    PointerToBase< ReferenceCountedVector< LVecBase2f > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase2f > >*)from_this;
    return (PointerToArray< LVecBase2f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< LVecBase2f >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArray< LVecBase2i >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< LVecBase2i > PointerToArray< LVecBase2i >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((LVecBase2i const *)(0))))
 */
static PyObject *Dtool_PointerToArray_LVecBase2i_empty_array_335(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline PointerToArray< LVecBase2i > PointerToArray< LVecBase2i >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((LVecBase2i const *)(0))))
  unsigned long param0;
  PyObject *param1 = nullptr;
  static const char *keyword_list[] = {"n", "type_handle", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "k|O:empty_array", (char **)keyword_list, &param0, &param1)) {
    TypeHandle param1_local;
    TypeHandle *param1_this;
    if (param1 != nullptr) {
      param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    } else {
      param1_local = (::_get_type_handle((LVecBase2i const *)(0)));
      param1_this = &param1_local;
    }
    if (param1 != nullptr && !(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
    }
    PointerToArray< LVecBase2i > *return_value = new PointerToArray< LVecBase2i >((PointerToArray< LVecBase2i >::empty_array)((unsigned long int)param0, *param1_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_LVecBase2i, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2i_empty_array_335_comment =
  "C++ Interface:\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2i_empty_array_335_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase2i >::clear(void)
 */
static PyObject *Dtool_PointerToArray_LVecBase2i_clear_336(PyObject *self, PyObject *) {
  PointerToArray< LVecBase2i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2i, (void **)&local_this, "PointerToArray_LVecBase2i.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LVecBase2i >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2i_clear_336_comment =
  "C++ Interface:\n"
  "clear(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2i_clear_336_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase2i >::push_back(LVecBase2i const &x)
 */
static PyObject *Dtool_PointerToArray_LVecBase2i_push_back_338(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase2i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2i, (void **)&local_this, "PointerToArray_LVecBase2i.push_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LVecBase2i >::push_back(LVecBase2i const &x)
  LVecBase2i arg_local;
  LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.push_back", "LVecBase2i");
  }
  ((*local_this).push_back)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, const LVecBase2i x)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2i_push_back_338_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, const LVecBase2i x)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2i_push_back_338_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase2i >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_LVecBase2i_pop_back_339(PyObject *self, PyObject *) {
  PointerToArray< LVecBase2i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2i, (void **)&local_this, "PointerToArray_LVecBase2i.pop_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LVecBase2i >::pop_back(void)
  ((*local_this).pop_back)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2i_pop_back_339_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2i_pop_back_339_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2i const &PointerToArray< LVecBase2i >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2i_get_element_340(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase2i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase2i)) {
    return nullptr;
  }
  // 1-inline LVecBase2i const &PointerToArray< LVecBase2i >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LVecBase2i const *return_value = &(((*(const PointerToArray< LVecBase2i >*)local_this).get_element)((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2i_get_element_340_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2i_get_element_340_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase2i >::set_element(unsigned long int n, LVecBase2i const &value)
 */
static PyObject *Dtool_PointerToArray_LVecBase2i_set_element_341(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase2i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2i, (void **)&local_this, "PointerToArray_LVecBase2i.set_element")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LVecBase2i >::set_element(unsigned long int n, LVecBase2i const &value)
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:set_element", (char **)keyword_list, &param1, &param2)) {
    LVecBase2i param2_local;
    LVecBase2i const *param2_this = Dtool_Coerce_LVecBase2i(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PointerToArray.set_element", "LVecBase2i");
    }
    ((*local_this).set_element)((unsigned long int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, const LVecBase2i value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2i_set_element_341_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, const LVecBase2i value)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2i_set_element_341_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< LVecBase2i >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2i_get_data_344(PyObject *self, PyObject *) {
  PointerToArray< LVecBase2i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase2i)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< LVecBase2i >::get_data(void) const
  PyObject *return_value = invoke_extension((const PointerToArray< LVecBase2i >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2i_get_data_344_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2i_get_data_344_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToArray< LVecBase2i >::set_data(PyObject *data)
 */
static PyObject *Dtool_PointerToArray_LVecBase2i_set_data_345(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase2i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2i, (void **)&local_this, "PointerToArray_LVecBase2i.set_data")) {
    return nullptr;
  }
  // 1-void PointerToArray< LVecBase2i >::set_data(PyObject *data)
  invoke_extension(local_this).set_data(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, object data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2i_set_data_345_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, object data)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2i_set_data_345_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< LVecBase2i >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2i_get_subdata_346(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase2i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase2i)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< LVecBase2i >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const PointerToArray< LVecBase2i >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2i_get_subdata_346_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2i_get_subdata_346_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase2i >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_LVecBase2i_set_subdata_347(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase2i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase2i, (void **)&local_this, "PointerToArray_LVecBase2i.set_subdata")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LVecBase2i >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  const char *param3_str = nullptr;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    ((*local_this).set_subdata)((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2i_set_subdata_347_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2i_set_subdata_347_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LVecBase2i >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2i_get_ref_count_348(PyObject *self, PyObject *) {
  PointerToArray< LVecBase2i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase2i)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< LVecBase2i >::get_ref_count(void) const
  int return_value = ((*(const PointerToArray< LVecBase2i >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2i_get_ref_count_348_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2i_get_ref_count_348_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LVecBase2i >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2i_get_node_ref_count_349(PyObject *self, PyObject *) {
  PointerToArray< LVecBase2i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase2i)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< LVecBase2i >::get_node_ref_count(void) const
  int return_value = ((*(const PointerToArray< LVecBase2i >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2i_get_node_ref_count_349_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2i_get_node_ref_count_349_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int PointerToArray< LVecBase2i >::count(LVecBase2i const &) const
 */
static PyObject *Dtool_PointerToArray_LVecBase2i_count_350(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase2i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase2i)) {
    return nullptr;
  }
  // 1-inline unsigned long int PointerToArray< LVecBase2i >::count(LVecBase2i const &) const
  LVecBase2i arg_local;
  LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.count", "LVecBase2i");
  }
  unsigned long int return_value = ((*(const PointerToArray< LVecBase2i >*)local_this).count)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(PointerToArray self, const LVecBase2i param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase2i_count_350_comment =
  "C++ Interface:\n"
  "count(PointerToArray self, const LVecBase2i param0)\n";
#else
static const char *Dtool_PointerToArray_LVecBase2i_count_350_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< LVecBase2i >::PointerToArray(PointerToArray< LVecBase2i > const &copy)
 * PointerToArray< LVecBase2i >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< LVecBase2i >::PointerToArray(TypeHandle type_handle = (::_get_type_handle((LVecBase2i const *)(0))))
 */
static int Dtool_Init_PointerToArray_LVecBase2i(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< LVecBase2i >::PointerToArray(TypeHandle type_handle)
      PointerToArray< LVecBase2i > *return_value = new PointerToArray< LVecBase2i >();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2i, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< LVecBase2i >::PointerToArray(PointerToArray< LVecBase2i > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< LVecBase2i > const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_PointerToArray_LVecBase2i);
          if (param0_this != nullptr) {
            PointerToArray< LVecBase2i > *return_value = new PointerToArray< LVecBase2i >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2i, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< LVecBase2i >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TypeHandle);
          if (param0_this != nullptr) {
            PointerToArray< LVecBase2i > *return_value = new PointerToArray< LVecBase2i >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2i, true, false);
          }
        }
      }

      {
        // -2 PointerToArray< LVecBase2i >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "source")) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, nullptr, &Dtool_PointerToArray_LVecBase2i, false, false);
          PointerToArray< LVecBase2i > *result = new PointerToArray< LVecBase2i >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< LVecBase2i > *return_value = result;
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != nullptr) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (UNLIKELY(notify->has_assert_failed())) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2i, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< LVecBase2i >::PointerToArray(PointerToArray< LVecBase2i > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< LVecBase2i > param0_local;
          PointerToArray< LVecBase2i > const *param0_this = Dtool_Coerce_PointerToArray_LVecBase2i(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< LVecBase2i > *return_value = new PointerToArray< LVecBase2i >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2i, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< LVecBase2i >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< LVecBase2i > *return_value = new PointerToArray< LVecBase2i >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase2i, true, false);
          }
        }
      }

      // No coercion possible: PointerToArray< LVecBase2i >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< LVecBase2i > *Dtool_Coerce_PointerToArray_LVecBase2i(PyObject *args, PointerToArray< LVecBase2i > &coerced) {
  PointerToArray< LVecBase2i > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_PointerToArray_LVecBase2i)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< LVecBase2i > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< LVecBase2i >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypeHandle);
      if (arg_this != nullptr) {
        coerced = PointerToArray< LVecBase2i >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< LVecBase2i >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_LVecBase2i(&Dtool_PointerToArray_LVecBase2i._PyType, nullptr, nullptr);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != nullptr) {
        return nullptr;
      } else {
        return &coerced;
      }
    }

  }
  return nullptr;
}

static void *Dtool_UpcastInterface_PointerToArray_LVecBase2i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArray_LVecBase2i) {
    printf("PointerToArray_LVecBase2i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArray< LVecBase2i > *local_this = (PointerToArray< LVecBase2i > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArray_LVecBase2i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LVecBase2i) {
    return (PointerToArrayBase< LVecBase2i > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2i) {
    return (PointerToBase< ReferenceCountedVector< LVecBase2i > > *)(PointerToArrayBase< LVecBase2i > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase2i > > *)(PointerToArrayBase< LVecBase2i > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArray_LVecBase2i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArray_LVecBase2i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase2i) {
    PointerToArrayBase< LVecBase2i >* other_this = (PointerToArrayBase< LVecBase2i >*)from_this;
    return (PointerToArray< LVecBase2i >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2i) {
    PointerToBase< ReferenceCountedVector< LVecBase2i > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase2i > >*)from_this;
    return (PointerToArray< LVecBase2i >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< LVecBase2i >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArray< LVecBase3d >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< LVecBase3d > PointerToArray< LVecBase3d >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((LVecBase3d const *)(0))))
 */
static PyObject *Dtool_PointerToArray_LVecBase3d_empty_array_356(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline PointerToArray< LVecBase3d > PointerToArray< LVecBase3d >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((LVecBase3d const *)(0))))
  unsigned long param0;
  PyObject *param1 = nullptr;
  static const char *keyword_list[] = {"n", "type_handle", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "k|O:empty_array", (char **)keyword_list, &param0, &param1)) {
    TypeHandle param1_local;
    TypeHandle *param1_this;
    if (param1 != nullptr) {
      param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    } else {
      param1_local = (::_get_type_handle((LVecBase3d const *)(0)));
      param1_this = &param1_local;
    }
    if (param1 != nullptr && !(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
    }
    PointerToArray< LVecBase3d > *return_value = new PointerToArray< LVecBase3d >((PointerToArray< LVecBase3d >::empty_array)((unsigned long int)param0, *param1_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_LVecBase3d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3d_empty_array_356_comment =
  "C++ Interface:\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3d_empty_array_356_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase3d >::clear(void)
 */
static PyObject *Dtool_PointerToArray_LVecBase3d_clear_357(PyObject *self, PyObject *) {
  PointerToArray< LVecBase3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3d, (void **)&local_this, "PointerToArray_LVecBase3d.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LVecBase3d >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3d_clear_357_comment =
  "C++ Interface:\n"
  "clear(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3d_clear_357_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase3d >::push_back(LVecBase3d const &x)
 */
static PyObject *Dtool_PointerToArray_LVecBase3d_push_back_359(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3d, (void **)&local_this, "PointerToArray_LVecBase3d.push_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LVecBase3d >::push_back(LVecBase3d const &x)
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.push_back", "LVecBase3d");
  }
  ((*local_this).push_back)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, const LVecBase3d x)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3d_push_back_359_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, const LVecBase3d x)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3d_push_back_359_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase3d >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_LVecBase3d_pop_back_360(PyObject *self, PyObject *) {
  PointerToArray< LVecBase3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3d, (void **)&local_this, "PointerToArray_LVecBase3d.pop_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LVecBase3d >::pop_back(void)
  ((*local_this).pop_back)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3d_pop_back_360_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3d_pop_back_360_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3d const &PointerToArray< LVecBase3d >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3d_get_element_361(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase3d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase3d)) {
    return nullptr;
  }
  // 1-inline LVecBase3d const &PointerToArray< LVecBase3d >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LVecBase3d const *return_value = &(((*(const PointerToArray< LVecBase3d >*)local_this).get_element)((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3d_get_element_361_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3d_get_element_361_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase3d >::set_element(unsigned long int n, LVecBase3d const &value)
 */
static PyObject *Dtool_PointerToArray_LVecBase3d_set_element_362(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3d, (void **)&local_this, "PointerToArray_LVecBase3d.set_element")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LVecBase3d >::set_element(unsigned long int n, LVecBase3d const &value)
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:set_element", (char **)keyword_list, &param1, &param2)) {
    LVecBase3d param2_local;
    LVecBase3d const *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PointerToArray.set_element", "LVecBase3d");
    }
    ((*local_this).set_element)((unsigned long int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, const LVecBase3d value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3d_set_element_362_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, const LVecBase3d value)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3d_set_element_362_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< LVecBase3d >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3d_get_data_365(PyObject *self, PyObject *) {
  PointerToArray< LVecBase3d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase3d)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< LVecBase3d >::get_data(void) const
  PyObject *return_value = invoke_extension((const PointerToArray< LVecBase3d >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3d_get_data_365_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3d_get_data_365_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToArray< LVecBase3d >::set_data(PyObject *data)
 */
static PyObject *Dtool_PointerToArray_LVecBase3d_set_data_366(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3d, (void **)&local_this, "PointerToArray_LVecBase3d.set_data")) {
    return nullptr;
  }
  // 1-void PointerToArray< LVecBase3d >::set_data(PyObject *data)
  invoke_extension(local_this).set_data(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, object data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3d_set_data_366_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, object data)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3d_set_data_366_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< LVecBase3d >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3d_get_subdata_367(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase3d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase3d)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< LVecBase3d >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const PointerToArray< LVecBase3d >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3d_get_subdata_367_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3d_get_subdata_367_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase3d >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_LVecBase3d_set_subdata_368(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3d, (void **)&local_this, "PointerToArray_LVecBase3d.set_subdata")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LVecBase3d >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  const char *param3_str = nullptr;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    ((*local_this).set_subdata)((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3d_set_subdata_368_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3d_set_subdata_368_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LVecBase3d >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3d_get_ref_count_369(PyObject *self, PyObject *) {
  PointerToArray< LVecBase3d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase3d)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< LVecBase3d >::get_ref_count(void) const
  int return_value = ((*(const PointerToArray< LVecBase3d >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3d_get_ref_count_369_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3d_get_ref_count_369_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LVecBase3d >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3d_get_node_ref_count_370(PyObject *self, PyObject *) {
  PointerToArray< LVecBase3d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase3d)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< LVecBase3d >::get_node_ref_count(void) const
  int return_value = ((*(const PointerToArray< LVecBase3d >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3d_get_node_ref_count_370_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3d_get_node_ref_count_370_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int PointerToArray< LVecBase3d >::count(LVecBase3d const &) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3d_count_371(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase3d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase3d)) {
    return nullptr;
  }
  // 1-inline unsigned long int PointerToArray< LVecBase3d >::count(LVecBase3d const &) const
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.count", "LVecBase3d");
  }
  unsigned long int return_value = ((*(const PointerToArray< LVecBase3d >*)local_this).count)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(PointerToArray self, const LVecBase3d param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3d_count_371_comment =
  "C++ Interface:\n"
  "count(PointerToArray self, const LVecBase3d param0)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3d_count_371_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< LVecBase3d >::PointerToArray(PointerToArray< LVecBase3d > const &copy)
 * PointerToArray< LVecBase3d >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< LVecBase3d >::PointerToArray(TypeHandle type_handle = (::_get_type_handle((LVecBase3d const *)(0))))
 */
static int Dtool_Init_PointerToArray_LVecBase3d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< LVecBase3d >::PointerToArray(TypeHandle type_handle)
      PointerToArray< LVecBase3d > *return_value = new PointerToArray< LVecBase3d >();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3d, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< LVecBase3d >::PointerToArray(PointerToArray< LVecBase3d > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< LVecBase3d > const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_PointerToArray_LVecBase3d);
          if (param0_this != nullptr) {
            PointerToArray< LVecBase3d > *return_value = new PointerToArray< LVecBase3d >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3d, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< LVecBase3d >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TypeHandle);
          if (param0_this != nullptr) {
            PointerToArray< LVecBase3d > *return_value = new PointerToArray< LVecBase3d >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3d, true, false);
          }
        }
      }

      {
        // -2 PointerToArray< LVecBase3d >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "source")) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, nullptr, &Dtool_PointerToArray_LVecBase3d, false, false);
          PointerToArray< LVecBase3d > *result = new PointerToArray< LVecBase3d >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< LVecBase3d > *return_value = result;
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != nullptr) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (UNLIKELY(notify->has_assert_failed())) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3d, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< LVecBase3d >::PointerToArray(PointerToArray< LVecBase3d > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< LVecBase3d > param0_local;
          PointerToArray< LVecBase3d > const *param0_this = Dtool_Coerce_PointerToArray_LVecBase3d(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< LVecBase3d > *return_value = new PointerToArray< LVecBase3d >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3d, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< LVecBase3d >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< LVecBase3d > *return_value = new PointerToArray< LVecBase3d >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3d, true, false);
          }
        }
      }

      // No coercion possible: PointerToArray< LVecBase3d >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< LVecBase3d > *Dtool_Coerce_PointerToArray_LVecBase3d(PyObject *args, PointerToArray< LVecBase3d > &coerced) {
  PointerToArray< LVecBase3d > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_PointerToArray_LVecBase3d)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< LVecBase3d > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< LVecBase3d >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypeHandle);
      if (arg_this != nullptr) {
        coerced = PointerToArray< LVecBase3d >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< LVecBase3d >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_LVecBase3d(&Dtool_PointerToArray_LVecBase3d._PyType, nullptr, nullptr);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != nullptr) {
        return nullptr;
      } else {
        return &coerced;
      }
    }

  }
  return nullptr;
}

static void *Dtool_UpcastInterface_PointerToArray_LVecBase3d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArray_LVecBase3d) {
    printf("PointerToArray_LVecBase3d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArray< LVecBase3d > *local_this = (PointerToArray< LVecBase3d > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArray_LVecBase3d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LVecBase3d) {
    return (PointerToArrayBase< LVecBase3d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3d) {
    return (PointerToBase< ReferenceCountedVector< LVecBase3d > > *)(PointerToArrayBase< LVecBase3d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase3d > > *)(PointerToArrayBase< LVecBase3d > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArray_LVecBase3d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArray_LVecBase3d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase3d) {
    PointerToArrayBase< LVecBase3d >* other_this = (PointerToArrayBase< LVecBase3d >*)from_this;
    return (PointerToArray< LVecBase3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3d) {
    PointerToBase< ReferenceCountedVector< LVecBase3d > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase3d > >*)from_this;
    return (PointerToArray< LVecBase3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< LVecBase3d >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArray< LVecBase3f >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< LVecBase3f > PointerToArray< LVecBase3f >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((LVecBase3f const *)(0))))
 */
static PyObject *Dtool_PointerToArray_LVecBase3f_empty_array_377(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline PointerToArray< LVecBase3f > PointerToArray< LVecBase3f >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((LVecBase3f const *)(0))))
  unsigned long param0;
  PyObject *param1 = nullptr;
  static const char *keyword_list[] = {"n", "type_handle", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "k|O:empty_array", (char **)keyword_list, &param0, &param1)) {
    TypeHandle param1_local;
    TypeHandle *param1_this;
    if (param1 != nullptr) {
      param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    } else {
      param1_local = (::_get_type_handle((LVecBase3f const *)(0)));
      param1_this = &param1_local;
    }
    if (param1 != nullptr && !(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
    }
    PointerToArray< LVecBase3f > *return_value = new PointerToArray< LVecBase3f >((PointerToArray< LVecBase3f >::empty_array)((unsigned long int)param0, *param1_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_LVecBase3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3f_empty_array_377_comment =
  "C++ Interface:\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3f_empty_array_377_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase3f >::clear(void)
 */
static PyObject *Dtool_PointerToArray_LVecBase3f_clear_378(PyObject *self, PyObject *) {
  PointerToArray< LVecBase3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3f, (void **)&local_this, "PointerToArray_LVecBase3f.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LVecBase3f >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3f_clear_378_comment =
  "C++ Interface:\n"
  "clear(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3f_clear_378_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase3f >::push_back(LVecBase3f const &x)
 */
static PyObject *Dtool_PointerToArray_LVecBase3f_push_back_380(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3f, (void **)&local_this, "PointerToArray_LVecBase3f.push_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LVecBase3f >::push_back(LVecBase3f const &x)
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.push_back", "LVecBase3f");
  }
  ((*local_this).push_back)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, const LVecBase3f x)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3f_push_back_380_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, const LVecBase3f x)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3f_push_back_380_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase3f >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_LVecBase3f_pop_back_381(PyObject *self, PyObject *) {
  PointerToArray< LVecBase3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3f, (void **)&local_this, "PointerToArray_LVecBase3f.pop_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LVecBase3f >::pop_back(void)
  ((*local_this).pop_back)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3f_pop_back_381_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3f_pop_back_381_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f const &PointerToArray< LVecBase3f >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3f_get_element_382(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase3f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase3f)) {
    return nullptr;
  }
  // 1-inline LVecBase3f const &PointerToArray< LVecBase3f >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LVecBase3f const *return_value = &(((*(const PointerToArray< LVecBase3f >*)local_this).get_element)((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3f_get_element_382_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3f_get_element_382_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase3f >::set_element(unsigned long int n, LVecBase3f const &value)
 */
static PyObject *Dtool_PointerToArray_LVecBase3f_set_element_383(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3f, (void **)&local_this, "PointerToArray_LVecBase3f.set_element")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LVecBase3f >::set_element(unsigned long int n, LVecBase3f const &value)
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:set_element", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PointerToArray.set_element", "LVecBase3f");
    }
    ((*local_this).set_element)((unsigned long int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, const LVecBase3f value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3f_set_element_383_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, const LVecBase3f value)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3f_set_element_383_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< LVecBase3f >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3f_get_data_386(PyObject *self, PyObject *) {
  PointerToArray< LVecBase3f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase3f)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< LVecBase3f >::get_data(void) const
  PyObject *return_value = invoke_extension((const PointerToArray< LVecBase3f >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3f_get_data_386_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3f_get_data_386_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToArray< LVecBase3f >::set_data(PyObject *data)
 */
static PyObject *Dtool_PointerToArray_LVecBase3f_set_data_387(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3f, (void **)&local_this, "PointerToArray_LVecBase3f.set_data")) {
    return nullptr;
  }
  // 1-void PointerToArray< LVecBase3f >::set_data(PyObject *data)
  invoke_extension(local_this).set_data(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, object data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3f_set_data_387_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, object data)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3f_set_data_387_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< LVecBase3f >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3f_get_subdata_388(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase3f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase3f)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< LVecBase3f >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const PointerToArray< LVecBase3f >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3f_get_subdata_388_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3f_get_subdata_388_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase3f >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_LVecBase3f_set_subdata_389(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3f, (void **)&local_this, "PointerToArray_LVecBase3f.set_subdata")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LVecBase3f >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  const char *param3_str = nullptr;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    ((*local_this).set_subdata)((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3f_set_subdata_389_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3f_set_subdata_389_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LVecBase3f >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3f_get_ref_count_390(PyObject *self, PyObject *) {
  PointerToArray< LVecBase3f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase3f)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< LVecBase3f >::get_ref_count(void) const
  int return_value = ((*(const PointerToArray< LVecBase3f >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3f_get_ref_count_390_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3f_get_ref_count_390_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LVecBase3f >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3f_get_node_ref_count_391(PyObject *self, PyObject *) {
  PointerToArray< LVecBase3f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase3f)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< LVecBase3f >::get_node_ref_count(void) const
  int return_value = ((*(const PointerToArray< LVecBase3f >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3f_get_node_ref_count_391_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3f_get_node_ref_count_391_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int PointerToArray< LVecBase3f >::count(LVecBase3f const &) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3f_count_392(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase3f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase3f)) {
    return nullptr;
  }
  // 1-inline unsigned long int PointerToArray< LVecBase3f >::count(LVecBase3f const &) const
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.count", "LVecBase3f");
  }
  unsigned long int return_value = ((*(const PointerToArray< LVecBase3f >*)local_this).count)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(PointerToArray self, const LVecBase3f param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3f_count_392_comment =
  "C++ Interface:\n"
  "count(PointerToArray self, const LVecBase3f param0)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3f_count_392_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< LVecBase3f >::PointerToArray(PointerToArray< LVecBase3f > const &copy)
 * PointerToArray< LVecBase3f >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< LVecBase3f >::PointerToArray(TypeHandle type_handle = (::_get_type_handle((LVecBase3f const *)(0))))
 */
static int Dtool_Init_PointerToArray_LVecBase3f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< LVecBase3f >::PointerToArray(TypeHandle type_handle)
      PointerToArray< LVecBase3f > *return_value = new PointerToArray< LVecBase3f >();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3f, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< LVecBase3f >::PointerToArray(PointerToArray< LVecBase3f > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< LVecBase3f > const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_PointerToArray_LVecBase3f);
          if (param0_this != nullptr) {
            PointerToArray< LVecBase3f > *return_value = new PointerToArray< LVecBase3f >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3f, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< LVecBase3f >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TypeHandle);
          if (param0_this != nullptr) {
            PointerToArray< LVecBase3f > *return_value = new PointerToArray< LVecBase3f >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3f, true, false);
          }
        }
      }

      {
        // -2 PointerToArray< LVecBase3f >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "source")) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, nullptr, &Dtool_PointerToArray_LVecBase3f, false, false);
          PointerToArray< LVecBase3f > *result = new PointerToArray< LVecBase3f >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< LVecBase3f > *return_value = result;
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != nullptr) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (UNLIKELY(notify->has_assert_failed())) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3f, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< LVecBase3f >::PointerToArray(PointerToArray< LVecBase3f > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< LVecBase3f > param0_local;
          PointerToArray< LVecBase3f > const *param0_this = Dtool_Coerce_PointerToArray_LVecBase3f(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< LVecBase3f > *return_value = new PointerToArray< LVecBase3f >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3f, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< LVecBase3f >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< LVecBase3f > *return_value = new PointerToArray< LVecBase3f >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3f, true, false);
          }
        }
      }

      // No coercion possible: PointerToArray< LVecBase3f >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< LVecBase3f > *Dtool_Coerce_PointerToArray_LVecBase3f(PyObject *args, PointerToArray< LVecBase3f > &coerced) {
  PointerToArray< LVecBase3f > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_PointerToArray_LVecBase3f)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< LVecBase3f > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< LVecBase3f >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypeHandle);
      if (arg_this != nullptr) {
        coerced = PointerToArray< LVecBase3f >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< LVecBase3f >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_LVecBase3f(&Dtool_PointerToArray_LVecBase3f._PyType, nullptr, nullptr);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != nullptr) {
        return nullptr;
      } else {
        return &coerced;
      }
    }

  }
  return nullptr;
}

static void *Dtool_UpcastInterface_PointerToArray_LVecBase3f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArray_LVecBase3f) {
    printf("PointerToArray_LVecBase3f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArray< LVecBase3f > *local_this = (PointerToArray< LVecBase3f > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArray_LVecBase3f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LVecBase3f) {
    return (PointerToArrayBase< LVecBase3f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3f) {
    return (PointerToBase< ReferenceCountedVector< LVecBase3f > > *)(PointerToArrayBase< LVecBase3f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase3f > > *)(PointerToArrayBase< LVecBase3f > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArray_LVecBase3f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArray_LVecBase3f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase3f) {
    PointerToArrayBase< LVecBase3f >* other_this = (PointerToArrayBase< LVecBase3f >*)from_this;
    return (PointerToArray< LVecBase3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3f) {
    PointerToBase< ReferenceCountedVector< LVecBase3f > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase3f > >*)from_this;
    return (PointerToArray< LVecBase3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< LVecBase3f >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArray< LVecBase3i >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< LVecBase3i > PointerToArray< LVecBase3i >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((LVecBase3i const *)(0))))
 */
static PyObject *Dtool_PointerToArray_LVecBase3i_empty_array_398(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline PointerToArray< LVecBase3i > PointerToArray< LVecBase3i >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((LVecBase3i const *)(0))))
  unsigned long param0;
  PyObject *param1 = nullptr;
  static const char *keyword_list[] = {"n", "type_handle", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "k|O:empty_array", (char **)keyword_list, &param0, &param1)) {
    TypeHandle param1_local;
    TypeHandle *param1_this;
    if (param1 != nullptr) {
      param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    } else {
      param1_local = (::_get_type_handle((LVecBase3i const *)(0)));
      param1_this = &param1_local;
    }
    if (param1 != nullptr && !(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
    }
    PointerToArray< LVecBase3i > *return_value = new PointerToArray< LVecBase3i >((PointerToArray< LVecBase3i >::empty_array)((unsigned long int)param0, *param1_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_LVecBase3i, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3i_empty_array_398_comment =
  "C++ Interface:\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3i_empty_array_398_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase3i >::clear(void)
 */
static PyObject *Dtool_PointerToArray_LVecBase3i_clear_399(PyObject *self, PyObject *) {
  PointerToArray< LVecBase3i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3i, (void **)&local_this, "PointerToArray_LVecBase3i.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LVecBase3i >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3i_clear_399_comment =
  "C++ Interface:\n"
  "clear(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3i_clear_399_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase3i >::push_back(LVecBase3i const &x)
 */
static PyObject *Dtool_PointerToArray_LVecBase3i_push_back_401(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase3i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3i, (void **)&local_this, "PointerToArray_LVecBase3i.push_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LVecBase3i >::push_back(LVecBase3i const &x)
  LVecBase3i arg_local;
  LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.push_back", "LVecBase3i");
  }
  ((*local_this).push_back)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, const LVecBase3i x)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3i_push_back_401_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, const LVecBase3i x)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3i_push_back_401_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase3i >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_LVecBase3i_pop_back_402(PyObject *self, PyObject *) {
  PointerToArray< LVecBase3i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3i, (void **)&local_this, "PointerToArray_LVecBase3i.pop_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LVecBase3i >::pop_back(void)
  ((*local_this).pop_back)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3i_pop_back_402_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3i_pop_back_402_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3i const &PointerToArray< LVecBase3i >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3i_get_element_403(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase3i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase3i)) {
    return nullptr;
  }
  // 1-inline LVecBase3i const &PointerToArray< LVecBase3i >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    LVecBase3i const *return_value = &(((*(const PointerToArray< LVecBase3i >*)local_this).get_element)((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3i_get_element_403_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3i_get_element_403_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase3i >::set_element(unsigned long int n, LVecBase3i const &value)
 */
static PyObject *Dtool_PointerToArray_LVecBase3i_set_element_404(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase3i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3i, (void **)&local_this, "PointerToArray_LVecBase3i.set_element")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LVecBase3i >::set_element(unsigned long int n, LVecBase3i const &value)
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:set_element", (char **)keyword_list, &param1, &param2)) {
    LVecBase3i param2_local;
    LVecBase3i const *param2_this = Dtool_Coerce_LVecBase3i(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PointerToArray.set_element", "LVecBase3i");
    }
    ((*local_this).set_element)((unsigned long int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, const LVecBase3i value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3i_set_element_404_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, const LVecBase3i value)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3i_set_element_404_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< LVecBase3i >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3i_get_data_407(PyObject *self, PyObject *) {
  PointerToArray< LVecBase3i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase3i)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< LVecBase3i >::get_data(void) const
  PyObject *return_value = invoke_extension((const PointerToArray< LVecBase3i >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3i_get_data_407_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3i_get_data_407_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToArray< LVecBase3i >::set_data(PyObject *data)
 */
static PyObject *Dtool_PointerToArray_LVecBase3i_set_data_408(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase3i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3i, (void **)&local_this, "PointerToArray_LVecBase3i.set_data")) {
    return nullptr;
  }
  // 1-void PointerToArray< LVecBase3i >::set_data(PyObject *data)
  invoke_extension(local_this).set_data(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, object data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3i_set_data_408_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, object data)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3i_set_data_408_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< LVecBase3i >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3i_get_subdata_409(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase3i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase3i)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< LVecBase3i >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const PointerToArray< LVecBase3i >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3i_get_subdata_409_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3i_get_subdata_409_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< LVecBase3i >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_LVecBase3i_set_subdata_410(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< LVecBase3i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_LVecBase3i, (void **)&local_this, "PointerToArray_LVecBase3i.set_subdata")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< LVecBase3i >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  const char *param3_str = nullptr;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    ((*local_this).set_subdata)((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3i_set_subdata_410_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3i_set_subdata_410_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LVecBase3i >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3i_get_ref_count_411(PyObject *self, PyObject *) {
  PointerToArray< LVecBase3i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase3i)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< LVecBase3i >::get_ref_count(void) const
  int return_value = ((*(const PointerToArray< LVecBase3i >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3i_get_ref_count_411_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3i_get_ref_count_411_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< LVecBase3i >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3i_get_node_ref_count_412(PyObject *self, PyObject *) {
  PointerToArray< LVecBase3i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase3i)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< LVecBase3i >::get_node_ref_count(void) const
  int return_value = ((*(const PointerToArray< LVecBase3i >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3i_get_node_ref_count_412_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3i_get_node_ref_count_412_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int PointerToArray< LVecBase3i >::count(LVecBase3i const &) const
 */
static PyObject *Dtool_PointerToArray_LVecBase3i_count_413(PyObject *self, PyObject *arg) {
  PointerToArray< LVecBase3i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_LVecBase3i)) {
    return nullptr;
  }
  // 1-inline unsigned long int PointerToArray< LVecBase3i >::count(LVecBase3i const &) const
  LVecBase3i arg_local;
  LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.count", "LVecBase3i");
  }
  unsigned long int return_value = ((*(const PointerToArray< LVecBase3i >*)local_this).count)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(PointerToArray self, const LVecBase3i param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_LVecBase3i_count_413_comment =
  "C++ Interface:\n"
  "count(PointerToArray self, const LVecBase3i param0)\n";
#else
static const char *Dtool_PointerToArray_LVecBase3i_count_413_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< LVecBase3i >::PointerToArray(PointerToArray< LVecBase3i > const &copy)
 * PointerToArray< LVecBase3i >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< LVecBase3i >::PointerToArray(TypeHandle type_handle = (::_get_type_handle((LVecBase3i const *)(0))))
 */
static int Dtool_Init_PointerToArray_LVecBase3i(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< LVecBase3i >::PointerToArray(TypeHandle type_handle)
      PointerToArray< LVecBase3i > *return_value = new PointerToArray< LVecBase3i >();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3i, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< LVecBase3i >::PointerToArray(PointerToArray< LVecBase3i > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< LVecBase3i > const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_PointerToArray_LVecBase3i);
          if (param0_this != nullptr) {
            PointerToArray< LVecBase3i > *return_value = new PointerToArray< LVecBase3i >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3i, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< LVecBase3i >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TypeHandle);
          if (param0_this != nullptr) {
            PointerToArray< LVecBase3i > *return_value = new PointerToArray< LVecBase3i >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3i, true, false);
          }
        }
      }

      {
        // -2 PointerToArray< LVecBase3i >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "source")) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, nullptr, &Dtool_PointerToArray_LVecBase3i, false, false);
          PointerToArray< LVecBase3i > *result = new PointerToArray< LVecBase3i >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< LVecBase3i > *return_value = result;
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != nullptr) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (UNLIKELY(notify->has_assert_failed())) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3i, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< LVecBase3i >::PointerToArray(PointerToArray< LVecBase3i > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< LVecBase3i > param0_local;
          PointerToArray< LVecBase3i > const *param0_this = Dtool_Coerce_PointerToArray_LVecBase3i(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< LVecBase3i > *return_value = new PointerToArray< LVecBase3i >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3i, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< LVecBase3i >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< LVecBase3i > *return_value = new PointerToArray< LVecBase3i >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_LVecBase3i, true, false);
          }
        }
      }

      // No coercion possible: PointerToArray< LVecBase3i >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< LVecBase3i > *Dtool_Coerce_PointerToArray_LVecBase3i(PyObject *args, PointerToArray< LVecBase3i > &coerced) {
  PointerToArray< LVecBase3i > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_PointerToArray_LVecBase3i)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< LVecBase3i > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< LVecBase3i >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypeHandle);
      if (arg_this != nullptr) {
        coerced = PointerToArray< LVecBase3i >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< LVecBase3i >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_LVecBase3i(&Dtool_PointerToArray_LVecBase3i._PyType, nullptr, nullptr);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != nullptr) {
        return nullptr;
      } else {
        return &coerced;
      }
    }

  }
  return nullptr;
}

static void *Dtool_UpcastInterface_PointerToArray_LVecBase3i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArray_LVecBase3i) {
    printf("PointerToArray_LVecBase3i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArray< LVecBase3i > *local_this = (PointerToArray< LVecBase3i > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArray_LVecBase3i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_LVecBase3i) {
    return (PointerToArrayBase< LVecBase3i > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3i) {
    return (PointerToBase< ReferenceCountedVector< LVecBase3i > > *)(PointerToArrayBase< LVecBase3i > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< LVecBase3i > > *)(PointerToArrayBase< LVecBase3i > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArray_LVecBase3i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArray_LVecBase3i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_LVecBase3i) {
    PointerToArrayBase< LVecBase3i >* other_this = (PointerToArrayBase< LVecBase3i >*)from_this;
    return (PointerToArray< LVecBase3i >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3i) {
    PointerToBase< ReferenceCountedVector< LVecBase3i > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase3i > >*)from_this;
    return (PointerToArray< LVecBase3i >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< LVecBase3i >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArray< UnalignedLMatrix4d >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< UnalignedLMatrix4d > PointerToArray< UnalignedLMatrix4d >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((UnalignedLMatrix4d const *)(0))))
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4d_empty_array_419(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline PointerToArray< UnalignedLMatrix4d > PointerToArray< UnalignedLMatrix4d >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((UnalignedLMatrix4d const *)(0))))
  unsigned long param0;
  PyObject *param1 = nullptr;
  static const char *keyword_list[] = {"n", "type_handle", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "k|O:empty_array", (char **)keyword_list, &param0, &param1)) {
    TypeHandle param1_local;
    TypeHandle *param1_this;
    if (param1 != nullptr) {
      param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    } else {
      param1_local = (::_get_type_handle((UnalignedLMatrix4d const *)(0)));
      param1_this = &param1_local;
    }
    if (param1 != nullptr && !(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
    }
    PointerToArray< UnalignedLMatrix4d > *return_value = new PointerToArray< UnalignedLMatrix4d >((PointerToArray< UnalignedLMatrix4d >::empty_array)((unsigned long int)param0, *param1_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_UnalignedLMatrix4d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_empty_array_419_comment =
  "C++ Interface:\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_empty_array_419_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLMatrix4d >::clear(void)
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4d_clear_420(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLMatrix4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLMatrix4d, (void **)&local_this, "PointerToArray_UnalignedLMatrix4d.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< UnalignedLMatrix4d >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_clear_420_comment =
  "C++ Interface:\n"
  "clear(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_clear_420_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLMatrix4d >::push_back(UnalignedLMatrix4d const &x)
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4d_push_back_422(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLMatrix4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLMatrix4d, (void **)&local_this, "PointerToArray_UnalignedLMatrix4d.push_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< UnalignedLMatrix4d >::push_back(UnalignedLMatrix4d const &x)
  UnalignedLMatrix4d arg_local;
  UnalignedLMatrix4d const *arg_this = Dtool_Coerce_UnalignedLMatrix4d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.push_back", "UnalignedLMatrix4d");
  }
  ((*local_this).push_back)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, const UnalignedLMatrix4d x)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_push_back_422_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, const UnalignedLMatrix4d x)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_push_back_422_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLMatrix4d >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4d_pop_back_423(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLMatrix4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLMatrix4d, (void **)&local_this, "PointerToArray_UnalignedLMatrix4d.pop_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< UnalignedLMatrix4d >::pop_back(void)
  ((*local_this).pop_back)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_pop_back_423_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_pop_back_423_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UnalignedLMatrix4d const &PointerToArray< UnalignedLMatrix4d >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4d_get_element_424(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLMatrix4d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_UnalignedLMatrix4d)) {
    return nullptr;
  }
  // 1-inline UnalignedLMatrix4d const &PointerToArray< UnalignedLMatrix4d >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    UnalignedLMatrix4d const *return_value = &(((*(const PointerToArray< UnalignedLMatrix4d >*)local_this).get_element)((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLMatrix4d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_get_element_424_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_get_element_424_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLMatrix4d >::set_element(unsigned long int n, UnalignedLMatrix4d const &value)
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4d_set_element_425(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< UnalignedLMatrix4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLMatrix4d, (void **)&local_this, "PointerToArray_UnalignedLMatrix4d.set_element")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< UnalignedLMatrix4d >::set_element(unsigned long int n, UnalignedLMatrix4d const &value)
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:set_element", (char **)keyword_list, &param1, &param2)) {
    UnalignedLMatrix4d param2_local;
    UnalignedLMatrix4d const *param2_this = Dtool_Coerce_UnalignedLMatrix4d(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PointerToArray.set_element", "UnalignedLMatrix4d");
    }
    ((*local_this).set_element)((unsigned long int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, const UnalignedLMatrix4d value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_set_element_425_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, const UnalignedLMatrix4d value)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_set_element_425_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< UnalignedLMatrix4d >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4d_get_data_428(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLMatrix4d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_UnalignedLMatrix4d)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< UnalignedLMatrix4d >::get_data(void) const
  PyObject *return_value = invoke_extension((const PointerToArray< UnalignedLMatrix4d >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_get_data_428_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_get_data_428_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToArray< UnalignedLMatrix4d >::set_data(PyObject *data)
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4d_set_data_429(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLMatrix4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLMatrix4d, (void **)&local_this, "PointerToArray_UnalignedLMatrix4d.set_data")) {
    return nullptr;
  }
  // 1-void PointerToArray< UnalignedLMatrix4d >::set_data(PyObject *data)
  invoke_extension(local_this).set_data(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, object data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_set_data_429_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, object data)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_set_data_429_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< UnalignedLMatrix4d >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4d_get_subdata_430(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< UnalignedLMatrix4d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_UnalignedLMatrix4d)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< UnalignedLMatrix4d >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const PointerToArray< UnalignedLMatrix4d >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_get_subdata_430_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_get_subdata_430_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLMatrix4d >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4d_set_subdata_431(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< UnalignedLMatrix4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLMatrix4d, (void **)&local_this, "PointerToArray_UnalignedLMatrix4d.set_subdata")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< UnalignedLMatrix4d >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  const char *param3_str = nullptr;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    ((*local_this).set_subdata)((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_set_subdata_431_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_set_subdata_431_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< UnalignedLMatrix4d >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4d_get_ref_count_432(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLMatrix4d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_UnalignedLMatrix4d)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< UnalignedLMatrix4d >::get_ref_count(void) const
  int return_value = ((*(const PointerToArray< UnalignedLMatrix4d >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_get_ref_count_432_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_get_ref_count_432_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< UnalignedLMatrix4d >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4d_get_node_ref_count_433(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLMatrix4d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_UnalignedLMatrix4d)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< UnalignedLMatrix4d >::get_node_ref_count(void) const
  int return_value = ((*(const PointerToArray< UnalignedLMatrix4d >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_get_node_ref_count_433_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_get_node_ref_count_433_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int PointerToArray< UnalignedLMatrix4d >::count(UnalignedLMatrix4d const &) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4d_count_434(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLMatrix4d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_UnalignedLMatrix4d)) {
    return nullptr;
  }
  // 1-inline unsigned long int PointerToArray< UnalignedLMatrix4d >::count(UnalignedLMatrix4d const &) const
  UnalignedLMatrix4d arg_local;
  UnalignedLMatrix4d const *arg_this = Dtool_Coerce_UnalignedLMatrix4d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.count", "UnalignedLMatrix4d");
  }
  unsigned long int return_value = ((*(const PointerToArray< UnalignedLMatrix4d >*)local_this).count)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(PointerToArray self, const UnalignedLMatrix4d param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_count_434_comment =
  "C++ Interface:\n"
  "count(PointerToArray self, const UnalignedLMatrix4d param0)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4d_count_434_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< UnalignedLMatrix4d >::PointerToArray(PointerToArray< UnalignedLMatrix4d > const &copy)
 * PointerToArray< UnalignedLMatrix4d >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< UnalignedLMatrix4d >::PointerToArray(TypeHandle type_handle = (::_get_type_handle((UnalignedLMatrix4d const *)(0))))
 */
static int Dtool_Init_PointerToArray_UnalignedLMatrix4d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< UnalignedLMatrix4d >::PointerToArray(TypeHandle type_handle)
      PointerToArray< UnalignedLMatrix4d > *return_value = new PointerToArray< UnalignedLMatrix4d >();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLMatrix4d, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< UnalignedLMatrix4d >::PointerToArray(PointerToArray< UnalignedLMatrix4d > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< UnalignedLMatrix4d > const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_PointerToArray_UnalignedLMatrix4d);
          if (param0_this != nullptr) {
            PointerToArray< UnalignedLMatrix4d > *return_value = new PointerToArray< UnalignedLMatrix4d >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLMatrix4d, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< UnalignedLMatrix4d >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TypeHandle);
          if (param0_this != nullptr) {
            PointerToArray< UnalignedLMatrix4d > *return_value = new PointerToArray< UnalignedLMatrix4d >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLMatrix4d, true, false);
          }
        }
      }

      {
        // -2 PointerToArray< UnalignedLMatrix4d >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "source")) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, nullptr, &Dtool_PointerToArray_UnalignedLMatrix4d, false, false);
          PointerToArray< UnalignedLMatrix4d > *result = new PointerToArray< UnalignedLMatrix4d >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< UnalignedLMatrix4d > *return_value = result;
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != nullptr) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (UNLIKELY(notify->has_assert_failed())) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLMatrix4d, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< UnalignedLMatrix4d >::PointerToArray(PointerToArray< UnalignedLMatrix4d > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< UnalignedLMatrix4d > param0_local;
          PointerToArray< UnalignedLMatrix4d > const *param0_this = Dtool_Coerce_PointerToArray_UnalignedLMatrix4d(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< UnalignedLMatrix4d > *return_value = new PointerToArray< UnalignedLMatrix4d >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLMatrix4d, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< UnalignedLMatrix4d >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< UnalignedLMatrix4d > *return_value = new PointerToArray< UnalignedLMatrix4d >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLMatrix4d, true, false);
          }
        }
      }

      // No coercion possible: PointerToArray< UnalignedLMatrix4d >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< UnalignedLMatrix4d > *Dtool_Coerce_PointerToArray_UnalignedLMatrix4d(PyObject *args, PointerToArray< UnalignedLMatrix4d > &coerced) {
  PointerToArray< UnalignedLMatrix4d > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_PointerToArray_UnalignedLMatrix4d)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< UnalignedLMatrix4d > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< UnalignedLMatrix4d >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypeHandle);
      if (arg_this != nullptr) {
        coerced = PointerToArray< UnalignedLMatrix4d >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< UnalignedLMatrix4d >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_UnalignedLMatrix4d(&Dtool_PointerToArray_UnalignedLMatrix4d._PyType, nullptr, nullptr);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != nullptr) {
        return nullptr;
      } else {
        return &coerced;
      }
    }

  }
  return nullptr;
}

static void *Dtool_UpcastInterface_PointerToArray_UnalignedLMatrix4d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArray_UnalignedLMatrix4d) {
    printf("PointerToArray_UnalignedLMatrix4d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArray< UnalignedLMatrix4d > *local_this = (PointerToArray< UnalignedLMatrix4d > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArray_UnalignedLMatrix4d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4d) {
    return (PointerToArrayBase< UnalignedLMatrix4d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d) {
    return (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > > *)(PointerToArrayBase< UnalignedLMatrix4d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > > *)(PointerToArrayBase< UnalignedLMatrix4d > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArray_UnalignedLMatrix4d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArray_UnalignedLMatrix4d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4d) {
    PointerToArrayBase< UnalignedLMatrix4d >* other_this = (PointerToArrayBase< UnalignedLMatrix4d >*)from_this;
    return (PointerToArray< UnalignedLMatrix4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d) {
    PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > >* other_this = (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > >*)from_this;
    return (PointerToArray< UnalignedLMatrix4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< UnalignedLMatrix4d >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArray< UnalignedLMatrix4f >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< UnalignedLMatrix4f > PointerToArray< UnalignedLMatrix4f >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((UnalignedLMatrix4f const *)(0))))
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4f_empty_array_440(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline PointerToArray< UnalignedLMatrix4f > PointerToArray< UnalignedLMatrix4f >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((UnalignedLMatrix4f const *)(0))))
  unsigned long param0;
  PyObject *param1 = nullptr;
  static const char *keyword_list[] = {"n", "type_handle", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "k|O:empty_array", (char **)keyword_list, &param0, &param1)) {
    TypeHandle param1_local;
    TypeHandle *param1_this;
    if (param1 != nullptr) {
      param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    } else {
      param1_local = (::_get_type_handle((UnalignedLMatrix4f const *)(0)));
      param1_this = &param1_local;
    }
    if (param1 != nullptr && !(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
    }
    PointerToArray< UnalignedLMatrix4f > *return_value = new PointerToArray< UnalignedLMatrix4f >((PointerToArray< UnalignedLMatrix4f >::empty_array)((unsigned long int)param0, *param1_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_UnalignedLMatrix4f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_empty_array_440_comment =
  "C++ Interface:\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_empty_array_440_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLMatrix4f >::clear(void)
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4f_clear_441(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLMatrix4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLMatrix4f, (void **)&local_this, "PointerToArray_UnalignedLMatrix4f.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< UnalignedLMatrix4f >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_clear_441_comment =
  "C++ Interface:\n"
  "clear(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_clear_441_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLMatrix4f >::push_back(UnalignedLMatrix4f const &x)
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4f_push_back_443(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLMatrix4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLMatrix4f, (void **)&local_this, "PointerToArray_UnalignedLMatrix4f.push_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< UnalignedLMatrix4f >::push_back(UnalignedLMatrix4f const &x)
  UnalignedLMatrix4f arg_local;
  UnalignedLMatrix4f const *arg_this = Dtool_Coerce_UnalignedLMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.push_back", "UnalignedLMatrix4f");
  }
  ((*local_this).push_back)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, const UnalignedLMatrix4f x)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_push_back_443_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, const UnalignedLMatrix4f x)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_push_back_443_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLMatrix4f >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4f_pop_back_444(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLMatrix4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLMatrix4f, (void **)&local_this, "PointerToArray_UnalignedLMatrix4f.pop_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< UnalignedLMatrix4f >::pop_back(void)
  ((*local_this).pop_back)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_pop_back_444_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_pop_back_444_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UnalignedLMatrix4f const &PointerToArray< UnalignedLMatrix4f >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4f_get_element_445(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLMatrix4f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_UnalignedLMatrix4f)) {
    return nullptr;
  }
  // 1-inline UnalignedLMatrix4f const &PointerToArray< UnalignedLMatrix4f >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    UnalignedLMatrix4f const *return_value = &(((*(const PointerToArray< UnalignedLMatrix4f >*)local_this).get_element)((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLMatrix4f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_get_element_445_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_get_element_445_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLMatrix4f >::set_element(unsigned long int n, UnalignedLMatrix4f const &value)
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4f_set_element_446(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< UnalignedLMatrix4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLMatrix4f, (void **)&local_this, "PointerToArray_UnalignedLMatrix4f.set_element")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< UnalignedLMatrix4f >::set_element(unsigned long int n, UnalignedLMatrix4f const &value)
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:set_element", (char **)keyword_list, &param1, &param2)) {
    UnalignedLMatrix4f param2_local;
    UnalignedLMatrix4f const *param2_this = Dtool_Coerce_UnalignedLMatrix4f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PointerToArray.set_element", "UnalignedLMatrix4f");
    }
    ((*local_this).set_element)((unsigned long int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, const UnalignedLMatrix4f value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_set_element_446_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, const UnalignedLMatrix4f value)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_set_element_446_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< UnalignedLMatrix4f >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4f_get_data_449(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLMatrix4f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_UnalignedLMatrix4f)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< UnalignedLMatrix4f >::get_data(void) const
  PyObject *return_value = invoke_extension((const PointerToArray< UnalignedLMatrix4f >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_get_data_449_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_get_data_449_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToArray< UnalignedLMatrix4f >::set_data(PyObject *data)
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4f_set_data_450(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLMatrix4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLMatrix4f, (void **)&local_this, "PointerToArray_UnalignedLMatrix4f.set_data")) {
    return nullptr;
  }
  // 1-void PointerToArray< UnalignedLMatrix4f >::set_data(PyObject *data)
  invoke_extension(local_this).set_data(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, object data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_set_data_450_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, object data)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_set_data_450_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< UnalignedLMatrix4f >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4f_get_subdata_451(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< UnalignedLMatrix4f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_UnalignedLMatrix4f)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< UnalignedLMatrix4f >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const PointerToArray< UnalignedLMatrix4f >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_get_subdata_451_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_get_subdata_451_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLMatrix4f >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4f_set_subdata_452(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< UnalignedLMatrix4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLMatrix4f, (void **)&local_this, "PointerToArray_UnalignedLMatrix4f.set_subdata")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< UnalignedLMatrix4f >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  const char *param3_str = nullptr;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    ((*local_this).set_subdata)((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_set_subdata_452_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_set_subdata_452_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< UnalignedLMatrix4f >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4f_get_ref_count_453(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLMatrix4f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_UnalignedLMatrix4f)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< UnalignedLMatrix4f >::get_ref_count(void) const
  int return_value = ((*(const PointerToArray< UnalignedLMatrix4f >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_get_ref_count_453_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_get_ref_count_453_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< UnalignedLMatrix4f >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4f_get_node_ref_count_454(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLMatrix4f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_UnalignedLMatrix4f)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< UnalignedLMatrix4f >::get_node_ref_count(void) const
  int return_value = ((*(const PointerToArray< UnalignedLMatrix4f >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_get_node_ref_count_454_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_get_node_ref_count_454_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int PointerToArray< UnalignedLMatrix4f >::count(UnalignedLMatrix4f const &) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4f_count_455(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLMatrix4f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_UnalignedLMatrix4f)) {
    return nullptr;
  }
  // 1-inline unsigned long int PointerToArray< UnalignedLMatrix4f >::count(UnalignedLMatrix4f const &) const
  UnalignedLMatrix4f arg_local;
  UnalignedLMatrix4f const *arg_this = Dtool_Coerce_UnalignedLMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.count", "UnalignedLMatrix4f");
  }
  unsigned long int return_value = ((*(const PointerToArray< UnalignedLMatrix4f >*)local_this).count)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(PointerToArray self, const UnalignedLMatrix4f param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_count_455_comment =
  "C++ Interface:\n"
  "count(PointerToArray self, const UnalignedLMatrix4f param0)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLMatrix4f_count_455_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< UnalignedLMatrix4f >::PointerToArray(PointerToArray< UnalignedLMatrix4f > const &copy)
 * PointerToArray< UnalignedLMatrix4f >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< UnalignedLMatrix4f >::PointerToArray(TypeHandle type_handle = (::_get_type_handle((UnalignedLMatrix4f const *)(0))))
 */
static int Dtool_Init_PointerToArray_UnalignedLMatrix4f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< UnalignedLMatrix4f >::PointerToArray(TypeHandle type_handle)
      PointerToArray< UnalignedLMatrix4f > *return_value = new PointerToArray< UnalignedLMatrix4f >();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLMatrix4f, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< UnalignedLMatrix4f >::PointerToArray(PointerToArray< UnalignedLMatrix4f > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< UnalignedLMatrix4f > const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_PointerToArray_UnalignedLMatrix4f);
          if (param0_this != nullptr) {
            PointerToArray< UnalignedLMatrix4f > *return_value = new PointerToArray< UnalignedLMatrix4f >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLMatrix4f, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< UnalignedLMatrix4f >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TypeHandle);
          if (param0_this != nullptr) {
            PointerToArray< UnalignedLMatrix4f > *return_value = new PointerToArray< UnalignedLMatrix4f >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLMatrix4f, true, false);
          }
        }
      }

      {
        // -2 PointerToArray< UnalignedLMatrix4f >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "source")) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, nullptr, &Dtool_PointerToArray_UnalignedLMatrix4f, false, false);
          PointerToArray< UnalignedLMatrix4f > *result = new PointerToArray< UnalignedLMatrix4f >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< UnalignedLMatrix4f > *return_value = result;
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != nullptr) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (UNLIKELY(notify->has_assert_failed())) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLMatrix4f, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< UnalignedLMatrix4f >::PointerToArray(PointerToArray< UnalignedLMatrix4f > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< UnalignedLMatrix4f > param0_local;
          PointerToArray< UnalignedLMatrix4f > const *param0_this = Dtool_Coerce_PointerToArray_UnalignedLMatrix4f(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< UnalignedLMatrix4f > *return_value = new PointerToArray< UnalignedLMatrix4f >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLMatrix4f, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< UnalignedLMatrix4f >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< UnalignedLMatrix4f > *return_value = new PointerToArray< UnalignedLMatrix4f >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLMatrix4f, true, false);
          }
        }
      }

      // No coercion possible: PointerToArray< UnalignedLMatrix4f >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< UnalignedLMatrix4f > *Dtool_Coerce_PointerToArray_UnalignedLMatrix4f(PyObject *args, PointerToArray< UnalignedLMatrix4f > &coerced) {
  PointerToArray< UnalignedLMatrix4f > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_PointerToArray_UnalignedLMatrix4f)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< UnalignedLMatrix4f > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< UnalignedLMatrix4f >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypeHandle);
      if (arg_this != nullptr) {
        coerced = PointerToArray< UnalignedLMatrix4f >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< UnalignedLMatrix4f >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_UnalignedLMatrix4f(&Dtool_PointerToArray_UnalignedLMatrix4f._PyType, nullptr, nullptr);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != nullptr) {
        return nullptr;
      } else {
        return &coerced;
      }
    }

  }
  return nullptr;
}

static void *Dtool_UpcastInterface_PointerToArray_UnalignedLMatrix4f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArray_UnalignedLMatrix4f) {
    printf("PointerToArray_UnalignedLMatrix4f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArray< UnalignedLMatrix4f > *local_this = (PointerToArray< UnalignedLMatrix4f > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArray_UnalignedLMatrix4f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4f) {
    return (PointerToArrayBase< UnalignedLMatrix4f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f) {
    return (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > > *)(PointerToArrayBase< UnalignedLMatrix4f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > > *)(PointerToArrayBase< UnalignedLMatrix4f > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArray_UnalignedLMatrix4f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArray_UnalignedLMatrix4f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4f) {
    PointerToArrayBase< UnalignedLMatrix4f >* other_this = (PointerToArrayBase< UnalignedLMatrix4f >*)from_this;
    return (PointerToArray< UnalignedLMatrix4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f) {
    PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > >* other_this = (PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > >*)from_this;
    return (PointerToArray< UnalignedLMatrix4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< UnalignedLMatrix4f >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArray< UnalignedLVecBase4d >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< UnalignedLVecBase4d > PointerToArray< UnalignedLVecBase4d >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((UnalignedLVecBase4d const *)(0))))
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4d_empty_array_461(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline PointerToArray< UnalignedLVecBase4d > PointerToArray< UnalignedLVecBase4d >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((UnalignedLVecBase4d const *)(0))))
  unsigned long param0;
  PyObject *param1 = nullptr;
  static const char *keyword_list[] = {"n", "type_handle", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "k|O:empty_array", (char **)keyword_list, &param0, &param1)) {
    TypeHandle param1_local;
    TypeHandle *param1_this;
    if (param1 != nullptr) {
      param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    } else {
      param1_local = (::_get_type_handle((UnalignedLVecBase4d const *)(0)));
      param1_this = &param1_local;
    }
    if (param1 != nullptr && !(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
    }
    PointerToArray< UnalignedLVecBase4d > *return_value = new PointerToArray< UnalignedLVecBase4d >((PointerToArray< UnalignedLVecBase4d >::empty_array)((unsigned long int)param0, *param1_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_UnalignedLVecBase4d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_empty_array_461_comment =
  "C++ Interface:\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_empty_array_461_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLVecBase4d >::clear(void)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4d_clear_462(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLVecBase4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4d, (void **)&local_this, "PointerToArray_UnalignedLVecBase4d.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< UnalignedLVecBase4d >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_clear_462_comment =
  "C++ Interface:\n"
  "clear(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_clear_462_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLVecBase4d >::push_back(UnalignedLVecBase4d const &x)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4d_push_back_464(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLVecBase4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4d, (void **)&local_this, "PointerToArray_UnalignedLVecBase4d.push_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< UnalignedLVecBase4d >::push_back(UnalignedLVecBase4d const &x)
  UnalignedLVecBase4d arg_local;
  UnalignedLVecBase4d const *arg_this = Dtool_Coerce_UnalignedLVecBase4d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.push_back", "UnalignedLVecBase4d");
  }
  ((*local_this).push_back)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, const UnalignedLVecBase4d x)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_push_back_464_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, const UnalignedLVecBase4d x)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_push_back_464_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLVecBase4d >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4d_pop_back_465(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLVecBase4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4d, (void **)&local_this, "PointerToArray_UnalignedLVecBase4d.pop_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< UnalignedLVecBase4d >::pop_back(void)
  ((*local_this).pop_back)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_pop_back_465_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_pop_back_465_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UnalignedLVecBase4d const &PointerToArray< UnalignedLVecBase4d >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4d_get_element_466(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLVecBase4d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_UnalignedLVecBase4d)) {
    return nullptr;
  }
  // 1-inline UnalignedLVecBase4d const &PointerToArray< UnalignedLVecBase4d >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    UnalignedLVecBase4d const *return_value = &(((*(const PointerToArray< UnalignedLVecBase4d >*)local_this).get_element)((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLVecBase4d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_get_element_466_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_get_element_466_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLVecBase4d >::set_element(unsigned long int n, UnalignedLVecBase4d const &value)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4d_set_element_467(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< UnalignedLVecBase4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4d, (void **)&local_this, "PointerToArray_UnalignedLVecBase4d.set_element")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< UnalignedLVecBase4d >::set_element(unsigned long int n, UnalignedLVecBase4d const &value)
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:set_element", (char **)keyword_list, &param1, &param2)) {
    UnalignedLVecBase4d param2_local;
    UnalignedLVecBase4d const *param2_this = Dtool_Coerce_UnalignedLVecBase4d(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PointerToArray.set_element", "UnalignedLVecBase4d");
    }
    ((*local_this).set_element)((unsigned long int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, const UnalignedLVecBase4d value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_set_element_467_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, const UnalignedLVecBase4d value)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_set_element_467_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< UnalignedLVecBase4d >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4d_get_data_470(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLVecBase4d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_UnalignedLVecBase4d)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< UnalignedLVecBase4d >::get_data(void) const
  PyObject *return_value = invoke_extension((const PointerToArray< UnalignedLVecBase4d >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_get_data_470_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_get_data_470_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToArray< UnalignedLVecBase4d >::set_data(PyObject *data)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4d_set_data_471(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLVecBase4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4d, (void **)&local_this, "PointerToArray_UnalignedLVecBase4d.set_data")) {
    return nullptr;
  }
  // 1-void PointerToArray< UnalignedLVecBase4d >::set_data(PyObject *data)
  invoke_extension(local_this).set_data(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, object data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_set_data_471_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, object data)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_set_data_471_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< UnalignedLVecBase4d >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4d_get_subdata_472(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< UnalignedLVecBase4d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_UnalignedLVecBase4d)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< UnalignedLVecBase4d >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const PointerToArray< UnalignedLVecBase4d >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_get_subdata_472_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_get_subdata_472_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLVecBase4d >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4d_set_subdata_473(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< UnalignedLVecBase4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4d, (void **)&local_this, "PointerToArray_UnalignedLVecBase4d.set_subdata")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< UnalignedLVecBase4d >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  const char *param3_str = nullptr;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    ((*local_this).set_subdata)((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_set_subdata_473_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_set_subdata_473_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< UnalignedLVecBase4d >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4d_get_ref_count_474(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLVecBase4d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_UnalignedLVecBase4d)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< UnalignedLVecBase4d >::get_ref_count(void) const
  int return_value = ((*(const PointerToArray< UnalignedLVecBase4d >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_get_ref_count_474_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_get_ref_count_474_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< UnalignedLVecBase4d >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4d_get_node_ref_count_475(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLVecBase4d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_UnalignedLVecBase4d)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< UnalignedLVecBase4d >::get_node_ref_count(void) const
  int return_value = ((*(const PointerToArray< UnalignedLVecBase4d >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_get_node_ref_count_475_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_get_node_ref_count_475_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int PointerToArray< UnalignedLVecBase4d >::count(UnalignedLVecBase4d const &) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4d_count_476(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLVecBase4d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_UnalignedLVecBase4d)) {
    return nullptr;
  }
  // 1-inline unsigned long int PointerToArray< UnalignedLVecBase4d >::count(UnalignedLVecBase4d const &) const
  UnalignedLVecBase4d arg_local;
  UnalignedLVecBase4d const *arg_this = Dtool_Coerce_UnalignedLVecBase4d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.count", "UnalignedLVecBase4d");
  }
  unsigned long int return_value = ((*(const PointerToArray< UnalignedLVecBase4d >*)local_this).count)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(PointerToArray self, const UnalignedLVecBase4d param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_count_476_comment =
  "C++ Interface:\n"
  "count(PointerToArray self, const UnalignedLVecBase4d param0)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4d_count_476_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< UnalignedLVecBase4d >::PointerToArray(PointerToArray< UnalignedLVecBase4d > const &copy)
 * PointerToArray< UnalignedLVecBase4d >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< UnalignedLVecBase4d >::PointerToArray(TypeHandle type_handle = (::_get_type_handle((UnalignedLVecBase4d const *)(0))))
 */
static int Dtool_Init_PointerToArray_UnalignedLVecBase4d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< UnalignedLVecBase4d >::PointerToArray(TypeHandle type_handle)
      PointerToArray< UnalignedLVecBase4d > *return_value = new PointerToArray< UnalignedLVecBase4d >();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4d, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< UnalignedLVecBase4d >::PointerToArray(PointerToArray< UnalignedLVecBase4d > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< UnalignedLVecBase4d > const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_PointerToArray_UnalignedLVecBase4d);
          if (param0_this != nullptr) {
            PointerToArray< UnalignedLVecBase4d > *return_value = new PointerToArray< UnalignedLVecBase4d >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4d, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< UnalignedLVecBase4d >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TypeHandle);
          if (param0_this != nullptr) {
            PointerToArray< UnalignedLVecBase4d > *return_value = new PointerToArray< UnalignedLVecBase4d >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4d, true, false);
          }
        }
      }

      {
        // -2 PointerToArray< UnalignedLVecBase4d >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "source")) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, nullptr, &Dtool_PointerToArray_UnalignedLVecBase4d, false, false);
          PointerToArray< UnalignedLVecBase4d > *result = new PointerToArray< UnalignedLVecBase4d >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< UnalignedLVecBase4d > *return_value = result;
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != nullptr) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (UNLIKELY(notify->has_assert_failed())) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4d, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< UnalignedLVecBase4d >::PointerToArray(PointerToArray< UnalignedLVecBase4d > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< UnalignedLVecBase4d > param0_local;
          PointerToArray< UnalignedLVecBase4d > const *param0_this = Dtool_Coerce_PointerToArray_UnalignedLVecBase4d(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< UnalignedLVecBase4d > *return_value = new PointerToArray< UnalignedLVecBase4d >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4d, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< UnalignedLVecBase4d >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< UnalignedLVecBase4d > *return_value = new PointerToArray< UnalignedLVecBase4d >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4d, true, false);
          }
        }
      }

      // No coercion possible: PointerToArray< UnalignedLVecBase4d >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< UnalignedLVecBase4d > *Dtool_Coerce_PointerToArray_UnalignedLVecBase4d(PyObject *args, PointerToArray< UnalignedLVecBase4d > &coerced) {
  PointerToArray< UnalignedLVecBase4d > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_PointerToArray_UnalignedLVecBase4d)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< UnalignedLVecBase4d > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< UnalignedLVecBase4d >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypeHandle);
      if (arg_this != nullptr) {
        coerced = PointerToArray< UnalignedLVecBase4d >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< UnalignedLVecBase4d >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_UnalignedLVecBase4d(&Dtool_PointerToArray_UnalignedLVecBase4d._PyType, nullptr, nullptr);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != nullptr) {
        return nullptr;
      } else {
        return &coerced;
      }
    }

  }
  return nullptr;
}

static void *Dtool_UpcastInterface_PointerToArray_UnalignedLVecBase4d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArray_UnalignedLVecBase4d) {
    printf("PointerToArray_UnalignedLVecBase4d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArray< UnalignedLVecBase4d > *local_this = (PointerToArray< UnalignedLVecBase4d > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArray_UnalignedLVecBase4d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4d) {
    return (PointerToArrayBase< UnalignedLVecBase4d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d) {
    return (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > > *)(PointerToArrayBase< UnalignedLVecBase4d > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > > *)(PointerToArrayBase< UnalignedLVecBase4d > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArray_UnalignedLVecBase4d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArray_UnalignedLVecBase4d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4d) {
    PointerToArrayBase< UnalignedLVecBase4d >* other_this = (PointerToArrayBase< UnalignedLVecBase4d >*)from_this;
    return (PointerToArray< UnalignedLVecBase4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d) {
    PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > >* other_this = (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > >*)from_this;
    return (PointerToArray< UnalignedLVecBase4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< UnalignedLVecBase4d >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArray< UnalignedLVecBase4f >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< UnalignedLVecBase4f > PointerToArray< UnalignedLVecBase4f >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((UnalignedLVecBase4f const *)(0))))
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4f_empty_array_482(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline PointerToArray< UnalignedLVecBase4f > PointerToArray< UnalignedLVecBase4f >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((UnalignedLVecBase4f const *)(0))))
  unsigned long param0;
  PyObject *param1 = nullptr;
  static const char *keyword_list[] = {"n", "type_handle", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "k|O:empty_array", (char **)keyword_list, &param0, &param1)) {
    TypeHandle param1_local;
    TypeHandle *param1_this;
    if (param1 != nullptr) {
      param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    } else {
      param1_local = (::_get_type_handle((UnalignedLVecBase4f const *)(0)));
      param1_this = &param1_local;
    }
    if (param1 != nullptr && !(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
    }
    PointerToArray< UnalignedLVecBase4f > *return_value = new PointerToArray< UnalignedLVecBase4f >((PointerToArray< UnalignedLVecBase4f >::empty_array)((unsigned long int)param0, *param1_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_UnalignedLVecBase4f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_empty_array_482_comment =
  "C++ Interface:\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_empty_array_482_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLVecBase4f >::clear(void)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4f_clear_483(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLVecBase4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4f, (void **)&local_this, "PointerToArray_UnalignedLVecBase4f.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< UnalignedLVecBase4f >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_clear_483_comment =
  "C++ Interface:\n"
  "clear(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_clear_483_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLVecBase4f >::push_back(UnalignedLVecBase4f const &x)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4f_push_back_485(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLVecBase4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4f, (void **)&local_this, "PointerToArray_UnalignedLVecBase4f.push_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< UnalignedLVecBase4f >::push_back(UnalignedLVecBase4f const &x)
  UnalignedLVecBase4f arg_local;
  UnalignedLVecBase4f const *arg_this = Dtool_Coerce_UnalignedLVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.push_back", "UnalignedLVecBase4f");
  }
  ((*local_this).push_back)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, const UnalignedLVecBase4f x)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_push_back_485_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, const UnalignedLVecBase4f x)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_push_back_485_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLVecBase4f >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4f_pop_back_486(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLVecBase4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4f, (void **)&local_this, "PointerToArray_UnalignedLVecBase4f.pop_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< UnalignedLVecBase4f >::pop_back(void)
  ((*local_this).pop_back)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_pop_back_486_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_pop_back_486_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UnalignedLVecBase4f const &PointerToArray< UnalignedLVecBase4f >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4f_get_element_487(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLVecBase4f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_UnalignedLVecBase4f)) {
    return nullptr;
  }
  // 1-inline UnalignedLVecBase4f const &PointerToArray< UnalignedLVecBase4f >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    UnalignedLVecBase4f const *return_value = &(((*(const PointerToArray< UnalignedLVecBase4f >*)local_this).get_element)((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLVecBase4f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_get_element_487_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_get_element_487_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLVecBase4f >::set_element(unsigned long int n, UnalignedLVecBase4f const &value)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4f_set_element_488(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< UnalignedLVecBase4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4f, (void **)&local_this, "PointerToArray_UnalignedLVecBase4f.set_element")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< UnalignedLVecBase4f >::set_element(unsigned long int n, UnalignedLVecBase4f const &value)
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:set_element", (char **)keyword_list, &param1, &param2)) {
    UnalignedLVecBase4f param2_local;
    UnalignedLVecBase4f const *param2_this = Dtool_Coerce_UnalignedLVecBase4f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PointerToArray.set_element", "UnalignedLVecBase4f");
    }
    ((*local_this).set_element)((unsigned long int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, const UnalignedLVecBase4f value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_set_element_488_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, const UnalignedLVecBase4f value)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_set_element_488_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< UnalignedLVecBase4f >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4f_get_data_491(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLVecBase4f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_UnalignedLVecBase4f)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< UnalignedLVecBase4f >::get_data(void) const
  PyObject *return_value = invoke_extension((const PointerToArray< UnalignedLVecBase4f >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_get_data_491_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_get_data_491_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToArray< UnalignedLVecBase4f >::set_data(PyObject *data)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4f_set_data_492(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLVecBase4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4f, (void **)&local_this, "PointerToArray_UnalignedLVecBase4f.set_data")) {
    return nullptr;
  }
  // 1-void PointerToArray< UnalignedLVecBase4f >::set_data(PyObject *data)
  invoke_extension(local_this).set_data(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, object data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_set_data_492_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, object data)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_set_data_492_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< UnalignedLVecBase4f >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4f_get_subdata_493(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< UnalignedLVecBase4f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_UnalignedLVecBase4f)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< UnalignedLVecBase4f >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const PointerToArray< UnalignedLVecBase4f >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_get_subdata_493_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_get_subdata_493_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLVecBase4f >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4f_set_subdata_494(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< UnalignedLVecBase4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4f, (void **)&local_this, "PointerToArray_UnalignedLVecBase4f.set_subdata")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< UnalignedLVecBase4f >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  const char *param3_str = nullptr;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    ((*local_this).set_subdata)((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_set_subdata_494_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_set_subdata_494_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< UnalignedLVecBase4f >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4f_get_ref_count_495(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLVecBase4f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_UnalignedLVecBase4f)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< UnalignedLVecBase4f >::get_ref_count(void) const
  int return_value = ((*(const PointerToArray< UnalignedLVecBase4f >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_get_ref_count_495_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_get_ref_count_495_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< UnalignedLVecBase4f >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4f_get_node_ref_count_496(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLVecBase4f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_UnalignedLVecBase4f)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< UnalignedLVecBase4f >::get_node_ref_count(void) const
  int return_value = ((*(const PointerToArray< UnalignedLVecBase4f >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_get_node_ref_count_496_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_get_node_ref_count_496_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int PointerToArray< UnalignedLVecBase4f >::count(UnalignedLVecBase4f const &) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4f_count_497(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLVecBase4f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_UnalignedLVecBase4f)) {
    return nullptr;
  }
  // 1-inline unsigned long int PointerToArray< UnalignedLVecBase4f >::count(UnalignedLVecBase4f const &) const
  UnalignedLVecBase4f arg_local;
  UnalignedLVecBase4f const *arg_this = Dtool_Coerce_UnalignedLVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.count", "UnalignedLVecBase4f");
  }
  unsigned long int return_value = ((*(const PointerToArray< UnalignedLVecBase4f >*)local_this).count)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(PointerToArray self, const UnalignedLVecBase4f param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_count_497_comment =
  "C++ Interface:\n"
  "count(PointerToArray self, const UnalignedLVecBase4f param0)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4f_count_497_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< UnalignedLVecBase4f >::PointerToArray(PointerToArray< UnalignedLVecBase4f > const &copy)
 * PointerToArray< UnalignedLVecBase4f >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< UnalignedLVecBase4f >::PointerToArray(TypeHandle type_handle = (::_get_type_handle((UnalignedLVecBase4f const *)(0))))
 */
static int Dtool_Init_PointerToArray_UnalignedLVecBase4f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< UnalignedLVecBase4f >::PointerToArray(TypeHandle type_handle)
      PointerToArray< UnalignedLVecBase4f > *return_value = new PointerToArray< UnalignedLVecBase4f >();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4f, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< UnalignedLVecBase4f >::PointerToArray(PointerToArray< UnalignedLVecBase4f > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< UnalignedLVecBase4f > const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_PointerToArray_UnalignedLVecBase4f);
          if (param0_this != nullptr) {
            PointerToArray< UnalignedLVecBase4f > *return_value = new PointerToArray< UnalignedLVecBase4f >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4f, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< UnalignedLVecBase4f >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TypeHandle);
          if (param0_this != nullptr) {
            PointerToArray< UnalignedLVecBase4f > *return_value = new PointerToArray< UnalignedLVecBase4f >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4f, true, false);
          }
        }
      }

      {
        // -2 PointerToArray< UnalignedLVecBase4f >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "source")) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, nullptr, &Dtool_PointerToArray_UnalignedLVecBase4f, false, false);
          PointerToArray< UnalignedLVecBase4f > *result = new PointerToArray< UnalignedLVecBase4f >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< UnalignedLVecBase4f > *return_value = result;
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != nullptr) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (UNLIKELY(notify->has_assert_failed())) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4f, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< UnalignedLVecBase4f >::PointerToArray(PointerToArray< UnalignedLVecBase4f > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< UnalignedLVecBase4f > param0_local;
          PointerToArray< UnalignedLVecBase4f > const *param0_this = Dtool_Coerce_PointerToArray_UnalignedLVecBase4f(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< UnalignedLVecBase4f > *return_value = new PointerToArray< UnalignedLVecBase4f >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4f, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< UnalignedLVecBase4f >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< UnalignedLVecBase4f > *return_value = new PointerToArray< UnalignedLVecBase4f >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4f, true, false);
          }
        }
      }

      // No coercion possible: PointerToArray< UnalignedLVecBase4f >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< UnalignedLVecBase4f > *Dtool_Coerce_PointerToArray_UnalignedLVecBase4f(PyObject *args, PointerToArray< UnalignedLVecBase4f > &coerced) {
  PointerToArray< UnalignedLVecBase4f > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_PointerToArray_UnalignedLVecBase4f)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< UnalignedLVecBase4f > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< UnalignedLVecBase4f >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypeHandle);
      if (arg_this != nullptr) {
        coerced = PointerToArray< UnalignedLVecBase4f >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< UnalignedLVecBase4f >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_UnalignedLVecBase4f(&Dtool_PointerToArray_UnalignedLVecBase4f._PyType, nullptr, nullptr);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != nullptr) {
        return nullptr;
      } else {
        return &coerced;
      }
    }

  }
  return nullptr;
}

static void *Dtool_UpcastInterface_PointerToArray_UnalignedLVecBase4f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArray_UnalignedLVecBase4f) {
    printf("PointerToArray_UnalignedLVecBase4f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArray< UnalignedLVecBase4f > *local_this = (PointerToArray< UnalignedLVecBase4f > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArray_UnalignedLVecBase4f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4f) {
    return (PointerToArrayBase< UnalignedLVecBase4f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f) {
    return (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > > *)(PointerToArrayBase< UnalignedLVecBase4f > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > > *)(PointerToArrayBase< UnalignedLVecBase4f > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArray_UnalignedLVecBase4f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArray_UnalignedLVecBase4f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4f) {
    PointerToArrayBase< UnalignedLVecBase4f >* other_this = (PointerToArrayBase< UnalignedLVecBase4f >*)from_this;
    return (PointerToArray< UnalignedLVecBase4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f) {
    PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > >* other_this = (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > >*)from_this;
    return (PointerToArray< UnalignedLVecBase4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< UnalignedLVecBase4f >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArray< UnalignedLVecBase4i >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< UnalignedLVecBase4i > PointerToArray< UnalignedLVecBase4i >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((UnalignedLVecBase4i const *)(0))))
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4i_empty_array_503(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline PointerToArray< UnalignedLVecBase4i > PointerToArray< UnalignedLVecBase4i >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((UnalignedLVecBase4i const *)(0))))
  unsigned long param0;
  PyObject *param1 = nullptr;
  static const char *keyword_list[] = {"n", "type_handle", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "k|O:empty_array", (char **)keyword_list, &param0, &param1)) {
    TypeHandle param1_local;
    TypeHandle *param1_this;
    if (param1 != nullptr) {
      param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    } else {
      param1_local = (::_get_type_handle((UnalignedLVecBase4i const *)(0)));
      param1_this = &param1_local;
    }
    if (param1 != nullptr && !(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
    }
    PointerToArray< UnalignedLVecBase4i > *return_value = new PointerToArray< UnalignedLVecBase4i >((PointerToArray< UnalignedLVecBase4i >::empty_array)((unsigned long int)param0, *param1_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_UnalignedLVecBase4i, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_empty_array_503_comment =
  "C++ Interface:\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_empty_array_503_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLVecBase4i >::clear(void)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4i_clear_504(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLVecBase4i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4i, (void **)&local_this, "PointerToArray_UnalignedLVecBase4i.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< UnalignedLVecBase4i >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_clear_504_comment =
  "C++ Interface:\n"
  "clear(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_clear_504_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLVecBase4i >::push_back(UnalignedLVecBase4i const &x)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4i_push_back_506(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLVecBase4i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4i, (void **)&local_this, "PointerToArray_UnalignedLVecBase4i.push_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< UnalignedLVecBase4i >::push_back(UnalignedLVecBase4i const &x)
  UnalignedLVecBase4i arg_local;
  UnalignedLVecBase4i const *arg_this = Dtool_Coerce_UnalignedLVecBase4i(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.push_back", "UnalignedLVecBase4i");
  }
  ((*local_this).push_back)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, const UnalignedLVecBase4i x)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_push_back_506_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, const UnalignedLVecBase4i x)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_push_back_506_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLVecBase4i >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4i_pop_back_507(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLVecBase4i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4i, (void **)&local_this, "PointerToArray_UnalignedLVecBase4i.pop_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< UnalignedLVecBase4i >::pop_back(void)
  ((*local_this).pop_back)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_pop_back_507_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_pop_back_507_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UnalignedLVecBase4i const &PointerToArray< UnalignedLVecBase4i >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4i_get_element_508(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLVecBase4i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_UnalignedLVecBase4i)) {
    return nullptr;
  }
  // 1-inline UnalignedLVecBase4i const &PointerToArray< UnalignedLVecBase4i >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    UnalignedLVecBase4i const *return_value = &(((*(const PointerToArray< UnalignedLVecBase4i >*)local_this).get_element)((unsigned long int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLVecBase4i, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_get_element_508_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_get_element_508_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLVecBase4i >::set_element(unsigned long int n, UnalignedLVecBase4i const &value)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4i_set_element_509(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< UnalignedLVecBase4i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4i, (void **)&local_this, "PointerToArray_UnalignedLVecBase4i.set_element")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< UnalignedLVecBase4i >::set_element(unsigned long int n, UnalignedLVecBase4i const &value)
  unsigned long param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:set_element", (char **)keyword_list, &param1, &param2)) {
    UnalignedLVecBase4i param2_local;
    UnalignedLVecBase4i const *param2_this = Dtool_Coerce_UnalignedLVecBase4i(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PointerToArray.set_element", "UnalignedLVecBase4i");
    }
    ((*local_this).set_element)((unsigned long int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, const UnalignedLVecBase4i value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_set_element_509_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, const UnalignedLVecBase4i value)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_set_element_509_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< UnalignedLVecBase4i >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4i_get_data_512(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLVecBase4i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_UnalignedLVecBase4i)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< UnalignedLVecBase4i >::get_data(void) const
  PyObject *return_value = invoke_extension((const PointerToArray< UnalignedLVecBase4i >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_get_data_512_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_get_data_512_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToArray< UnalignedLVecBase4i >::set_data(PyObject *data)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4i_set_data_513(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLVecBase4i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4i, (void **)&local_this, "PointerToArray_UnalignedLVecBase4i.set_data")) {
    return nullptr;
  }
  // 1-void PointerToArray< UnalignedLVecBase4i >::set_data(PyObject *data)
  invoke_extension(local_this).set_data(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, object data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_set_data_513_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, object data)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_set_data_513_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< UnalignedLVecBase4i >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4i_get_subdata_514(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< UnalignedLVecBase4i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_UnalignedLVecBase4i)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< UnalignedLVecBase4i >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const PointerToArray< UnalignedLVecBase4i >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_get_subdata_514_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_get_subdata_514_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< UnalignedLVecBase4i >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4i_set_subdata_515(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< UnalignedLVecBase4i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_UnalignedLVecBase4i, (void **)&local_this, "PointerToArray_UnalignedLVecBase4i.set_subdata")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< UnalignedLVecBase4i >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  const char *param3_str = nullptr;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    ((*local_this).set_subdata)((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_set_subdata_515_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_set_subdata_515_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< UnalignedLVecBase4i >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4i_get_ref_count_516(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLVecBase4i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_UnalignedLVecBase4i)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< UnalignedLVecBase4i >::get_ref_count(void) const
  int return_value = ((*(const PointerToArray< UnalignedLVecBase4i >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_get_ref_count_516_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_get_ref_count_516_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< UnalignedLVecBase4i >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4i_get_node_ref_count_517(PyObject *self, PyObject *) {
  PointerToArray< UnalignedLVecBase4i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_UnalignedLVecBase4i)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< UnalignedLVecBase4i >::get_node_ref_count(void) const
  int return_value = ((*(const PointerToArray< UnalignedLVecBase4i >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_get_node_ref_count_517_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_get_node_ref_count_517_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int PointerToArray< UnalignedLVecBase4i >::count(UnalignedLVecBase4i const &) const
 */
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4i_count_518(PyObject *self, PyObject *arg) {
  PointerToArray< UnalignedLVecBase4i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_UnalignedLVecBase4i)) {
    return nullptr;
  }
  // 1-inline unsigned long int PointerToArray< UnalignedLVecBase4i >::count(UnalignedLVecBase4i const &) const
  UnalignedLVecBase4i arg_local;
  UnalignedLVecBase4i const *arg_this = Dtool_Coerce_UnalignedLVecBase4i(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PointerToArray.count", "UnalignedLVecBase4i");
  }
  unsigned long int return_value = ((*(const PointerToArray< UnalignedLVecBase4i >*)local_this).count)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(PointerToArray self, const UnalignedLVecBase4i param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_count_518_comment =
  "C++ Interface:\n"
  "count(PointerToArray self, const UnalignedLVecBase4i param0)\n";
#else
static const char *Dtool_PointerToArray_UnalignedLVecBase4i_count_518_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< UnalignedLVecBase4i >::PointerToArray(PointerToArray< UnalignedLVecBase4i > const &copy)
 * PointerToArray< UnalignedLVecBase4i >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< UnalignedLVecBase4i >::PointerToArray(TypeHandle type_handle = (::_get_type_handle((UnalignedLVecBase4i const *)(0))))
 */
static int Dtool_Init_PointerToArray_UnalignedLVecBase4i(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< UnalignedLVecBase4i >::PointerToArray(TypeHandle type_handle)
      PointerToArray< UnalignedLVecBase4i > *return_value = new PointerToArray< UnalignedLVecBase4i >();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4i, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< UnalignedLVecBase4i >::PointerToArray(PointerToArray< UnalignedLVecBase4i > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< UnalignedLVecBase4i > const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_PointerToArray_UnalignedLVecBase4i);
          if (param0_this != nullptr) {
            PointerToArray< UnalignedLVecBase4i > *return_value = new PointerToArray< UnalignedLVecBase4i >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4i, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< UnalignedLVecBase4i >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TypeHandle);
          if (param0_this != nullptr) {
            PointerToArray< UnalignedLVecBase4i > *return_value = new PointerToArray< UnalignedLVecBase4i >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4i, true, false);
          }
        }
      }

      {
        // -2 PointerToArray< UnalignedLVecBase4i >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "source")) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, nullptr, &Dtool_PointerToArray_UnalignedLVecBase4i, false, false);
          PointerToArray< UnalignedLVecBase4i > *result = new PointerToArray< UnalignedLVecBase4i >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< UnalignedLVecBase4i > *return_value = result;
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != nullptr) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (UNLIKELY(notify->has_assert_failed())) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4i, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< UnalignedLVecBase4i >::PointerToArray(PointerToArray< UnalignedLVecBase4i > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< UnalignedLVecBase4i > param0_local;
          PointerToArray< UnalignedLVecBase4i > const *param0_this = Dtool_Coerce_PointerToArray_UnalignedLVecBase4i(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< UnalignedLVecBase4i > *return_value = new PointerToArray< UnalignedLVecBase4i >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4i, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< UnalignedLVecBase4i >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< UnalignedLVecBase4i > *return_value = new PointerToArray< UnalignedLVecBase4i >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_UnalignedLVecBase4i, true, false);
          }
        }
      }

      // No coercion possible: PointerToArray< UnalignedLVecBase4i >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< UnalignedLVecBase4i > *Dtool_Coerce_PointerToArray_UnalignedLVecBase4i(PyObject *args, PointerToArray< UnalignedLVecBase4i > &coerced) {
  PointerToArray< UnalignedLVecBase4i > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_PointerToArray_UnalignedLVecBase4i)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< UnalignedLVecBase4i > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< UnalignedLVecBase4i >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypeHandle);
      if (arg_this != nullptr) {
        coerced = PointerToArray< UnalignedLVecBase4i >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< UnalignedLVecBase4i >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_UnalignedLVecBase4i(&Dtool_PointerToArray_UnalignedLVecBase4i._PyType, nullptr, nullptr);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != nullptr) {
        return nullptr;
      } else {
        return &coerced;
      }
    }

  }
  return nullptr;
}

static void *Dtool_UpcastInterface_PointerToArray_UnalignedLVecBase4i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArray_UnalignedLVecBase4i) {
    printf("PointerToArray_UnalignedLVecBase4i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArray< UnalignedLVecBase4i > *local_this = (PointerToArray< UnalignedLVecBase4i > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArray_UnalignedLVecBase4i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4i) {
    return (PointerToArrayBase< UnalignedLVecBase4i > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i) {
    return (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > > *)(PointerToArrayBase< UnalignedLVecBase4i > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > > *)(PointerToArrayBase< UnalignedLVecBase4i > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArray_UnalignedLVecBase4i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArray_UnalignedLVecBase4i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4i) {
    PointerToArrayBase< UnalignedLVecBase4i >* other_this = (PointerToArrayBase< UnalignedLVecBase4i >*)from_this;
    return (PointerToArray< UnalignedLVecBase4i >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i) {
    PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > >* other_this = (PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > >*)from_this;
    return (PointerToArray< UnalignedLVecBase4i >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< UnalignedLVecBase4i >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BoundingVolume
 */
/**
 * Python function wrapper for:
 * virtual BoundingVolume *BoundingVolume::make_copy(void) const = 0
 */
static PyObject *Dtool_BoundingVolume_make_copy_524(PyObject *self, PyObject *) {
  BoundingVolume *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BoundingVolume)) {
    return nullptr;
  }
  // 1-virtual BoundingVolume *BoundingVolume::make_copy(void) const = 0
  BoundingVolume *return_value = ((*(const BoundingVolume*)local_this).make_copy)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_BoundingVolume, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BoundingVolume_make_copy_524_comment =
  "C++ Interface:\n"
  "make_copy(BoundingVolume self)\n";
#else
static const char *Dtool_BoundingVolume_make_copy_524_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BoundingVolume::is_empty(void) const
 */
static PyObject *Dtool_BoundingVolume_is_empty_525(PyObject *self, PyObject *) {
  BoundingVolume *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BoundingVolume)) {
    return nullptr;
  }
  // 1-inline bool BoundingVolume::is_empty(void) const
  bool return_value = ((*(const BoundingVolume*)local_this).is_empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BoundingVolume_is_empty_525_comment =
  "C++ Interface:\n"
  "is_empty(BoundingVolume self)\n"
  "\n"
  "/**\n"
  " * Any kind of volume might be empty.  This is a degenerate volume that\n"
  " * contains no points; it's not the same as, for instance, a sphere with\n"
  " * radius zero, since that contains one point (the center).  It intersects\n"
  " * with no other volumes.\n"
  " */";
#else
static const char *Dtool_BoundingVolume_is_empty_525_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BoundingVolume::is_infinite(void) const
 */
static PyObject *Dtool_BoundingVolume_is_infinite_526(PyObject *self, PyObject *) {
  BoundingVolume *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BoundingVolume)) {
    return nullptr;
  }
  // 1-inline bool BoundingVolume::is_infinite(void) const
  bool return_value = ((*(const BoundingVolume*)local_this).is_infinite)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BoundingVolume_is_infinite_526_comment =
  "C++ Interface:\n"
  "is_infinite(BoundingVolume self)\n"
  "\n"
  "/**\n"
  " * The other side of the empty coin is an infinite volume.  This is a\n"
  " * degenerate state of a normally finite volume that contains all points.\n"
  " * (Note that some kinds of infinite bounding volumes, like binary separating\n"
  " * planes, do not contain all points and thus correctly return is_infinite()\n"
  " * == false, even though they are technically infinite.  This is a special\n"
  " * case of the word 'infinite' meaning the volume covers all points in space.)\n"
  " *\n"
  " * It completely intersects with all other volumes except empty volumes.\n"
  " */";
#else
static const char *Dtool_BoundingVolume_is_infinite_526_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BoundingVolume::set_infinite(void)
 */
static PyObject *Dtool_BoundingVolume_set_infinite_527(PyObject *self, PyObject *) {
  BoundingVolume *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BoundingVolume, (void **)&local_this, "BoundingVolume.set_infinite")) {
    return nullptr;
  }
  // 1-inline void BoundingVolume::set_infinite(void)
  ((*local_this).set_infinite)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BoundingVolume_set_infinite_527_comment =
  "C++ Interface:\n"
  "set_infinite(const BoundingVolume self)\n"
  "\n"
  "/**\n"
  " * Marks the volume as infinite, even if it is normally finite.  You can think\n"
  " * of this as an infinite extend_by() operation.\n"
  " */";
#else
static const char *Dtool_BoundingVolume_set_infinite_527_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BoundingVolume::extend_by(BoundingVolume const *vol)
 */
static PyObject *Dtool_BoundingVolume_extend_by_528(PyObject *self, PyObject *arg) {
  BoundingVolume *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BoundingVolume, (void **)&local_this, "BoundingVolume.extend_by")) {
    return nullptr;
  }
  // 1-inline bool BoundingVolume::extend_by(BoundingVolume const *vol)
  BoundingVolume const *arg_this = (BoundingVolume *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BoundingVolume, 1, "BoundingVolume.extend_by", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).extend_by)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extend_by(const BoundingVolume self, const BoundingVolume vol)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BoundingVolume_extend_by_528_comment =
  "C++ Interface:\n"
  "extend_by(const BoundingVolume self, const BoundingVolume vol)\n"
  "\n"
  "/**\n"
  " * Increases the size of the volume to include the given volume.\n"
  " */";
#else
static const char *Dtool_BoundingVolume_extend_by_528_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BoundingVolume::contains(BoundingVolume const *vol) const
 */
static PyObject *Dtool_BoundingVolume_contains_530(PyObject *self, PyObject *arg) {
  BoundingVolume *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BoundingVolume)) {
    return nullptr;
  }
  // 1-inline int BoundingVolume::contains(BoundingVolume const *vol) const
  BoundingVolume const *arg_this = (BoundingVolume *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BoundingVolume, 1, "BoundingVolume.contains", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const BoundingVolume*)local_this).contains)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "contains(BoundingVolume self, const BoundingVolume vol)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BoundingVolume_contains_530_comment =
  "C++ Interface:\n"
  "contains(BoundingVolume self, const BoundingVolume vol)\n"
  "\n"
  "/**\n"
  " * Returns the appropriate set of IntersectionFlags to indicate the amount of\n"
  " * intersection with the indicated volume.\n"
  " */";
#else
static const char *Dtool_BoundingVolume_contains_530_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void BoundingVolume::output(std::ostream &out) const = 0
 */
static PyObject *Dtool_BoundingVolume_output_531(PyObject *self, PyObject *arg) {
  BoundingVolume *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BoundingVolume)) {
    return nullptr;
  }
  // 1-virtual void BoundingVolume::output(std::ostream &out) const = 0
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "BoundingVolume.output", false, true);
  if (arg_this != nullptr) {
    ((*(const BoundingVolume*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(BoundingVolume self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BoundingVolume_output_531_comment =
  "C++ Interface:\n"
  "output(BoundingVolume self, ostream out)\n";
#else
static const char *Dtool_BoundingVolume_output_531_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void BoundingVolume::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_BoundingVolume_write_532(PyObject *self, PyObject *args, PyObject *kwds) {
  BoundingVolume *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BoundingVolume)) {
    return nullptr;
  }
  // 1-virtual void BoundingVolume::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "BoundingVolume.write", false, true);
    if (param1_this != nullptr) {
      ((*(const BoundingVolume*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(BoundingVolume self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BoundingVolume_write_532_comment =
  "C++ Interface:\n"
  "write(BoundingVolume self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_BoundingVolume_write_532_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BoundingVolume::get_class_type(void)
 */
static PyObject *Dtool_BoundingVolume_get_class_type_534(PyObject *, PyObject *) {
  // 1-static TypeHandle BoundingVolume::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((BoundingVolume::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BoundingVolume_get_class_type_534_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BoundingVolume_get_class_type_534_comment = nullptr;
#endif

static int Dtool_Init_BoundingVolume(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_BoundingVolume(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BoundingVolume) {
    printf("BoundingVolume ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BoundingVolume *local_this = (BoundingVolume *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BoundingVolume) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BoundingVolume(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BoundingVolume) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (BoundingVolume*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GeometricBoundingVolume
 */
/**
 * Python function wrapper for:
 * inline bool GeometricBoundingVolume::extend_by(GeometricBoundingVolume const *vol)
 * inline bool GeometricBoundingVolume::extend_by(LPoint3 const &point)
 */
static PyObject *Dtool_GeometricBoundingVolume_extend_by_537(PyObject *self, PyObject *arg) {
  GeometricBoundingVolume *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeometricBoundingVolume, (void **)&local_this, "GeometricBoundingVolume.extend_by")) {
    return nullptr;
  }
  {
    // -2 inline bool GeometricBoundingVolume::extend_by(GeometricBoundingVolume const *vol)
    GeometricBoundingVolume const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_GeometricBoundingVolume);
    if (arg_this != nullptr) {
      bool return_value = ((*local_this).extend_by)(arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  // No coercion possible: inline bool GeometricBoundingVolume::extend_by(GeometricBoundingVolume const *vol)
  {
    // -2 inline bool GeometricBoundingVolume::extend_by(LPoint3 const &point)
    LPoint3f arg_local;
    LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
    if ((arg_this != nullptr)) {
      bool return_value = ((*local_this).extend_by)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extend_by(const GeometricBoundingVolume self, const GeometricBoundingVolume vol)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeometricBoundingVolume_extend_by_537_comment =
  "C++ Interface:\n"
  "extend_by(const GeometricBoundingVolume self, const GeometricBoundingVolume vol)\n"
  "\n"
  "/**\n"
  " * Increases the size of the volume to include the given volume.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Increases the size of the volume to include the given point.\n"
  " */";
#else
static const char *Dtool_GeometricBoundingVolume_extend_by_537_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GeometricBoundingVolume::contains(GeometricBoundingVolume const *vol) const
 * inline int GeometricBoundingVolume::contains(LPoint3 const &point) const
 * inline int GeometricBoundingVolume::contains(LPoint3 const &a, LPoint3 const &b) const
 */
static PyObject *Dtool_GeometricBoundingVolume_contains_538(PyObject *self, PyObject *args, PyObject *kwds) {
  GeometricBoundingVolume *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeometricBoundingVolume)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline int GeometricBoundingVolume::contains(GeometricBoundingVolume const *vol) const
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "vol")) {
          GeometricBoundingVolume const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_GeometricBoundingVolume);
          if (param1_this != nullptr) {
            int return_value = ((*(const GeometricBoundingVolume*)local_this).contains)(param1_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }
      }

      // No coercion possible: inline int GeometricBoundingVolume::contains(GeometricBoundingVolume const *vol) const
      {
        // -2 inline int GeometricBoundingVolume::contains(LPoint3 const &point) const
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "point")) {
          LPoint3f param1_local;
          LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
          if ((param1_this != nullptr)) {
            int return_value = ((*(const GeometricBoundingVolume*)local_this).contains)(*param1_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }
      }

    }
    break;
  case 2:
    {
      // 1-inline int GeometricBoundingVolume::contains(LPoint3 const &a, LPoint3 const &b) const
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"a", "b", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:contains", (char **)keyword_list, &param1, &param2)) {
        LPoint3f param1_local;
        LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "GeometricBoundingVolume.contains", "LPoint3f");
        }
        LPoint3f param2_local;
        LPoint3 const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "GeometricBoundingVolume.contains", "LPoint3f");
        }
        int return_value = ((*(const GeometricBoundingVolume*)local_this).contains)(*param1_this, *param2_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "contains() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "contains(GeometricBoundingVolume self, const GeometricBoundingVolume vol)\n"
      "contains(GeometricBoundingVolume self, const LPoint3f a, const LPoint3f b)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeometricBoundingVolume_contains_538_comment =
  "C++ Interface:\n"
  "contains(GeometricBoundingVolume self, const GeometricBoundingVolume vol)\n"
  "contains(GeometricBoundingVolume self, const LPoint3f a, const LPoint3f b)\n"
  "\n"
  "/**\n"
  " * Returns the appropriate set of IntersectionFlags to indicate the amount of\n"
  " * intersection with the indicated volume.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the appropriate set of IntersectionFlags to indicate the amount of\n"
  " * intersection with the indicated point.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the appropriate set of IntersectionFlags to indicate the amount of\n"
  " * intersection with the indicated line segment.\n"
  " */";
#else
static const char *Dtool_GeometricBoundingVolume_contains_538_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual LPoint3 GeometricBoundingVolume::get_approx_center(void) const = 0
 */
static PyObject *Dtool_GeometricBoundingVolume_get_approx_center_539(PyObject *self, PyObject *) {
  GeometricBoundingVolume *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GeometricBoundingVolume)) {
    return nullptr;
  }
  // 1-virtual LPoint3 GeometricBoundingVolume::get_approx_center(void) const = 0
  LPoint3 *return_value = new LPoint3(((*(const GeometricBoundingVolume*)local_this).get_approx_center)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeometricBoundingVolume_get_approx_center_539_comment =
  "C++ Interface:\n"
  "get_approx_center(GeometricBoundingVolume self)\n";
#else
static const char *Dtool_GeometricBoundingVolume_get_approx_center_539_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void GeometricBoundingVolume::xform(LMatrix4 const &mat) = 0
 */
static PyObject *Dtool_GeometricBoundingVolume_xform_540(PyObject *self, PyObject *arg) {
  GeometricBoundingVolume *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GeometricBoundingVolume, (void **)&local_this, "GeometricBoundingVolume.xform")) {
    return nullptr;
  }
  // 1-virtual void GeometricBoundingVolume::xform(LMatrix4 const &mat) = 0
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GeometricBoundingVolume.xform", "LMatrix4f");
  }
  ((*local_this).xform)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform(const GeometricBoundingVolume self, const LMatrix4f mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GeometricBoundingVolume_xform_540_comment =
  "C++ Interface:\n"
  "xform(const GeometricBoundingVolume self, const LMatrix4f mat)\n";
#else
static const char *Dtool_GeometricBoundingVolume_xform_540_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle GeometricBoundingVolume::get_class_type(void)
 */
static PyObject *Dtool_GeometricBoundingVolume_get_class_type_541(PyObject *, PyObject *) {
  // 1-static TypeHandle GeometricBoundingVolume::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GeometricBoundingVolume::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GeometricBoundingVolume_get_class_type_541_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GeometricBoundingVolume_get_class_type_541_comment = nullptr;
#endif

static int Dtool_Init_GeometricBoundingVolume(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_GeometricBoundingVolume(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GeometricBoundingVolume) {
    printf("GeometricBoundingVolume ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GeometricBoundingVolume *local_this = (GeometricBoundingVolume *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GeometricBoundingVolume) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BoundingVolume) {
    return (BoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BoundingVolume *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GeometricBoundingVolume(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GeometricBoundingVolume) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BoundingVolume) {
    BoundingVolume* other_this = (BoundingVolume*)from_this;
    return (GeometricBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GeometricBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GeometricBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (GeometricBoundingVolume*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class FiniteBoundingVolume
 */
/**
 * Python function wrapper for:
 * virtual LPoint3 FiniteBoundingVolume::get_min(void) const = 0
 */
static PyObject *Dtool_FiniteBoundingVolume_get_min_544(PyObject *self, PyObject *) {
  FiniteBoundingVolume *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FiniteBoundingVolume)) {
    return nullptr;
  }
  // 1-virtual LPoint3 FiniteBoundingVolume::get_min(void) const = 0
  LPoint3 *return_value = new LPoint3(((*(const FiniteBoundingVolume*)local_this).get_min)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_FiniteBoundingVolume_get_min_544_comment =
  "C++ Interface:\n"
  "get_min(FiniteBoundingVolume self)\n";
#else
static const char *Dtool_FiniteBoundingVolume_get_min_544_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual LPoint3 FiniteBoundingVolume::get_max(void) const = 0
 */
static PyObject *Dtool_FiniteBoundingVolume_get_max_545(PyObject *self, PyObject *) {
  FiniteBoundingVolume *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FiniteBoundingVolume)) {
    return nullptr;
  }
  // 1-virtual LPoint3 FiniteBoundingVolume::get_max(void) const = 0
  LPoint3 *return_value = new LPoint3(((*(const FiniteBoundingVolume*)local_this).get_max)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_FiniteBoundingVolume_get_max_545_comment =
  "C++ Interface:\n"
  "get_max(FiniteBoundingVolume self)\n";
#else
static const char *Dtool_FiniteBoundingVolume_get_max_545_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat FiniteBoundingVolume::get_volume(void) const
 */
static PyObject *Dtool_FiniteBoundingVolume_get_volume_546(PyObject *self, PyObject *) {
  FiniteBoundingVolume *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FiniteBoundingVolume)) {
    return nullptr;
  }
  // 1-virtual PN_stdfloat FiniteBoundingVolume::get_volume(void) const
  PN_stdfloat return_value = ((*(const FiniteBoundingVolume*)local_this).get_volume)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FiniteBoundingVolume_get_volume_546_comment =
  "C++ Interface:\n"
  "get_volume(FiniteBoundingVolume self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FiniteBoundingVolume_get_volume_546_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle FiniteBoundingVolume::get_class_type(void)
 */
static PyObject *Dtool_FiniteBoundingVolume_get_class_type_554(PyObject *, PyObject *) {
  // 1-static TypeHandle FiniteBoundingVolume::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((FiniteBoundingVolume::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_FiniteBoundingVolume_get_class_type_554_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_FiniteBoundingVolume_get_class_type_554_comment = nullptr;
#endif

static PyObject *Dtool_FiniteBoundingVolume_min_Getter(PyObject *self, void *) {
  const FiniteBoundingVolume *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FiniteBoundingVolume, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual LPoint3 FiniteBoundingVolume::get_min(void) const = 0
  LPoint3 *return_value = new LPoint3(((*(const FiniteBoundingVolume*)local_this).get_min)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

static PyObject *Dtool_FiniteBoundingVolume_max_Getter(PyObject *self, void *) {
  const FiniteBoundingVolume *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FiniteBoundingVolume, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual LPoint3 FiniteBoundingVolume::get_max(void) const = 0
  LPoint3 *return_value = new LPoint3(((*(const FiniteBoundingVolume*)local_this).get_max)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

static PyObject *Dtool_FiniteBoundingVolume_volume_Getter(PyObject *self, void *) {
  const FiniteBoundingVolume *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FiniteBoundingVolume, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual PN_stdfloat FiniteBoundingVolume::get_volume(void) const
  PN_stdfloat return_value = ((*(const FiniteBoundingVolume*)local_this).get_volume)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_FiniteBoundingVolume(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_FiniteBoundingVolume(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_FiniteBoundingVolume) {
    printf("FiniteBoundingVolume ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  FiniteBoundingVolume *local_this = (FiniteBoundingVolume *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_FiniteBoundingVolume) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BoundingVolume) {
    return (BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeometricBoundingVolume) {
    return (GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_FiniteBoundingVolume(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_FiniteBoundingVolume) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BoundingVolume) {
    BoundingVolume* other_this = (BoundingVolume*)from_this;
    return (FiniteBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_GeometricBoundingVolume) {
    GeometricBoundingVolume* other_this = (GeometricBoundingVolume*)from_this;
    return (FiniteBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (FiniteBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (FiniteBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (FiniteBoundingVolume*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LParabolaf
 */
/**
 * Python function wrapper for:
 * inline void LParabolaf::operator =(LParabolaf const &copy)
 */
static PyObject *Dtool_LParabolaf_operator_558(PyObject *self, PyObject *arg) {
  LParabolaf *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LParabolaf, (void **)&local_this, "LParabolaf.assign")) {
    return nullptr;
  }
  // 1-inline void LParabolaf::operator =(LParabolaf const &copy)
  LParabolaf arg_local;
  LParabolaf const *arg_this = Dtool_Coerce_LParabolaf(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LParabolaf.assign", "LParabolaf");
  }
  ((*local_this).operator =)(*arg_this);
  LParabolaf *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LParabolaf, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const LParabolaf self, const LParabolaf copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LParabolaf_operator_558_comment =
  "C++ Interface:\n"
  "assign(const LParabolaf self, const LParabolaf copy)\n";
#else
static const char *Dtool_LParabolaf_operator_558_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LParabolaf::xform(LMatrix4f const &mat)
 */
static PyObject *Dtool_LParabolaf_xform_560(PyObject *self, PyObject *arg) {
  LParabolaf *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LParabolaf, (void **)&local_this, "LParabolaf.xform")) {
    return nullptr;
  }
  // 1-void LParabolaf::xform(LMatrix4f const &mat)
  LMatrix4f arg_local;
  LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LParabolaf.xform", "LMatrix4f");
  }
  ((*local_this).xform)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform(const LParabolaf self, const LMatrix4f mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LParabolaf_xform_560_comment =
  "C++ Interface:\n"
  "xform(const LParabolaf self, const LMatrix4f mat)\n"
  "\n"
  "/**\n"
  " * Transforms the parabola by the indicated matrix.\n"
  " */";
#else
static const char *Dtool_LParabolaf_xform_560_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f const &LParabolaf::get_a(void) const
 */
static PyObject *Dtool_LParabolaf_get_a_561(PyObject *self, PyObject *) {
  LParabolaf *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LParabolaf)) {
    return nullptr;
  }
  // 1-inline LVecBase3f const &LParabolaf::get_a(void) const
  LVecBase3f const *return_value = &(((*(const LParabolaf*)local_this).get_a)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LParabolaf_get_a_561_comment =
  "C++ Interface:\n"
  "get_a(LParabolaf self)\n"
  "\n"
  "/**\n"
  " * Returns the first point of the parabola's parametric equation: the\n"
  " * acceleration.\n"
  " */";
#else
static const char *Dtool_LParabolaf_get_a_561_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f const &LParabolaf::get_b(void) const
 */
static PyObject *Dtool_LParabolaf_get_b_562(PyObject *self, PyObject *) {
  LParabolaf *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LParabolaf)) {
    return nullptr;
  }
  // 1-inline LVecBase3f const &LParabolaf::get_b(void) const
  LVecBase3f const *return_value = &(((*(const LParabolaf*)local_this).get_b)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LParabolaf_get_b_562_comment =
  "C++ Interface:\n"
  "get_b(LParabolaf self)\n"
  "\n"
  "/**\n"
  " * Returns the second point of the parabola's parametric equation: the initial\n"
  " * velocity.\n"
  " */";
#else
static const char *Dtool_LParabolaf_get_b_562_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f const &LParabolaf::get_c(void) const
 */
static PyObject *Dtool_LParabolaf_get_c_563(PyObject *self, PyObject *) {
  LParabolaf *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LParabolaf)) {
    return nullptr;
  }
  // 1-inline LVecBase3f const &LParabolaf::get_c(void) const
  LVecBase3f const *return_value = &(((*(const LParabolaf*)local_this).get_c)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LParabolaf_get_c_563_comment =
  "C++ Interface:\n"
  "get_c(LParabolaf self)\n"
  "\n"
  "/**\n"
  " * Returns the third point of the parabola's parametric equation: the start\n"
  " * point.\n"
  " */";
#else
static const char *Dtool_LParabolaf_get_c_563_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f LParabolaf::calc_point(float t) const
 */
static PyObject *Dtool_LParabolaf_calc_point_564(PyObject *self, PyObject *arg) {
  LParabolaf *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LParabolaf)) {
    return nullptr;
  }
  // 1-inline LPoint3f LParabolaf::calc_point(float t) const
  if (PyNumber_Check(arg)) {
    LPoint3f *return_value = new LPoint3f(((*(const LParabolaf*)local_this).calc_point)((float)PyFloat_AsDouble(arg)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_point(LParabolaf self, float t)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LParabolaf_calc_point_564_comment =
  "C++ Interface:\n"
  "calc_point(LParabolaf self, float t)\n"
  "\n"
  "/**\n"
  " * Computes the point on the parabola at time t.\n"
  " */";
#else
static const char *Dtool_LParabolaf_calc_point_564_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LParabolaf::output(std::ostream &out) const
 */
static PyObject *Dtool_LParabolaf_output_565(PyObject *self, PyObject *arg) {
  LParabolaf *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LParabolaf)) {
    return nullptr;
  }
  // 1-void LParabolaf::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "LParabolaf.output", false, true);
  if (arg_this != nullptr) {
    ((*(const LParabolaf*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LParabolaf self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LParabolaf_output_565_comment =
  "C++ Interface:\n"
  "output(LParabolaf self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LParabolaf_output_565_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LParabolaf::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_LParabolaf_write_566(PyObject *self, PyObject *args, PyObject *kwds) {
  LParabolaf *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LParabolaf)) {
    return nullptr;
  }
  // 1-void LParabolaf::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "LParabolaf.write", false, true);
    if (param1_this != nullptr) {
      ((*(const LParabolaf*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(LParabolaf self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LParabolaf_write_566_comment =
  "C++ Interface:\n"
  "write(LParabolaf self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LParabolaf_write_566_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LParabolaf::write_datagram_fixed(Datagram &destination) const
 */
static PyObject *Dtool_LParabolaf_write_datagram_fixed_567(PyObject *self, PyObject *arg) {
  LParabolaf *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LParabolaf)) {
    return nullptr;
  }
  // 1-void LParabolaf::write_datagram_fixed(Datagram &destination) const
  Datagram arg_local;
  Datagram *arg_this = Dtool_Coerce_Datagram(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LParabolaf.write_datagram_fixed", "Datagram");
  }
  ((*(const LParabolaf*)local_this).write_datagram_fixed)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram_fixed(LParabolaf self, Datagram destination)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LParabolaf_write_datagram_fixed_567_comment =
  "C++ Interface:\n"
  "write_datagram_fixed(LParabolaf self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the parabola to the Datagram using add_float32() or add_float64(),\n"
  " * depending on the type of floats in the parabola, regardless of the setting\n"
  " * of Datagram::set_stdfloat_double().  This is appropriate when you want to\n"
  " * write a fixed-width value to the datagram, especially when you are not\n"
  " * writing a bam file.\n"
  " */";
#else
static const char *Dtool_LParabolaf_write_datagram_fixed_567_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LParabolaf::read_datagram_fixed(DatagramIterator &source)
 */
static PyObject *Dtool_LParabolaf_read_datagram_fixed_568(PyObject *self, PyObject *arg) {
  LParabolaf *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LParabolaf, (void **)&local_this, "LParabolaf.read_datagram_fixed")) {
    return nullptr;
  }
  // 1-void LParabolaf::read_datagram_fixed(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LParabolaf.read_datagram_fixed", "DatagramIterator");
  }
  ((*local_this).read_datagram_fixed)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram_fixed(const LParabolaf self, DatagramIterator source)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LParabolaf_read_datagram_fixed_568_comment =
  "C++ Interface:\n"
  "read_datagram_fixed(const LParabolaf self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " * Reads the parabola from the Datagram using get_float32() or get_float64().\n"
  " * See write_datagram_fixed().\n"
  " */";
#else
static const char *Dtool_LParabolaf_read_datagram_fixed_568_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LParabolaf::write_datagram(Datagram &destination) const
 */
static PyObject *Dtool_LParabolaf_write_datagram_569(PyObject *self, PyObject *arg) {
  LParabolaf *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LParabolaf)) {
    return nullptr;
  }
  // 1-void LParabolaf::write_datagram(Datagram &destination) const
  Datagram arg_local;
  Datagram *arg_this = Dtool_Coerce_Datagram(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LParabolaf.write_datagram", "Datagram");
  }
  ((*(const LParabolaf*)local_this).write_datagram)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram(LParabolaf self, Datagram destination)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LParabolaf_write_datagram_569_comment =
  "C++ Interface:\n"
  "write_datagram(LParabolaf self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the parabola to the Datagram using add_stdfloat().  This is\n"
  " * appropriate when you want to write the vector using the standard width\n"
  " * setting, especially when you are writing a bam file.\n"
  " */";
#else
static const char *Dtool_LParabolaf_write_datagram_569_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LParabolaf::read_datagram(DatagramIterator &source)
 */
static PyObject *Dtool_LParabolaf_read_datagram_570(PyObject *self, PyObject *arg) {
  LParabolaf *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LParabolaf, (void **)&local_this, "LParabolaf.read_datagram")) {
    return nullptr;
  }
  // 1-void LParabolaf::read_datagram(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LParabolaf.read_datagram", "DatagramIterator");
  }
  ((*local_this).read_datagram)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram(const LParabolaf self, DatagramIterator source)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LParabolaf_read_datagram_570_comment =
  "C++ Interface:\n"
  "read_datagram(const LParabolaf self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " * Reads the parabola from the Datagram using get_stdfloat().\n"
  " */";
#else
static const char *Dtool_LParabolaf_read_datagram_570_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LParabolaf::LParabolaf(void)
 * inline LParabolaf::LParabolaf(LParabolaf const &copy)
 * inline LParabolaf::LParabolaf(LVecBase3f const &a, LVecBase3f const &b, LVecBase3f const &c)
 */
static int Dtool_Init_LParabolaf(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LParabolaf::LParabolaf(void)
      LParabolaf *return_value = new LParabolaf();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LParabolaf, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-inline LParabolaf::LParabolaf(LParabolaf const &copy)
        LParabolaf arg_local;
        LParabolaf const *arg_this = Dtool_Coerce_LParabolaf(arg, arg_local);
        if (!(arg_this != nullptr)) {
          Dtool_Raise_ArgTypeError(arg, 0, "LParabolaf.LParabolaf", "LParabolaf");
          return -1;
        }
        LParabolaf *return_value = new LParabolaf(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LParabolaf, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-inline LParabolaf::LParabolaf(LVecBase3f const &a, LVecBase3f const &b, LVecBase3f const &c)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"a", "b", "c", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:LParabolaf", (char **)keyword_list, &param0, &param1, &param2)) {
        LVecBase3f param0_local;
        LVecBase3f const *param0_this = Dtool_Coerce_LVecBase3f(param0, param0_local);
        if (!(param0_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LParabolaf.LParabolaf", "LVecBase3f");
          return -1;
        }
        LVecBase3f param1_local;
        LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param1, 1, "LParabolaf.LParabolaf", "LVecBase3f");
          return -1;
        }
        LVecBase3f param2_local;
        LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param2, 2, "LParabolaf.LParabolaf", "LVecBase3f");
          return -1;
        }
        LParabolaf *return_value = new LParabolaf(*param0_this, *param1_this, *param2_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LParabolaf, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LParabolaf() takes 0, 1 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LParabolaf()\n"
      "LParabolaf(const LParabolaf copy)\n"
      "LParabolaf(const LVecBase3f a, const LVecBase3f b, const LVecBase3f c)\n");
  }
  return -1;
}

LParabolaf *Dtool_Coerce_LParabolaf(PyObject *args, LParabolaf &coerced) {
  LParabolaf *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_LParabolaf)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const LParabolaf *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-inline LParabolaf::LParabolaf(LVecBase3f const &a, LVecBase3f const &b, LVecBase3f const &c)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      if (PyArg_UnpackTuple(args, "LParabolaf", 3, 3, &param0, &param1, &param2)) {
        LVecBase3f const *param0_this = nullptr;
        DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LVecBase3f);
        LVecBase3f const *param1_this = nullptr;
        DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVecBase3f);
        LVecBase3f const *param2_this = nullptr;
        DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVecBase3f);
        if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
          coerced = LParabolaf(*param0_this, *param1_this, *param2_this);
          if (_PyErr_OCCURRED()) {
            return nullptr;
          } else {
            return &coerced;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return nullptr;
}

static void *Dtool_UpcastInterface_LParabolaf(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LParabolaf) {
    printf("LParabolaf ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LParabolaf *local_this = (LParabolaf *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LParabolaf) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LParabolaf(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LParabolaf) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LParabolad
 */
/**
 * Python function wrapper for:
 * inline void LParabolad::operator =(LParabolad const &copy)
 */
static PyObject *Dtool_LParabolad_operator_573(PyObject *self, PyObject *arg) {
  LParabolad *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LParabolad, (void **)&local_this, "LParabolad.assign")) {
    return nullptr;
  }
  // 1-inline void LParabolad::operator =(LParabolad const &copy)
  LParabolad arg_local;
  LParabolad const *arg_this = Dtool_Coerce_LParabolad(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LParabolad.assign", "LParabolad");
  }
  ((*local_this).operator =)(*arg_this);
  LParabolad *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LParabolad, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const LParabolad self, const LParabolad copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LParabolad_operator_573_comment =
  "C++ Interface:\n"
  "assign(const LParabolad self, const LParabolad copy)\n";
#else
static const char *Dtool_LParabolad_operator_573_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LParabolad::xform(LMatrix4d const &mat)
 */
static PyObject *Dtool_LParabolad_xform_575(PyObject *self, PyObject *arg) {
  LParabolad *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LParabolad, (void **)&local_this, "LParabolad.xform")) {
    return nullptr;
  }
  // 1-void LParabolad::xform(LMatrix4d const &mat)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LParabolad.xform", "LMatrix4d");
  }
  ((*local_this).xform)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform(const LParabolad self, const LMatrix4d mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LParabolad_xform_575_comment =
  "C++ Interface:\n"
  "xform(const LParabolad self, const LMatrix4d mat)\n"
  "\n"
  "/**\n"
  " * Transforms the parabola by the indicated matrix.\n"
  " */";
#else
static const char *Dtool_LParabolad_xform_575_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3d const &LParabolad::get_a(void) const
 */
static PyObject *Dtool_LParabolad_get_a_576(PyObject *self, PyObject *) {
  LParabolad *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LParabolad)) {
    return nullptr;
  }
  // 1-inline LVecBase3d const &LParabolad::get_a(void) const
  LVecBase3d const *return_value = &(((*(const LParabolad*)local_this).get_a)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LParabolad_get_a_576_comment =
  "C++ Interface:\n"
  "get_a(LParabolad self)\n"
  "\n"
  "/**\n"
  " * Returns the first point of the parabola's parametric equation: the\n"
  " * acceleration.\n"
  " */";
#else
static const char *Dtool_LParabolad_get_a_576_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3d const &LParabolad::get_b(void) const
 */
static PyObject *Dtool_LParabolad_get_b_577(PyObject *self, PyObject *) {
  LParabolad *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LParabolad)) {
    return nullptr;
  }
  // 1-inline LVecBase3d const &LParabolad::get_b(void) const
  LVecBase3d const *return_value = &(((*(const LParabolad*)local_this).get_b)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LParabolad_get_b_577_comment =
  "C++ Interface:\n"
  "get_b(LParabolad self)\n"
  "\n"
  "/**\n"
  " * Returns the second point of the parabola's parametric equation: the initial\n"
  " * velocity.\n"
  " */";
#else
static const char *Dtool_LParabolad_get_b_577_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3d const &LParabolad::get_c(void) const
 */
static PyObject *Dtool_LParabolad_get_c_578(PyObject *self, PyObject *) {
  LParabolad *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LParabolad)) {
    return nullptr;
  }
  // 1-inline LVecBase3d const &LParabolad::get_c(void) const
  LVecBase3d const *return_value = &(((*(const LParabolad*)local_this).get_c)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LParabolad_get_c_578_comment =
  "C++ Interface:\n"
  "get_c(LParabolad self)\n"
  "\n"
  "/**\n"
  " * Returns the third point of the parabola's parametric equation: the start\n"
  " * point.\n"
  " */";
#else
static const char *Dtool_LParabolad_get_c_578_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3d LParabolad::calc_point(double t) const
 */
static PyObject *Dtool_LParabolad_calc_point_579(PyObject *self, PyObject *arg) {
  LParabolad *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LParabolad)) {
    return nullptr;
  }
  // 1-inline LPoint3d LParabolad::calc_point(double t) const
  if (PyNumber_Check(arg)) {
    LPoint3d *return_value = new LPoint3d(((*(const LParabolad*)local_this).calc_point)(PyFloat_AsDouble(arg)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_point(LParabolad self, double t)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LParabolad_calc_point_579_comment =
  "C++ Interface:\n"
  "calc_point(LParabolad self, double t)\n"
  "\n"
  "/**\n"
  " * Computes the point on the parabola at time t.\n"
  " */";
#else
static const char *Dtool_LParabolad_calc_point_579_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LParabolad::output(std::ostream &out) const
 */
static PyObject *Dtool_LParabolad_output_580(PyObject *self, PyObject *arg) {
  LParabolad *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LParabolad)) {
    return nullptr;
  }
  // 1-void LParabolad::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "LParabolad.output", false, true);
  if (arg_this != nullptr) {
    ((*(const LParabolad*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LParabolad self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LParabolad_output_580_comment =
  "C++ Interface:\n"
  "output(LParabolad self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LParabolad_output_580_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LParabolad::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_LParabolad_write_581(PyObject *self, PyObject *args, PyObject *kwds) {
  LParabolad *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LParabolad)) {
    return nullptr;
  }
  // 1-void LParabolad::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "LParabolad.write", false, true);
    if (param1_this != nullptr) {
      ((*(const LParabolad*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(LParabolad self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LParabolad_write_581_comment =
  "C++ Interface:\n"
  "write(LParabolad self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LParabolad_write_581_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LParabolad::write_datagram_fixed(Datagram &destination) const
 */
static PyObject *Dtool_LParabolad_write_datagram_fixed_582(PyObject *self, PyObject *arg) {
  LParabolad *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LParabolad)) {
    return nullptr;
  }
  // 1-void LParabolad::write_datagram_fixed(Datagram &destination) const
  Datagram arg_local;
  Datagram *arg_this = Dtool_Coerce_Datagram(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LParabolad.write_datagram_fixed", "Datagram");
  }
  ((*(const LParabolad*)local_this).write_datagram_fixed)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram_fixed(LParabolad self, Datagram destination)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LParabolad_write_datagram_fixed_582_comment =
  "C++ Interface:\n"
  "write_datagram_fixed(LParabolad self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the parabola to the Datagram using add_float32() or add_float64(),\n"
  " * depending on the type of floats in the parabola, regardless of the setting\n"
  " * of Datagram::set_stdfloat_double().  This is appropriate when you want to\n"
  " * write a fixed-width value to the datagram, especially when you are not\n"
  " * writing a bam file.\n"
  " */";
#else
static const char *Dtool_LParabolad_write_datagram_fixed_582_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LParabolad::read_datagram_fixed(DatagramIterator &source)
 */
static PyObject *Dtool_LParabolad_read_datagram_fixed_583(PyObject *self, PyObject *arg) {
  LParabolad *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LParabolad, (void **)&local_this, "LParabolad.read_datagram_fixed")) {
    return nullptr;
  }
  // 1-void LParabolad::read_datagram_fixed(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LParabolad.read_datagram_fixed", "DatagramIterator");
  }
  ((*local_this).read_datagram_fixed)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram_fixed(const LParabolad self, DatagramIterator source)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LParabolad_read_datagram_fixed_583_comment =
  "C++ Interface:\n"
  "read_datagram_fixed(const LParabolad self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " * Reads the parabola from the Datagram using get_float32() or get_float64().\n"
  " * See write_datagram_fixed().\n"
  " */";
#else
static const char *Dtool_LParabolad_read_datagram_fixed_583_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LParabolad::write_datagram(Datagram &destination) const
 */
static PyObject *Dtool_LParabolad_write_datagram_584(PyObject *self, PyObject *arg) {
  LParabolad *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LParabolad)) {
    return nullptr;
  }
  // 1-void LParabolad::write_datagram(Datagram &destination) const
  Datagram arg_local;
  Datagram *arg_this = Dtool_Coerce_Datagram(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LParabolad.write_datagram", "Datagram");
  }
  ((*(const LParabolad*)local_this).write_datagram)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram(LParabolad self, Datagram destination)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LParabolad_write_datagram_584_comment =
  "C++ Interface:\n"
  "write_datagram(LParabolad self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the parabola to the Datagram using add_stdfloat().  This is\n"
  " * appropriate when you want to write the vector using the standard width\n"
  " * setting, especially when you are writing a bam file.\n"
  " */";
#else
static const char *Dtool_LParabolad_write_datagram_584_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LParabolad::read_datagram(DatagramIterator &source)
 */
static PyObject *Dtool_LParabolad_read_datagram_585(PyObject *self, PyObject *arg) {
  LParabolad *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LParabolad, (void **)&local_this, "LParabolad.read_datagram")) {
    return nullptr;
  }
  // 1-void LParabolad::read_datagram(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LParabolad.read_datagram", "DatagramIterator");
  }
  ((*local_this).read_datagram)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram(const LParabolad self, DatagramIterator source)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LParabolad_read_datagram_585_comment =
  "C++ Interface:\n"
  "read_datagram(const LParabolad self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " * Reads the parabola from the Datagram using get_stdfloat().\n"
  " */";
#else
static const char *Dtool_LParabolad_read_datagram_585_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LParabolad::LParabolad(void)
 * inline LParabolad::LParabolad(LParabolad const &copy)
 * inline LParabolad::LParabolad(LVecBase3d const &a, LVecBase3d const &b, LVecBase3d const &c)
 */
static int Dtool_Init_LParabolad(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LParabolad::LParabolad(void)
      LParabolad *return_value = new LParabolad();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LParabolad, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-inline LParabolad::LParabolad(LParabolad const &copy)
        LParabolad arg_local;
        LParabolad const *arg_this = Dtool_Coerce_LParabolad(arg, arg_local);
        if (!(arg_this != nullptr)) {
          Dtool_Raise_ArgTypeError(arg, 0, "LParabolad.LParabolad", "LParabolad");
          return -1;
        }
        LParabolad *return_value = new LParabolad(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LParabolad, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-inline LParabolad::LParabolad(LVecBase3d const &a, LVecBase3d const &b, LVecBase3d const &c)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"a", "b", "c", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:LParabolad", (char **)keyword_list, &param0, &param1, &param2)) {
        LVecBase3d param0_local;
        LVecBase3d const *param0_this = Dtool_Coerce_LVecBase3d(param0, param0_local);
        if (!(param0_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LParabolad.LParabolad", "LVecBase3d");
          return -1;
        }
        LVecBase3d param1_local;
        LVecBase3d const *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
        if (!(param1_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param1, 1, "LParabolad.LParabolad", "LVecBase3d");
          return -1;
        }
        LVecBase3d param2_local;
        LVecBase3d const *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
        if (!(param2_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param2, 2, "LParabolad.LParabolad", "LVecBase3d");
          return -1;
        }
        LParabolad *return_value = new LParabolad(*param0_this, *param1_this, *param2_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LParabolad, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LParabolad() takes 0, 1 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LParabolad()\n"
      "LParabolad(const LParabolad copy)\n"
      "LParabolad(const LVecBase3d a, const LVecBase3d b, const LVecBase3d c)\n");
  }
  return -1;
}

LParabolad *Dtool_Coerce_LParabolad(PyObject *args, LParabolad &coerced) {
  LParabolad *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_LParabolad)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const LParabolad *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-inline LParabolad::LParabolad(LVecBase3d const &a, LVecBase3d const &b, LVecBase3d const &c)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      if (PyArg_UnpackTuple(args, "LParabolad", 3, 3, &param0, &param1, &param2)) {
        LVecBase3d const *param0_this = nullptr;
        DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LVecBase3d);
        LVecBase3d const *param1_this = nullptr;
        DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVecBase3d);
        LVecBase3d const *param2_this = nullptr;
        DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVecBase3d);
        if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
          coerced = LParabolad(*param0_this, *param1_this, *param2_this);
          if (_PyErr_OCCURRED()) {
            return nullptr;
          } else {
            return &coerced;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return nullptr;
}

static void *Dtool_UpcastInterface_LParabolad(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LParabolad) {
    printf("LParabolad ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LParabolad *local_this = (LParabolad *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LParabolad) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LParabolad(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LParabolad) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LPlanef
 */
/**
 * Python function wrapper for:
 * inline void LPlanef::xform(LMatrix4f const &mat)
 */
static PyObject *Dtool_LPlanef_xform_592(PyObject *self, PyObject *arg) {
  LPlanef *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LPlanef, (void **)&local_this, "LPlanef.xform")) {
    return nullptr;
  }
  // 1-inline void LPlanef::xform(LMatrix4f const &mat)
  LMatrix4f arg_local;
  LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LPlanef.xform", "LMatrix4f");
  }
  ((*local_this).xform)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform(const LPlanef self, const LMatrix4f mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LPlanef_xform_592_comment =
  "C++ Interface:\n"
  "xform(const LPlanef self, const LMatrix4f mat)\n"
  "\n"
  "/**\n"
  " * Transforms the plane by the indicated matrix.\n"
  " */";
#else
static const char *Dtool_LPlanef_xform_592_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LMatrix4f LPlanef::get_reflection_mat(void) const
 */
static PyObject *Dtool_LPlanef_get_reflection_mat_594(PyObject *self, PyObject *) {
  LPlanef *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LPlanef)) {
    return nullptr;
  }
  // 1-LMatrix4f LPlanef::get_reflection_mat(void) const
  LMatrix4f *return_value = new LMatrix4f(((*(const LPlanef*)local_this).get_reflection_mat)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPlanef_get_reflection_mat_594_comment =
  "C++ Interface:\n"
  "get_reflection_mat(LPlanef self)\n"
  "\n"
  "/**\n"
  " * This computes a transform matrix that reflects the universe to the other\n"
  " * side of the plane, as in a mirror.\n"
  " */";
#else
static const char *Dtool_LPlanef_get_reflection_mat_594_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector3f LPlanef::get_normal(void) const
 */
static PyObject *Dtool_LPlanef_get_normal_595(PyObject *self, PyObject *) {
  LPlanef *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LPlanef)) {
    return nullptr;
  }
  // 1-inline LVector3f LPlanef::get_normal(void) const
  LVector3f *return_value = new LVector3f(((*(const LPlanef*)local_this).get_normal)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPlanef_get_normal_595_comment =
  "C++ Interface:\n"
  "get_normal(LPlanef self)\n"
  "\n"
  "/**\n"
  " * Returns the surface normal of the plane.\n"
  " */";
#else
static const char *Dtool_LPlanef_get_normal_595_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LPoint3f LPlanef::get_point(void) const
 */
static PyObject *Dtool_LPlanef_get_point_596(PyObject *self, PyObject *) {
  LPlanef *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LPlanef)) {
    return nullptr;
  }
  // 1-LPoint3f LPlanef::get_point(void) const
  LPoint3f *return_value = new LPoint3f(((*(const LPlanef*)local_this).get_point)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPlanef_get_point_596_comment =
  "C++ Interface:\n"
  "get_point(LPlanef self)\n"
  "\n"
  "/**\n"
  " * Returns an arbitrary point in the plane.  This can be used along with the\n"
  " * normal returned by get_normal() to reconstruct the plane.\n"
  " */";
#else
static const char *Dtool_LPlanef_get_point_596_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float LPlanef::dist_to_plane(LPoint3f const &point) const
 */
static PyObject *Dtool_LPlanef_dist_to_plane_597(PyObject *self, PyObject *arg) {
  LPlanef *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LPlanef)) {
    return nullptr;
  }
  // 1-inline float LPlanef::dist_to_plane(LPoint3f const &point) const
  LPoint3f arg_local;
  LPoint3f const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LPlanef.dist_to_plane", "LPoint3f");
  }
  float return_value = ((*(const LPlanef*)local_this).dist_to_plane)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dist_to_plane(LPlanef self, const LPoint3f point)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LPlanef_dist_to_plane_597_comment =
  "C++ Interface:\n"
  "dist_to_plane(LPlanef self, const LPoint3f point)\n"
  "\n"
  "/**\n"
  " * Returns the straight-line shortest distance from the point to the plane.\n"
  " * The returned value is positive if the point is in front of the plane (on\n"
  " * the side with the normal), or negative in the point is behind the plane (on\n"
  " * the opposite side from the normal). It's zero if the point is exactly in\n"
  " * the plane.\n"
  " */";
#else
static const char *Dtool_LPlanef_dist_to_plane_597_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LPlanef::normalize(void)
 */
static PyObject *Dtool_LPlanef_normalize_598(PyObject *self, PyObject *) {
  LPlanef *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LPlanef, (void **)&local_this, "LPlanef.normalize")) {
    return nullptr;
  }
  // 1-inline bool LPlanef::normalize(void)
  bool return_value = ((*local_this).normalize)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LPlanef_normalize_598_comment =
  "C++ Interface:\n"
  "normalize(const LPlanef self)\n"
  "\n"
  "/**\n"
  " * Normalizes the plane in place.  Returns true if the plane was normalized,\n"
  " * false if the plane had a zero-length normal vector.\n"
  " */";
#else
static const char *Dtool_LPlanef_normalize_598_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPlanef LPlanef::normalized(void) const
 */
static PyObject *Dtool_LPlanef_normalized_599(PyObject *self, PyObject *) {
  LPlanef *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LPlanef)) {
    return nullptr;
  }
  // 1-inline LPlanef LPlanef::normalized(void) const
  LPlanef *return_value = new LPlanef(((*(const LPlanef*)local_this).normalized)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPlanef_normalized_599_comment =
  "C++ Interface:\n"
  "normalized(LPlanef self)\n"
  "\n"
  "/**\n"
  " * Normalizes the plane and returns the normalized plane as a copy.  If the\n"
  " * plane's normal was a zero-length vector, the same plane is returned.\n"
  " */";
#else
static const char *Dtool_LPlanef_normalized_599_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f LPlanef::project(LPoint3f const &point) const
 */
static PyObject *Dtool_LPlanef_project_600(PyObject *self, PyObject *arg) {
  LPlanef *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LPlanef)) {
    return nullptr;
  }
  // 1-inline LPoint3f LPlanef::project(LPoint3f const &point) const
  LPoint3f arg_local;
  LPoint3f const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LPlanef.project", "LPoint3f");
  }
  LPoint3f *return_value = new LPoint3f(((*(const LPlanef*)local_this).project)(*arg_this));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "project(LPlanef self, const LPoint3f point)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LPlanef_project_600_comment =
  "C++ Interface:\n"
  "project(LPlanef self, const LPoint3f point)\n"
  "\n"
  "/**\n"
  " * Returns the point within the plane nearest to the indicated point in space.\n"
  " */";
#else
static const char *Dtool_LPlanef_project_600_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LPlanef::flip(void)
 */
static PyObject *Dtool_LPlanef_flip_601(PyObject *self, PyObject *) {
  LPlanef *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LPlanef, (void **)&local_this, "LPlanef.flip")) {
    return nullptr;
  }
  // 1-inline void LPlanef::flip(void)
  ((*local_this).flip)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LPlanef_flip_601_comment =
  "C++ Interface:\n"
  "flip(const LPlanef self)\n"
  "\n"
  "/**\n"
  " * Convenience method that flips the plane in-place.  This is done by simply\n"
  " * flipping the normal vector.\n"
  " */";
#else
static const char *Dtool_LPlanef_flip_601_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LPlanef::intersects_line(LPoint3f &intersection_point, LPoint3f const &p1, LPoint3f const &p2) const
 */
static PyObject *Dtool_LPlanef_intersects_line_602(PyObject *self, PyObject *args, PyObject *kwds) {
  LPlanef *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LPlanef)) {
    return nullptr;
  }
  // 1-inline bool LPlanef::intersects_line(LPoint3f &intersection_point, LPoint3f const &p1, LPoint3f const &p2) const
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"intersection_point", "p1", "p2", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:intersects_line", (char **)keyword_list, &param1, &param2, &param3)) {
    LPoint3f param1_local;
    LPoint3f *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LPlanef.intersects_line", "LPoint3f");
    }
    LPoint3f param2_local;
    LPoint3f const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LPlanef.intersects_line", "LPoint3f");
    }
    LPoint3f param3_local;
    LPoint3f const *param3_this = Dtool_Coerce_LPoint3f(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "LPlanef.intersects_line", "LPoint3f");
    }
    bool return_value = ((*(const LPlanef*)local_this).intersects_line)(*param1_this, *param2_this, *param3_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "intersects_line(LPlanef self, LPoint3f intersection_point, const LPoint3f p1, const LPoint3f p2)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LPlanef_intersects_line_602_comment =
  "C++ Interface:\n"
  "intersects_line(LPlanef self, LPoint3f intersection_point, const LPoint3f p1, const LPoint3f p2)\n"
  "\n"
  "/**\n"
  " * Returns true if the plane intersects the infinite line passing through\n"
  " * points p1 and p2, false if the line is parallel.  The points p1 and p2 are\n"
  " * used only to define the Euclidean line; they have no other bearing on the\n"
  " * intersection test.  If true, sets intersection_point to the point of\n"
  " * intersection.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This flavor of intersects_line() returns a bit more information about the\n"
  " * nature of the intersecting point.  The line is defined via the parametric\n"
  " * equation from + t * delta for all real values of t.\n"
  " *\n"
  " * If there is no intersection with the plane, the function returns false and\n"
  " * leaves t undefined.  If there is an intersection with the plane, the\n"
  " * function returns true and sets t to the parametric value that defines the\n"
  " * point of intersection.  That is, t == 0.0f implies that the intersection\n"
  " * occurred exactly at point from, and t == 1.0f implies at point from +\n"
  " * delta, with other values of t accordingly.\n"
  " */";
#else
static const char *Dtool_LPlanef_intersects_line_602_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool LPlanef::intersects_plane(LPoint3f &from, LVector3f &delta, LPlanef const &other) const
 */
static PyObject *Dtool_LPlanef_intersects_plane_603(PyObject *self, PyObject *args, PyObject *kwds) {
  LPlanef *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LPlanef)) {
    return nullptr;
  }
  // 1-bool LPlanef::intersects_plane(LPoint3f &from, LVector3f &delta, LPlanef const &other) const
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"from", "delta", "other", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:intersects_plane", (char **)keyword_list, &param1, &param2, &param3)) {
    LPoint3f param1_local;
    LPoint3f *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LPlanef.intersects_plane", "LPoint3f");
    }
    LVector3f param2_local;
    LVector3f *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LPlanef.intersects_plane", "LVector3f");
    }
    LPlanef param3_local;
    LPlanef const *param3_this = Dtool_Coerce_LPlanef(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "LPlanef.intersects_plane", "LPlanef");
    }
    bool return_value = ((*(const LPlanef*)local_this).intersects_plane)(*param1_this, *param2_this, *param3_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "intersects_plane(LPlanef self, LPoint3f from, LVector3f delta, const LPlanef other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LPlanef_intersects_plane_603_comment =
  "C++ Interface:\n"
  "intersects_plane(LPlanef self, LPoint3f from, LVector3f delta, const LPlanef other)\n"
  "\n"
  "/**\n"
  " * Returns true if the two planes intersect, false if they do not.  If they do\n"
  " * intersect, then from and delta are filled in with the parametric\n"
  " * representation of the line of intersection: that is, from is a point on\n"
  " * that line, and delta is a vector showing the direction of the line.\n"
  " */";
#else
static const char *Dtool_LPlanef_intersects_plane_603_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LPlanef::output(std::ostream &out) const
 */
static PyObject *Dtool_LPlanef_output_605(PyObject *self, PyObject *arg) {
  LPlanef *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LPlanef)) {
    return nullptr;
  }
  // 1-void LPlanef::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "LPlanef.output", false, true);
  if (arg_this != nullptr) {
    ((*(const LPlanef*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LPlanef self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LPlanef_output_605_comment =
  "C++ Interface:\n"
  "output(LPlanef self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LPlanef_output_605_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LPlanef::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_LPlanef_write_606(PyObject *self, PyObject *args, PyObject *kwds) {
  LPlanef *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LPlanef)) {
    return nullptr;
  }
  // 1-void LPlanef::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "LPlanef.write", false, true);
    if (param1_this != nullptr) {
      ((*(const LPlanef*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(LPlanef self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LPlanef_write_606_comment =
  "C++ Interface:\n"
  "write(LPlanef self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LPlanef_write_606_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPlanef::LPlanef(void)
 * inline LPlanef::LPlanef(LPlanef const &) = default
 * inline LPlanef::LPlanef(LPoint3f const &a, LPoint3f const &b, LPoint3f const &c)
 * inline LPlanef::LPlanef(LVecBase4f const &copy)
 * inline LPlanef::LPlanef(LVector3f const &normal, LPoint3f const &point)
 * inline LPlanef::LPlanef(float a, float b, float c, float d)
 */
static int Dtool_Init_LPlanef(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LPlanef::LPlanef(void)
      LPlanef *return_value = new LPlanef();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlanef, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LPlanef::LPlanef(LPlanef const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          LPlanef const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LPlanef);
          if (param0_this != nullptr) {
            LPlanef *return_value = new LPlanef(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlanef, true, false);
          }
        }
      }

      {
        // -2 inline LPlanef::LPlanef(LVecBase4f const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          LVecBase4f const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LVecBase4f);
          if (param0_this != nullptr) {
            LPlanef *return_value = new LPlanef(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlanef, true, false);
          }
        }
      }

      {
        // -2 inline LPlanef::LPlanef(LPlanef const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          LPlanef param0_local;
          LPlanef const *param0_this = Dtool_Coerce_LPlanef(param0, param0_local);
          if ((param0_this != nullptr)) {
            LPlanef *return_value = new LPlanef(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlanef, true, false);
          }
        }
      }

      {
        // -2 inline LPlanef::LPlanef(LVecBase4f const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          LVecBase4f param0_local;
          LVecBase4f const *param0_this = Dtool_Coerce_LVecBase4f(param0, param0_local);
          if ((param0_this != nullptr)) {
            LPlanef *return_value = new LPlanef(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlanef, true, false);
          }
        }
      }

    }
    break;
  case 2:
    {
      // 1-inline LPlanef::LPlanef(LVector3f const &normal, LPoint3f const &point)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"normal", "point", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:LPlanef", (char **)keyword_list, &param0, &param1)) {
        LVector3f param0_local;
        LVector3f const *param0_this = Dtool_Coerce_LVector3f(param0, param0_local);
        if (!(param0_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LPlanef.LPlanef", "LVector3f");
          return -1;
        }
        LPoint3f param1_local;
        LPoint3f const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param1, 1, "LPlanef.LPlanef", "LPoint3f");
          return -1;
        }
        LPlanef *return_value = new LPlanef(*param0_this, *param1_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlanef, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-inline LPlanef::LPlanef(LPoint3f const &a, LPoint3f const &b, LPoint3f const &c)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"a", "b", "c", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:LPlanef", (char **)keyword_list, &param0, &param1, &param2)) {
        LPoint3f param0_local;
        LPoint3f const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LPlanef.LPlanef", "LPoint3f");
          return -1;
        }
        LPoint3f param1_local;
        LPoint3f const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param1, 1, "LPlanef.LPlanef", "LPoint3f");
          return -1;
        }
        LPoint3f param2_local;
        LPoint3f const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param2, 2, "LPlanef.LPlanef", "LPoint3f");
          return -1;
        }
        LPlanef *return_value = new LPlanef(*param0_this, *param1_this, *param2_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlanef, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline LPlanef::LPlanef(float a, float b, float c, float d)
      float param0;
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"a", "b", "c", "d", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:LPlanef", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LPlanef *return_value = new LPlanef((float)param0, (float)param1, (float)param2, (float)param3);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlanef, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LPlanef() takes 0, 1, 2, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LPlanef()\n"
      "LPlanef(const LPlanef param0)\n"
      "LPlanef(const LVecBase4f copy)\n"
      "LPlanef(const LVector3f normal, const LPoint3f point)\n"
      "LPlanef(const LPoint3f a, const LPoint3f b, const LPoint3f c)\n"
      "LPlanef(float a, float b, float c, float d)\n");
  }
  return -1;
}

LPlanef *Dtool_Coerce_LPlanef(PyObject *args, LPlanef &coerced) {
  LPlanef *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_LPlanef)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const LPlanef *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline LPlanef::LPlanef(LVecBase4f const &copy)
    LVecBase4f const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase4f);
    if (arg_this != nullptr) {
      coerced = LPlanef(*arg_this);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline LPlanef::LPlanef(LVector3f const &normal, LPoint3f const &point)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "LPlanef", 2, 2, &param0, &param1)) {
          LVector3f const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LVector3f);
          LPoint3f const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LPoint3f);
          if (param0_this != nullptr && param1_this != nullptr) {
            coerced = LPlanef(*param0_this, *param1_this);
            if (_PyErr_OCCURRED()) {
              return nullptr;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-inline LPlanef::LPlanef(LPoint3f const &a, LPoint3f const &b, LPoint3f const &c)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        if (PyArg_UnpackTuple(args, "LPlanef", 3, 3, &param0, &param1, &param2)) {
          LPoint3f const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LPoint3f);
          LPoint3f const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LPoint3f);
          LPoint3f const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LPoint3f);
          if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
            coerced = LPlanef(*param0_this, *param1_this, *param2_this);
            if (_PyErr_OCCURRED()) {
              return nullptr;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline LPlanef::LPlanef(float a, float b, float c, float d)
        float param0;
        float param1;
        float param2;
        float param3;
        if (PyArg_ParseTuple(args, "ffff:LPlanef", &param0, &param1, &param2, &param3)) {
          coerced = LPlanef((float)param0, (float)param1, (float)param2, (float)param3);
          if (_PyErr_OCCURRED()) {
            return nullptr;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return nullptr;
}

static void *Dtool_UpcastInterface_LPlanef(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LPlanef) {
    printf("LPlanef ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LPlanef *local_this = (LPlanef *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LPlanef) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LVecBase4f) {
    return (LVecBase4f *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LPlanef(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LPlanef) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LVecBase4f) {
    LVecBase4f* other_this = (LVecBase4f*)from_this;
    return (LPlanef*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LPlaned
 */
/**
 * Python function wrapper for:
 * inline void LPlaned::xform(LMatrix4d const &mat)
 */
static PyObject *Dtool_LPlaned_xform_613(PyObject *self, PyObject *arg) {
  LPlaned *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LPlaned, (void **)&local_this, "LPlaned.xform")) {
    return nullptr;
  }
  // 1-inline void LPlaned::xform(LMatrix4d const &mat)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LPlaned.xform", "LMatrix4d");
  }
  ((*local_this).xform)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform(const LPlaned self, const LMatrix4d mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LPlaned_xform_613_comment =
  "C++ Interface:\n"
  "xform(const LPlaned self, const LMatrix4d mat)\n"
  "\n"
  "/**\n"
  " * Transforms the plane by the indicated matrix.\n"
  " */";
#else
static const char *Dtool_LPlaned_xform_613_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LMatrix4d LPlaned::get_reflection_mat(void) const
 */
static PyObject *Dtool_LPlaned_get_reflection_mat_615(PyObject *self, PyObject *) {
  LPlaned *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LPlaned)) {
    return nullptr;
  }
  // 1-LMatrix4d LPlaned::get_reflection_mat(void) const
  LMatrix4d *return_value = new LMatrix4d(((*(const LPlaned*)local_this).get_reflection_mat)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPlaned_get_reflection_mat_615_comment =
  "C++ Interface:\n"
  "get_reflection_mat(LPlaned self)\n"
  "\n"
  "/**\n"
  " * This computes a transform matrix that reflects the universe to the other\n"
  " * side of the plane, as in a mirror.\n"
  " */";
#else
static const char *Dtool_LPlaned_get_reflection_mat_615_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector3d LPlaned::get_normal(void) const
 */
static PyObject *Dtool_LPlaned_get_normal_616(PyObject *self, PyObject *) {
  LPlaned *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LPlaned)) {
    return nullptr;
  }
  // 1-inline LVector3d LPlaned::get_normal(void) const
  LVector3d *return_value = new LVector3d(((*(const LPlaned*)local_this).get_normal)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPlaned_get_normal_616_comment =
  "C++ Interface:\n"
  "get_normal(LPlaned self)\n"
  "\n"
  "/**\n"
  " * Returns the surface normal of the plane.\n"
  " */";
#else
static const char *Dtool_LPlaned_get_normal_616_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LPoint3d LPlaned::get_point(void) const
 */
static PyObject *Dtool_LPlaned_get_point_617(PyObject *self, PyObject *) {
  LPlaned *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LPlaned)) {
    return nullptr;
  }
  // 1-LPoint3d LPlaned::get_point(void) const
  LPoint3d *return_value = new LPoint3d(((*(const LPlaned*)local_this).get_point)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPlaned_get_point_617_comment =
  "C++ Interface:\n"
  "get_point(LPlaned self)\n"
  "\n"
  "/**\n"
  " * Returns an arbitrary point in the plane.  This can be used along with the\n"
  " * normal returned by get_normal() to reconstruct the plane.\n"
  " */";
#else
static const char *Dtool_LPlaned_get_point_617_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double LPlaned::dist_to_plane(LPoint3d const &point) const
 */
static PyObject *Dtool_LPlaned_dist_to_plane_618(PyObject *self, PyObject *arg) {
  LPlaned *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LPlaned)) {
    return nullptr;
  }
  // 1-inline double LPlaned::dist_to_plane(LPoint3d const &point) const
  LPoint3d arg_local;
  LPoint3d const *arg_this = Dtool_Coerce_LPoint3d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LPlaned.dist_to_plane", "LPoint3d");
  }
  double return_value = ((*(const LPlaned*)local_this).dist_to_plane)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dist_to_plane(LPlaned self, const LPoint3d point)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LPlaned_dist_to_plane_618_comment =
  "C++ Interface:\n"
  "dist_to_plane(LPlaned self, const LPoint3d point)\n"
  "\n"
  "/**\n"
  " * Returns the straight-line shortest distance from the point to the plane.\n"
  " * The returned value is positive if the point is in front of the plane (on\n"
  " * the side with the normal), or negative in the point is behind the plane (on\n"
  " * the opposite side from the normal). It's zero if the point is exactly in\n"
  " * the plane.\n"
  " */";
#else
static const char *Dtool_LPlaned_dist_to_plane_618_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LPlaned::normalize(void)
 */
static PyObject *Dtool_LPlaned_normalize_619(PyObject *self, PyObject *) {
  LPlaned *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LPlaned, (void **)&local_this, "LPlaned.normalize")) {
    return nullptr;
  }
  // 1-inline bool LPlaned::normalize(void)
  bool return_value = ((*local_this).normalize)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LPlaned_normalize_619_comment =
  "C++ Interface:\n"
  "normalize(const LPlaned self)\n"
  "\n"
  "/**\n"
  " * Normalizes the plane in place.  Returns true if the plane was normalized,\n"
  " * false if the plane had a zero-length normal vector.\n"
  " */";
#else
static const char *Dtool_LPlaned_normalize_619_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPlaned LPlaned::normalized(void) const
 */
static PyObject *Dtool_LPlaned_normalized_620(PyObject *self, PyObject *) {
  LPlaned *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LPlaned)) {
    return nullptr;
  }
  // 1-inline LPlaned LPlaned::normalized(void) const
  LPlaned *return_value = new LPlaned(((*(const LPlaned*)local_this).normalized)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlaned, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPlaned_normalized_620_comment =
  "C++ Interface:\n"
  "normalized(LPlaned self)\n"
  "\n"
  "/**\n"
  " * Normalizes the plane and returns the normalized plane as a copy.  If the\n"
  " * plane's normal was a zero-length vector, the same plane is returned.\n"
  " */";
#else
static const char *Dtool_LPlaned_normalized_620_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3d LPlaned::project(LPoint3d const &point) const
 */
static PyObject *Dtool_LPlaned_project_621(PyObject *self, PyObject *arg) {
  LPlaned *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LPlaned)) {
    return nullptr;
  }
  // 1-inline LPoint3d LPlaned::project(LPoint3d const &point) const
  LPoint3d arg_local;
  LPoint3d const *arg_this = Dtool_Coerce_LPoint3d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LPlaned.project", "LPoint3d");
  }
  LPoint3d *return_value = new LPoint3d(((*(const LPlaned*)local_this).project)(*arg_this));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "project(LPlaned self, const LPoint3d point)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LPlaned_project_621_comment =
  "C++ Interface:\n"
  "project(LPlaned self, const LPoint3d point)\n"
  "\n"
  "/**\n"
  " * Returns the point within the plane nearest to the indicated point in space.\n"
  " */";
#else
static const char *Dtool_LPlaned_project_621_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LPlaned::flip(void)
 */
static PyObject *Dtool_LPlaned_flip_622(PyObject *self, PyObject *) {
  LPlaned *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LPlaned, (void **)&local_this, "LPlaned.flip")) {
    return nullptr;
  }
  // 1-inline void LPlaned::flip(void)
  ((*local_this).flip)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LPlaned_flip_622_comment =
  "C++ Interface:\n"
  "flip(const LPlaned self)\n"
  "\n"
  "/**\n"
  " * Convenience method that flips the plane in-place.  This is done by simply\n"
  " * flipping the normal vector.\n"
  " */";
#else
static const char *Dtool_LPlaned_flip_622_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LPlaned::intersects_line(LPoint3d &intersection_point, LPoint3d const &p1, LPoint3d const &p2) const
 */
static PyObject *Dtool_LPlaned_intersects_line_623(PyObject *self, PyObject *args, PyObject *kwds) {
  LPlaned *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LPlaned)) {
    return nullptr;
  }
  // 1-inline bool LPlaned::intersects_line(LPoint3d &intersection_point, LPoint3d const &p1, LPoint3d const &p2) const
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"intersection_point", "p1", "p2", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:intersects_line", (char **)keyword_list, &param1, &param2, &param3)) {
    LPoint3d param1_local;
    LPoint3d *param1_this = Dtool_Coerce_LPoint3d(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LPlaned.intersects_line", "LPoint3d");
    }
    LPoint3d param2_local;
    LPoint3d const *param2_this = Dtool_Coerce_LPoint3d(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LPlaned.intersects_line", "LPoint3d");
    }
    LPoint3d param3_local;
    LPoint3d const *param3_this = Dtool_Coerce_LPoint3d(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "LPlaned.intersects_line", "LPoint3d");
    }
    bool return_value = ((*(const LPlaned*)local_this).intersects_line)(*param1_this, *param2_this, *param3_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "intersects_line(LPlaned self, LPoint3d intersection_point, const LPoint3d p1, const LPoint3d p2)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LPlaned_intersects_line_623_comment =
  "C++ Interface:\n"
  "intersects_line(LPlaned self, LPoint3d intersection_point, const LPoint3d p1, const LPoint3d p2)\n"
  "\n"
  "/**\n"
  " * Returns true if the plane intersects the infinite line passing through\n"
  " * points p1 and p2, false if the line is parallel.  The points p1 and p2 are\n"
  " * used only to define the Euclidean line; they have no other bearing on the\n"
  " * intersection test.  If true, sets intersection_point to the point of\n"
  " * intersection.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This flavor of intersects_line() returns a bit more information about the\n"
  " * nature of the intersecting point.  The line is defined via the parametric\n"
  " * equation from + t * delta for all real values of t.\n"
  " *\n"
  " * If there is no intersection with the plane, the function returns false and\n"
  " * leaves t undefined.  If there is an intersection with the plane, the\n"
  " * function returns true and sets t to the parametric value that defines the\n"
  " * point of intersection.  That is, t == 0.0f implies that the intersection\n"
  " * occurred exactly at point from, and t == 1.0f implies at point from +\n"
  " * delta, with other values of t accordingly.\n"
  " */";
#else
static const char *Dtool_LPlaned_intersects_line_623_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool LPlaned::intersects_plane(LPoint3d &from, LVector3d &delta, LPlaned const &other) const
 */
static PyObject *Dtool_LPlaned_intersects_plane_624(PyObject *self, PyObject *args, PyObject *kwds) {
  LPlaned *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LPlaned)) {
    return nullptr;
  }
  // 1-bool LPlaned::intersects_plane(LPoint3d &from, LVector3d &delta, LPlaned const &other) const
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"from", "delta", "other", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:intersects_plane", (char **)keyword_list, &param1, &param2, &param3)) {
    LPoint3d param1_local;
    LPoint3d *param1_this = Dtool_Coerce_LPoint3d(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LPlaned.intersects_plane", "LPoint3d");
    }
    LVector3d param2_local;
    LVector3d *param2_this = Dtool_Coerce_LVector3d(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LPlaned.intersects_plane", "LVector3d");
    }
    LPlaned param3_local;
    LPlaned const *param3_this = Dtool_Coerce_LPlaned(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "LPlaned.intersects_plane", "LPlaned");
    }
    bool return_value = ((*(const LPlaned*)local_this).intersects_plane)(*param1_this, *param2_this, *param3_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "intersects_plane(LPlaned self, LPoint3d from, LVector3d delta, const LPlaned other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LPlaned_intersects_plane_624_comment =
  "C++ Interface:\n"
  "intersects_plane(LPlaned self, LPoint3d from, LVector3d delta, const LPlaned other)\n"
  "\n"
  "/**\n"
  " * Returns true if the two planes intersect, false if they do not.  If they do\n"
  " * intersect, then from and delta are filled in with the parametric\n"
  " * representation of the line of intersection: that is, from is a point on\n"
  " * that line, and delta is a vector showing the direction of the line.\n"
  " */";
#else
static const char *Dtool_LPlaned_intersects_plane_624_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LPlaned::output(std::ostream &out) const
 */
static PyObject *Dtool_LPlaned_output_626(PyObject *self, PyObject *arg) {
  LPlaned *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LPlaned)) {
    return nullptr;
  }
  // 1-void LPlaned::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "LPlaned.output", false, true);
  if (arg_this != nullptr) {
    ((*(const LPlaned*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LPlaned self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LPlaned_output_626_comment =
  "C++ Interface:\n"
  "output(LPlaned self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LPlaned_output_626_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LPlaned::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_LPlaned_write_627(PyObject *self, PyObject *args, PyObject *kwds) {
  LPlaned *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LPlaned)) {
    return nullptr;
  }
  // 1-void LPlaned::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "LPlaned.write", false, true);
    if (param1_this != nullptr) {
      ((*(const LPlaned*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(LPlaned self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LPlaned_write_627_comment =
  "C++ Interface:\n"
  "write(LPlaned self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LPlaned_write_627_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPlaned::LPlaned(void)
 * inline LPlaned::LPlaned(LPlaned const &) = default
 * inline LPlaned::LPlaned(LPoint3d const &a, LPoint3d const &b, LPoint3d const &c)
 * inline LPlaned::LPlaned(LVecBase4d const &copy)
 * inline LPlaned::LPlaned(LVector3d const &normal, LPoint3d const &point)
 * inline LPlaned::LPlaned(double a, double b, double c, double d)
 */
static int Dtool_Init_LPlaned(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LPlaned::LPlaned(void)
      LPlaned *return_value = new LPlaned();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlaned, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LPlaned::LPlaned(LPlaned const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          LPlaned const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LPlaned);
          if (param0_this != nullptr) {
            LPlaned *return_value = new LPlaned(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlaned, true, false);
          }
        }
      }

      {
        // -2 inline LPlaned::LPlaned(LVecBase4d const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          LVecBase4d const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LVecBase4d);
          if (param0_this != nullptr) {
            LPlaned *return_value = new LPlaned(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlaned, true, false);
          }
        }
      }

      {
        // -2 inline LPlaned::LPlaned(LPlaned const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          LPlaned param0_local;
          LPlaned const *param0_this = Dtool_Coerce_LPlaned(param0, param0_local);
          if ((param0_this != nullptr)) {
            LPlaned *return_value = new LPlaned(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlaned, true, false);
          }
        }
      }

      {
        // -2 inline LPlaned::LPlaned(LVecBase4d const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          LVecBase4d param0_local;
          LVecBase4d const *param0_this = Dtool_Coerce_LVecBase4d(param0, param0_local);
          if ((param0_this != nullptr)) {
            LPlaned *return_value = new LPlaned(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlaned, true, false);
          }
        }
      }

    }
    break;
  case 2:
    {
      // 1-inline LPlaned::LPlaned(LVector3d const &normal, LPoint3d const &point)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"normal", "point", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:LPlaned", (char **)keyword_list, &param0, &param1)) {
        LVector3d param0_local;
        LVector3d const *param0_this = Dtool_Coerce_LVector3d(param0, param0_local);
        if (!(param0_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LPlaned.LPlaned", "LVector3d");
          return -1;
        }
        LPoint3d param1_local;
        LPoint3d const *param1_this = Dtool_Coerce_LPoint3d(param1, param1_local);
        if (!(param1_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param1, 1, "LPlaned.LPlaned", "LPoint3d");
          return -1;
        }
        LPlaned *return_value = new LPlaned(*param0_this, *param1_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlaned, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-inline LPlaned::LPlaned(LPoint3d const &a, LPoint3d const &b, LPoint3d const &c)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"a", "b", "c", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:LPlaned", (char **)keyword_list, &param0, &param1, &param2)) {
        LPoint3d param0_local;
        LPoint3d const *param0_this = Dtool_Coerce_LPoint3d(param0, param0_local);
        if (!(param0_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LPlaned.LPlaned", "LPoint3d");
          return -1;
        }
        LPoint3d param1_local;
        LPoint3d const *param1_this = Dtool_Coerce_LPoint3d(param1, param1_local);
        if (!(param1_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param1, 1, "LPlaned.LPlaned", "LPoint3d");
          return -1;
        }
        LPoint3d param2_local;
        LPoint3d const *param2_this = Dtool_Coerce_LPoint3d(param2, param2_local);
        if (!(param2_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param2, 2, "LPlaned.LPlaned", "LPoint3d");
          return -1;
        }
        LPlaned *return_value = new LPlaned(*param0_this, *param1_this, *param2_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlaned, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline LPlaned::LPlaned(double a, double b, double c, double d)
      double param0;
      double param1;
      double param2;
      double param3;
      static const char *keyword_list[] = {"a", "b", "c", "d", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dddd:LPlaned", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LPlaned *return_value = new LPlaned((double)param0, (double)param1, (double)param2, (double)param3);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPlaned, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LPlaned() takes 0, 1, 2, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LPlaned()\n"
      "LPlaned(const LPlaned param0)\n"
      "LPlaned(const LVecBase4d copy)\n"
      "LPlaned(const LVector3d normal, const LPoint3d point)\n"
      "LPlaned(const LPoint3d a, const LPoint3d b, const LPoint3d c)\n"
      "LPlaned(double a, double b, double c, double d)\n");
  }
  return -1;
}

LPlaned *Dtool_Coerce_LPlaned(PyObject *args, LPlaned &coerced) {
  LPlaned *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_LPlaned)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const LPlaned *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline LPlaned::LPlaned(LVecBase4d const &copy)
    LVecBase4d const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase4d);
    if (arg_this != nullptr) {
      coerced = LPlaned(*arg_this);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline LPlaned::LPlaned(LVector3d const &normal, LPoint3d const &point)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "LPlaned", 2, 2, &param0, &param1)) {
          LVector3d const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LVector3d);
          LPoint3d const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LPoint3d);
          if (param0_this != nullptr && param1_this != nullptr) {
            coerced = LPlaned(*param0_this, *param1_this);
            if (_PyErr_OCCURRED()) {
              return nullptr;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-inline LPlaned::LPlaned(LPoint3d const &a, LPoint3d const &b, LPoint3d const &c)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        if (PyArg_UnpackTuple(args, "LPlaned", 3, 3, &param0, &param1, &param2)) {
          LPoint3d const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LPoint3d);
          LPoint3d const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LPoint3d);
          LPoint3d const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LPoint3d);
          if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
            coerced = LPlaned(*param0_this, *param1_this, *param2_this);
            if (_PyErr_OCCURRED()) {
              return nullptr;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline LPlaned::LPlaned(double a, double b, double c, double d)
        double param0;
        double param1;
        double param2;
        double param3;
        if (PyArg_ParseTuple(args, "dddd:LPlaned", &param0, &param1, &param2, &param3)) {
          coerced = LPlaned((double)param0, (double)param1, (double)param2, (double)param3);
          if (_PyErr_OCCURRED()) {
            return nullptr;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return nullptr;
}

static void *Dtool_UpcastInterface_LPlaned(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LPlaned) {
    printf("LPlaned ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LPlaned *local_this = (LPlaned *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LPlaned) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LVecBase4d) {
    return (LVecBase4d *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LPlaned(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LPlaned) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LVecBase4d) {
    LVecBase4d* other_this = (LVecBase4d*)from_this;
    return (LPlaned*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BoundingBox
 */
/**
 * Python function wrapper for:
 * inline int BoundingBox::get_num_points(void) const
 */
static PyObject *Dtool_BoundingBox_get_num_points_638(PyObject *self, PyObject *) {
  BoundingBox *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BoundingBox)) {
    return nullptr;
  }
  // 1-inline int BoundingBox::get_num_points(void) const
  int return_value = ((*(const BoundingBox*)local_this).get_num_points)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BoundingBox_get_num_points_638_comment =
  "C++ Interface:\n"
  "get_num_points(BoundingBox self)\n"
  "\n"
  "/**\n"
  " * Returns 8: the number of vertices of a rectangular solid.\n"
  " */";
#else
static const char *Dtool_BoundingBox_get_num_points_638_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 BoundingBox::get_point(int n) const
 */
static PyObject *Dtool_BoundingBox_get_point_639(PyObject *self, PyObject *arg) {
  BoundingBox *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BoundingBox)) {
    return nullptr;
  }
  // 1-inline LPoint3 BoundingBox::get_point(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPoint3 *return_value = new LPoint3(((*(const BoundingBox*)local_this).get_point)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point(BoundingBox self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BoundingBox_get_point_639_comment =
  "C++ Interface:\n"
  "get_point(BoundingBox self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth vertex of the rectangular solid.\n"
  " */";
#else
static const char *Dtool_BoundingBox_get_point_639_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BoundingBox::get_num_planes(void) const
 */
static PyObject *Dtool_BoundingBox_get_num_planes_641(PyObject *self, PyObject *) {
  BoundingBox *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BoundingBox)) {
    return nullptr;
  }
  // 1-inline int BoundingBox::get_num_planes(void) const
  int return_value = ((*(const BoundingBox*)local_this).get_num_planes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BoundingBox_get_num_planes_641_comment =
  "C++ Interface:\n"
  "get_num_planes(BoundingBox self)\n"
  "\n"
  "/**\n"
  " * Returns 6: the number of faces of a rectangular solid.\n"
  " */";
#else
static const char *Dtool_BoundingBox_get_num_planes_641_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPlane BoundingBox::get_plane(int n) const
 */
static PyObject *Dtool_BoundingBox_get_plane_642(PyObject *self, PyObject *arg) {
  BoundingBox *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BoundingBox)) {
    return nullptr;
  }
  // 1-inline LPlane BoundingBox::get_plane(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPlane *return_value = new LPlane(((*(const BoundingBox*)local_this).get_plane)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_plane(BoundingBox self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BoundingBox_get_plane_642_comment =
  "C++ Interface:\n"
  "get_plane(BoundingBox self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth face of the rectangular solid.\n"
  " */";
#else
static const char *Dtool_BoundingBox_get_plane_642_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BoundingBox::set_min_max(LPoint3 const &min, LPoint3 const &max)
 */
static PyObject *Dtool_BoundingBox_set_min_max_646(PyObject *self, PyObject *args, PyObject *kwds) {
  BoundingBox *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BoundingBox, (void **)&local_this, "BoundingBox.set_min_max")) {
    return nullptr;
  }
  // 1-inline void BoundingBox::set_min_max(LPoint3 const &min, LPoint3 const &max)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"min", "max", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_min_max", (char **)keyword_list, &param1, &param2)) {
    LPoint3f param1_local;
    LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "BoundingBox.set_min_max", "LPoint3f");
    }
    LPoint3f param2_local;
    LPoint3 const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "BoundingBox.set_min_max", "LPoint3f");
    }
    ((*local_this).set_min_max)(*param1_this, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_min_max(const BoundingBox self, const LPoint3f min, const LPoint3f max)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BoundingBox_set_min_max_646_comment =
  "C++ Interface:\n"
  "set_min_max(const BoundingBox self, const LPoint3f min, const LPoint3f max)\n"
  "\n"
  "/**\n"
  " * Sets the min and max point of the rectangular solid.\n"
  " */";
#else
static const char *Dtool_BoundingBox_set_min_max_646_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BoundingBox::get_class_type(void)
 */
static PyObject *Dtool_BoundingBox_get_class_type_647(PyObject *, PyObject *) {
  // 1-static TypeHandle BoundingBox::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((BoundingBox::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BoundingBox_get_class_type_647_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BoundingBox_get_class_type_647_comment = nullptr;
#endif

/**
 * sequence length function for property BoundingBox::points
 */
static Py_ssize_t Dtool_BoundingBox_points_Len(PyObject *self) {
  BoundingBox *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingBox, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_points)();
}

/**
 * sequence getter for property BoundingBox::points
 */
static PyObject *Dtool_BoundingBox_points_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  BoundingBox *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingBox, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_points)()) {
    PyErr_SetString(PyExc_IndexError, "BoundingBox.points[] index out of range");
    return nullptr;
  }
  // 1-inline LPoint3 BoundingBox::get_point(int n) const
  LPoint3 *return_value = new LPoint3(((*(const BoundingBox*)local_this).get_point)(index));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point(BoundingBox self, index)\n");
  }
}

static PyObject *Dtool_BoundingBox_points_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "BoundingBox.points");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_BoundingBox_points_Len;
    wrap->_getitem_func = &Dtool_BoundingBox_points_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * sequence length function for property BoundingBox::planes
 */
static Py_ssize_t Dtool_BoundingBox_planes_Len(PyObject *self) {
  BoundingBox *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingBox, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_planes)();
}

/**
 * sequence getter for property BoundingBox::planes
 */
static PyObject *Dtool_BoundingBox_planes_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  BoundingBox *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingBox, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_planes)()) {
    PyErr_SetString(PyExc_IndexError, "BoundingBox.planes[] index out of range");
    return nullptr;
  }
  // 1-inline LPlane BoundingBox::get_plane(int n) const
  LPlane *return_value = new LPlane(((*(const BoundingBox*)local_this).get_plane)(index));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_plane(BoundingBox self, index)\n");
  }
}

static PyObject *Dtool_BoundingBox_planes_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "BoundingBox.planes");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_BoundingBox_planes_Len;
    wrap->_getitem_func = &Dtool_BoundingBox_planes_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * inline BoundingBox::BoundingBox(void)
 * inline explicit BoundingBox::BoundingBox(LPoint3 const &min, LPoint3 const &max)
 */
static int Dtool_Init_BoundingBox(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline BoundingBox::BoundingBox(void)
      BoundingBox *return_value = new BoundingBox();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BoundingBox, true, false);
    }
    break;
  case 2:
    {
      // 1-inline explicit BoundingBox::BoundingBox(LPoint3 const &min, LPoint3 const &max)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"min", "max", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:BoundingBox", (char **)keyword_list, &param0, &param1)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param0, 0, "BoundingBox.BoundingBox", "LPoint3f");
          return -1;
        }
        LPoint3f param1_local;
        LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param1, 1, "BoundingBox.BoundingBox", "LPoint3f");
          return -1;
        }
        BoundingBox *return_value = new BoundingBox(*param0_this, *param1_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BoundingBox, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BoundingBox() takes 0 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BoundingBox()\n"
      "BoundingBox(const LPoint3f min, const LPoint3f max)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_BoundingBox_get_points(PyObject *self, PyObject *) {
  BoundingBox *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingBox, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_points)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_BoundingBox_get_point_639(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_BoundingBox_get_planes(PyObject *self, PyObject *) {
  BoundingBox *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingBox, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_planes)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_BoundingBox_get_plane_642(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_BoundingBox(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BoundingBox) {
    printf("BoundingBox ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BoundingBox *local_this = (BoundingBox *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BoundingBox) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BoundingVolume) {
    return (BoundingVolume *)(GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_FiniteBoundingVolume) {
    return (FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeometricBoundingVolume) {
    return (GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BoundingBox(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BoundingBox) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BoundingVolume) {
    BoundingVolume* other_this = (BoundingVolume*)from_this;
    return (BoundingBox*)other_this;
  }
  if (from_type == Dtool_Ptr_FiniteBoundingVolume) {
    FiniteBoundingVolume* other_this = (FiniteBoundingVolume*)from_this;
    return (BoundingBox*)other_this;
  }
  if (from_type == Dtool_Ptr_GeometricBoundingVolume) {
    GeometricBoundingVolume* other_this = (GeometricBoundingVolume*)from_this;
    return (BoundingBox*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BoundingBox*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BoundingBox*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (BoundingBox*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LFrustumf
 */
/**
 * Python function wrapper for:
 * inline void LFrustumf::make_ortho_2D(void)
 * inline void LFrustumf::make_ortho_2D(float l, float r, float t, float b)
 */
static PyObject *Dtool_LFrustumf_make_ortho_2D_651(PyObject *self, PyObject *args, PyObject *kwds) {
  LFrustumf *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LFrustumf, (void **)&local_this, "LFrustumf.make_ortho_2D")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void LFrustumf::make_ortho_2D(void)
      ((*local_this).make_ortho_2D)();
      return Dtool_Return_None();
    }
    break;
  case 4:
    {
      // 1-inline void LFrustumf::make_ortho_2D(float l, float r, float t, float b)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"l", "r", "t", "b", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:make_ortho_2D", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).make_ortho_2D)((float)param1, (float)param2, (float)param3, (float)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make_ortho_2D() takes 1 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_ortho_2D(const LFrustumf self)\n"
      "make_ortho_2D(const LFrustumf self, float l, float r, float t, float b)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LFrustumf_make_ortho_2D_651_comment =
  "C++ Interface:\n"
  "make_ortho_2D(const LFrustumf self)\n"
  "make_ortho_2D(const LFrustumf self, float l, float r, float t, float b)\n"
  "\n"
  "/**\n"
  " * Sets up a two-dimensional orthographic frustum\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets up a two-dimensional orthographic frustum\n"
  " */";
#else
static const char *Dtool_LFrustumf_make_ortho_2D_651_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LFrustumf::make_ortho(float fnear, float ffar)
 * inline void LFrustumf::make_ortho(float fnear, float ffar, float l, float r, float t, float b)
 */
static PyObject *Dtool_LFrustumf_make_ortho_652(PyObject *self, PyObject *args, PyObject *kwds) {
  LFrustumf *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LFrustumf, (void **)&local_this, "LFrustumf.make_ortho")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline void LFrustumf::make_ortho(float fnear, float ffar)
      float param1;
      float param2;
      static const char *keyword_list[] = {"fnear", "ffar", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:make_ortho", (char **)keyword_list, &param1, &param2)) {
        ((*local_this).make_ortho)((float)param1, (float)param2);
        return Dtool_Return_None();
      }
    }
    break;
  case 6:
    {
      // 1-inline void LFrustumf::make_ortho(float fnear, float ffar, float l, float r, float t, float b)
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      static const char *keyword_list[] = {"fnear", "ffar", "l", "r", "t", "b", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffff:make_ortho", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        ((*local_this).make_ortho)((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make_ortho() takes 3 or 7 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_ortho(const LFrustumf self, float fnear, float ffar)\n"
      "make_ortho(const LFrustumf self, float fnear, float ffar, float l, float r, float t, float b)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LFrustumf_make_ortho_652_comment =
  "C++ Interface:\n"
  "make_ortho(const LFrustumf self, float fnear, float ffar)\n"
  "make_ortho(const LFrustumf self, float fnear, float ffar, float l, float r, float t, float b)\n"
  "\n"
  "/**\n"
  " * Behaves like gluOrtho\n"
  " */\n"
  "\n"
  "/**\n"
  " * Behaves like gluOrtho\n"
  " */";
#else
static const char *Dtool_LFrustumf_make_ortho_652_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LFrustumf::make_perspective_hfov(float xfov, float aspect, float fnear, float ffar)
 */
static PyObject *Dtool_LFrustumf_make_perspective_hfov_653(PyObject *self, PyObject *args, PyObject *kwds) {
  LFrustumf *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LFrustumf, (void **)&local_this, "LFrustumf.make_perspective_hfov")) {
    return nullptr;
  }
  // 1-inline void LFrustumf::make_perspective_hfov(float xfov, float aspect, float fnear, float ffar)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"xfov", "aspect", "fnear", "ffar", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:make_perspective_hfov", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    ((*local_this).make_perspective_hfov)((float)param1, (float)param2, (float)param3, (float)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_perspective_hfov(const LFrustumf self, float xfov, float aspect, float fnear, float ffar)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LFrustumf_make_perspective_hfov_653_comment =
  "C++ Interface:\n"
  "make_perspective_hfov(const LFrustumf self, float xfov, float aspect, float fnear, float ffar)\n"
  "\n"
  "/**\n"
  " * Behaves like gluPerspective (Aspect = width/height, Yfov in degrees) aspect\n"
  " * +------------+ |            | 1 |            | yfov |            |\n"
  " * +------------+\n"
  " *\n"
  " * -------+------ \\     | \\    | \\   | \\  | \\ | \\| W yfov\n"
  " *\n"
  " */";
#else
static const char *Dtool_LFrustumf_make_perspective_hfov_653_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LFrustumf::make_perspective_vfov(float yfov, float aspect, float fnear, float ffar)
 */
static PyObject *Dtool_LFrustumf_make_perspective_vfov_654(PyObject *self, PyObject *args, PyObject *kwds) {
  LFrustumf *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LFrustumf, (void **)&local_this, "LFrustumf.make_perspective_vfov")) {
    return nullptr;
  }
  // 1-inline void LFrustumf::make_perspective_vfov(float yfov, float aspect, float fnear, float ffar)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"yfov", "aspect", "fnear", "ffar", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:make_perspective_vfov", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    ((*local_this).make_perspective_vfov)((float)param1, (float)param2, (float)param3, (float)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_perspective_vfov(const LFrustumf self, float yfov, float aspect, float fnear, float ffar)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LFrustumf_make_perspective_vfov_654_comment =
  "C++ Interface:\n"
  "make_perspective_vfov(const LFrustumf self, float yfov, float aspect, float fnear, float ffar)\n";
#else
static const char *Dtool_LFrustumf_make_perspective_vfov_654_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LFrustumf::make_perspective(float xfov, float yfov, float fnear, float ffar)
 */
static PyObject *Dtool_LFrustumf_make_perspective_655(PyObject *self, PyObject *args, PyObject *kwds) {
  LFrustumf *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LFrustumf, (void **)&local_this, "LFrustumf.make_perspective")) {
    return nullptr;
  }
  // 1-inline void LFrustumf::make_perspective(float xfov, float yfov, float fnear, float ffar)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"xfov", "yfov", "fnear", "ffar", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:make_perspective", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    ((*local_this).make_perspective)((float)param1, (float)param2, (float)param3, (float)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_perspective(const LFrustumf self, float xfov, float yfov, float fnear, float ffar)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LFrustumf_make_perspective_655_comment =
  "C++ Interface:\n"
  "make_perspective(const LFrustumf self, float xfov, float yfov, float fnear, float ffar)\n";
#else
static const char *Dtool_LFrustumf_make_perspective_655_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LFrustumf::LFrustumf(void)
 * inline LFrustumf::LFrustumf(LFrustumf const &) = default
 */
static int Dtool_Init_LFrustumf(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("LFrustumf() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LFrustumf::LFrustumf(void)
      LFrustumf *return_value = new LFrustumf();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LFrustumf, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline LFrustumf::LFrustumf(LFrustumf const &) = default
      LFrustumf const *arg_this = (LFrustumf *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LFrustumf, 0, "LFrustumf.LFrustumf", true, true);
      if (arg_this != nullptr) {
        LFrustumf *return_value = new LFrustumf(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LFrustumf, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LFrustumf() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LFrustumf()\n"
      "LFrustumf(const LFrustumf param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LFrustumf(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LFrustumf) {
    printf("LFrustumf ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LFrustumf *local_this = (LFrustumf *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LFrustumf) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LFrustumf(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LFrustumf) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LFrustumd
 */
/**
 * Python function wrapper for:
 * inline void LFrustumd::make_ortho_2D(void)
 * inline void LFrustumd::make_ortho_2D(double l, double r, double t, double b)
 */
static PyObject *Dtool_LFrustumd_make_ortho_2D_660(PyObject *self, PyObject *args, PyObject *kwds) {
  LFrustumd *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LFrustumd, (void **)&local_this, "LFrustumd.make_ortho_2D")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void LFrustumd::make_ortho_2D(void)
      ((*local_this).make_ortho_2D)();
      return Dtool_Return_None();
    }
    break;
  case 4:
    {
      // 1-inline void LFrustumd::make_ortho_2D(double l, double r, double t, double b)
      double param1;
      double param2;
      double param3;
      double param4;
      static const char *keyword_list[] = {"l", "r", "t", "b", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dddd:make_ortho_2D", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).make_ortho_2D)((double)param1, (double)param2, (double)param3, (double)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make_ortho_2D() takes 1 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_ortho_2D(const LFrustumd self)\n"
      "make_ortho_2D(const LFrustumd self, double l, double r, double t, double b)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LFrustumd_make_ortho_2D_660_comment =
  "C++ Interface:\n"
  "make_ortho_2D(const LFrustumd self)\n"
  "make_ortho_2D(const LFrustumd self, double l, double r, double t, double b)\n"
  "\n"
  "/**\n"
  " * Sets up a two-dimensional orthographic frustum\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets up a two-dimensional orthographic frustum\n"
  " */";
#else
static const char *Dtool_LFrustumd_make_ortho_2D_660_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LFrustumd::make_ortho(double fnear, double ffar)
 * inline void LFrustumd::make_ortho(double fnear, double ffar, double l, double r, double t, double b)
 */
static PyObject *Dtool_LFrustumd_make_ortho_661(PyObject *self, PyObject *args, PyObject *kwds) {
  LFrustumd *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LFrustumd, (void **)&local_this, "LFrustumd.make_ortho")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline void LFrustumd::make_ortho(double fnear, double ffar)
      double param1;
      double param2;
      static const char *keyword_list[] = {"fnear", "ffar", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:make_ortho", (char **)keyword_list, &param1, &param2)) {
        ((*local_this).make_ortho)((double)param1, (double)param2);
        return Dtool_Return_None();
      }
    }
    break;
  case 6:
    {
      // 1-inline void LFrustumd::make_ortho(double fnear, double ffar, double l, double r, double t, double b)
      double param1;
      double param2;
      double param3;
      double param4;
      double param5;
      double param6;
      static const char *keyword_list[] = {"fnear", "ffar", "l", "r", "t", "b", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dddddd:make_ortho", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        ((*local_this).make_ortho)((double)param1, (double)param2, (double)param3, (double)param4, (double)param5, (double)param6);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make_ortho() takes 3 or 7 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_ortho(const LFrustumd self, double fnear, double ffar)\n"
      "make_ortho(const LFrustumd self, double fnear, double ffar, double l, double r, double t, double b)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LFrustumd_make_ortho_661_comment =
  "C++ Interface:\n"
  "make_ortho(const LFrustumd self, double fnear, double ffar)\n"
  "make_ortho(const LFrustumd self, double fnear, double ffar, double l, double r, double t, double b)\n"
  "\n"
  "/**\n"
  " * Behaves like gluOrtho\n"
  " */\n"
  "\n"
  "/**\n"
  " * Behaves like gluOrtho\n"
  " */";
#else
static const char *Dtool_LFrustumd_make_ortho_661_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LFrustumd::make_perspective_hfov(double xfov, double aspect, double fnear, double ffar)
 */
static PyObject *Dtool_LFrustumd_make_perspective_hfov_662(PyObject *self, PyObject *args, PyObject *kwds) {
  LFrustumd *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LFrustumd, (void **)&local_this, "LFrustumd.make_perspective_hfov")) {
    return nullptr;
  }
  // 1-inline void LFrustumd::make_perspective_hfov(double xfov, double aspect, double fnear, double ffar)
  double param1;
  double param2;
  double param3;
  double param4;
  static const char *keyword_list[] = {"xfov", "aspect", "fnear", "ffar", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dddd:make_perspective_hfov", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    ((*local_this).make_perspective_hfov)((double)param1, (double)param2, (double)param3, (double)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_perspective_hfov(const LFrustumd self, double xfov, double aspect, double fnear, double ffar)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LFrustumd_make_perspective_hfov_662_comment =
  "C++ Interface:\n"
  "make_perspective_hfov(const LFrustumd self, double xfov, double aspect, double fnear, double ffar)\n"
  "\n"
  "/**\n"
  " * Behaves like gluPerspective (Aspect = width/height, Yfov in degrees) aspect\n"
  " * +------------+ |            | 1 |            | yfov |            |\n"
  " * +------------+\n"
  " *\n"
  " * -------+------ \\     | \\    | \\   | \\  | \\ | \\| W yfov\n"
  " *\n"
  " */";
#else
static const char *Dtool_LFrustumd_make_perspective_hfov_662_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LFrustumd::make_perspective_vfov(double yfov, double aspect, double fnear, double ffar)
 */
static PyObject *Dtool_LFrustumd_make_perspective_vfov_663(PyObject *self, PyObject *args, PyObject *kwds) {
  LFrustumd *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LFrustumd, (void **)&local_this, "LFrustumd.make_perspective_vfov")) {
    return nullptr;
  }
  // 1-inline void LFrustumd::make_perspective_vfov(double yfov, double aspect, double fnear, double ffar)
  double param1;
  double param2;
  double param3;
  double param4;
  static const char *keyword_list[] = {"yfov", "aspect", "fnear", "ffar", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dddd:make_perspective_vfov", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    ((*local_this).make_perspective_vfov)((double)param1, (double)param2, (double)param3, (double)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_perspective_vfov(const LFrustumd self, double yfov, double aspect, double fnear, double ffar)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LFrustumd_make_perspective_vfov_663_comment =
  "C++ Interface:\n"
  "make_perspective_vfov(const LFrustumd self, double yfov, double aspect, double fnear, double ffar)\n";
#else
static const char *Dtool_LFrustumd_make_perspective_vfov_663_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LFrustumd::make_perspective(double xfov, double yfov, double fnear, double ffar)
 */
static PyObject *Dtool_LFrustumd_make_perspective_664(PyObject *self, PyObject *args, PyObject *kwds) {
  LFrustumd *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LFrustumd, (void **)&local_this, "LFrustumd.make_perspective")) {
    return nullptr;
  }
  // 1-inline void LFrustumd::make_perspective(double xfov, double yfov, double fnear, double ffar)
  double param1;
  double param2;
  double param3;
  double param4;
  static const char *keyword_list[] = {"xfov", "yfov", "fnear", "ffar", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dddd:make_perspective", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    ((*local_this).make_perspective)((double)param1, (double)param2, (double)param3, (double)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_perspective(const LFrustumd self, double xfov, double yfov, double fnear, double ffar)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LFrustumd_make_perspective_664_comment =
  "C++ Interface:\n"
  "make_perspective(const LFrustumd self, double xfov, double yfov, double fnear, double ffar)\n";
#else
static const char *Dtool_LFrustumd_make_perspective_664_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LFrustumd::LFrustumd(void)
 * inline LFrustumd::LFrustumd(LFrustumd const &) = default
 */
static int Dtool_Init_LFrustumd(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("LFrustumd() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LFrustumd::LFrustumd(void)
      LFrustumd *return_value = new LFrustumd();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LFrustumd, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline LFrustumd::LFrustumd(LFrustumd const &) = default
      LFrustumd const *arg_this = (LFrustumd *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LFrustumd, 0, "LFrustumd.LFrustumd", true, true);
      if (arg_this != nullptr) {
        LFrustumd *return_value = new LFrustumd(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LFrustumd, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LFrustumd() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LFrustumd()\n"
      "LFrustumd(const LFrustumd param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LFrustumd(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LFrustumd) {
    printf("LFrustumd ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LFrustumd *local_this = (LFrustumd *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LFrustumd) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LFrustumd(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LFrustumd) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BoundingHexahedron
 */
/**
 * Python function wrapper for:
 * inline int BoundingHexahedron::get_num_points(void) const
 */
static PyObject *Dtool_BoundingHexahedron_get_num_points_673(PyObject *self, PyObject *) {
  BoundingHexahedron *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BoundingHexahedron)) {
    return nullptr;
  }
  // 1-inline int BoundingHexahedron::get_num_points(void) const
  int return_value = ((*(const BoundingHexahedron*)local_this).get_num_points)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BoundingHexahedron_get_num_points_673_comment =
  "C++ Interface:\n"
  "get_num_points(BoundingHexahedron self)\n"
  "\n"
  "/**\n"
  " * Returns 8: the number of vertices of a hexahedron.\n"
  " */";
#else
static const char *Dtool_BoundingHexahedron_get_num_points_673_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 BoundingHexahedron::get_point(int n) const
 */
static PyObject *Dtool_BoundingHexahedron_get_point_674(PyObject *self, PyObject *arg) {
  BoundingHexahedron *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BoundingHexahedron)) {
    return nullptr;
  }
  // 1-inline LPoint3 BoundingHexahedron::get_point(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPoint3 *return_value = new LPoint3(((*(const BoundingHexahedron*)local_this).get_point)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point(BoundingHexahedron self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BoundingHexahedron_get_point_674_comment =
  "C++ Interface:\n"
  "get_point(BoundingHexahedron self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth vertex of the hexahedron.\n"
  " */";
#else
static const char *Dtool_BoundingHexahedron_get_point_674_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BoundingHexahedron::get_num_planes(void) const
 */
static PyObject *Dtool_BoundingHexahedron_get_num_planes_676(PyObject *self, PyObject *) {
  BoundingHexahedron *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BoundingHexahedron)) {
    return nullptr;
  }
  // 1-inline int BoundingHexahedron::get_num_planes(void) const
  int return_value = ((*(const BoundingHexahedron*)local_this).get_num_planes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BoundingHexahedron_get_num_planes_676_comment =
  "C++ Interface:\n"
  "get_num_planes(BoundingHexahedron self)\n"
  "\n"
  "/**\n"
  " * Returns 6: the number of faces of a hexahedron.\n"
  " */";
#else
static const char *Dtool_BoundingHexahedron_get_num_planes_676_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPlane BoundingHexahedron::get_plane(int n) const
 */
static PyObject *Dtool_BoundingHexahedron_get_plane_677(PyObject *self, PyObject *arg) {
  BoundingHexahedron *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BoundingHexahedron)) {
    return nullptr;
  }
  // 1-inline LPlane BoundingHexahedron::get_plane(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPlane *return_value = new LPlane(((*(const BoundingHexahedron*)local_this).get_plane)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_plane(BoundingHexahedron self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BoundingHexahedron_get_plane_677_comment =
  "C++ Interface:\n"
  "get_plane(BoundingHexahedron self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth face of the hexahedron.\n"
  " */";
#else
static const char *Dtool_BoundingHexahedron_get_plane_677_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BoundingHexahedron::get_class_type(void)
 */
static PyObject *Dtool_BoundingHexahedron_get_class_type_681(PyObject *, PyObject *) {
  // 1-static TypeHandle BoundingHexahedron::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((BoundingHexahedron::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BoundingHexahedron_get_class_type_681_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BoundingHexahedron_get_class_type_681_comment = nullptr;
#endif

/**
 * sequence length function for property BoundingHexahedron::points
 */
static Py_ssize_t Dtool_BoundingHexahedron_points_Len(PyObject *self) {
  BoundingHexahedron *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingHexahedron, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_points)();
}

/**
 * sequence getter for property BoundingHexahedron::points
 */
static PyObject *Dtool_BoundingHexahedron_points_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  BoundingHexahedron *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingHexahedron, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_points)()) {
    PyErr_SetString(PyExc_IndexError, "BoundingHexahedron.points[] index out of range");
    return nullptr;
  }
  // 1-inline LPoint3 BoundingHexahedron::get_point(int n) const
  LPoint3 *return_value = new LPoint3(((*(const BoundingHexahedron*)local_this).get_point)(index));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point(BoundingHexahedron self, index)\n");
  }
}

static PyObject *Dtool_BoundingHexahedron_points_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "BoundingHexahedron.points");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_BoundingHexahedron_points_Len;
    wrap->_getitem_func = &Dtool_BoundingHexahedron_points_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * sequence length function for property BoundingHexahedron::planes
 */
static Py_ssize_t Dtool_BoundingHexahedron_planes_Len(PyObject *self) {
  BoundingHexahedron *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingHexahedron, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_planes)();
}

/**
 * sequence getter for property BoundingHexahedron::planes
 */
static PyObject *Dtool_BoundingHexahedron_planes_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  BoundingHexahedron *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingHexahedron, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_planes)()) {
    PyErr_SetString(PyExc_IndexError, "BoundingHexahedron.planes[] index out of range");
    return nullptr;
  }
  // 1-inline LPlane BoundingHexahedron::get_plane(int n) const
  LPlane *return_value = new LPlane(((*(const BoundingHexahedron*)local_this).get_plane)(index));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_plane(BoundingHexahedron self, index)\n");
  }
}

static PyObject *Dtool_BoundingHexahedron_planes_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "BoundingHexahedron.planes");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_BoundingHexahedron_planes_Len;
    wrap->_getitem_func = &Dtool_BoundingHexahedron_planes_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * BoundingHexahedron::BoundingHexahedron(LFrustum const &frustum, bool is_ortho, CoordinateSystem cs = ::CS_default)
 * BoundingHexahedron::BoundingHexahedron(LPoint3 const &fll, LPoint3 const &flr, LPoint3 const &fur, LPoint3 const &ful, LPoint3 const &nll, LPoint3 const &nlr, LPoint3 const &nur, LPoint3 const &nul)
 */
static int Dtool_Init_BoundingHexahedron(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-BoundingHexahedron::BoundingHexahedron(LFrustum const &frustum, bool is_ortho, CoordinateSystem cs)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"frustum", "is_ortho", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:BoundingHexahedron", (char **)keyword_list, &param0, &param1)) {
        LFrustum const *param0_this = (LFrustumf *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LFrustumf, 0, "BoundingHexahedron.BoundingHexahedron", true, true);
        if (param0_this != nullptr) {
          BoundingHexahedron *return_value = new BoundingHexahedron(*param0_this, (PyObject_IsTrue(param1) != 0));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BoundingHexahedron, true, false);
        }
      }
    }
    break;
  case 3:
    {
      // 1-BoundingHexahedron::BoundingHexahedron(LFrustum const &frustum, bool is_ortho, CoordinateSystem cs)
      PyObject *param0;
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"frustum", "is_ortho", "cs", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:BoundingHexahedron", (char **)keyword_list, &param0, &param1, &param2)) {
        LFrustum const *param0_this = (LFrustumf *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LFrustumf, 0, "BoundingHexahedron.BoundingHexahedron", true, true);
        if (param0_this != nullptr) {
          BoundingHexahedron *return_value = new BoundingHexahedron(*param0_this, (PyObject_IsTrue(param1) != 0), (CoordinateSystem)param2);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BoundingHexahedron, true, false);
        }
      }
    }
    break;
  case 8:
    {
      // 1-BoundingHexahedron::BoundingHexahedron(LPoint3 const &fll, LPoint3 const &flr, LPoint3 const &fur, LPoint3 const &ful, LPoint3 const &nll, LPoint3 const &nlr, LPoint3 const &nur, LPoint3 const &nul)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      PyObject *param5;
      PyObject *param6;
      PyObject *param7;
      static const char *keyword_list[] = {"fll", "flr", "fur", "ful", "nll", "nlr", "nur", "nul", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOO:BoundingHexahedron", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param0, 0, "BoundingHexahedron.BoundingHexahedron", "LPoint3f");
          return -1;
        }
        LPoint3f param1_local;
        LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param1, 1, "BoundingHexahedron.BoundingHexahedron", "LPoint3f");
          return -1;
        }
        LPoint3f param2_local;
        LPoint3 const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param2, 2, "BoundingHexahedron.BoundingHexahedron", "LPoint3f");
          return -1;
        }
        LPoint3f param3_local;
        LPoint3 const *param3_this = Dtool_Coerce_LPoint3f(param3, param3_local);
        if (!(param3_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param3, 3, "BoundingHexahedron.BoundingHexahedron", "LPoint3f");
          return -1;
        }
        LPoint3f param4_local;
        LPoint3 const *param4_this = Dtool_Coerce_LPoint3f(param4, param4_local);
        if (!(param4_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param4, 4, "BoundingHexahedron.BoundingHexahedron", "LPoint3f");
          return -1;
        }
        LPoint3f param5_local;
        LPoint3 const *param5_this = Dtool_Coerce_LPoint3f(param5, param5_local);
        if (!(param5_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param5, 5, "BoundingHexahedron.BoundingHexahedron", "LPoint3f");
          return -1;
        }
        LPoint3f param6_local;
        LPoint3 const *param6_this = Dtool_Coerce_LPoint3f(param6, param6_local);
        if (!(param6_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param6, 6, "BoundingHexahedron.BoundingHexahedron", "LPoint3f");
          return -1;
        }
        LPoint3f param7_local;
        LPoint3 const *param7_this = Dtool_Coerce_LPoint3f(param7, param7_local);
        if (!(param7_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param7, 7, "BoundingHexahedron.BoundingHexahedron", "LPoint3f");
          return -1;
        }
        BoundingHexahedron *return_value = new BoundingHexahedron(*param0_this, *param1_this, *param2_this, *param3_this, *param4_this, *param5_this, *param6_this, *param7_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BoundingHexahedron, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BoundingHexahedron() takes 2, 3 or 8 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BoundingHexahedron(const LFrustumf frustum, bool is_ortho)\n"
      "BoundingHexahedron(const LFrustumf frustum, bool is_ortho, int cs)\n"
      "BoundingHexahedron(const LPoint3f fll, const LPoint3f flr, const LPoint3f fur, const LPoint3f ful, const LPoint3f nll, const LPoint3f nlr, const LPoint3f nur, const LPoint3f nul)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_BoundingHexahedron(PyObject *args, CPT(BoundingHexahedron) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BoundingHexahedron)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-BoundingHexahedron::BoundingHexahedron(LFrustum const &frustum, bool is_ortho, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "BoundingHexahedron", 2, 2, &param0, &param1)) {
          LFrustum const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LFrustumf);
          if (param0_this != nullptr) {
            BoundingHexahedron *return_value = new BoundingHexahedron(*param0_this, (PyObject_IsTrue(param1) != 0));
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = std::move(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-BoundingHexahedron::BoundingHexahedron(LFrustum const &frustum, bool is_ortho, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        if (PyArg_ParseTuple(args, "OOi:BoundingHexahedron", &param0, &param1, &param2)) {
          LFrustum const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LFrustumf);
          if (param0_this != nullptr) {
            BoundingHexahedron *return_value = new BoundingHexahedron(*param0_this, (PyObject_IsTrue(param1) != 0), (CoordinateSystem)param2);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = std::move(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 8: {
        // 1-BoundingHexahedron::BoundingHexahedron(LPoint3 const &fll, LPoint3 const &flr, LPoint3 const &fur, LPoint3 const &ful, LPoint3 const &nll, LPoint3 const &nlr, LPoint3 const &nur, LPoint3 const &nul)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        PyObject *param5;
        PyObject *param6;
        PyObject *param7;
        if (PyArg_UnpackTuple(args, "BoundingHexahedron", 8, 8, &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
          LPoint3 const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LPoint3f);
          LPoint3 const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LPoint3f);
          LPoint3 const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LPoint3f);
          LPoint3 const *param3_this = nullptr;
          DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_LPoint3f);
          LPoint3 const *param4_this = nullptr;
          DtoolInstance_GetPointer(param4, param4_this, *Dtool_Ptr_LPoint3f);
          LPoint3 const *param5_this = nullptr;
          DtoolInstance_GetPointer(param5, param5_this, *Dtool_Ptr_LPoint3f);
          LPoint3 const *param6_this = nullptr;
          DtoolInstance_GetPointer(param6, param6_this, *Dtool_Ptr_LPoint3f);
          LPoint3 const *param7_this = nullptr;
          DtoolInstance_GetPointer(param7, param7_this, *Dtool_Ptr_LPoint3f);
          if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr && param3_this != nullptr && param4_this != nullptr && param5_this != nullptr && param6_this != nullptr && param7_this != nullptr) {
            BoundingHexahedron *return_value = new BoundingHexahedron(*param0_this, *param1_this, *param2_this, *param3_this, *param4_this, *param5_this, *param6_this, *param7_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = std::move(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_BoundingHexahedron(PyObject *args, PT(BoundingHexahedron) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BoundingHexahedron)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-BoundingHexahedron::BoundingHexahedron(LFrustum const &frustum, bool is_ortho, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "BoundingHexahedron", 2, 2, &param0, &param1)) {
          LFrustum const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LFrustumf);
          if (param0_this != nullptr) {
            BoundingHexahedron *return_value = new BoundingHexahedron(*param0_this, (PyObject_IsTrue(param1) != 0));
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = std::move(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-BoundingHexahedron::BoundingHexahedron(LFrustum const &frustum, bool is_ortho, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        int param2;
        if (PyArg_ParseTuple(args, "OOi:BoundingHexahedron", &param0, &param1, &param2)) {
          LFrustum const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LFrustumf);
          if (param0_this != nullptr) {
            BoundingHexahedron *return_value = new BoundingHexahedron(*param0_this, (PyObject_IsTrue(param1) != 0), (CoordinateSystem)param2);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = std::move(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 8: {
        // 1-BoundingHexahedron::BoundingHexahedron(LPoint3 const &fll, LPoint3 const &flr, LPoint3 const &fur, LPoint3 const &ful, LPoint3 const &nll, LPoint3 const &nlr, LPoint3 const &nur, LPoint3 const &nul)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        PyObject *param5;
        PyObject *param6;
        PyObject *param7;
        if (PyArg_UnpackTuple(args, "BoundingHexahedron", 8, 8, &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
          LPoint3 const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LPoint3f);
          LPoint3 const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LPoint3f);
          LPoint3 const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LPoint3f);
          LPoint3 const *param3_this = nullptr;
          DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_LPoint3f);
          LPoint3 const *param4_this = nullptr;
          DtoolInstance_GetPointer(param4, param4_this, *Dtool_Ptr_LPoint3f);
          LPoint3 const *param5_this = nullptr;
          DtoolInstance_GetPointer(param5, param5_this, *Dtool_Ptr_LPoint3f);
          LPoint3 const *param6_this = nullptr;
          DtoolInstance_GetPointer(param6, param6_this, *Dtool_Ptr_LPoint3f);
          LPoint3 const *param7_this = nullptr;
          DtoolInstance_GetPointer(param7, param7_this, *Dtool_Ptr_LPoint3f);
          if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr && param3_this != nullptr && param4_this != nullptr && param5_this != nullptr && param6_this != nullptr && param7_this != nullptr) {
            BoundingHexahedron *return_value = new BoundingHexahedron(*param0_this, *param1_this, *param2_this, *param3_this, *param4_this, *param5_this, *param6_this, *param7_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = std::move(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_BoundingHexahedron_get_points(PyObject *self, PyObject *) {
  BoundingHexahedron *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingHexahedron, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_points)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_BoundingHexahedron_get_point_674(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_BoundingHexahedron_get_planes(PyObject *self, PyObject *) {
  BoundingHexahedron *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingHexahedron, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_planes)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_BoundingHexahedron_get_plane_677(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_BoundingHexahedron(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BoundingHexahedron) {
    printf("BoundingHexahedron ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BoundingHexahedron *local_this = (BoundingHexahedron *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BoundingHexahedron) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BoundingVolume) {
    return (BoundingVolume *)(GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_FiniteBoundingVolume) {
    return (FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeometricBoundingVolume) {
    return (GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BoundingHexahedron(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BoundingHexahedron) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BoundingVolume) {
    BoundingVolume* other_this = (BoundingVolume*)from_this;
    return (BoundingHexahedron*)other_this;
  }
  if (from_type == Dtool_Ptr_FiniteBoundingVolume) {
    FiniteBoundingVolume* other_this = (FiniteBoundingVolume*)from_this;
    return (BoundingHexahedron*)other_this;
  }
  if (from_type == Dtool_Ptr_GeometricBoundingVolume) {
    GeometricBoundingVolume* other_this = (GeometricBoundingVolume*)from_this;
    return (BoundingHexahedron*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BoundingHexahedron*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BoundingHexahedron*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (BoundingHexahedron*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BoundingLine
 */
/**
 * Python function wrapper for:
 * inline LPoint3 const &BoundingLine::get_point_a(void) const
 */
static PyObject *Dtool_BoundingLine_get_point_a_688(PyObject *self, PyObject *) {
  BoundingLine *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BoundingLine)) {
    return nullptr;
  }
  // 1-inline LPoint3 const &BoundingLine::get_point_a(void) const
  LPoint3 const *return_value = &(((*(const BoundingLine*)local_this).get_point_a)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_BoundingLine_get_point_a_688_comment =
  "C++ Interface:\n"
  "get_point_a(BoundingLine self)\n"
  "\n"
  "/**\n"
  " * Returns the first point that defines the line.\n"
  " */";
#else
static const char *Dtool_BoundingLine_get_point_a_688_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 BoundingLine::get_point_b(void) const
 */
static PyObject *Dtool_BoundingLine_get_point_b_689(PyObject *self, PyObject *) {
  BoundingLine *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BoundingLine)) {
    return nullptr;
  }
  // 1-inline LPoint3 BoundingLine::get_point_b(void) const
  LPoint3 *return_value = new LPoint3(((*(const BoundingLine*)local_this).get_point_b)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BoundingLine_get_point_b_689_comment =
  "C++ Interface:\n"
  "get_point_b(BoundingLine self)\n"
  "\n"
  "/**\n"
  " * Returns the second point that defines the line.\n"
  " */";
#else
static const char *Dtool_BoundingLine_get_point_b_689_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BoundingLine::get_class_type(void)
 */
static PyObject *Dtool_BoundingLine_get_class_type_690(PyObject *, PyObject *) {
  // 1-static TypeHandle BoundingLine::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((BoundingLine::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BoundingLine_get_class_type_690_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BoundingLine_get_class_type_690_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline explicit BoundingLine::BoundingLine(LPoint3 const &a, LPoint3 const &b)
 */
static int Dtool_Init_BoundingLine(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-inline explicit BoundingLine::BoundingLine(LPoint3 const &a, LPoint3 const &b)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"a", "b", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:BoundingLine", (char **)keyword_list, &param0, &param1)) {
    LPoint3f param0_local;
    LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
    if (!(param0_this != nullptr)) {
      Dtool_Raise_ArgTypeError(param0, 0, "BoundingLine.BoundingLine", "LPoint3f");
      return -1;
    }
    LPoint3f param1_local;
    LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      Dtool_Raise_ArgTypeError(param1, 1, "BoundingLine.BoundingLine", "LPoint3f");
      return -1;
    }
    BoundingLine *return_value = new BoundingLine(*param0_this, *param1_this);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BoundingLine, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BoundingLine(const LPoint3f a, const LPoint3f b)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_BoundingLine(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BoundingLine) {
    printf("BoundingLine ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BoundingLine *local_this = (BoundingLine *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BoundingLine) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BoundingVolume) {
    return (BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeometricBoundingVolume) {
    return (GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BoundingLine(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BoundingLine) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BoundingVolume) {
    BoundingVolume* other_this = (BoundingVolume*)from_this;
    return (BoundingLine*)other_this;
  }
  if (from_type == Dtool_Ptr_GeometricBoundingVolume) {
    GeometricBoundingVolume* other_this = (GeometricBoundingVolume*)from_this;
    return (BoundingLine*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BoundingLine*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BoundingLine*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (BoundingLine*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BoundingPlane
 */
/**
 * Python function wrapper for:
 * inline LPlane const &BoundingPlane::get_plane(void) const
 */
static PyObject *Dtool_BoundingPlane_get_plane_697(PyObject *self, PyObject *) {
  BoundingPlane *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BoundingPlane)) {
    return nullptr;
  }
  // 1-inline LPlane const &BoundingPlane::get_plane(void) const
  LPlane const *return_value = &(((*(const BoundingPlane*)local_this).get_plane)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, false, true);
}

#ifndef NDEBUG
static const char *Dtool_BoundingPlane_get_plane_697_comment =
  "C++ Interface:\n"
  "get_plane(BoundingPlane self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_BoundingPlane_get_plane_697_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BoundingPlane::get_class_type(void)
 */
static PyObject *Dtool_BoundingPlane_get_class_type_700(PyObject *, PyObject *) {
  // 1-static TypeHandle BoundingPlane::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((BoundingPlane::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BoundingPlane_get_class_type_700_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BoundingPlane_get_class_type_700_comment = nullptr;
#endif

static PyObject *Dtool_BoundingPlane_plane_Getter(PyObject *self, void *) {
  const BoundingPlane *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingPlane, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LPlane const &BoundingPlane::get_plane(void) const
  LPlane const *return_value = &(((*(const BoundingPlane*)local_this).get_plane)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, false, true);
}

/**
 * Python function wrapper for:
 * inline BoundingPlane::BoundingPlane(void)
 * inline BoundingPlane::BoundingPlane(LPlane const &plane)
 */
static int Dtool_Init_BoundingPlane(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline BoundingPlane::BoundingPlane(void)
      BoundingPlane *return_value = new BoundingPlane();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BoundingPlane, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "plane")) {
        // 1-inline BoundingPlane::BoundingPlane(LPlane const &plane)
        LPlanef arg_local;
        LPlane const *arg_this = Dtool_Coerce_LPlanef(arg, arg_local);
        if (!(arg_this != nullptr)) {
          Dtool_Raise_ArgTypeError(arg, 0, "BoundingPlane.BoundingPlane", "LPlanef");
          return -1;
        }
        BoundingPlane *return_value = new BoundingPlane(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BoundingPlane, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BoundingPlane() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BoundingPlane()\n"
      "BoundingPlane(const LPlanef plane)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_BoundingPlane(PyObject *args, CPT(BoundingPlane) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BoundingPlane)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline BoundingPlane::BoundingPlane(LPlane const &plane)
    LPlane const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LPlanef);
    if (arg_this != nullptr) {
      BoundingPlane *return_value = new BoundingPlane(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_BoundingPlane(PyObject *args, PT(BoundingPlane) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_BoundingPlane)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline BoundingPlane::BoundingPlane(LPlane const &plane)
    LPlane const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LPlanef);
    if (arg_this != nullptr) {
      BoundingPlane *return_value = new BoundingPlane(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_BoundingPlane(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BoundingPlane) {
    printf("BoundingPlane ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BoundingPlane *local_this = (BoundingPlane *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BoundingPlane) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BoundingVolume) {
    return (BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeometricBoundingVolume) {
    return (GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BoundingPlane(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BoundingPlane) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BoundingVolume) {
    BoundingVolume* other_this = (BoundingVolume*)from_this;
    return (BoundingPlane*)other_this;
  }
  if (from_type == Dtool_Ptr_GeometricBoundingVolume) {
    GeometricBoundingVolume* other_this = (GeometricBoundingVolume*)from_this;
    return (BoundingPlane*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BoundingPlane*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BoundingPlane*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (BoundingPlane*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BoundingSphere
 */
/**
 * Python function wrapper for:
 * inline LPoint3 BoundingSphere::get_center(void) const
 */
static PyObject *Dtool_BoundingSphere_get_center_707(PyObject *self, PyObject *) {
  BoundingSphere *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BoundingSphere)) {
    return nullptr;
  }
  // 1-inline LPoint3 BoundingSphere::get_center(void) const
  LPoint3 *return_value = new LPoint3(((*(const BoundingSphere*)local_this).get_center)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BoundingSphere_get_center_707_comment =
  "C++ Interface:\n"
  "get_center(BoundingSphere self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_BoundingSphere_get_center_707_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat BoundingSphere::get_radius(void) const
 */
static PyObject *Dtool_BoundingSphere_get_radius_708(PyObject *self, PyObject *) {
  BoundingSphere *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BoundingSphere)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat BoundingSphere::get_radius(void) const
  PN_stdfloat return_value = ((*(const BoundingSphere*)local_this).get_radius)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BoundingSphere_get_radius_708_comment =
  "C++ Interface:\n"
  "get_radius(BoundingSphere self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_BoundingSphere_get_radius_708_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BoundingSphere::set_center(LPoint3 const &center)
 */
static PyObject *Dtool_BoundingSphere_set_center_709(PyObject *self, PyObject *arg) {
  BoundingSphere *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BoundingSphere, (void **)&local_this, "BoundingSphere.set_center")) {
    return nullptr;
  }
  // 1-inline void BoundingSphere::set_center(LPoint3 const &center)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BoundingSphere.set_center", "LPoint3f");
  }
  ((*local_this).set_center)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_center(const BoundingSphere self, const LPoint3f center)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BoundingSphere_set_center_709_comment =
  "C++ Interface:\n"
  "set_center(const BoundingSphere self, const LPoint3f center)\n"
  "\n"
  "/**\n"
  " * Sets the center point of the sphere.\n"
  " */";
#else
static const char *Dtool_BoundingSphere_set_center_709_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BoundingSphere::set_radius(PN_stdfloat radius)
 */
static PyObject *Dtool_BoundingSphere_set_radius_710(PyObject *self, PyObject *arg) {
  BoundingSphere *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BoundingSphere, (void **)&local_this, "BoundingSphere.set_radius")) {
    return nullptr;
  }
  // 1-inline void BoundingSphere::set_radius(PN_stdfloat radius)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_radius)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_radius(const BoundingSphere self, float radius)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BoundingSphere_set_radius_710_comment =
  "C++ Interface:\n"
  "set_radius(const BoundingSphere self, float radius)\n"
  "\n"
  "/**\n"
  " * Sets the radius of the sphere.\n"
  " */";
#else
static const char *Dtool_BoundingSphere_set_radius_710_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BoundingSphere::get_class_type(void)
 */
static PyObject *Dtool_BoundingSphere_get_class_type_713(PyObject *, PyObject *) {
  // 1-static TypeHandle BoundingSphere::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((BoundingSphere::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BoundingSphere_get_class_type_713_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BoundingSphere_get_class_type_713_comment = nullptr;
#endif

static PyObject *Dtool_BoundingSphere_center_Getter(PyObject *self, void *) {
  const BoundingSphere *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingSphere, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LPoint3 BoundingSphere::get_center(void) const
  LPoint3 *return_value = new LPoint3(((*(const BoundingSphere*)local_this).get_center)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

static int Dtool_BoundingSphere_center_Setter(PyObject *self, PyObject *arg, void *) {
  BoundingSphere *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BoundingSphere, (void **)&local_this, "BoundingSphere.center")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete center attribute");
    return -1;
  }
  // 1-inline void BoundingSphere::set_center(LPoint3 const &center)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "BoundingSphere.set_center", "LPoint3f");
    return -1;
  }
  ((*local_this).set_center)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_center(const BoundingSphere self, const LPoint3f center)\n");
  }
  return -1;
}

static PyObject *Dtool_BoundingSphere_radius_Getter(PyObject *self, void *) {
  const BoundingSphere *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingSphere, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat BoundingSphere::get_radius(void) const
  PN_stdfloat return_value = ((*(const BoundingSphere*)local_this).get_radius)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_BoundingSphere_radius_Setter(PyObject *self, PyObject *arg, void *) {
  BoundingSphere *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BoundingSphere, (void **)&local_this, "BoundingSphere.radius")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete radius attribute");
    return -1;
  }
  // 1-inline void BoundingSphere::set_radius(PN_stdfloat radius)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_radius)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_radius(const BoundingSphere self, float radius)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline BoundingSphere::BoundingSphere(void)
 * inline explicit BoundingSphere::BoundingSphere(LPoint3 const &center, PN_stdfloat radius)
 */
static int Dtool_Init_BoundingSphere(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline BoundingSphere::BoundingSphere(void)
      BoundingSphere *return_value = new BoundingSphere();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BoundingSphere, true, false);
    }
    break;
  case 2:
    {
      // 1-inline explicit BoundingSphere::BoundingSphere(LPoint3 const &center, PN_stdfloat radius)
      PyObject *param0;
      float param1;
      static const char *keyword_list[] = {"center", "radius", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:BoundingSphere", (char **)keyword_list, &param0, &param1)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param0, 0, "BoundingSphere.BoundingSphere", "LPoint3f");
          return -1;
        }
        BoundingSphere *return_value = new BoundingSphere(*param0_this, (PN_stdfloat)param1);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BoundingSphere, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BoundingSphere() takes 0 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BoundingSphere()\n"
      "BoundingSphere(const LPoint3f center, float radius)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_BoundingSphere(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BoundingSphere) {
    printf("BoundingSphere ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BoundingSphere *local_this = (BoundingSphere *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BoundingSphere) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BoundingVolume) {
    return (BoundingVolume *)(GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_FiniteBoundingVolume) {
    return (FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeometricBoundingVolume) {
    return (GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *)(FiniteBoundingVolume *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BoundingSphere(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BoundingSphere) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BoundingVolume) {
    BoundingVolume* other_this = (BoundingVolume*)from_this;
    return (BoundingSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_FiniteBoundingVolume) {
    FiniteBoundingVolume* other_this = (FiniteBoundingVolume*)from_this;
    return (BoundingSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_GeometricBoundingVolume) {
    GeometricBoundingVolume* other_this = (GeometricBoundingVolume*)from_this;
    return (BoundingSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BoundingSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BoundingSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (BoundingSphere*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class IntersectionBoundingVolume
 */
/**
 * Python function wrapper for:
 * inline int IntersectionBoundingVolume::get_num_components(void) const
 */
static PyObject *Dtool_IntersectionBoundingVolume_get_num_components_720(PyObject *self, PyObject *) {
  IntersectionBoundingVolume *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_IntersectionBoundingVolume)) {
    return nullptr;
  }
  // 1-inline int IntersectionBoundingVolume::get_num_components(void) const
  int return_value = ((*(const IntersectionBoundingVolume*)local_this).get_num_components)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_IntersectionBoundingVolume_get_num_components_720_comment =
  "C++ Interface:\n"
  "get_num_components(IntersectionBoundingVolume self)\n"
  "\n"
  "/**\n"
  " * Returns the number of components in the intersection.\n"
  " */";
#else
static const char *Dtool_IntersectionBoundingVolume_get_num_components_720_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeometricBoundingVolume const *IntersectionBoundingVolume::get_component(int n) const
 */
static PyObject *Dtool_IntersectionBoundingVolume_get_component_721(PyObject *self, PyObject *arg) {
  IntersectionBoundingVolume *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_IntersectionBoundingVolume)) {
    return nullptr;
  }
  // 1-inline GeometricBoundingVolume const *IntersectionBoundingVolume::get_component(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    GeometricBoundingVolume const *return_value = ((*(const IntersectionBoundingVolume*)local_this).get_component)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GeometricBoundingVolume, true, true, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_component(IntersectionBoundingVolume self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_IntersectionBoundingVolume_get_component_721_comment =
  "C++ Interface:\n"
  "get_component(IntersectionBoundingVolume self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth component in the intersection.\n"
  " */";
#else
static const char *Dtool_IntersectionBoundingVolume_get_component_721_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void IntersectionBoundingVolume::clear_components(void)
 */
static PyObject *Dtool_IntersectionBoundingVolume_clear_components_726(PyObject *self, PyObject *) {
  IntersectionBoundingVolume *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IntersectionBoundingVolume, (void **)&local_this, "IntersectionBoundingVolume.clear_components")) {
    return nullptr;
  }
  // 1-void IntersectionBoundingVolume::clear_components(void)
  ((*local_this).clear_components)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_IntersectionBoundingVolume_clear_components_726_comment =
  "C++ Interface:\n"
  "clear_components(const IntersectionBoundingVolume self)\n"
  "\n"
  "/**\n"
  " * Removes all components from the volume.\n"
  " */";
#else
static const char *Dtool_IntersectionBoundingVolume_clear_components_726_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void IntersectionBoundingVolume::add_component(GeometricBoundingVolume const *component)
 */
static PyObject *Dtool_IntersectionBoundingVolume_add_component_727(PyObject *self, PyObject *arg) {
  IntersectionBoundingVolume *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IntersectionBoundingVolume, (void **)&local_this, "IntersectionBoundingVolume.add_component")) {
    return nullptr;
  }
  // 1-void IntersectionBoundingVolume::add_component(GeometricBoundingVolume const *component)
  GeometricBoundingVolume const *arg_this = (GeometricBoundingVolume *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeometricBoundingVolume, 1, "IntersectionBoundingVolume.add_component", true, true);
  if (arg_this != nullptr) {
    ((*local_this).add_component)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_component(const IntersectionBoundingVolume self, const GeometricBoundingVolume component)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_IntersectionBoundingVolume_add_component_727_comment =
  "C++ Interface:\n"
  "add_component(const IntersectionBoundingVolume self, const GeometricBoundingVolume component)\n"
  "\n"
  "/**\n"
  " * Adds a new component to the volume.  This does not necessarily increase the\n"
  " * total number of components by one, and you may or may not be able to find\n"
  " * this component in the volume by a subsequent call to get_component();\n"
  " * certain optimizations may prevent the component from being added, or have\n"
  " * other unexpected effects on the total set of components.\n"
  " */";
#else
static const char *Dtool_IntersectionBoundingVolume_add_component_727_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle IntersectionBoundingVolume::get_class_type(void)
 */
static PyObject *Dtool_IntersectionBoundingVolume_get_class_type_728(PyObject *, PyObject *) {
  // 1-static TypeHandle IntersectionBoundingVolume::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((IntersectionBoundingVolume::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_IntersectionBoundingVolume_get_class_type_728_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_IntersectionBoundingVolume_get_class_type_728_comment = nullptr;
#endif

/**
 * sequence length function for property IntersectionBoundingVolume::components
 */
static Py_ssize_t Dtool_IntersectionBoundingVolume_components_Len(PyObject *self) {
  IntersectionBoundingVolume *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_IntersectionBoundingVolume, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_components)();
}

/**
 * sequence getter for property IntersectionBoundingVolume::components
 */
static PyObject *Dtool_IntersectionBoundingVolume_components_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  IntersectionBoundingVolume *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_IntersectionBoundingVolume, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_components)()) {
    PyErr_SetString(PyExc_IndexError, "IntersectionBoundingVolume.components[] index out of range");
    return nullptr;
  }
  // 1-inline GeometricBoundingVolume const *IntersectionBoundingVolume::get_component(int n) const
  GeometricBoundingVolume const *return_value = ((*(const IntersectionBoundingVolume*)local_this).get_component)(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GeometricBoundingVolume, true, true, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_component(IntersectionBoundingVolume self, index)\n");
  }
}

static PyObject *Dtool_IntersectionBoundingVolume_components_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "IntersectionBoundingVolume.components");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_IntersectionBoundingVolume_components_Len;
    wrap->_getitem_func = &Dtool_IntersectionBoundingVolume_components_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * inline IntersectionBoundingVolume::IntersectionBoundingVolume(void)
 */
static int Dtool_Init_IntersectionBoundingVolume(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("IntersectionBoundingVolume() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "IntersectionBoundingVolume() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-inline IntersectionBoundingVolume::IntersectionBoundingVolume(void)
  IntersectionBoundingVolume *return_value = new IntersectionBoundingVolume();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_IntersectionBoundingVolume, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "IntersectionBoundingVolume()\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_IntersectionBoundingVolume_get_components(PyObject *self, PyObject *) {
  IntersectionBoundingVolume *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_IntersectionBoundingVolume, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_components)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_IntersectionBoundingVolume_get_component_721(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_IntersectionBoundingVolume(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_IntersectionBoundingVolume) {
    printf("IntersectionBoundingVolume ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  IntersectionBoundingVolume *local_this = (IntersectionBoundingVolume *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_IntersectionBoundingVolume) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BoundingVolume) {
    return (BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeometricBoundingVolume) {
    return (GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_IntersectionBoundingVolume(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_IntersectionBoundingVolume) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BoundingVolume) {
    BoundingVolume* other_this = (BoundingVolume*)from_this;
    return (IntersectionBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_GeometricBoundingVolume) {
    GeometricBoundingVolume* other_this = (GeometricBoundingVolume*)from_this;
    return (IntersectionBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (IntersectionBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (IntersectionBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (IntersectionBoundingVolume*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Mersenne
 */
/**
 * Python function wrapper for:
 * unsigned long int Mersenne::get_uint31(void)
 */
static PyObject *Dtool_Mersenne_get_uint31_734(PyObject *self, PyObject *) {
  Mersenne *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Mersenne, (void **)&local_this, "Mersenne.get_uint31")) {
    return nullptr;
  }
  // 1-unsigned long int Mersenne::get_uint31(void)
  unsigned long int return_value = ((*local_this).get_uint31)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Mersenne_get_uint31_734_comment =
  "C++ Interface:\n"
  "get_uint31(const Mersenne self)\n"
  "\n"
  "/* generates a random number on [0,0x7fffffff]-interval */";
#else
static const char *Dtool_Mersenne_get_uint31_734_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Mersenne::Mersenne(Mersenne const &) = default
 * explicit Mersenne::Mersenne(unsigned long int seed)
 */
static int Dtool_Init_Mersenne(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "Mersenne() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline Mersenne::Mersenne(Mersenne const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      Mersenne const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_Mersenne);
      if (param0_this != nullptr) {
        Mersenne *return_value = new Mersenne(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Mersenne, true, false);
      }
    }
  }

  {
    // -2 explicit Mersenne::Mersenne(unsigned long int seed)
    unsigned long param0;
    static const char *keyword_list[] = {"seed", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "k:Mersenne", (char **)keyword_list, &param0)) {
      Mersenne *return_value = new Mersenne((unsigned long int)param0);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Mersenne, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: inline Mersenne::Mersenne(Mersenne const &) = default
  // No coercion possible: explicit Mersenne::Mersenne(unsigned long int seed)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Mersenne(const Mersenne param0)\n"
      "Mersenne(int seed)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Mersenne(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Mersenne) {
    printf("Mersenne ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Mersenne *local_this = (Mersenne *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Mersenne) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Mersenne(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Mersenne) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OmniBoundingVolume
 */
/**
 * Python function wrapper for:
 * static TypeHandle OmniBoundingVolume::get_class_type(void)
 */
static PyObject *Dtool_OmniBoundingVolume_get_class_type_739(PyObject *, PyObject *) {
  // 1-static TypeHandle OmniBoundingVolume::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OmniBoundingVolume::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OmniBoundingVolume_get_class_type_739_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OmniBoundingVolume_get_class_type_739_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline OmniBoundingVolume::OmniBoundingVolume(void)
 */
static int Dtool_Init_OmniBoundingVolume(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("OmniBoundingVolume() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "OmniBoundingVolume() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-inline OmniBoundingVolume::OmniBoundingVolume(void)
  OmniBoundingVolume *return_value = new OmniBoundingVolume();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OmniBoundingVolume, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OmniBoundingVolume()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OmniBoundingVolume(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OmniBoundingVolume) {
    printf("OmniBoundingVolume ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OmniBoundingVolume *local_this = (OmniBoundingVolume *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OmniBoundingVolume) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BoundingVolume) {
    return (BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeometricBoundingVolume) {
    return (GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OmniBoundingVolume(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OmniBoundingVolume) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BoundingVolume) {
    BoundingVolume* other_this = (BoundingVolume*)from_this;
    return (OmniBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_GeometricBoundingVolume) {
    GeometricBoundingVolume* other_this = (GeometricBoundingVolume*)from_this;
    return (OmniBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (OmniBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OmniBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (OmniBoundingVolume*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class UnionBoundingVolume
 */
/**
 * Python function wrapper for:
 * inline int UnionBoundingVolume::get_num_components(void) const
 */
static PyObject *Dtool_UnionBoundingVolume_get_num_components_746(PyObject *self, PyObject *) {
  UnionBoundingVolume *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_UnionBoundingVolume)) {
    return nullptr;
  }
  // 1-inline int UnionBoundingVolume::get_num_components(void) const
  int return_value = ((*(const UnionBoundingVolume*)local_this).get_num_components)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_UnionBoundingVolume_get_num_components_746_comment =
  "C++ Interface:\n"
  "get_num_components(UnionBoundingVolume self)\n"
  "\n"
  "/**\n"
  " * Returns the number of components in the union.\n"
  " */";
#else
static const char *Dtool_UnionBoundingVolume_get_num_components_746_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GeometricBoundingVolume const *UnionBoundingVolume::get_component(int n) const
 */
static PyObject *Dtool_UnionBoundingVolume_get_component_747(PyObject *self, PyObject *arg) {
  UnionBoundingVolume *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_UnionBoundingVolume)) {
    return nullptr;
  }
  // 1-inline GeometricBoundingVolume const *UnionBoundingVolume::get_component(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    GeometricBoundingVolume const *return_value = ((*(const UnionBoundingVolume*)local_this).get_component)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GeometricBoundingVolume, true, true, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_component(UnionBoundingVolume self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_UnionBoundingVolume_get_component_747_comment =
  "C++ Interface:\n"
  "get_component(UnionBoundingVolume self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth component in the union.\n"
  " */";
#else
static const char *Dtool_UnionBoundingVolume_get_component_747_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void UnionBoundingVolume::clear_components(void)
 */
static PyObject *Dtool_UnionBoundingVolume_clear_components_750(PyObject *self, PyObject *) {
  UnionBoundingVolume *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UnionBoundingVolume, (void **)&local_this, "UnionBoundingVolume.clear_components")) {
    return nullptr;
  }
  // 1-void UnionBoundingVolume::clear_components(void)
  ((*local_this).clear_components)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_UnionBoundingVolume_clear_components_750_comment =
  "C++ Interface:\n"
  "clear_components(const UnionBoundingVolume self)\n"
  "\n"
  "/**\n"
  " * Removes all components from the volume.\n"
  " */";
#else
static const char *Dtool_UnionBoundingVolume_clear_components_750_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void UnionBoundingVolume::add_component(GeometricBoundingVolume const *component)
 */
static PyObject *Dtool_UnionBoundingVolume_add_component_751(PyObject *self, PyObject *arg) {
  UnionBoundingVolume *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UnionBoundingVolume, (void **)&local_this, "UnionBoundingVolume.add_component")) {
    return nullptr;
  }
  // 1-void UnionBoundingVolume::add_component(GeometricBoundingVolume const *component)
  GeometricBoundingVolume const *arg_this = (GeometricBoundingVolume *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GeometricBoundingVolume, 1, "UnionBoundingVolume.add_component", true, true);
  if (arg_this != nullptr) {
    ((*local_this).add_component)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_component(const UnionBoundingVolume self, const GeometricBoundingVolume component)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_UnionBoundingVolume_add_component_751_comment =
  "C++ Interface:\n"
  "add_component(const UnionBoundingVolume self, const GeometricBoundingVolume component)\n"
  "\n"
  "/**\n"
  " * Adds a new component to the volume.  This does not necessarily increase the\n"
  " * total number of components by one, and you may or may not be able to find\n"
  " * this component in the volume by a subsequent call to get_component();\n"
  " * certain optimizations may prevent the component from being added, or have\n"
  " * other unexpected effects on the total set of components.\n"
  " */";
#else
static const char *Dtool_UnionBoundingVolume_add_component_751_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void UnionBoundingVolume::filter_intersection(BoundingVolume const *volume)
 */
static PyObject *Dtool_UnionBoundingVolume_filter_intersection_752(PyObject *self, PyObject *arg) {
  UnionBoundingVolume *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UnionBoundingVolume, (void **)&local_this, "UnionBoundingVolume.filter_intersection")) {
    return nullptr;
  }
  // 1-void UnionBoundingVolume::filter_intersection(BoundingVolume const *volume)
  BoundingVolume const *arg_this = (BoundingVolume *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BoundingVolume, 1, "UnionBoundingVolume.filter_intersection", true, true);
  if (arg_this != nullptr) {
    ((*local_this).filter_intersection)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "filter_intersection(const UnionBoundingVolume self, const BoundingVolume volume)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_UnionBoundingVolume_filter_intersection_752_comment =
  "C++ Interface:\n"
  "filter_intersection(const UnionBoundingVolume self, const BoundingVolume volume)\n"
  "\n"
  "/**\n"
  " * Removes from the union any components that have no intersection with the\n"
  " * indicated volume.\n"
  " */";
#else
static const char *Dtool_UnionBoundingVolume_filter_intersection_752_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle UnionBoundingVolume::get_class_type(void)
 */
static PyObject *Dtool_UnionBoundingVolume_get_class_type_753(PyObject *, PyObject *) {
  // 1-static TypeHandle UnionBoundingVolume::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((UnionBoundingVolume::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_UnionBoundingVolume_get_class_type_753_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_UnionBoundingVolume_get_class_type_753_comment = nullptr;
#endif

/**
 * sequence length function for property UnionBoundingVolume::components
 */
static Py_ssize_t Dtool_UnionBoundingVolume_components_Len(PyObject *self) {
  UnionBoundingVolume *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UnionBoundingVolume, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_components)();
}

/**
 * sequence getter for property UnionBoundingVolume::components
 */
static PyObject *Dtool_UnionBoundingVolume_components_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  UnionBoundingVolume *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UnionBoundingVolume, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_components)()) {
    PyErr_SetString(PyExc_IndexError, "UnionBoundingVolume.components[] index out of range");
    return nullptr;
  }
  // 1-inline GeometricBoundingVolume const *UnionBoundingVolume::get_component(int n) const
  GeometricBoundingVolume const *return_value = ((*(const UnionBoundingVolume*)local_this).get_component)(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GeometricBoundingVolume, true, true, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_component(UnionBoundingVolume self, index)\n");
  }
}

static PyObject *Dtool_UnionBoundingVolume_components_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "UnionBoundingVolume.components");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_UnionBoundingVolume_components_Len;
    wrap->_getitem_func = &Dtool_UnionBoundingVolume_components_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * inline UnionBoundingVolume::UnionBoundingVolume(void)
 */
static int Dtool_Init_UnionBoundingVolume(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("UnionBoundingVolume() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "UnionBoundingVolume() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-inline UnionBoundingVolume::UnionBoundingVolume(void)
  UnionBoundingVolume *return_value = new UnionBoundingVolume();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnionBoundingVolume, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "UnionBoundingVolume()\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_UnionBoundingVolume_get_components(PyObject *self, PyObject *) {
  UnionBoundingVolume *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UnionBoundingVolume, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_components)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_UnionBoundingVolume_get_component_747(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_UnionBoundingVolume(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_UnionBoundingVolume) {
    printf("UnionBoundingVolume ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  UnionBoundingVolume *local_this = (UnionBoundingVolume *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_UnionBoundingVolume) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BoundingVolume) {
    return (BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_GeometricBoundingVolume) {
    return (GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BoundingVolume *)(GeometricBoundingVolume *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_UnionBoundingVolume(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_UnionBoundingVolume) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BoundingVolume) {
    BoundingVolume* other_this = (BoundingVolume*)from_this;
    return (UnionBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_GeometricBoundingVolume) {
    GeometricBoundingVolume* other_this = (GeometricBoundingVolume*)from_this;
    return (UnionBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (UnionBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (UnionBoundingVolume*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (UnionBoundingVolume*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Randomizer
 */
/**
 * Python function wrapper for:
 * inline void Randomizer::operator =(Randomizer const &copy)
 */
static PyObject *Dtool_Randomizer_operator_757(PyObject *self, PyObject *arg) {
  Randomizer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Randomizer, (void **)&local_this, "Randomizer.assign")) {
    return nullptr;
  }
  // 1-inline void Randomizer::operator =(Randomizer const &copy)
  Randomizer const *arg_this = (Randomizer *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Randomizer, 1, "Randomizer.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    Randomizer *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Randomizer, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const Randomizer self, const Randomizer copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Randomizer_operator_757_comment =
  "C++ Interface:\n"
  "assign(const Randomizer self, const Randomizer copy)\n";
#else
static const char *Dtool_Randomizer_operator_757_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Randomizer::random_int(int range)
 */
static PyObject *Dtool_Randomizer_random_int_758(PyObject *self, PyObject *arg) {
  Randomizer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Randomizer, (void **)&local_this, "Randomizer.random_int")) {
    return nullptr;
  }
  // 1-inline int Randomizer::random_int(int range)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*local_this).random_int)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "random_int(const Randomizer self, int range)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Randomizer_random_int_758_comment =
  "C++ Interface:\n"
  "random_int(const Randomizer self, int range)\n"
  "\n"
  "/**\n"
  " * Returns a random integer in the range [0, range).\n"
  " */";
#else
static const char *Dtool_Randomizer_random_int_758_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double Randomizer::random_real(double range)
 */
static PyObject *Dtool_Randomizer_random_real_759(PyObject *self, PyObject *arg) {
  Randomizer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Randomizer, (void **)&local_this, "Randomizer.random_real")) {
    return nullptr;
  }
  // 1-inline double Randomizer::random_real(double range)
  if (PyNumber_Check(arg)) {
    double return_value = ((*local_this).random_real)(PyFloat_AsDouble(arg));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "random_real(const Randomizer self, double range)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Randomizer_random_real_759_comment =
  "C++ Interface:\n"
  "random_real(const Randomizer self, double range)\n"
  "\n"
  "/**\n"
  " * Returns a random double in the range [0, range).\n"
  " */";
#else
static const char *Dtool_Randomizer_random_real_759_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double Randomizer::random_real_unit(void)
 */
static PyObject *Dtool_Randomizer_random_real_unit_760(PyObject *self, PyObject *) {
  Randomizer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Randomizer, (void **)&local_this, "Randomizer.random_real_unit")) {
    return nullptr;
  }
  // 1-inline double Randomizer::random_real_unit(void)
  double return_value = ((*local_this).random_real_unit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Randomizer_random_real_unit_760_comment =
  "C++ Interface:\n"
  "random_real_unit(const Randomizer self)\n"
  "\n"
  "/**\n"
  " * Returns a random double in the range [-0.5, 0.5).\n"
  " */";
#else
static const char *Dtool_Randomizer_random_real_unit_760_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline unsigned long int Randomizer::get_next_seed(void)
 */
static PyObject *Dtool_Randomizer_get_next_seed_761(PyObject *, PyObject *) {
  // 1-static inline unsigned long int Randomizer::get_next_seed(void)
  unsigned long int return_value = (Randomizer::get_next_seed)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Randomizer_get_next_seed_761_comment =
  "C++ Interface:\n"
  "get_next_seed()\n"
  "\n"
  "/**\n"
  " * Returns a random seed value for the next global Randomizer object.\n"
  " */";
#else
static const char *Dtool_Randomizer_get_next_seed_761_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int Randomizer::get_seed(void)
 */
static PyObject *Dtool_Randomizer_get_seed_762(PyObject *self, PyObject *) {
  Randomizer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Randomizer, (void **)&local_this, "Randomizer.get_seed")) {
    return nullptr;
  }
  // 1-inline unsigned long int Randomizer::get_seed(void)
  unsigned long int return_value = ((*local_this).get_seed)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Randomizer_get_seed_762_comment =
  "C++ Interface:\n"
  "get_seed(const Randomizer self)\n"
  "\n"
  "/**\n"
  " * Returns a unique seed value based on the seed value passed to this\n"
  " * Randomizer object (and on its current state).\n"
  " */";
#else
static const char *Dtool_Randomizer_get_seed_762_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Randomizer::Randomizer(Randomizer const &copy)
 * inline explicit Randomizer::Randomizer(unsigned long int seed = 0)
 */
static int Dtool_Init_Randomizer(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline explicit Randomizer::Randomizer(unsigned long int seed)
      Randomizer *return_value = new Randomizer();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Randomizer, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline Randomizer::Randomizer(Randomizer const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          Randomizer const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_Randomizer);
          if (param0_this != nullptr) {
            Randomizer *return_value = new Randomizer(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Randomizer, true, false);
          }
        }
      }

      {
        // -2 inline explicit Randomizer::Randomizer(unsigned long int seed)
        unsigned long param0;
        static const char *keyword_list[] = {"seed", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "k:Randomizer", (char **)keyword_list, &param0)) {
          Randomizer *return_value = new Randomizer((unsigned long int)param0);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Randomizer, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline Randomizer::Randomizer(Randomizer const &copy)
      // No coercion possible: inline explicit Randomizer::Randomizer(unsigned long int seed)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Randomizer() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Randomizer()\n"
      "Randomizer(const Randomizer copy)\n"
      "Randomizer(int seed)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Randomizer(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Randomizer) {
    printf("Randomizer ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Randomizer *local_this = (Randomizer *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Randomizer) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Randomizer(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Randomizer) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PerlinNoise
 */
/**
 * Python function wrapper for:
 * inline unsigned long int PerlinNoise::get_seed(void)
 */
static PyObject *Dtool_PerlinNoise_get_seed_765(PyObject *self, PyObject *) {
  PerlinNoise *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PerlinNoise, (void **)&local_this, "PerlinNoise.get_seed")) {
    return nullptr;
  }
  // 1-inline unsigned long int PerlinNoise::get_seed(void)
  unsigned long int return_value = ((*local_this).get_seed)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PerlinNoise_get_seed_765_comment =
  "C++ Interface:\n"
  "get_seed(const PerlinNoise self)\n"
  "\n"
  "/**\n"
  " * Returns a unique seed value based on the seed value passed to this\n"
  " * PerlinNoise object (and on its current state).\n"
  " */";
#else
static const char *Dtool_PerlinNoise_get_seed_765_comment = nullptr;
#endif

static int Dtool_Init_PerlinNoise(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PerlinNoise(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PerlinNoise) {
    printf("PerlinNoise ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PerlinNoise *local_this = (PerlinNoise *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PerlinNoise) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PerlinNoise(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PerlinNoise) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PerlinNoise2
 */
/**
 * Python function wrapper for:
 * inline void PerlinNoise2::operator =(PerlinNoise2 const &copy)
 */
static PyObject *Dtool_PerlinNoise2_operator_769(PyObject *self, PyObject *arg) {
  PerlinNoise2 *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PerlinNoise2, (void **)&local_this, "PerlinNoise2.assign")) {
    return nullptr;
  }
  // 1-inline void PerlinNoise2::operator =(PerlinNoise2 const &copy)
  PerlinNoise2 const *arg_this = (PerlinNoise2 *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PerlinNoise2, 1, "PerlinNoise2.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    PerlinNoise2 *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PerlinNoise2, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const PerlinNoise2 self, const PerlinNoise2 copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PerlinNoise2_operator_769_comment =
  "C++ Interface:\n"
  "assign(const PerlinNoise2 self, const PerlinNoise2 copy)\n";
#else
static const char *Dtool_PerlinNoise2_operator_769_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PerlinNoise2::set_scale(LVecBase2d const &scale)
 * inline void PerlinNoise2::set_scale(LVecBase2f const &scale)
 * inline void PerlinNoise2::set_scale(double scale)
 * inline void PerlinNoise2::set_scale(double sx, double sy)
 */
static PyObject *Dtool_PerlinNoise2_set_scale_770(PyObject *self, PyObject *args, PyObject *kwds) {
  PerlinNoise2 *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PerlinNoise2, (void **)&local_this, "PerlinNoise2.set_scale")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "scale")) {
        {
          // -2 inline void PerlinNoise2::set_scale(LVecBase2d const &scale)
          LVecBase2d const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase2d);
          if (arg_this != nullptr) {
            ((*local_this).set_scale)(*arg_this);
            return Dtool_Return_None();
          }
        }

        {
          // -2 inline void PerlinNoise2::set_scale(LVecBase2f const &scale)
          LVecBase2f const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase2f);
          if (arg_this != nullptr) {
            ((*local_this).set_scale)(*arg_this);
            return Dtool_Return_None();
          }
        }

        {
          // -2 inline void PerlinNoise2::set_scale(double scale)
          if (PyNumber_Check(arg)) {
            ((*local_this).set_scale)(PyFloat_AsDouble(arg));
            return Dtool_Return_None();
          }
        }

        {
          // -2 inline void PerlinNoise2::set_scale(LVecBase2d const &scale)
          LVecBase2d arg_local;
          LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
          if ((arg_this != nullptr)) {
            ((*local_this).set_scale)(*arg_this);
            return Dtool_Return_None();
          }
        }

        {
          // -2 inline void PerlinNoise2::set_scale(LVecBase2f const &scale)
          LVecBase2f arg_local;
          LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
          if ((arg_this != nullptr)) {
            ((*local_this).set_scale)(*arg_this);
            return Dtool_Return_None();
          }
        }

        // No coercion possible: inline void PerlinNoise2::set_scale(double scale)
      }
    }
    break;
  case 2:
    {
      // 1-inline void PerlinNoise2::set_scale(double sx, double sy)
      double param1;
      double param2;
      static const char *keyword_list[] = {"sx", "sy", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:set_scale", (char **)keyword_list, &param1, &param2)) {
        ((*local_this).set_scale)((double)param1, (double)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_scale() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scale(const PerlinNoise2 self, const LVecBase2d scale)\n"
      "set_scale(const PerlinNoise2 self, const LVecBase2f scale)\n"
      "set_scale(const PerlinNoise2 self, double scale)\n"
      "set_scale(const PerlinNoise2 self, double sx, double sy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PerlinNoise2_set_scale_770_comment =
  "C++ Interface:\n"
  "set_scale(const PerlinNoise2 self, const LVecBase2d scale)\n"
  "set_scale(const PerlinNoise2 self, const LVecBase2f scale)\n"
  "set_scale(const PerlinNoise2 self, double scale)\n"
  "set_scale(const PerlinNoise2 self, double sx, double sy)\n"
  "\n"
  "/**\n"
  " * Changes the scale (frequency) of the noise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Changes the scale (frequency) of the noise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Changes the scale (frequency) of the noise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Changes the scale (frequency) of the noise.\n"
  " */";
#else
static const char *Dtool_PerlinNoise2_set_scale_770_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * double PerlinNoise2::noise(LVecBase2d const &value) const
 * inline float PerlinNoise2::noise(LVecBase2f const &value) const
 * inline double PerlinNoise2::noise(double x, double y) const
 */
static PyObject *Dtool_PerlinNoise2_noise_771(PyObject *self, PyObject *args, PyObject *kwds) {
  PerlinNoise2 *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PerlinNoise2)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "value")) {
        {
          // -2 double PerlinNoise2::noise(LVecBase2d const &value) const
          LVecBase2d const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase2d);
          if (arg_this != nullptr) {
            double return_value = ((*(const PerlinNoise2*)local_this).noise)(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

        {
          // -2 inline float PerlinNoise2::noise(LVecBase2f const &value) const
          LVecBase2f const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase2f);
          if (arg_this != nullptr) {
            float return_value = ((*(const PerlinNoise2*)local_this).noise)(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

        {
          // -2 double PerlinNoise2::noise(LVecBase2d const &value) const
          LVecBase2d arg_local;
          LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
          if ((arg_this != nullptr)) {
            double return_value = ((*(const PerlinNoise2*)local_this).noise)(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

        {
          // -2 inline float PerlinNoise2::noise(LVecBase2f const &value) const
          LVecBase2f arg_local;
          LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
          if ((arg_this != nullptr)) {
            float return_value = ((*(const PerlinNoise2*)local_this).noise)(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

      }
    }
    break;
  case 2:
    {
      // 1-inline double PerlinNoise2::noise(double x, double y) const
      double param1;
      double param2;
      static const char *keyword_list[] = {"x", "y", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:noise", (char **)keyword_list, &param1, &param2)) {
        double return_value = ((*(const PerlinNoise2*)local_this).noise)((double)param1, (double)param2);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "noise() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "noise(PerlinNoise2 self, const LVecBase2d value)\n"
      "noise(PerlinNoise2 self, const LVecBase2f value)\n"
      "noise(PerlinNoise2 self, double x, double y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PerlinNoise2_noise_771_comment =
  "C++ Interface:\n"
  "noise(PerlinNoise2 self, const LVecBase2d value)\n"
  "noise(PerlinNoise2 self, const LVecBase2f value)\n"
  "noise(PerlinNoise2 self, double x, double y)\n"
  "\n"
  "/**\n"
  " * Returns the noise function of the three inputs.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the noise function of the three inputs.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the noise function of the three inputs.\n"
  " */";
#else
static const char *Dtool_PerlinNoise2_noise_771_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PerlinNoise2::PerlinNoise2(void)
 * inline PerlinNoise2::PerlinNoise2(PerlinNoise2 const &copy)
 * inline explicit PerlinNoise2::PerlinNoise2(double sx, double sy, int table_size = 256, unsigned long int seed = 0)
 */
static int Dtool_Init_PerlinNoise2(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PerlinNoise2::PerlinNoise2(void)
      PerlinNoise2 *return_value = new PerlinNoise2();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PerlinNoise2, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-inline PerlinNoise2::PerlinNoise2(PerlinNoise2 const &copy)
        PerlinNoise2 const *arg_this = (PerlinNoise2 *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PerlinNoise2, 0, "PerlinNoise2.PerlinNoise2", true, true);
        if (arg_this != nullptr) {
          PerlinNoise2 *return_value = new PerlinNoise2(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PerlinNoise2, true, false);
        }
      }
    }
    break;
  case 2:
  case 3:
  case 4:
    {
      // 1-inline explicit PerlinNoise2::PerlinNoise2(double sx, double sy, int table_size = 256, unsigned long int seed = 0)
      double param0;
      double param1;
      int param2 = 256;
      unsigned long param3 = 0;
      static const char *keyword_list[] = {"sx", "sy", "table_size", "seed", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dd|ik:PerlinNoise2", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        PerlinNoise2 *return_value = new PerlinNoise2((double)param0, (double)param1, (int)param2, (unsigned long int)param3);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PerlinNoise2, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PerlinNoise2() takes 0, 1, 2, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PerlinNoise2()\n"
      "PerlinNoise2(const PerlinNoise2 copy)\n"
      "PerlinNoise2(double sx, double sy, int table_size, int seed)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PerlinNoise2(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PerlinNoise2) {
    printf("PerlinNoise2 ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PerlinNoise2 *local_this = (PerlinNoise2 *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PerlinNoise2) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PerlinNoise) {
    return (PerlinNoise *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PerlinNoise2(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PerlinNoise2) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PerlinNoise) {
    PerlinNoise* other_this = (PerlinNoise*)from_this;
    return (PerlinNoise2*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PerlinNoise3
 */
/**
 * Python function wrapper for:
 * inline void PerlinNoise3::operator =(PerlinNoise3 const &copy)
 */
static PyObject *Dtool_PerlinNoise3_operator_776(PyObject *self, PyObject *arg) {
  PerlinNoise3 *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PerlinNoise3, (void **)&local_this, "PerlinNoise3.assign")) {
    return nullptr;
  }
  // 1-inline void PerlinNoise3::operator =(PerlinNoise3 const &copy)
  PerlinNoise3 const *arg_this = (PerlinNoise3 *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PerlinNoise3, 1, "PerlinNoise3.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    PerlinNoise3 *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PerlinNoise3, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const PerlinNoise3 self, const PerlinNoise3 copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PerlinNoise3_operator_776_comment =
  "C++ Interface:\n"
  "assign(const PerlinNoise3 self, const PerlinNoise3 copy)\n";
#else
static const char *Dtool_PerlinNoise3_operator_776_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PerlinNoise3::set_scale(LVecBase3d const &scale)
 * inline void PerlinNoise3::set_scale(LVecBase3f const &scale)
 * inline void PerlinNoise3::set_scale(double scale)
 * inline void PerlinNoise3::set_scale(double sx, double sy, double sz)
 */
static PyObject *Dtool_PerlinNoise3_set_scale_777(PyObject *self, PyObject *args, PyObject *kwds) {
  PerlinNoise3 *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PerlinNoise3, (void **)&local_this, "PerlinNoise3.set_scale")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "scale")) {
        {
          // -2 inline void PerlinNoise3::set_scale(LVecBase3d const &scale)
          LVecBase3d const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase3d);
          if (arg_this != nullptr) {
            ((*local_this).set_scale)(*arg_this);
            return Dtool_Return_None();
          }
        }

        {
          // -2 inline void PerlinNoise3::set_scale(LVecBase3f const &scale)
          LVecBase3f const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase3f);
          if (arg_this != nullptr) {
            ((*local_this).set_scale)(*arg_this);
            return Dtool_Return_None();
          }
        }

        {
          // -2 inline void PerlinNoise3::set_scale(double scale)
          if (PyNumber_Check(arg)) {
            ((*local_this).set_scale)(PyFloat_AsDouble(arg));
            return Dtool_Return_None();
          }
        }

        {
          // -2 inline void PerlinNoise3::set_scale(LVecBase3d const &scale)
          LVecBase3d arg_local;
          LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
          if ((arg_this != nullptr)) {
            ((*local_this).set_scale)(*arg_this);
            return Dtool_Return_None();
          }
        }

        {
          // -2 inline void PerlinNoise3::set_scale(LVecBase3f const &scale)
          LVecBase3f arg_local;
          LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
          if ((arg_this != nullptr)) {
            ((*local_this).set_scale)(*arg_this);
            return Dtool_Return_None();
          }
        }

        // No coercion possible: inline void PerlinNoise3::set_scale(double scale)
      }
    }
    break;
  case 3:
    {
      // 1-inline void PerlinNoise3::set_scale(double sx, double sy, double sz)
      double param1;
      double param2;
      double param3;
      static const char *keyword_list[] = {"sx", "sy", "sz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ddd:set_scale", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_scale)((double)param1, (double)param2, (double)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_scale() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scale(const PerlinNoise3 self, const LVecBase3d scale)\n"
      "set_scale(const PerlinNoise3 self, const LVecBase3f scale)\n"
      "set_scale(const PerlinNoise3 self, double scale)\n"
      "set_scale(const PerlinNoise3 self, double sx, double sy, double sz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PerlinNoise3_set_scale_777_comment =
  "C++ Interface:\n"
  "set_scale(const PerlinNoise3 self, const LVecBase3d scale)\n"
  "set_scale(const PerlinNoise3 self, const LVecBase3f scale)\n"
  "set_scale(const PerlinNoise3 self, double scale)\n"
  "set_scale(const PerlinNoise3 self, double sx, double sy, double sz)\n"
  "\n"
  "/**\n"
  " * Changes the scale (frequency) of the noise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Changes the scale (frequency) of the noise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Changes the scale (frequency) of the noise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Changes the scale (frequency) of the noise.\n"
  " */";
#else
static const char *Dtool_PerlinNoise3_set_scale_777_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * double PerlinNoise3::noise(LVecBase3d const &value) const
 * inline float PerlinNoise3::noise(LVecBase3f const &value) const
 * inline double PerlinNoise3::noise(double x, double y, double z) const
 */
static PyObject *Dtool_PerlinNoise3_noise_778(PyObject *self, PyObject *args, PyObject *kwds) {
  PerlinNoise3 *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PerlinNoise3)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "value")) {
        {
          // -2 double PerlinNoise3::noise(LVecBase3d const &value) const
          LVecBase3d const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase3d);
          if (arg_this != nullptr) {
            double return_value = ((*(const PerlinNoise3*)local_this).noise)(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

        {
          // -2 inline float PerlinNoise3::noise(LVecBase3f const &value) const
          LVecBase3f const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase3f);
          if (arg_this != nullptr) {
            float return_value = ((*(const PerlinNoise3*)local_this).noise)(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

        {
          // -2 double PerlinNoise3::noise(LVecBase3d const &value) const
          LVecBase3d arg_local;
          LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
          if ((arg_this != nullptr)) {
            double return_value = ((*(const PerlinNoise3*)local_this).noise)(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

        {
          // -2 inline float PerlinNoise3::noise(LVecBase3f const &value) const
          LVecBase3f arg_local;
          LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
          if ((arg_this != nullptr)) {
            float return_value = ((*(const PerlinNoise3*)local_this).noise)(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

      }
    }
    break;
  case 3:
    {
      // 1-inline double PerlinNoise3::noise(double x, double y, double z) const
      double param1;
      double param2;
      double param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ddd:noise", (char **)keyword_list, &param1, &param2, &param3)) {
        double return_value = ((*(const PerlinNoise3*)local_this).noise)((double)param1, (double)param2, (double)param3);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "noise() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "noise(PerlinNoise3 self, const LVecBase3d value)\n"
      "noise(PerlinNoise3 self, const LVecBase3f value)\n"
      "noise(PerlinNoise3 self, double x, double y, double z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PerlinNoise3_noise_778_comment =
  "C++ Interface:\n"
  "noise(PerlinNoise3 self, const LVecBase3d value)\n"
  "noise(PerlinNoise3 self, const LVecBase3f value)\n"
  "noise(PerlinNoise3 self, double x, double y, double z)\n"
  "\n"
  "/**\n"
  " * Returns the noise function of the three inputs.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the noise function of the three inputs.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the noise function of the three inputs.\n"
  " */";
#else
static const char *Dtool_PerlinNoise3_noise_778_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PerlinNoise3::PerlinNoise3(void)
 * inline PerlinNoise3::PerlinNoise3(PerlinNoise3 const &copy)
 * inline explicit PerlinNoise3::PerlinNoise3(double sx, double sy, double sz, int table_size = 256, unsigned long int seed = 0)
 */
static int Dtool_Init_PerlinNoise3(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PerlinNoise3::PerlinNoise3(void)
      PerlinNoise3 *return_value = new PerlinNoise3();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PerlinNoise3, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-inline PerlinNoise3::PerlinNoise3(PerlinNoise3 const &copy)
        PerlinNoise3 const *arg_this = (PerlinNoise3 *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PerlinNoise3, 0, "PerlinNoise3.PerlinNoise3", true, true);
        if (arg_this != nullptr) {
          PerlinNoise3 *return_value = new PerlinNoise3(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PerlinNoise3, true, false);
        }
      }
    }
    break;
  case 3:
  case 4:
  case 5:
    {
      // 1-inline explicit PerlinNoise3::PerlinNoise3(double sx, double sy, double sz, int table_size = 256, unsigned long int seed = 0)
      double param0;
      double param1;
      double param2;
      int param3 = 256;
      unsigned long param4 = 0;
      static const char *keyword_list[] = {"sx", "sy", "sz", "table_size", "seed", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ddd|ik:PerlinNoise3", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
        PerlinNoise3 *return_value = new PerlinNoise3((double)param0, (double)param1, (double)param2, (int)param3, (unsigned long int)param4);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PerlinNoise3, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PerlinNoise3() takes 0, 1, 3, 4 or 5 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PerlinNoise3()\n"
      "PerlinNoise3(const PerlinNoise3 copy)\n"
      "PerlinNoise3(double sx, double sy, double sz, int table_size, int seed)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PerlinNoise3(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PerlinNoise3) {
    printf("PerlinNoise3 ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PerlinNoise3 *local_this = (PerlinNoise3 *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PerlinNoise3) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PerlinNoise) {
    return (PerlinNoise *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PerlinNoise3(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PerlinNoise3) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PerlinNoise) {
    PerlinNoise* other_this = (PerlinNoise*)from_this;
    return (PerlinNoise3*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class StackedPerlinNoise2
 */
/**
 * Python function wrapper for:
 * void StackedPerlinNoise2::operator =(StackedPerlinNoise2 const &copy)
 */
static PyObject *Dtool_StackedPerlinNoise2_operator_840(PyObject *self, PyObject *arg) {
  StackedPerlinNoise2 *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StackedPerlinNoise2, (void **)&local_this, "StackedPerlinNoise2.assign")) {
    return nullptr;
  }
  // 1-void StackedPerlinNoise2::operator =(StackedPerlinNoise2 const &copy)
  StackedPerlinNoise2 const *arg_this = (StackedPerlinNoise2 *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_StackedPerlinNoise2, 1, "StackedPerlinNoise2.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    StackedPerlinNoise2 *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_StackedPerlinNoise2, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const StackedPerlinNoise2 self, const StackedPerlinNoise2 copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StackedPerlinNoise2_operator_840_comment =
  "C++ Interface:\n"
  "assign(const StackedPerlinNoise2 self, const StackedPerlinNoise2 copy)\n";
#else
static const char *Dtool_StackedPerlinNoise2_operator_840_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void StackedPerlinNoise2::add_level(PerlinNoise2 const &level, double amp = 1.0)
 */
static PyObject *Dtool_StackedPerlinNoise2_add_level_841(PyObject *self, PyObject *args, PyObject *kwds) {
  StackedPerlinNoise2 *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StackedPerlinNoise2, (void **)&local_this, "StackedPerlinNoise2.add_level")) {
    return nullptr;
  }
  // 1-void StackedPerlinNoise2::add_level(PerlinNoise2 const &level, double amp = 1.0)
  PyObject *param1;
  double param2 = 1.0;
  static const char *keyword_list[] = {"level", "amp", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|d:add_level", (char **)keyword_list, &param1, &param2)) {
    PerlinNoise2 const *param1_this = (PerlinNoise2 *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PerlinNoise2, 1, "StackedPerlinNoise2.add_level", true, true);
    if (param1_this != nullptr) {
      ((*local_this).add_level)(*param1_this, (double)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_level(const StackedPerlinNoise2 self, const PerlinNoise2 level, double amp)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StackedPerlinNoise2_add_level_841_comment =
  "C++ Interface:\n"
  "add_level(const StackedPerlinNoise2 self, const PerlinNoise2 level, double amp)\n"
  "\n"
  "/**\n"
  " * Adds an arbitrary PerlinNoise2 object, and an associated amplitude, to the\n"
  " * stack.\n"
  " */";
#else
static const char *Dtool_StackedPerlinNoise2_add_level_841_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void StackedPerlinNoise2::clear(void)
 */
static PyObject *Dtool_StackedPerlinNoise2_clear_842(PyObject *self, PyObject *) {
  StackedPerlinNoise2 *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StackedPerlinNoise2, (void **)&local_this, "StackedPerlinNoise2.clear")) {
    return nullptr;
  }
  // 1-void StackedPerlinNoise2::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_StackedPerlinNoise2_clear_842_comment =
  "C++ Interface:\n"
  "clear(const StackedPerlinNoise2 self)\n"
  "\n"
  "/**\n"
  " * Removes all levels from the stack.  You must call add_level() again to\n"
  " * restore them.\n"
  " */";
#else
static const char *Dtool_StackedPerlinNoise2_clear_842_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * double StackedPerlinNoise2::noise(LVecBase2d const &value)
 * inline float StackedPerlinNoise2::noise(LVecBase2f const &value)
 * inline double StackedPerlinNoise2::noise(double x, double y)
 */
static PyObject *Dtool_StackedPerlinNoise2_noise_843(PyObject *self, PyObject *args, PyObject *kwds) {
  StackedPerlinNoise2 *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StackedPerlinNoise2, (void **)&local_this, "StackedPerlinNoise2.noise")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "value")) {
        {
          // -2 double StackedPerlinNoise2::noise(LVecBase2d const &value)
          LVecBase2d const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase2d);
          if (arg_this != nullptr) {
            double return_value = ((*local_this).noise)(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

        {
          // -2 inline float StackedPerlinNoise2::noise(LVecBase2f const &value)
          LVecBase2f const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase2f);
          if (arg_this != nullptr) {
            float return_value = ((*local_this).noise)(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

        {
          // -2 double StackedPerlinNoise2::noise(LVecBase2d const &value)
          LVecBase2d arg_local;
          LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
          if ((arg_this != nullptr)) {
            double return_value = ((*local_this).noise)(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

        {
          // -2 inline float StackedPerlinNoise2::noise(LVecBase2f const &value)
          LVecBase2f arg_local;
          LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
          if ((arg_this != nullptr)) {
            float return_value = ((*local_this).noise)(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

      }
    }
    break;
  case 2:
    {
      // 1-inline double StackedPerlinNoise2::noise(double x, double y)
      double param1;
      double param2;
      static const char *keyword_list[] = {"x", "y", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:noise", (char **)keyword_list, &param1, &param2)) {
        double return_value = ((*local_this).noise)((double)param1, (double)param2);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "noise() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "noise(const StackedPerlinNoise2 self, const LVecBase2d value)\n"
      "noise(const StackedPerlinNoise2 self, const LVecBase2f value)\n"
      "noise(const StackedPerlinNoise2 self, double x, double y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StackedPerlinNoise2_noise_843_comment =
  "C++ Interface:\n"
  "noise(const StackedPerlinNoise2 self, const LVecBase2d value)\n"
  "noise(const StackedPerlinNoise2 self, const LVecBase2f value)\n"
  "noise(const StackedPerlinNoise2 self, double x, double y)\n"
  "\n"
  "/**\n"
  " * Returns the noise function of the three inputs.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the noise function of the three inputs.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the noise function of the three inputs.\n"
  " */";
#else
static const char *Dtool_StackedPerlinNoise2_noise_843_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline StackedPerlinNoise2::StackedPerlinNoise2(void)
 * StackedPerlinNoise2::StackedPerlinNoise2(StackedPerlinNoise2 const &copy)
 * explicit StackedPerlinNoise2::StackedPerlinNoise2(double sx, double sy, int num_levels = 2, double scale_factor = 4.0, double amp_scale = 0.5, int table_size = 256, unsigned long int seed = 0)
 */
static int Dtool_Init_StackedPerlinNoise2(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline StackedPerlinNoise2::StackedPerlinNoise2(void)
      StackedPerlinNoise2 *return_value = new StackedPerlinNoise2();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StackedPerlinNoise2, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-StackedPerlinNoise2::StackedPerlinNoise2(StackedPerlinNoise2 const &copy)
        StackedPerlinNoise2 const *arg_this = (StackedPerlinNoise2 *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_StackedPerlinNoise2, 0, "StackedPerlinNoise2.StackedPerlinNoise2", true, true);
        if (arg_this != nullptr) {
          StackedPerlinNoise2 *return_value = new StackedPerlinNoise2(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StackedPerlinNoise2, true, false);
        }
      }
    }
    break;
  case 2:
  case 3:
  case 4:
  case 5:
  case 6:
  case 7:
    {
      // 1-explicit StackedPerlinNoise2::StackedPerlinNoise2(double sx, double sy, int num_levels = 2, double scale_factor = 4.0, double amp_scale = 0.5, int table_size = 256, unsigned long int seed = 0)
      double param0;
      double param1;
      int param2 = 2;
      double param3 = 4.0;
      double param4 = 0.5;
      int param5 = 256;
      unsigned long param6 = 0;
      static const char *keyword_list[] = {"sx", "sy", "num_levels", "scale_factor", "amp_scale", "table_size", "seed", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dd|iddik:StackedPerlinNoise2", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6)) {
        StackedPerlinNoise2 *return_value = new StackedPerlinNoise2((double)param0, (double)param1, (int)param2, (double)param3, (double)param4, (int)param5, (unsigned long int)param6);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StackedPerlinNoise2, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "StackedPerlinNoise2() takes 0, 1, 2, 3, 4, 5, 6 or 7 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "StackedPerlinNoise2()\n"
      "StackedPerlinNoise2(const StackedPerlinNoise2 copy)\n"
      "StackedPerlinNoise2(double sx, double sy, int num_levels, double scale_factor, double amp_scale, int table_size, int seed)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_StackedPerlinNoise2(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_StackedPerlinNoise2) {
    printf("StackedPerlinNoise2 ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  StackedPerlinNoise2 *local_this = (StackedPerlinNoise2 *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_StackedPerlinNoise2) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_StackedPerlinNoise2(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_StackedPerlinNoise2) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class StackedPerlinNoise3
 */
/**
 * Python function wrapper for:
 * void StackedPerlinNoise3::operator =(StackedPerlinNoise3 const &copy)
 */
static PyObject *Dtool_StackedPerlinNoise3_operator_848(PyObject *self, PyObject *arg) {
  StackedPerlinNoise3 *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StackedPerlinNoise3, (void **)&local_this, "StackedPerlinNoise3.assign")) {
    return nullptr;
  }
  // 1-void StackedPerlinNoise3::operator =(StackedPerlinNoise3 const &copy)
  StackedPerlinNoise3 const *arg_this = (StackedPerlinNoise3 *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_StackedPerlinNoise3, 1, "StackedPerlinNoise3.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    StackedPerlinNoise3 *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_StackedPerlinNoise3, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const StackedPerlinNoise3 self, const StackedPerlinNoise3 copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StackedPerlinNoise3_operator_848_comment =
  "C++ Interface:\n"
  "assign(const StackedPerlinNoise3 self, const StackedPerlinNoise3 copy)\n";
#else
static const char *Dtool_StackedPerlinNoise3_operator_848_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void StackedPerlinNoise3::add_level(PerlinNoise3 const &level, double amp = 1.0)
 */
static PyObject *Dtool_StackedPerlinNoise3_add_level_849(PyObject *self, PyObject *args, PyObject *kwds) {
  StackedPerlinNoise3 *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StackedPerlinNoise3, (void **)&local_this, "StackedPerlinNoise3.add_level")) {
    return nullptr;
  }
  // 1-void StackedPerlinNoise3::add_level(PerlinNoise3 const &level, double amp = 1.0)
  PyObject *param1;
  double param2 = 1.0;
  static const char *keyword_list[] = {"level", "amp", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|d:add_level", (char **)keyword_list, &param1, &param2)) {
    PerlinNoise3 const *param1_this = (PerlinNoise3 *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PerlinNoise3, 1, "StackedPerlinNoise3.add_level", true, true);
    if (param1_this != nullptr) {
      ((*local_this).add_level)(*param1_this, (double)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_level(const StackedPerlinNoise3 self, const PerlinNoise3 level, double amp)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StackedPerlinNoise3_add_level_849_comment =
  "C++ Interface:\n"
  "add_level(const StackedPerlinNoise3 self, const PerlinNoise3 level, double amp)\n"
  "\n"
  "/**\n"
  " * Adds an arbitrary PerlinNoise3 object, and an associated amplitude, to the\n"
  " * stack.\n"
  " */";
#else
static const char *Dtool_StackedPerlinNoise3_add_level_849_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void StackedPerlinNoise3::clear(void)
 */
static PyObject *Dtool_StackedPerlinNoise3_clear_850(PyObject *self, PyObject *) {
  StackedPerlinNoise3 *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StackedPerlinNoise3, (void **)&local_this, "StackedPerlinNoise3.clear")) {
    return nullptr;
  }
  // 1-void StackedPerlinNoise3::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_StackedPerlinNoise3_clear_850_comment =
  "C++ Interface:\n"
  "clear(const StackedPerlinNoise3 self)\n"
  "\n"
  "/**\n"
  " * Removes all levels from the stack.  You must call add_level() again to\n"
  " * restore them.\n"
  " */";
#else
static const char *Dtool_StackedPerlinNoise3_clear_850_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * double StackedPerlinNoise3::noise(LVecBase3d const &value)
 * inline float StackedPerlinNoise3::noise(LVecBase3f const &value)
 * inline double StackedPerlinNoise3::noise(double x, double y, double z)
 */
static PyObject *Dtool_StackedPerlinNoise3_noise_851(PyObject *self, PyObject *args, PyObject *kwds) {
  StackedPerlinNoise3 *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StackedPerlinNoise3, (void **)&local_this, "StackedPerlinNoise3.noise")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "value")) {
        {
          // -2 double StackedPerlinNoise3::noise(LVecBase3d const &value)
          LVecBase3d const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase3d);
          if (arg_this != nullptr) {
            double return_value = ((*local_this).noise)(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

        {
          // -2 inline float StackedPerlinNoise3::noise(LVecBase3f const &value)
          LVecBase3f const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase3f);
          if (arg_this != nullptr) {
            float return_value = ((*local_this).noise)(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

        {
          // -2 double StackedPerlinNoise3::noise(LVecBase3d const &value)
          LVecBase3d arg_local;
          LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
          if ((arg_this != nullptr)) {
            double return_value = ((*local_this).noise)(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

        {
          // -2 inline float StackedPerlinNoise3::noise(LVecBase3f const &value)
          LVecBase3f arg_local;
          LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
          if ((arg_this != nullptr)) {
            float return_value = ((*local_this).noise)(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

      }
    }
    break;
  case 3:
    {
      // 1-inline double StackedPerlinNoise3::noise(double x, double y, double z)
      double param1;
      double param2;
      double param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ddd:noise", (char **)keyword_list, &param1, &param2, &param3)) {
        double return_value = ((*local_this).noise)((double)param1, (double)param2, (double)param3);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "noise() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "noise(const StackedPerlinNoise3 self, const LVecBase3d value)\n"
      "noise(const StackedPerlinNoise3 self, const LVecBase3f value)\n"
      "noise(const StackedPerlinNoise3 self, double x, double y, double z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StackedPerlinNoise3_noise_851_comment =
  "C++ Interface:\n"
  "noise(const StackedPerlinNoise3 self, const LVecBase3d value)\n"
  "noise(const StackedPerlinNoise3 self, const LVecBase3f value)\n"
  "noise(const StackedPerlinNoise3 self, double x, double y, double z)\n"
  "\n"
  "/**\n"
  " * Returns the noise function of the three inputs.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the noise function of the three inputs.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the noise function of the three inputs.\n"
  " */";
#else
static const char *Dtool_StackedPerlinNoise3_noise_851_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline StackedPerlinNoise3::StackedPerlinNoise3(void)
 * StackedPerlinNoise3::StackedPerlinNoise3(StackedPerlinNoise3 const &copy)
 * explicit StackedPerlinNoise3::StackedPerlinNoise3(double sx, double sy, double sz, int num_levels = 3, double scale_factor = 4.0, double amp_scale = 0.5, int table_size = 256, unsigned long int seed = 0)
 */
static int Dtool_Init_StackedPerlinNoise3(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline StackedPerlinNoise3::StackedPerlinNoise3(void)
      StackedPerlinNoise3 *return_value = new StackedPerlinNoise3();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StackedPerlinNoise3, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-StackedPerlinNoise3::StackedPerlinNoise3(StackedPerlinNoise3 const &copy)
        StackedPerlinNoise3 const *arg_this = (StackedPerlinNoise3 *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_StackedPerlinNoise3, 0, "StackedPerlinNoise3.StackedPerlinNoise3", true, true);
        if (arg_this != nullptr) {
          StackedPerlinNoise3 *return_value = new StackedPerlinNoise3(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StackedPerlinNoise3, true, false);
        }
      }
    }
    break;
  case 3:
  case 4:
  case 5:
  case 6:
  case 7:
  case 8:
    {
      // 1-explicit StackedPerlinNoise3::StackedPerlinNoise3(double sx, double sy, double sz, int num_levels = 3, double scale_factor = 4.0, double amp_scale = 0.5, int table_size = 256, unsigned long int seed = 0)
      double param0;
      double param1;
      double param2;
      int param3 = 3;
      double param4 = 4.0;
      double param5 = 0.5;
      int param6 = 256;
      unsigned long param7 = 0;
      static const char *keyword_list[] = {"sx", "sy", "sz", "num_levels", "scale_factor", "amp_scale", "table_size", "seed", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ddd|iddik:StackedPerlinNoise3", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
        StackedPerlinNoise3 *return_value = new StackedPerlinNoise3((double)param0, (double)param1, (double)param2, (int)param3, (double)param4, (double)param5, (int)param6, (unsigned long int)param7);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StackedPerlinNoise3, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "StackedPerlinNoise3() takes 0, 1, 3, 4, 5, 6, 7 or 8 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "StackedPerlinNoise3()\n"
      "StackedPerlinNoise3(const StackedPerlinNoise3 copy)\n"
      "StackedPerlinNoise3(double sx, double sy, double sz, int num_levels, double scale_factor, double amp_scale, int table_size, int seed)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_StackedPerlinNoise3(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_StackedPerlinNoise3) {
    printf("StackedPerlinNoise3 ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  StackedPerlinNoise3 *local_this = (StackedPerlinNoise3 *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_StackedPerlinNoise3) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_StackedPerlinNoise3(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_StackedPerlinNoise3) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Triangulator
 */
/**
 * Python function wrapper for:
 * void Triangulator::clear(void)
 */
static PyObject *Dtool_Triangulator_clear_856(PyObject *self, PyObject *) {
  Triangulator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Triangulator, (void **)&local_this, "Triangulator.clear")) {
    return nullptr;
  }
  // 1-void Triangulator::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Triangulator_clear_856_comment =
  "C++ Interface:\n"
  "clear(const Triangulator self)\n"
  "\n"
  "/**\n"
  " * Removes all vertices and polygon specifications from the Triangulator, and\n"
  " * prepares it to start over.\n"
  " */";
#else
static const char *Dtool_Triangulator_clear_856_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int Triangulator::add_vertex(LPoint2d const &point)
 * inline int Triangulator::add_vertex(double x, double y)
 */
static PyObject *Dtool_Triangulator_add_vertex_857(PyObject *self, PyObject *args, PyObject *kwds) {
  Triangulator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Triangulator, (void **)&local_this, "Triangulator.add_vertex")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "point")) {
        // 1-int Triangulator::add_vertex(LPoint2d const &point)
        LPoint2d arg_local;
        LPoint2d const *arg_this = Dtool_Coerce_LPoint2d(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "Triangulator.add_vertex", "LPoint2d");
        }
        int return_value = ((*local_this).add_vertex)(*arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-inline int Triangulator::add_vertex(double x, double y)
      double param1;
      double param2;
      static const char *keyword_list[] = {"x", "y", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:add_vertex", (char **)keyword_list, &param1, &param2)) {
        int return_value = ((*local_this).add_vertex)((double)param1, (double)param2);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_vertex() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_vertex(const Triangulator self, const LPoint2d point)\n"
      "add_vertex(const Triangulator self, double x, double y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Triangulator_add_vertex_857_comment =
  "C++ Interface:\n"
  "add_vertex(const Triangulator self, const LPoint2d point)\n"
  "add_vertex(const Triangulator self, double x, double y)\n"
  "\n"
  "/**\n"
  " * Adds a new vertex to the vertex pool.  Returns the vertex index number.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds a new vertex to the vertex pool.  Returns the vertex index number.\n"
  " */";
#else
static const char *Dtool_Triangulator_add_vertex_857_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Triangulator::get_num_vertices(void) const
 */
static PyObject *Dtool_Triangulator_get_num_vertices_858(PyObject *self, PyObject *) {
  Triangulator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Triangulator)) {
    return nullptr;
  }
  // 1-inline int Triangulator::get_num_vertices(void) const
  int return_value = ((*(const Triangulator*)local_this).get_num_vertices)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Triangulator_get_num_vertices_858_comment =
  "C++ Interface:\n"
  "get_num_vertices(Triangulator self)\n"
  "\n"
  "/**\n"
  " * Returns the number of vertices in the pool.  Note that the Triangulator\n"
  " * might append new vertices, in addition to those added by the user, if any\n"
  " * of the polygon is self-intersecting, or if any of the holes intersect some\n"
  " * part of the polygon edges.\n"
  " */";
#else
static const char *Dtool_Triangulator_get_num_vertices_858_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2d const &Triangulator::get_vertex(int n) const
 */
static PyObject *Dtool_Triangulator_get_vertex_859(PyObject *self, PyObject *arg) {
  Triangulator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Triangulator)) {
    return nullptr;
  }
  // 1-inline LPoint2d const &Triangulator::get_vertex(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPoint2d const *return_value = &(((*(const Triangulator*)local_this).get_vertex)((int)arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex(Triangulator self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Triangulator_get_vertex_859_comment =
  "C++ Interface:\n"
  "get_vertex(Triangulator self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth vertex.\n"
  " */";
#else
static const char *Dtool_Triangulator_get_vertex_859_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Triangulator::clear_polygon(void)
 */
static PyObject *Dtool_Triangulator_clear_polygon_864(PyObject *self, PyObject *) {
  Triangulator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Triangulator, (void **)&local_this, "Triangulator.clear_polygon")) {
    return nullptr;
  }
  // 1-void Triangulator::clear_polygon(void)
  ((*local_this).clear_polygon)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Triangulator_clear_polygon_864_comment =
  "C++ Interface:\n"
  "clear_polygon(const Triangulator self)\n"
  "\n"
  "/**\n"
  " * Removes the current polygon definition (and its set of holes), but does not\n"
  " * clear the vertex pool.\n"
  " */";
#else
static const char *Dtool_Triangulator_clear_polygon_864_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Triangulator::add_polygon_vertex(int index)
 */
static PyObject *Dtool_Triangulator_add_polygon_vertex_865(PyObject *self, PyObject *arg) {
  Triangulator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Triangulator, (void **)&local_this, "Triangulator.add_polygon_vertex")) {
    return nullptr;
  }
  // 1-void Triangulator::add_polygon_vertex(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).add_polygon_vertex)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_polygon_vertex(const Triangulator self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Triangulator_add_polygon_vertex_865_comment =
  "C++ Interface:\n"
  "add_polygon_vertex(const Triangulator self, int index)\n"
  "\n"
  "/**\n"
  " * Adds the next consecutive vertex of the polygon.  This vertex should index\n"
  " * into the vertex pool established by repeated calls to add_vertex().\n"
  " *\n"
  " * The vertices may be listed in either clockwise or counterclockwise order.\n"
  " * Vertices should not be repeated.  In particular, do not repeat the first\n"
  " * vertex at the end.\n"
  " */";
#else
static const char *Dtool_Triangulator_add_polygon_vertex_865_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Triangulator::is_left_winding(void) const
 */
static PyObject *Dtool_Triangulator_is_left_winding_866(PyObject *self, PyObject *) {
  Triangulator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Triangulator)) {
    return nullptr;
  }
  // 1-inline bool Triangulator::is_left_winding(void) const
  bool return_value = ((*(const Triangulator*)local_this).is_left_winding)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Triangulator_is_left_winding_866_comment =
  "C++ Interface:\n"
  "is_left_winding(Triangulator self)\n"
  "\n"
  "/**\n"
  " * Returns true if the polygon vertices are listed in counterclockwise order,\n"
  " * or false if they appear to be listed in clockwise order.\n"
  " */";
#else
static const char *Dtool_Triangulator_is_left_winding_866_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Triangulator::begin_hole(void)
 */
static PyObject *Dtool_Triangulator_begin_hole_867(PyObject *self, PyObject *) {
  Triangulator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Triangulator, (void **)&local_this, "Triangulator.begin_hole")) {
    return nullptr;
  }
  // 1-void Triangulator::begin_hole(void)
  ((*local_this).begin_hole)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Triangulator_begin_hole_867_comment =
  "C++ Interface:\n"
  "begin_hole(const Triangulator self)\n"
  "\n"
  "/**\n"
  " * Finishes the previous hole, if any, and prepares to add a new hole.\n"
  " */";
#else
static const char *Dtool_Triangulator_begin_hole_867_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Triangulator::add_hole_vertex(int index)
 */
static PyObject *Dtool_Triangulator_add_hole_vertex_868(PyObject *self, PyObject *arg) {
  Triangulator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Triangulator, (void **)&local_this, "Triangulator.add_hole_vertex")) {
    return nullptr;
  }
  // 1-void Triangulator::add_hole_vertex(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).add_hole_vertex)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_hole_vertex(const Triangulator self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Triangulator_add_hole_vertex_868_comment =
  "C++ Interface:\n"
  "add_hole_vertex(const Triangulator self, int index)\n"
  "\n"
  "/**\n"
  " * Adds the next consecutive vertex of the current hole.  This vertex should\n"
  " * index into the vertex pool established by repeated calls to add_vertex().\n"
  " *\n"
  " * The vertices may be listed in either clockwise or counterclockwise order.\n"
  " * Vertices should not be repeated.\n"
  " */";
#else
static const char *Dtool_Triangulator_add_hole_vertex_868_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Triangulator::triangulate(void)
 */
static PyObject *Dtool_Triangulator_triangulate_869(PyObject *self, PyObject *) {
  Triangulator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Triangulator, (void **)&local_this, "Triangulator.triangulate")) {
    return nullptr;
  }
  // 1-void Triangulator::triangulate(void)
  ((*local_this).triangulate)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Triangulator_triangulate_869_comment =
  "C++ Interface:\n"
  "triangulate(const Triangulator self)\n"
  "\n"
  "/**\n"
  " * Does the work of triangulating the specified polygon.  After this call, you\n"
  " * may retrieve the new triangles one at a time by iterating through\n"
  " * get_triangle_v0/1/2().\n"
  " */";
#else
static const char *Dtool_Triangulator_triangulate_869_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int Triangulator::get_num_triangles(void) const
 */
static PyObject *Dtool_Triangulator_get_num_triangles_870(PyObject *self, PyObject *) {
  Triangulator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Triangulator)) {
    return nullptr;
  }
  // 1-int Triangulator::get_num_triangles(void) const
  int return_value = ((*(const Triangulator*)local_this).get_num_triangles)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Triangulator_get_num_triangles_870_comment =
  "C++ Interface:\n"
  "get_num_triangles(Triangulator self)\n"
  "\n"
  "/**\n"
  " * Returns the number of triangles generated by the previous call to\n"
  " * triangulate().\n"
  " */";
#else
static const char *Dtool_Triangulator_get_num_triangles_870_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int Triangulator::get_triangle_v0(int n) const
 */
static PyObject *Dtool_Triangulator_get_triangle_v0_871(PyObject *self, PyObject *arg) {
  Triangulator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Triangulator)) {
    return nullptr;
  }
  // 1-int Triangulator::get_triangle_v0(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const Triangulator*)local_this).get_triangle_v0)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_triangle_v0(Triangulator self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Triangulator_get_triangle_v0_871_comment =
  "C++ Interface:\n"
  "get_triangle_v0(Triangulator self, int n)\n"
  "\n"
  "/**\n"
  " * Returns vertex 0 of the nth triangle generated by the previous call to\n"
  " * triangulate().\n"
  " *\n"
  " * This is a zero-based index into the vertices added by repeated calls to\n"
  " * add_vertex().\n"
  " */";
#else
static const char *Dtool_Triangulator_get_triangle_v0_871_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int Triangulator::get_triangle_v1(int n) const
 */
static PyObject *Dtool_Triangulator_get_triangle_v1_872(PyObject *self, PyObject *arg) {
  Triangulator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Triangulator)) {
    return nullptr;
  }
  // 1-int Triangulator::get_triangle_v1(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const Triangulator*)local_this).get_triangle_v1)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_triangle_v1(Triangulator self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Triangulator_get_triangle_v1_872_comment =
  "C++ Interface:\n"
  "get_triangle_v1(Triangulator self, int n)\n"
  "\n"
  "/**\n"
  " * Returns vertex 1 of the nth triangle generated by the previous call to\n"
  " * triangulate().\n"
  " *\n"
  " * This is a zero-based index into the vertices added by repeated calls to\n"
  " * add_vertex().\n"
  " */";
#else
static const char *Dtool_Triangulator_get_triangle_v1_872_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int Triangulator::get_triangle_v2(int n) const
 */
static PyObject *Dtool_Triangulator_get_triangle_v2_873(PyObject *self, PyObject *arg) {
  Triangulator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Triangulator)) {
    return nullptr;
  }
  // 1-int Triangulator::get_triangle_v2(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const Triangulator*)local_this).get_triangle_v2)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_triangle_v2(Triangulator self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Triangulator_get_triangle_v2_873_comment =
  "C++ Interface:\n"
  "get_triangle_v2(Triangulator self, int n)\n"
  "\n"
  "/**\n"
  " * Returns vertex 2 of the nth triangle generated by the previous call to\n"
  " * triangulate().\n"
  " *\n"
  " * This is a zero-based index into the vertices added by repeated calls to\n"
  " * add_vertex().\n"
  " */";
#else
static const char *Dtool_Triangulator_get_triangle_v2_873_comment = nullptr;
#endif

/**
 * sequence length function for property Triangulator::vertices
 */
static Py_ssize_t Dtool_Triangulator_vertices_Len(PyObject *self) {
  Triangulator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Triangulator, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_vertices)();
}

/**
 * sequence getter for property Triangulator::vertices
 */
static PyObject *Dtool_Triangulator_vertices_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  Triangulator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Triangulator, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_vertices)()) {
    PyErr_SetString(PyExc_IndexError, "Triangulator.vertices[] index out of range");
    return nullptr;
  }
  // 1-inline LPoint2d const &Triangulator::get_vertex(int n) const
  LPoint2d const *return_value = &(((*(const Triangulator*)local_this).get_vertex)(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex(Triangulator self, index)\n");
  }
}

static PyObject *Dtool_Triangulator_vertices_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "Triangulator.vertices");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_Triangulator_vertices_Len;
    wrap->_getitem_func = &Dtool_Triangulator_vertices_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * Triangulator::Triangulator(void)
 * inline Triangulator::Triangulator(Triangulator const &) = default
 */
static int Dtool_Init_Triangulator(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("Triangulator() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-Triangulator::Triangulator(void)
      Triangulator *return_value = new Triangulator();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Triangulator, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline Triangulator::Triangulator(Triangulator const &) = default
      Triangulator const *arg_this = (Triangulator *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Triangulator, 0, "Triangulator.Triangulator", true, true);
      if (arg_this != nullptr) {
        Triangulator *return_value = new Triangulator(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Triangulator, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Triangulator() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Triangulator()\n"
      "Triangulator(const Triangulator param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_Triangulator_get_vertices(PyObject *self, PyObject *) {
  Triangulator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Triangulator, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_vertices)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_Triangulator_get_vertex_859(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_Triangulator(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Triangulator) {
    printf("Triangulator ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Triangulator *local_this = (Triangulator *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Triangulator) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Triangulator(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Triangulator) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Triangulator3
 */
/**
 * Python function wrapper for:
 * void Triangulator3::clear(void)
 */
static PyObject *Dtool_Triangulator3_clear_877(PyObject *self, PyObject *) {
  Triangulator3 *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Triangulator3, (void **)&local_this, "Triangulator3.clear")) {
    return nullptr;
  }
  // 1-void Triangulator3::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Triangulator3_clear_877_comment =
  "C++ Interface:\n"
  "clear(const Triangulator3 self)\n"
  "\n"
  "/**\n"
  " * Removes all vertices and polygon specifications from the Triangulator, and\n"
  " * prepares it to start over.\n"
  " */";
#else
static const char *Dtool_Triangulator3_clear_877_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int Triangulator3::add_vertex(LPoint3d const &point)
 * inline int Triangulator3::add_vertex(double x, double y, double z)
 */
static PyObject *Dtool_Triangulator3_add_vertex_878(PyObject *self, PyObject *args, PyObject *kwds) {
  Triangulator3 *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Triangulator3, (void **)&local_this, "Triangulator3.add_vertex")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "point")) {
        // 1-int Triangulator3::add_vertex(LPoint3d const &point)
        LPoint3d arg_local;
        LPoint3d const *arg_this = Dtool_Coerce_LPoint3d(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "Triangulator3.add_vertex", "LPoint3d");
        }
        int return_value = ((*local_this).add_vertex)(*arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 3:
    {
      // 1-inline int Triangulator3::add_vertex(double x, double y, double z)
      double param1;
      double param2;
      double param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ddd:add_vertex", (char **)keyword_list, &param1, &param2, &param3)) {
        int return_value = ((*local_this).add_vertex)((double)param1, (double)param2, (double)param3);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_vertex() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_vertex(const Triangulator3 self, const LPoint3d point)\n"
      "add_vertex(const Triangulator3 self, double x, double y, double z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Triangulator3_add_vertex_878_comment =
  "C++ Interface:\n"
  "add_vertex(const Triangulator3 self, const LPoint3d point)\n"
  "add_vertex(const Triangulator3 self, double x, double y, double z)\n"
  "\n"
  "/**\n"
  " * Adds a new vertex to the vertex pool.  Returns the vertex index number.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds a new vertex to the vertex pool.  Returns the vertex index number.\n"
  " */";
#else
static const char *Dtool_Triangulator3_add_vertex_878_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Triangulator3::get_num_vertices(void) const
 */
static PyObject *Dtool_Triangulator3_get_num_vertices_879(PyObject *self, PyObject *) {
  Triangulator3 *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Triangulator3)) {
    return nullptr;
  }
  // 1-inline int Triangulator3::get_num_vertices(void) const
  int return_value = ((*(const Triangulator3*)local_this).get_num_vertices)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Triangulator3_get_num_vertices_879_comment =
  "C++ Interface:\n"
  "get_num_vertices(Triangulator3 self)\n"
  "\n"
  "/**\n"
  " * Returns the number of vertices in the pool.  Note that the Triangulator\n"
  " * might append new vertices, in addition to those added by the user, if any\n"
  " * of the polygon is self-intersecting, or if any of the holes intersect some\n"
  " * part of the polygon edges.\n"
  " */";
#else
static const char *Dtool_Triangulator3_get_num_vertices_879_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3d const &Triangulator3::get_vertex(int n) const
 */
static PyObject *Dtool_Triangulator3_get_vertex_880(PyObject *self, PyObject *arg) {
  Triangulator3 *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Triangulator3)) {
    return nullptr;
  }
  // 1-inline LPoint3d const &Triangulator3::get_vertex(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPoint3d const *return_value = &(((*(const Triangulator3*)local_this).get_vertex)((int)arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex(Triangulator3 self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Triangulator3_get_vertex_880_comment =
  "C++ Interface:\n"
  "get_vertex(Triangulator3 self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth vertex.\n"
  " */";
#else
static const char *Dtool_Triangulator3_get_vertex_880_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Triangulator3::triangulate(void)
 */
static PyObject *Dtool_Triangulator3_triangulate_882(PyObject *self, PyObject *) {
  Triangulator3 *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Triangulator3, (void **)&local_this, "Triangulator3.triangulate")) {
    return nullptr;
  }
  // 1-void Triangulator3::triangulate(void)
  ((*local_this).triangulate)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Triangulator3_triangulate_882_comment =
  "C++ Interface:\n"
  "triangulate(const Triangulator3 self)\n"
  "\n"
  "/**\n"
  " * Does the work of triangulating the specified polygon.  After this call, you\n"
  " * may retrieve the new triangles one at a time by iterating through\n"
  " * get_triangle_v0/1/2().\n"
  " */";
#else
static const char *Dtool_Triangulator3_triangulate_882_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPlaned const &Triangulator3::get_plane(void) const
 */
static PyObject *Dtool_Triangulator3_get_plane_883(PyObject *self, PyObject *) {
  Triangulator3 *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Triangulator3)) {
    return nullptr;
  }
  // 1-inline LPlaned const &Triangulator3::get_plane(void) const
  LPlaned const *return_value = &(((*(const Triangulator3*)local_this).get_plane)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlaned, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Triangulator3_get_plane_883_comment =
  "C++ Interface:\n"
  "get_plane(Triangulator3 self)\n"
  "\n"
  "/**\n"
  " * Returns the plane of the polygon.  This is only available after calling\n"
  " * triangulate().\n"
  " */";
#else
static const char *Dtool_Triangulator3_get_plane_883_comment = nullptr;
#endif

/**
 * sequence length function for property Triangulator3::vertices
 */
static Py_ssize_t Dtool_Triangulator3_vertices_Len(PyObject *self) {
  Triangulator3 *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Triangulator3, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_vertices)();
}

/**
 * sequence getter for property Triangulator3::vertices
 */
static PyObject *Dtool_Triangulator3_vertices_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  Triangulator3 *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Triangulator3, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_vertices)()) {
    PyErr_SetString(PyExc_IndexError, "Triangulator3.vertices[] index out of range");
    return nullptr;
  }
  // 1-inline LPoint3d const &Triangulator3::get_vertex(int n) const
  LPoint3d const *return_value = &(((*(const Triangulator3*)local_this).get_vertex)(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex(Triangulator3 self, index)\n");
  }
}

static PyObject *Dtool_Triangulator3_vertices_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "Triangulator3.vertices");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_Triangulator3_vertices_Len;
    wrap->_getitem_func = &Dtool_Triangulator3_vertices_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

static PyObject *Dtool_Triangulator3_plane_Getter(PyObject *self, void *) {
  const Triangulator3 *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Triangulator3, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LPlaned const &Triangulator3::get_plane(void) const
  LPlaned const *return_value = &(((*(const Triangulator3*)local_this).get_plane)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlaned, false, true);
}

/**
 * Python function wrapper for:
 * Triangulator3::Triangulator3(void)
 * inline Triangulator3::Triangulator3(Triangulator3 const &) = default
 */
static int Dtool_Init_Triangulator3(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("Triangulator3() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-Triangulator3::Triangulator3(void)
      Triangulator3 *return_value = new Triangulator3();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Triangulator3, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline Triangulator3::Triangulator3(Triangulator3 const &) = default
      Triangulator3 const *arg_this = (Triangulator3 *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Triangulator3, 0, "Triangulator3.Triangulator3", true, true);
      if (arg_this != nullptr) {
        Triangulator3 *return_value = new Triangulator3(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Triangulator3, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Triangulator3() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Triangulator3()\n"
      "Triangulator3(const Triangulator3 param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_Triangulator3_get_vertices(PyObject *self, PyObject *) {
  Triangulator3 *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Triangulator3, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_vertices)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_Triangulator3_get_vertex_880(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_Triangulator3(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Triangulator3) {
    printf("Triangulator3 ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Triangulator3 *local_this = (Triangulator3 *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Triangulator3) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Triangulator) {
    return (Triangulator *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Triangulator3(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Triangulator3) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Triangulator) {
    Triangulator* other_this = (Triangulator*)from_this;
    return (Triangulator3*)other_this;
  }
  return nullptr;
}

/**
 * Python method tables for ConstPointerToArray_LMatrix3d (ConstPointerToArray_LMatrix3d)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_LMatrix3d[] = {
  {"clear", &Dtool_ConstPointerToArray_LMatrix3d_clear_9, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LMatrix3d_clear_9_comment},
  {"get_element", &Dtool_ConstPointerToArray_LMatrix3d_get_element_11, METH_O, (const char *)Dtool_ConstPointerToArray_LMatrix3d_get_element_11_comment},
  {"getElement", &Dtool_ConstPointerToArray_LMatrix3d_get_element_11, METH_O, (const char *)Dtool_ConstPointerToArray_LMatrix3d_get_element_11_comment},
  {"get_data", &Dtool_ConstPointerToArray_LMatrix3d_get_data_13, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LMatrix3d_get_data_13_comment},
  {"getData", &Dtool_ConstPointerToArray_LMatrix3d_get_data_13, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LMatrix3d_get_data_13_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_LMatrix3d_get_subdata_14, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LMatrix3d_get_subdata_14_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_LMatrix3d_get_subdata_14, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LMatrix3d_get_subdata_14_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_LMatrix3d_get_ref_count_15, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LMatrix3d_get_ref_count_15_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_LMatrix3d_get_ref_count_15, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LMatrix3d_get_ref_count_15_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_LMatrix3d_get_node_ref_count_16, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LMatrix3d_get_node_ref_count_16_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_LMatrix3d_get_node_ref_count_16, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LMatrix3d_get_node_ref_count_16_comment},
  {"count", &Dtool_ConstPointerToArray_LMatrix3d_count_17, METH_O, (const char *)Dtool_ConstPointerToArray_LMatrix3d_count_17_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LMatrix3d slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_LMatrix3d_getbuffer_18_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< LMatrix3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LMatrix3d, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< LMatrix3d > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LMatrix3d slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_LMatrix3d_releasebuffer_19_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< LMatrix3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LMatrix3d, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< LMatrix3d > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LMatrix3d slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_LMatrix3d_getitem_12_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< LMatrix3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LMatrix3d, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_LMatrix3d index out of range");
    return nullptr;
  }
  // 1-LMatrix3d const &ConstPointerToArray< LMatrix3d >::__getitem__(unsigned long int n) const
  LMatrix3d const *return_value = &(invoke_extension((const ConstPointerToArray< LMatrix3d >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LMatrix3d slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_LMatrix3d_size_10_sq_length(PyObject *self) {
  ConstPointerToArray< LMatrix3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LMatrix3d, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_LMatrix3d = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_LMatrix3d = {
  &Dtool_ConstPointerToArray_LMatrix3d_size_10_sq_length,
  nullptr,
  nullptr,
  &Dtool_ConstPointerToArray_LMatrix3d_getitem_12_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_LMatrix3d = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_LMatrix3d = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_LMatrix3d_getbuffer_18_bf_getbuffer,
  &Dtool_ConstPointerToArray_LMatrix3d_releasebuffer_19_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConstPointerToArray_LMatrix3d = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_LMatrix3d = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConstPointerToArray_LMatrix3d",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_LMatrix3d,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConstPointerToArray_LMatrix3d,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ConstPointerToArray_LMatrix3d,
    &Dtool_SequenceMethods_ConstPointerToArray_LMatrix3d,
    &Dtool_MappingMethods_ConstPointerToArray_LMatrix3d,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConstPointerToArray_LMatrix3d,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConstPointerToArray_LMatrix3d,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_LMatrix3d,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_LMatrix3d,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_LMatrix3d,
  Dtool_UpcastInterface_ConstPointerToArray_LMatrix3d,
  Dtool_DowncastInterface_ConstPointerToArray_LMatrix3d,
  nullptr,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_LMatrix3d,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_LMatrix3d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LMatrix3d(nullptr);
    Dtool_ConstPointerToArray_LMatrix3d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LMatrix3d);
    Dtool_ConstPointerToArray_LMatrix3d._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_LMatrix3d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_LMatrix3d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_LMatrix3d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_LMatrix3d);
  }
}

/**
 * Python method tables for PointerToArrayBase_LMatrix3d (PointerToArrayBase_LMatrix3d)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_LMatrix3d[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_LMatrix3d = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_LMatrix3d = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_LMatrix3d = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_LMatrix3d = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArrayBase_LMatrix3d = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_LMatrix3d = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArrayBase_LMatrix3d",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_LMatrix3d,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArrayBase_LMatrix3d,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArrayBase_LMatrix3d,
    &Dtool_SequenceMethods_PointerToArrayBase_LMatrix3d,
    &Dtool_MappingMethods_PointerToArrayBase_LMatrix3d,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArrayBase_LMatrix3d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArrayBase_LMatrix3d,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_LMatrix3d,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_LMatrix3d,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_LMatrix3d,
  Dtool_UpcastInterface_PointerToArrayBase_LMatrix3d,
  Dtool_DowncastInterface_PointerToArrayBase_LMatrix3d,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_LMatrix3d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LMatrix3d(nullptr);
    Dtool_PointerToArrayBase_LMatrix3d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d);
    Dtool_PointerToArrayBase_LMatrix3d._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_LMatrix3d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_LMatrix3d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_LMatrix3d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_LMatrix3d);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_LMatrix3d (PointerToBase_ReferenceCountedVector_LMatrix3d)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_LMatrix3d[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d_clear_5, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d_clear_5_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d_output_6, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d_output_6_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_LMatrix3d
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_LMatrix3d(PyObject *self) {
  PointerToBase< ReferenceCountedVector< LMatrix3d > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LMatrix3d = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LMatrix3d = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LMatrix3d = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LMatrix3d = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_LMatrix3d = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_LMatrix3d",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_LMatrix3d,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_LMatrix3d,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LMatrix3d,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LMatrix3d,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LMatrix3d,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LMatrix3d,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LMatrix3d,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LMatrix3d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToBase_ReferenceCountedVector_LMatrix3d,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_LMatrix3d,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_LMatrix3d,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LMatrix3d,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LMatrix3d,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LMatrix3d,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LMatrix3d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PointerToVoid != nullptr);
    assert(Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit(nullptr);
    Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PointerToVoid);
    Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_LMatrix3d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d);
  }
}

/**
 * Python method tables for ConstPointerToArray_LMatrix3f (ConstPointerToArray_LMatrix3f)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_LMatrix3f[] = {
  {"clear", &Dtool_ConstPointerToArray_LMatrix3f_clear_28, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LMatrix3f_clear_28_comment},
  {"get_element", &Dtool_ConstPointerToArray_LMatrix3f_get_element_30, METH_O, (const char *)Dtool_ConstPointerToArray_LMatrix3f_get_element_30_comment},
  {"getElement", &Dtool_ConstPointerToArray_LMatrix3f_get_element_30, METH_O, (const char *)Dtool_ConstPointerToArray_LMatrix3f_get_element_30_comment},
  {"get_data", &Dtool_ConstPointerToArray_LMatrix3f_get_data_32, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LMatrix3f_get_data_32_comment},
  {"getData", &Dtool_ConstPointerToArray_LMatrix3f_get_data_32, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LMatrix3f_get_data_32_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_LMatrix3f_get_subdata_33, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LMatrix3f_get_subdata_33_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_LMatrix3f_get_subdata_33, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LMatrix3f_get_subdata_33_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_LMatrix3f_get_ref_count_34, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LMatrix3f_get_ref_count_34_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_LMatrix3f_get_ref_count_34, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LMatrix3f_get_ref_count_34_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_LMatrix3f_get_node_ref_count_35, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LMatrix3f_get_node_ref_count_35_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_LMatrix3f_get_node_ref_count_35, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LMatrix3f_get_node_ref_count_35_comment},
  {"count", &Dtool_ConstPointerToArray_LMatrix3f_count_36, METH_O, (const char *)Dtool_ConstPointerToArray_LMatrix3f_count_36_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LMatrix3f slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_LMatrix3f_getbuffer_37_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< LMatrix3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LMatrix3f, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< LMatrix3f > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LMatrix3f slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_LMatrix3f_releasebuffer_38_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< LMatrix3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LMatrix3f, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< LMatrix3f > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LMatrix3f slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_LMatrix3f_getitem_31_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< LMatrix3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LMatrix3f, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_LMatrix3f index out of range");
    return nullptr;
  }
  // 1-LMatrix3f const &ConstPointerToArray< LMatrix3f >::__getitem__(unsigned long int n) const
  LMatrix3f const *return_value = &(invoke_extension((const ConstPointerToArray< LMatrix3f >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LMatrix3f slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_LMatrix3f_size_29_sq_length(PyObject *self) {
  ConstPointerToArray< LMatrix3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LMatrix3f, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_LMatrix3f = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_LMatrix3f = {
  &Dtool_ConstPointerToArray_LMatrix3f_size_29_sq_length,
  nullptr,
  nullptr,
  &Dtool_ConstPointerToArray_LMatrix3f_getitem_31_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_LMatrix3f = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_LMatrix3f = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_LMatrix3f_getbuffer_37_bf_getbuffer,
  &Dtool_ConstPointerToArray_LMatrix3f_releasebuffer_38_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConstPointerToArray_LMatrix3f = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_LMatrix3f = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConstPointerToArray_LMatrix3f",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_LMatrix3f,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConstPointerToArray_LMatrix3f,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ConstPointerToArray_LMatrix3f,
    &Dtool_SequenceMethods_ConstPointerToArray_LMatrix3f,
    &Dtool_MappingMethods_ConstPointerToArray_LMatrix3f,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConstPointerToArray_LMatrix3f,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConstPointerToArray_LMatrix3f,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_LMatrix3f,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_LMatrix3f,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_LMatrix3f,
  Dtool_UpcastInterface_ConstPointerToArray_LMatrix3f,
  Dtool_DowncastInterface_ConstPointerToArray_LMatrix3f,
  nullptr,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_LMatrix3f,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_LMatrix3f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LMatrix3f(nullptr);
    Dtool_ConstPointerToArray_LMatrix3f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LMatrix3f);
    Dtool_ConstPointerToArray_LMatrix3f._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_LMatrix3f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_LMatrix3f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_LMatrix3f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_LMatrix3f);
  }
}

/**
 * Python method tables for PointerToArrayBase_LMatrix3f (PointerToArrayBase_LMatrix3f)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_LMatrix3f[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_LMatrix3f = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_LMatrix3f = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_LMatrix3f = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_LMatrix3f = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArrayBase_LMatrix3f = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_LMatrix3f = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArrayBase_LMatrix3f",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_LMatrix3f,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArrayBase_LMatrix3f,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArrayBase_LMatrix3f,
    &Dtool_SequenceMethods_PointerToArrayBase_LMatrix3f,
    &Dtool_MappingMethods_PointerToArrayBase_LMatrix3f,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArrayBase_LMatrix3f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArrayBase_LMatrix3f,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_LMatrix3f,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_LMatrix3f,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_LMatrix3f,
  Dtool_UpcastInterface_PointerToArrayBase_LMatrix3f,
  Dtool_DowncastInterface_PointerToArrayBase_LMatrix3f,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_LMatrix3f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LMatrix3f(nullptr);
    Dtool_PointerToArrayBase_LMatrix3f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f);
    Dtool_PointerToArrayBase_LMatrix3f._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_LMatrix3f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_LMatrix3f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_LMatrix3f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_LMatrix3f);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_LMatrix3f (PointerToBase_ReferenceCountedVector_LMatrix3f)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_LMatrix3f[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f_clear_24, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f_clear_24_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f_output_25, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f_output_25_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_LMatrix3f
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_LMatrix3f(PyObject *self) {
  PointerToBase< ReferenceCountedVector< LMatrix3f > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LMatrix3f = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LMatrix3f = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LMatrix3f = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LMatrix3f = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_LMatrix3f = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_LMatrix3f",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_LMatrix3f,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_LMatrix3f,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LMatrix3f,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LMatrix3f,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LMatrix3f,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LMatrix3f,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LMatrix3f,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LMatrix3f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToBase_ReferenceCountedVector_LMatrix3f,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_LMatrix3f,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_LMatrix3f,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LMatrix3f,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LMatrix3f,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LMatrix3f,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LMatrix3f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PointerToVoid != nullptr);
    assert(Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit(nullptr);
    Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PointerToVoid);
    Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_LMatrix3f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f);
  }
}

/**
 * Python method tables for ConstPointerToArray_LVecBase2d (ConstPointerToArray_LVecBase2d)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_LVecBase2d[] = {
  {"clear", &Dtool_ConstPointerToArray_LVecBase2d_clear_47, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2d_clear_47_comment},
  {"get_element", &Dtool_ConstPointerToArray_LVecBase2d_get_element_49, METH_O, (const char *)Dtool_ConstPointerToArray_LVecBase2d_get_element_49_comment},
  {"getElement", &Dtool_ConstPointerToArray_LVecBase2d_get_element_49, METH_O, (const char *)Dtool_ConstPointerToArray_LVecBase2d_get_element_49_comment},
  {"get_data", &Dtool_ConstPointerToArray_LVecBase2d_get_data_51, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2d_get_data_51_comment},
  {"getData", &Dtool_ConstPointerToArray_LVecBase2d_get_data_51, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2d_get_data_51_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_LVecBase2d_get_subdata_52, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LVecBase2d_get_subdata_52_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_LVecBase2d_get_subdata_52, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LVecBase2d_get_subdata_52_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_LVecBase2d_get_ref_count_53, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2d_get_ref_count_53_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_LVecBase2d_get_ref_count_53, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2d_get_ref_count_53_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_LVecBase2d_get_node_ref_count_54, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2d_get_node_ref_count_54_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_LVecBase2d_get_node_ref_count_54, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2d_get_node_ref_count_54_comment},
  {"count", &Dtool_ConstPointerToArray_LVecBase2d_count_55, METH_O, (const char *)Dtool_ConstPointerToArray_LVecBase2d_count_55_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase2d slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_LVecBase2d_getbuffer_56_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< LVecBase2d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2d, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< LVecBase2d > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase2d slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_LVecBase2d_releasebuffer_57_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< LVecBase2d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2d, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< LVecBase2d > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase2d slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_LVecBase2d_getitem_50_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< LVecBase2d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2d, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_LVecBase2d index out of range");
    return nullptr;
  }
  // 1-LVecBase2d const &ConstPointerToArray< LVecBase2d >::__getitem__(unsigned long int n) const
  LVecBase2d const *return_value = &(invoke_extension((const ConstPointerToArray< LVecBase2d >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase2d slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_LVecBase2d_size_48_sq_length(PyObject *self) {
  ConstPointerToArray< LVecBase2d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2d, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_LVecBase2d = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_LVecBase2d = {
  &Dtool_ConstPointerToArray_LVecBase2d_size_48_sq_length,
  nullptr,
  nullptr,
  &Dtool_ConstPointerToArray_LVecBase2d_getitem_50_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_LVecBase2d = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_LVecBase2d = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_LVecBase2d_getbuffer_56_bf_getbuffer,
  &Dtool_ConstPointerToArray_LVecBase2d_releasebuffer_57_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConstPointerToArray_LVecBase2d = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_LVecBase2d = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConstPointerToArray_LVecBase2d",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_LVecBase2d,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConstPointerToArray_LVecBase2d,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ConstPointerToArray_LVecBase2d,
    &Dtool_SequenceMethods_ConstPointerToArray_LVecBase2d,
    &Dtool_MappingMethods_ConstPointerToArray_LVecBase2d,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConstPointerToArray_LVecBase2d,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConstPointerToArray_LVecBase2d,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_LVecBase2d,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_LVecBase2d,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2d,
  Dtool_UpcastInterface_ConstPointerToArray_LVecBase2d,
  Dtool_DowncastInterface_ConstPointerToArray_LVecBase2d,
  nullptr,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_LVecBase2d,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2d(nullptr);
    Dtool_ConstPointerToArray_LVecBase2d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase2d);
    Dtool_ConstPointerToArray_LVecBase2d._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_LVecBase2d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_LVecBase2d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_LVecBase2d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_LVecBase2d);
  }
}

/**
 * Python method tables for PointerToArrayBase_LVecBase2d (PointerToArrayBase_LVecBase2d)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_LVecBase2d[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_LVecBase2d = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_LVecBase2d = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_LVecBase2d = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_LVecBase2d = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArrayBase_LVecBase2d = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_LVecBase2d = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArrayBase_LVecBase2d",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_LVecBase2d,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArrayBase_LVecBase2d,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArrayBase_LVecBase2d,
    &Dtool_SequenceMethods_PointerToArrayBase_LVecBase2d,
    &Dtool_MappingMethods_PointerToArrayBase_LVecBase2d,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArrayBase_LVecBase2d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArrayBase_LVecBase2d,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_LVecBase2d,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_LVecBase2d,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2d,
  Dtool_UpcastInterface_PointerToArrayBase_LVecBase2d,
  Dtool_DowncastInterface_PointerToArrayBase_LVecBase2d,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2d(nullptr);
    Dtool_PointerToArrayBase_LVecBase2d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d);
    Dtool_PointerToArrayBase_LVecBase2d._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_LVecBase2d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase2d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_LVecBase2d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase2d);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_LVecBase2d (PointerToBase_ReferenceCountedVector_LVecBase2d)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_LVecBase2d[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d_clear_43, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d_clear_43_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d_output_44, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d_output_44_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_LVecBase2d
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase2d(PyObject *self) {
  PointerToBase< ReferenceCountedVector< LVecBase2d > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LVecBase2d = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LVecBase2d = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LVecBase2d = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LVecBase2d = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_LVecBase2d = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_LVecBase2d",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_LVecBase2d,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_LVecBase2d,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase2d,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LVecBase2d,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LVecBase2d,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LVecBase2d,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase2d,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LVecBase2d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToBase_ReferenceCountedVector_LVecBase2d,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_LVecBase2d,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_LVecBase2d,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2d,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LVecBase2d,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LVecBase2d,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PointerToVoid != nullptr);
    assert(Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit(nullptr);
    Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PointerToVoid);
    Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_LVecBase2d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d);
  }
}

/**
 * Python method tables for ConstPointerToArray_LVecBase2f (ConstPointerToArray_LVecBase2f)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_LVecBase2f[] = {
  {"clear", &Dtool_ConstPointerToArray_LVecBase2f_clear_66, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2f_clear_66_comment},
  {"get_element", &Dtool_ConstPointerToArray_LVecBase2f_get_element_68, METH_O, (const char *)Dtool_ConstPointerToArray_LVecBase2f_get_element_68_comment},
  {"getElement", &Dtool_ConstPointerToArray_LVecBase2f_get_element_68, METH_O, (const char *)Dtool_ConstPointerToArray_LVecBase2f_get_element_68_comment},
  {"get_data", &Dtool_ConstPointerToArray_LVecBase2f_get_data_70, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2f_get_data_70_comment},
  {"getData", &Dtool_ConstPointerToArray_LVecBase2f_get_data_70, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2f_get_data_70_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_LVecBase2f_get_subdata_71, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LVecBase2f_get_subdata_71_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_LVecBase2f_get_subdata_71, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LVecBase2f_get_subdata_71_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_LVecBase2f_get_ref_count_72, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2f_get_ref_count_72_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_LVecBase2f_get_ref_count_72, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2f_get_ref_count_72_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_LVecBase2f_get_node_ref_count_73, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2f_get_node_ref_count_73_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_LVecBase2f_get_node_ref_count_73, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2f_get_node_ref_count_73_comment},
  {"count", &Dtool_ConstPointerToArray_LVecBase2f_count_74, METH_O, (const char *)Dtool_ConstPointerToArray_LVecBase2f_count_74_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase2f slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_LVecBase2f_getbuffer_75_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< LVecBase2f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2f, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< LVecBase2f > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase2f slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_LVecBase2f_releasebuffer_76_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< LVecBase2f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2f, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< LVecBase2f > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase2f slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_LVecBase2f_getitem_69_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< LVecBase2f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2f, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_LVecBase2f index out of range");
    return nullptr;
  }
  // 1-LVecBase2f const &ConstPointerToArray< LVecBase2f >::__getitem__(unsigned long int n) const
  LVecBase2f const *return_value = &(invoke_extension((const ConstPointerToArray< LVecBase2f >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase2f slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_LVecBase2f_size_67_sq_length(PyObject *self) {
  ConstPointerToArray< LVecBase2f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2f, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_LVecBase2f = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_LVecBase2f = {
  &Dtool_ConstPointerToArray_LVecBase2f_size_67_sq_length,
  nullptr,
  nullptr,
  &Dtool_ConstPointerToArray_LVecBase2f_getitem_69_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_LVecBase2f = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_LVecBase2f = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_LVecBase2f_getbuffer_75_bf_getbuffer,
  &Dtool_ConstPointerToArray_LVecBase2f_releasebuffer_76_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConstPointerToArray_LVecBase2f = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_LVecBase2f = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConstPointerToArray_LVecBase2f",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_LVecBase2f,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConstPointerToArray_LVecBase2f,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ConstPointerToArray_LVecBase2f,
    &Dtool_SequenceMethods_ConstPointerToArray_LVecBase2f,
    &Dtool_MappingMethods_ConstPointerToArray_LVecBase2f,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConstPointerToArray_LVecBase2f,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConstPointerToArray_LVecBase2f,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_LVecBase2f,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_LVecBase2f,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2f,
  Dtool_UpcastInterface_ConstPointerToArray_LVecBase2f,
  Dtool_DowncastInterface_ConstPointerToArray_LVecBase2f,
  nullptr,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_LVecBase2f,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2f(nullptr);
    Dtool_ConstPointerToArray_LVecBase2f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase2f);
    Dtool_ConstPointerToArray_LVecBase2f._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_LVecBase2f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_LVecBase2f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_LVecBase2f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_LVecBase2f);
  }
}

/**
 * Python method tables for PointerToArrayBase_LVecBase2f (PointerToArrayBase_LVecBase2f)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_LVecBase2f[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_LVecBase2f = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_LVecBase2f = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_LVecBase2f = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_LVecBase2f = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArrayBase_LVecBase2f = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_LVecBase2f = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArrayBase_LVecBase2f",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_LVecBase2f,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArrayBase_LVecBase2f,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArrayBase_LVecBase2f,
    &Dtool_SequenceMethods_PointerToArrayBase_LVecBase2f,
    &Dtool_MappingMethods_PointerToArrayBase_LVecBase2f,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArrayBase_LVecBase2f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArrayBase_LVecBase2f,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_LVecBase2f,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_LVecBase2f,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2f,
  Dtool_UpcastInterface_PointerToArrayBase_LVecBase2f,
  Dtool_DowncastInterface_PointerToArrayBase_LVecBase2f,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2f(nullptr);
    Dtool_PointerToArrayBase_LVecBase2f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f);
    Dtool_PointerToArrayBase_LVecBase2f._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_LVecBase2f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase2f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_LVecBase2f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase2f);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_LVecBase2f (PointerToBase_ReferenceCountedVector_LVecBase2f)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_LVecBase2f[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f_clear_62, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f_clear_62_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f_output_63, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f_output_63_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_LVecBase2f
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase2f(PyObject *self) {
  PointerToBase< ReferenceCountedVector< LVecBase2f > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LVecBase2f = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LVecBase2f = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LVecBase2f = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LVecBase2f = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_LVecBase2f = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_LVecBase2f",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_LVecBase2f,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_LVecBase2f,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase2f,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LVecBase2f,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LVecBase2f,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LVecBase2f,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase2f,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LVecBase2f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToBase_ReferenceCountedVector_LVecBase2f,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_LVecBase2f,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_LVecBase2f,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2f,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LVecBase2f,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LVecBase2f,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PointerToVoid != nullptr);
    assert(Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit(nullptr);
    Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PointerToVoid);
    Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_LVecBase2f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f);
  }
}

/**
 * Python method tables for ConstPointerToArray_LVecBase2i (ConstPointerToArray_LVecBase2i)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_LVecBase2i[] = {
  {"clear", &Dtool_ConstPointerToArray_LVecBase2i_clear_85, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2i_clear_85_comment},
  {"get_element", &Dtool_ConstPointerToArray_LVecBase2i_get_element_87, METH_O, (const char *)Dtool_ConstPointerToArray_LVecBase2i_get_element_87_comment},
  {"getElement", &Dtool_ConstPointerToArray_LVecBase2i_get_element_87, METH_O, (const char *)Dtool_ConstPointerToArray_LVecBase2i_get_element_87_comment},
  {"get_data", &Dtool_ConstPointerToArray_LVecBase2i_get_data_89, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2i_get_data_89_comment},
  {"getData", &Dtool_ConstPointerToArray_LVecBase2i_get_data_89, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2i_get_data_89_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_LVecBase2i_get_subdata_90, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LVecBase2i_get_subdata_90_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_LVecBase2i_get_subdata_90, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LVecBase2i_get_subdata_90_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_LVecBase2i_get_ref_count_91, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2i_get_ref_count_91_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_LVecBase2i_get_ref_count_91, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2i_get_ref_count_91_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_LVecBase2i_get_node_ref_count_92, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2i_get_node_ref_count_92_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_LVecBase2i_get_node_ref_count_92, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase2i_get_node_ref_count_92_comment},
  {"count", &Dtool_ConstPointerToArray_LVecBase2i_count_93, METH_O, (const char *)Dtool_ConstPointerToArray_LVecBase2i_count_93_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase2i slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_LVecBase2i_getbuffer_94_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< LVecBase2i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2i, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< LVecBase2i > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase2i slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_LVecBase2i_releasebuffer_95_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< LVecBase2i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2i, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< LVecBase2i > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase2i slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_LVecBase2i_getitem_88_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< LVecBase2i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2i, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_LVecBase2i index out of range");
    return nullptr;
  }
  // 1-LVecBase2i const &ConstPointerToArray< LVecBase2i >::__getitem__(unsigned long int n) const
  LVecBase2i const *return_value = &(invoke_extension((const ConstPointerToArray< LVecBase2i >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase2i slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_LVecBase2i_size_86_sq_length(PyObject *self) {
  ConstPointerToArray< LVecBase2i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase2i, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_LVecBase2i = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_LVecBase2i = {
  &Dtool_ConstPointerToArray_LVecBase2i_size_86_sq_length,
  nullptr,
  nullptr,
  &Dtool_ConstPointerToArray_LVecBase2i_getitem_88_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_LVecBase2i = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_LVecBase2i = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_LVecBase2i_getbuffer_94_bf_getbuffer,
  &Dtool_ConstPointerToArray_LVecBase2i_releasebuffer_95_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConstPointerToArray_LVecBase2i = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_LVecBase2i = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConstPointerToArray_LVecBase2i",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_LVecBase2i,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConstPointerToArray_LVecBase2i,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ConstPointerToArray_LVecBase2i,
    &Dtool_SequenceMethods_ConstPointerToArray_LVecBase2i,
    &Dtool_MappingMethods_ConstPointerToArray_LVecBase2i,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConstPointerToArray_LVecBase2i,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConstPointerToArray_LVecBase2i,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_LVecBase2i,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_LVecBase2i,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2i,
  Dtool_UpcastInterface_ConstPointerToArray_LVecBase2i,
  Dtool_DowncastInterface_ConstPointerToArray_LVecBase2i,
  nullptr,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_LVecBase2i,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2i(nullptr);
    Dtool_ConstPointerToArray_LVecBase2i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase2i);
    Dtool_ConstPointerToArray_LVecBase2i._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_LVecBase2i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_LVecBase2i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_LVecBase2i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_LVecBase2i);
  }
}

/**
 * Python method tables for PointerToArrayBase_LVecBase2i (PointerToArrayBase_LVecBase2i)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_LVecBase2i[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_LVecBase2i = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_LVecBase2i = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_LVecBase2i = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_LVecBase2i = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArrayBase_LVecBase2i = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_LVecBase2i = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArrayBase_LVecBase2i",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_LVecBase2i,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArrayBase_LVecBase2i,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArrayBase_LVecBase2i,
    &Dtool_SequenceMethods_PointerToArrayBase_LVecBase2i,
    &Dtool_MappingMethods_PointerToArrayBase_LVecBase2i,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArrayBase_LVecBase2i,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArrayBase_LVecBase2i,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_LVecBase2i,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_LVecBase2i,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2i,
  Dtool_UpcastInterface_PointerToArrayBase_LVecBase2i,
  Dtool_DowncastInterface_PointerToArrayBase_LVecBase2i,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2i(nullptr);
    Dtool_PointerToArrayBase_LVecBase2i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i);
    Dtool_PointerToArrayBase_LVecBase2i._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_LVecBase2i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase2i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_LVecBase2i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase2i);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_LVecBase2i (PointerToBase_ReferenceCountedVector_LVecBase2i)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_LVecBase2i[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i_clear_81, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i_clear_81_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i_output_82, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i_output_82_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_LVecBase2i
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase2i(PyObject *self) {
  PointerToBase< ReferenceCountedVector< LVecBase2i > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LVecBase2i = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LVecBase2i = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LVecBase2i = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LVecBase2i = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_LVecBase2i = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_LVecBase2i",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_LVecBase2i,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_LVecBase2i,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase2i,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LVecBase2i,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LVecBase2i,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LVecBase2i,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase2i,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LVecBase2i,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToBase_ReferenceCountedVector_LVecBase2i,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_LVecBase2i,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_LVecBase2i,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2i,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LVecBase2i,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LVecBase2i,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PointerToVoid != nullptr);
    assert(Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit(nullptr);
    Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PointerToVoid);
    Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_LVecBase2i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i);
  }
}

/**
 * Python method tables for ConstPointerToArray_LVecBase3d (ConstPointerToArray_LVecBase3d)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_LVecBase3d[] = {
  {"clear", &Dtool_ConstPointerToArray_LVecBase3d_clear_104, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3d_clear_104_comment},
  {"get_element", &Dtool_ConstPointerToArray_LVecBase3d_get_element_106, METH_O, (const char *)Dtool_ConstPointerToArray_LVecBase3d_get_element_106_comment},
  {"getElement", &Dtool_ConstPointerToArray_LVecBase3d_get_element_106, METH_O, (const char *)Dtool_ConstPointerToArray_LVecBase3d_get_element_106_comment},
  {"get_data", &Dtool_ConstPointerToArray_LVecBase3d_get_data_108, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3d_get_data_108_comment},
  {"getData", &Dtool_ConstPointerToArray_LVecBase3d_get_data_108, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3d_get_data_108_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_LVecBase3d_get_subdata_109, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LVecBase3d_get_subdata_109_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_LVecBase3d_get_subdata_109, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LVecBase3d_get_subdata_109_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_LVecBase3d_get_ref_count_110, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3d_get_ref_count_110_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_LVecBase3d_get_ref_count_110, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3d_get_ref_count_110_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_LVecBase3d_get_node_ref_count_111, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3d_get_node_ref_count_111_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_LVecBase3d_get_node_ref_count_111, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3d_get_node_ref_count_111_comment},
  {"count", &Dtool_ConstPointerToArray_LVecBase3d_count_112, METH_O, (const char *)Dtool_ConstPointerToArray_LVecBase3d_count_112_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase3d slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_LVecBase3d_getbuffer_113_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< LVecBase3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3d, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< LVecBase3d > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase3d slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_LVecBase3d_releasebuffer_114_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< LVecBase3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3d, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< LVecBase3d > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase3d slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_LVecBase3d_getitem_107_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< LVecBase3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3d, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_LVecBase3d index out of range");
    return nullptr;
  }
  // 1-LVecBase3d const &ConstPointerToArray< LVecBase3d >::__getitem__(unsigned long int n) const
  LVecBase3d const *return_value = &(invoke_extension((const ConstPointerToArray< LVecBase3d >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase3d slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_LVecBase3d_size_105_sq_length(PyObject *self) {
  ConstPointerToArray< LVecBase3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3d, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_LVecBase3d = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_LVecBase3d = {
  &Dtool_ConstPointerToArray_LVecBase3d_size_105_sq_length,
  nullptr,
  nullptr,
  &Dtool_ConstPointerToArray_LVecBase3d_getitem_107_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_LVecBase3d = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_LVecBase3d = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_LVecBase3d_getbuffer_113_bf_getbuffer,
  &Dtool_ConstPointerToArray_LVecBase3d_releasebuffer_114_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConstPointerToArray_LVecBase3d = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_LVecBase3d = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConstPointerToArray_LVecBase3d",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_LVecBase3d,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConstPointerToArray_LVecBase3d,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ConstPointerToArray_LVecBase3d,
    &Dtool_SequenceMethods_ConstPointerToArray_LVecBase3d,
    &Dtool_MappingMethods_ConstPointerToArray_LVecBase3d,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConstPointerToArray_LVecBase3d,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConstPointerToArray_LVecBase3d,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_LVecBase3d,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_LVecBase3d,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3d,
  Dtool_UpcastInterface_ConstPointerToArray_LVecBase3d,
  Dtool_DowncastInterface_ConstPointerToArray_LVecBase3d,
  nullptr,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_LVecBase3d,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3d(nullptr);
    Dtool_ConstPointerToArray_LVecBase3d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase3d);
    Dtool_ConstPointerToArray_LVecBase3d._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_LVecBase3d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_LVecBase3d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_LVecBase3d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_LVecBase3d);
  }
}

/**
 * Python method tables for PointerToArrayBase_LVecBase3d (PointerToArrayBase_LVecBase3d)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_LVecBase3d[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_LVecBase3d = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_LVecBase3d = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_LVecBase3d = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_LVecBase3d = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArrayBase_LVecBase3d = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_LVecBase3d = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArrayBase_LVecBase3d",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_LVecBase3d,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArrayBase_LVecBase3d,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArrayBase_LVecBase3d,
    &Dtool_SequenceMethods_PointerToArrayBase_LVecBase3d,
    &Dtool_MappingMethods_PointerToArrayBase_LVecBase3d,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArrayBase_LVecBase3d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArrayBase_LVecBase3d,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_LVecBase3d,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_LVecBase3d,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3d,
  Dtool_UpcastInterface_PointerToArrayBase_LVecBase3d,
  Dtool_DowncastInterface_PointerToArrayBase_LVecBase3d,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3d(nullptr);
    Dtool_PointerToArrayBase_LVecBase3d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d);
    Dtool_PointerToArrayBase_LVecBase3d._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_LVecBase3d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase3d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_LVecBase3d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase3d);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_LVecBase3d (PointerToBase_ReferenceCountedVector_LVecBase3d)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_LVecBase3d[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d_clear_100, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d_clear_100_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d_output_101, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d_output_101_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_LVecBase3d
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase3d(PyObject *self) {
  PointerToBase< ReferenceCountedVector< LVecBase3d > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LVecBase3d = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LVecBase3d = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LVecBase3d = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LVecBase3d = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_LVecBase3d = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_LVecBase3d",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_LVecBase3d,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_LVecBase3d,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase3d,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LVecBase3d,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LVecBase3d,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LVecBase3d,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase3d,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LVecBase3d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToBase_ReferenceCountedVector_LVecBase3d,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_LVecBase3d,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_LVecBase3d,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3d,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LVecBase3d,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LVecBase3d,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PointerToVoid != nullptr);
    assert(Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit(nullptr);
    Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PointerToVoid);
    Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_LVecBase3d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d);
  }
}

/**
 * Python method tables for ConstPointerToArray_LVecBase3f (ConstPointerToArray_LVecBase3f)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_LVecBase3f[] = {
  {"clear", &Dtool_ConstPointerToArray_LVecBase3f_clear_123, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3f_clear_123_comment},
  {"get_element", &Dtool_ConstPointerToArray_LVecBase3f_get_element_125, METH_O, (const char *)Dtool_ConstPointerToArray_LVecBase3f_get_element_125_comment},
  {"getElement", &Dtool_ConstPointerToArray_LVecBase3f_get_element_125, METH_O, (const char *)Dtool_ConstPointerToArray_LVecBase3f_get_element_125_comment},
  {"get_data", &Dtool_ConstPointerToArray_LVecBase3f_get_data_127, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3f_get_data_127_comment},
  {"getData", &Dtool_ConstPointerToArray_LVecBase3f_get_data_127, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3f_get_data_127_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_LVecBase3f_get_subdata_128, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LVecBase3f_get_subdata_128_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_LVecBase3f_get_subdata_128, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LVecBase3f_get_subdata_128_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_LVecBase3f_get_ref_count_129, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3f_get_ref_count_129_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_LVecBase3f_get_ref_count_129, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3f_get_ref_count_129_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_LVecBase3f_get_node_ref_count_130, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3f_get_node_ref_count_130_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_LVecBase3f_get_node_ref_count_130, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3f_get_node_ref_count_130_comment},
  {"count", &Dtool_ConstPointerToArray_LVecBase3f_count_131, METH_O, (const char *)Dtool_ConstPointerToArray_LVecBase3f_count_131_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase3f slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_LVecBase3f_getbuffer_132_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< LVecBase3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3f, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< LVecBase3f > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase3f slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_LVecBase3f_releasebuffer_133_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< LVecBase3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3f, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< LVecBase3f > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase3f slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_LVecBase3f_getitem_126_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< LVecBase3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3f, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_LVecBase3f index out of range");
    return nullptr;
  }
  // 1-LVecBase3f const &ConstPointerToArray< LVecBase3f >::__getitem__(unsigned long int n) const
  LVecBase3f const *return_value = &(invoke_extension((const ConstPointerToArray< LVecBase3f >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase3f slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_LVecBase3f_size_124_sq_length(PyObject *self) {
  ConstPointerToArray< LVecBase3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3f, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_LVecBase3f = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_LVecBase3f = {
  &Dtool_ConstPointerToArray_LVecBase3f_size_124_sq_length,
  nullptr,
  nullptr,
  &Dtool_ConstPointerToArray_LVecBase3f_getitem_126_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_LVecBase3f = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_LVecBase3f = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_LVecBase3f_getbuffer_132_bf_getbuffer,
  &Dtool_ConstPointerToArray_LVecBase3f_releasebuffer_133_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConstPointerToArray_LVecBase3f = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_LVecBase3f = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConstPointerToArray_LVecBase3f",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_LVecBase3f,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConstPointerToArray_LVecBase3f,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ConstPointerToArray_LVecBase3f,
    &Dtool_SequenceMethods_ConstPointerToArray_LVecBase3f,
    &Dtool_MappingMethods_ConstPointerToArray_LVecBase3f,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConstPointerToArray_LVecBase3f,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConstPointerToArray_LVecBase3f,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_LVecBase3f,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_LVecBase3f,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3f,
  Dtool_UpcastInterface_ConstPointerToArray_LVecBase3f,
  Dtool_DowncastInterface_ConstPointerToArray_LVecBase3f,
  nullptr,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_LVecBase3f,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3f(nullptr);
    Dtool_ConstPointerToArray_LVecBase3f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase3f);
    Dtool_ConstPointerToArray_LVecBase3f._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_LVecBase3f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_LVecBase3f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_LVecBase3f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_LVecBase3f);
  }
}

/**
 * Python method tables for PointerToArrayBase_LVecBase3f (PointerToArrayBase_LVecBase3f)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_LVecBase3f[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_LVecBase3f = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_LVecBase3f = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_LVecBase3f = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_LVecBase3f = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArrayBase_LVecBase3f = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_LVecBase3f = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArrayBase_LVecBase3f",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_LVecBase3f,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArrayBase_LVecBase3f,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArrayBase_LVecBase3f,
    &Dtool_SequenceMethods_PointerToArrayBase_LVecBase3f,
    &Dtool_MappingMethods_PointerToArrayBase_LVecBase3f,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArrayBase_LVecBase3f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArrayBase_LVecBase3f,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_LVecBase3f,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_LVecBase3f,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3f,
  Dtool_UpcastInterface_PointerToArrayBase_LVecBase3f,
  Dtool_DowncastInterface_PointerToArrayBase_LVecBase3f,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3f(nullptr);
    Dtool_PointerToArrayBase_LVecBase3f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f);
    Dtool_PointerToArrayBase_LVecBase3f._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_LVecBase3f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase3f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_LVecBase3f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase3f);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_LVecBase3f (PointerToBase_ReferenceCountedVector_LVecBase3f)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_LVecBase3f[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f_clear_119, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f_clear_119_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f_output_120, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f_output_120_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_LVecBase3f
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase3f(PyObject *self) {
  PointerToBase< ReferenceCountedVector< LVecBase3f > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LVecBase3f = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LVecBase3f = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LVecBase3f = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LVecBase3f = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_LVecBase3f = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_LVecBase3f",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_LVecBase3f,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_LVecBase3f,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase3f,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LVecBase3f,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LVecBase3f,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LVecBase3f,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase3f,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LVecBase3f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToBase_ReferenceCountedVector_LVecBase3f,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_LVecBase3f,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_LVecBase3f,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3f,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LVecBase3f,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LVecBase3f,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PointerToVoid != nullptr);
    assert(Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit(nullptr);
    Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PointerToVoid);
    Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_LVecBase3f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f);
  }
}

/**
 * Python method tables for ConstPointerToArray_LVecBase3i (ConstPointerToArray_LVecBase3i)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_LVecBase3i[] = {
  {"clear", &Dtool_ConstPointerToArray_LVecBase3i_clear_142, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3i_clear_142_comment},
  {"get_element", &Dtool_ConstPointerToArray_LVecBase3i_get_element_144, METH_O, (const char *)Dtool_ConstPointerToArray_LVecBase3i_get_element_144_comment},
  {"getElement", &Dtool_ConstPointerToArray_LVecBase3i_get_element_144, METH_O, (const char *)Dtool_ConstPointerToArray_LVecBase3i_get_element_144_comment},
  {"get_data", &Dtool_ConstPointerToArray_LVecBase3i_get_data_146, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3i_get_data_146_comment},
  {"getData", &Dtool_ConstPointerToArray_LVecBase3i_get_data_146, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3i_get_data_146_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_LVecBase3i_get_subdata_147, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LVecBase3i_get_subdata_147_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_LVecBase3i_get_subdata_147, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_LVecBase3i_get_subdata_147_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_LVecBase3i_get_ref_count_148, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3i_get_ref_count_148_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_LVecBase3i_get_ref_count_148, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3i_get_ref_count_148_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_LVecBase3i_get_node_ref_count_149, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3i_get_node_ref_count_149_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_LVecBase3i_get_node_ref_count_149, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_LVecBase3i_get_node_ref_count_149_comment},
  {"count", &Dtool_ConstPointerToArray_LVecBase3i_count_150, METH_O, (const char *)Dtool_ConstPointerToArray_LVecBase3i_count_150_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase3i slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_LVecBase3i_getbuffer_151_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< LVecBase3i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3i, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< LVecBase3i > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase3i slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_LVecBase3i_releasebuffer_152_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< LVecBase3i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3i, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< LVecBase3i > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase3i slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_LVecBase3i_getitem_145_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< LVecBase3i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3i, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_LVecBase3i index out of range");
    return nullptr;
  }
  // 1-LVecBase3i const &ConstPointerToArray< LVecBase3i >::__getitem__(unsigned long int n) const
  LVecBase3i const *return_value = &(invoke_extension((const ConstPointerToArray< LVecBase3i >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_LVecBase3i slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_LVecBase3i_size_143_sq_length(PyObject *self) {
  ConstPointerToArray< LVecBase3i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_LVecBase3i, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_LVecBase3i = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_LVecBase3i = {
  &Dtool_ConstPointerToArray_LVecBase3i_size_143_sq_length,
  nullptr,
  nullptr,
  &Dtool_ConstPointerToArray_LVecBase3i_getitem_145_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_LVecBase3i = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_LVecBase3i = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_LVecBase3i_getbuffer_151_bf_getbuffer,
  &Dtool_ConstPointerToArray_LVecBase3i_releasebuffer_152_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConstPointerToArray_LVecBase3i = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_LVecBase3i = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConstPointerToArray_LVecBase3i",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_LVecBase3i,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConstPointerToArray_LVecBase3i,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ConstPointerToArray_LVecBase3i,
    &Dtool_SequenceMethods_ConstPointerToArray_LVecBase3i,
    &Dtool_MappingMethods_ConstPointerToArray_LVecBase3i,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConstPointerToArray_LVecBase3i,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConstPointerToArray_LVecBase3i,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_LVecBase3i,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_LVecBase3i,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3i,
  Dtool_UpcastInterface_ConstPointerToArray_LVecBase3i,
  Dtool_DowncastInterface_ConstPointerToArray_LVecBase3i,
  nullptr,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_LVecBase3i,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3i(nullptr);
    Dtool_ConstPointerToArray_LVecBase3i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase3i);
    Dtool_ConstPointerToArray_LVecBase3i._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_LVecBase3i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_LVecBase3i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_LVecBase3i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_LVecBase3i);
  }
}

/**
 * Python method tables for PointerToArrayBase_LVecBase3i (PointerToArrayBase_LVecBase3i)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_LVecBase3i[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_LVecBase3i = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_LVecBase3i = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_LVecBase3i = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_LVecBase3i = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArrayBase_LVecBase3i = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_LVecBase3i = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArrayBase_LVecBase3i",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_LVecBase3i,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArrayBase_LVecBase3i,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArrayBase_LVecBase3i,
    &Dtool_SequenceMethods_PointerToArrayBase_LVecBase3i,
    &Dtool_MappingMethods_PointerToArrayBase_LVecBase3i,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArrayBase_LVecBase3i,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArrayBase_LVecBase3i,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_LVecBase3i,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_LVecBase3i,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3i,
  Dtool_UpcastInterface_PointerToArrayBase_LVecBase3i,
  Dtool_DowncastInterface_PointerToArrayBase_LVecBase3i,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3i(nullptr);
    Dtool_PointerToArrayBase_LVecBase3i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i);
    Dtool_PointerToArrayBase_LVecBase3i._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_LVecBase3i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase3i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_LVecBase3i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase3i);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_LVecBase3i (PointerToBase_ReferenceCountedVector_LVecBase3i)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_LVecBase3i[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i_clear_138, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i_clear_138_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i_output_139, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i_output_139_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_LVecBase3i
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase3i(PyObject *self) {
  PointerToBase< ReferenceCountedVector< LVecBase3i > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LVecBase3i = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LVecBase3i = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LVecBase3i = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LVecBase3i = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_LVecBase3i = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_LVecBase3i",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_LVecBase3i,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_LVecBase3i,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase3i,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_LVecBase3i,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_LVecBase3i,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_LVecBase3i,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase3i,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_LVecBase3i,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToBase_ReferenceCountedVector_LVecBase3i,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_LVecBase3i,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_LVecBase3i,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3i,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LVecBase3i,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LVecBase3i,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PointerToVoid != nullptr);
    assert(Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit(nullptr);
    Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PointerToVoid);
    Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_LVecBase3i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i);
  }
}

/**
 * Python method tables for ConstPointerToArray_UnalignedLMatrix4d (ConstPointerToArray_UnalignedLMatrix4d)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_UnalignedLMatrix4d[] = {
  {"clear", &Dtool_ConstPointerToArray_UnalignedLMatrix4d_clear_161, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4d_clear_161_comment},
  {"get_element", &Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_element_163, METH_O, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_element_163_comment},
  {"getElement", &Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_element_163, METH_O, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_element_163_comment},
  {"get_data", &Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_data_165, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_data_165_comment},
  {"getData", &Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_data_165, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_data_165_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_subdata_166, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_subdata_166_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_subdata_166, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_subdata_166_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_ref_count_167, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_ref_count_167_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_ref_count_167, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_ref_count_167_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_node_ref_count_168, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_node_ref_count_168_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_node_ref_count_168, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4d_get_node_ref_count_168_comment},
  {"count", &Dtool_ConstPointerToArray_UnalignedLMatrix4d_count_169, METH_O, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4d_count_169_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLMatrix4d slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_UnalignedLMatrix4d_getbuffer_170_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< UnalignedLMatrix4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLMatrix4d, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< UnalignedLMatrix4d > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLMatrix4d slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_UnalignedLMatrix4d_releasebuffer_171_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< UnalignedLMatrix4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLMatrix4d, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< UnalignedLMatrix4d > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLMatrix4d slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_UnalignedLMatrix4d_getitem_164_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< UnalignedLMatrix4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLMatrix4d, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_UnalignedLMatrix4d index out of range");
    return nullptr;
  }
  // 1-UnalignedLMatrix4d const &ConstPointerToArray< UnalignedLMatrix4d >::__getitem__(unsigned long int n) const
  UnalignedLMatrix4d const *return_value = &(invoke_extension((const ConstPointerToArray< UnalignedLMatrix4d >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLMatrix4d, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLMatrix4d slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_UnalignedLMatrix4d_size_162_sq_length(PyObject *self) {
  ConstPointerToArray< UnalignedLMatrix4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLMatrix4d, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_UnalignedLMatrix4d = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_UnalignedLMatrix4d = {
  &Dtool_ConstPointerToArray_UnalignedLMatrix4d_size_162_sq_length,
  nullptr,
  nullptr,
  &Dtool_ConstPointerToArray_UnalignedLMatrix4d_getitem_164_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_UnalignedLMatrix4d = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_UnalignedLMatrix4d = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_UnalignedLMatrix4d_getbuffer_170_bf_getbuffer,
  &Dtool_ConstPointerToArray_UnalignedLMatrix4d_releasebuffer_171_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConstPointerToArray_UnalignedLMatrix4d = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_UnalignedLMatrix4d = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConstPointerToArray_UnalignedLMatrix4d",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_UnalignedLMatrix4d,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConstPointerToArray_UnalignedLMatrix4d,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ConstPointerToArray_UnalignedLMatrix4d,
    &Dtool_SequenceMethods_ConstPointerToArray_UnalignedLMatrix4d,
    &Dtool_MappingMethods_ConstPointerToArray_UnalignedLMatrix4d,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConstPointerToArray_UnalignedLMatrix4d,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConstPointerToArray_UnalignedLMatrix4d,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_UnalignedLMatrix4d,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_UnalignedLMatrix4d,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLMatrix4d,
  Dtool_UpcastInterface_ConstPointerToArray_UnalignedLMatrix4d,
  Dtool_DowncastInterface_ConstPointerToArray_UnalignedLMatrix4d,
  nullptr,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_UnalignedLMatrix4d,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLMatrix4d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLMatrix4d(nullptr);
    Dtool_ConstPointerToArray_UnalignedLMatrix4d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLMatrix4d);
    Dtool_ConstPointerToArray_UnalignedLMatrix4d._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_UnalignedLMatrix4d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_UnalignedLMatrix4d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4d);
  }
}

/**
 * Python method tables for PointerToArrayBase_UnalignedLMatrix4d (PointerToArrayBase_UnalignedLMatrix4d)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_UnalignedLMatrix4d[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_UnalignedLMatrix4d = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_UnalignedLMatrix4d = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_UnalignedLMatrix4d = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_UnalignedLMatrix4d = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArrayBase_UnalignedLMatrix4d = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_UnalignedLMatrix4d = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArrayBase_UnalignedLMatrix4d",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_UnalignedLMatrix4d,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArrayBase_UnalignedLMatrix4d,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArrayBase_UnalignedLMatrix4d,
    &Dtool_SequenceMethods_PointerToArrayBase_UnalignedLMatrix4d,
    &Dtool_MappingMethods_PointerToArrayBase_UnalignedLMatrix4d,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArrayBase_UnalignedLMatrix4d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArrayBase_UnalignedLMatrix4d,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_UnalignedLMatrix4d,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_UnalignedLMatrix4d,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLMatrix4d,
  Dtool_UpcastInterface_PointerToArrayBase_UnalignedLMatrix4d,
  Dtool_DowncastInterface_PointerToArrayBase_UnalignedLMatrix4d,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLMatrix4d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d(nullptr);
    Dtool_PointerToArrayBase_UnalignedLMatrix4d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d);
    Dtool_PointerToArrayBase_UnalignedLMatrix4d._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_UnalignedLMatrix4d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLMatrix4d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_UnalignedLMatrix4d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLMatrix4d);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d (PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d_clear_157, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d_clear_157_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d_output_158, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d_output_158_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d(PyObject *self) {
  PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PointerToVoid != nullptr);
    assert(Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit(nullptr);
    Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PointerToVoid);
    Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d);
  }
}

/**
 * Python method tables for ConstPointerToArray_UnalignedLMatrix4f (ConstPointerToArray_UnalignedLMatrix4f)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_UnalignedLMatrix4f[] = {
  {"clear", &Dtool_ConstPointerToArray_UnalignedLMatrix4f_clear_180, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4f_clear_180_comment},
  {"get_element", &Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_element_182, METH_O, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_element_182_comment},
  {"getElement", &Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_element_182, METH_O, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_element_182_comment},
  {"get_data", &Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_data_184, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_data_184_comment},
  {"getData", &Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_data_184, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_data_184_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_subdata_185, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_subdata_185_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_subdata_185, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_subdata_185_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_ref_count_186, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_ref_count_186_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_ref_count_186, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_ref_count_186_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_node_ref_count_187, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_node_ref_count_187_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_node_ref_count_187, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4f_get_node_ref_count_187_comment},
  {"count", &Dtool_ConstPointerToArray_UnalignedLMatrix4f_count_188, METH_O, (const char *)Dtool_ConstPointerToArray_UnalignedLMatrix4f_count_188_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLMatrix4f slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_UnalignedLMatrix4f_getbuffer_189_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< UnalignedLMatrix4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLMatrix4f, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< UnalignedLMatrix4f > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLMatrix4f slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_UnalignedLMatrix4f_releasebuffer_190_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< UnalignedLMatrix4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLMatrix4f, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< UnalignedLMatrix4f > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLMatrix4f slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_UnalignedLMatrix4f_getitem_183_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< UnalignedLMatrix4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLMatrix4f, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_UnalignedLMatrix4f index out of range");
    return nullptr;
  }
  // 1-UnalignedLMatrix4f const &ConstPointerToArray< UnalignedLMatrix4f >::__getitem__(unsigned long int n) const
  UnalignedLMatrix4f const *return_value = &(invoke_extension((const ConstPointerToArray< UnalignedLMatrix4f >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLMatrix4f, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLMatrix4f slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_UnalignedLMatrix4f_size_181_sq_length(PyObject *self) {
  ConstPointerToArray< UnalignedLMatrix4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLMatrix4f, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_UnalignedLMatrix4f = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_UnalignedLMatrix4f = {
  &Dtool_ConstPointerToArray_UnalignedLMatrix4f_size_181_sq_length,
  nullptr,
  nullptr,
  &Dtool_ConstPointerToArray_UnalignedLMatrix4f_getitem_183_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_UnalignedLMatrix4f = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_UnalignedLMatrix4f = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_UnalignedLMatrix4f_getbuffer_189_bf_getbuffer,
  &Dtool_ConstPointerToArray_UnalignedLMatrix4f_releasebuffer_190_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConstPointerToArray_UnalignedLMatrix4f = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_UnalignedLMatrix4f = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConstPointerToArray_UnalignedLMatrix4f",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_UnalignedLMatrix4f,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConstPointerToArray_UnalignedLMatrix4f,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ConstPointerToArray_UnalignedLMatrix4f,
    &Dtool_SequenceMethods_ConstPointerToArray_UnalignedLMatrix4f,
    &Dtool_MappingMethods_ConstPointerToArray_UnalignedLMatrix4f,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConstPointerToArray_UnalignedLMatrix4f,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConstPointerToArray_UnalignedLMatrix4f,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_UnalignedLMatrix4f,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_UnalignedLMatrix4f,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLMatrix4f,
  Dtool_UpcastInterface_ConstPointerToArray_UnalignedLMatrix4f,
  Dtool_DowncastInterface_ConstPointerToArray_UnalignedLMatrix4f,
  nullptr,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_UnalignedLMatrix4f,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLMatrix4f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLMatrix4f(nullptr);
    Dtool_ConstPointerToArray_UnalignedLMatrix4f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLMatrix4f);
    Dtool_ConstPointerToArray_UnalignedLMatrix4f._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_UnalignedLMatrix4f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_UnalignedLMatrix4f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4f);
  }
}

/**
 * Python method tables for PointerToArrayBase_UnalignedLMatrix4f (PointerToArrayBase_UnalignedLMatrix4f)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_UnalignedLMatrix4f[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_UnalignedLMatrix4f = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_UnalignedLMatrix4f = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_UnalignedLMatrix4f = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_UnalignedLMatrix4f = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArrayBase_UnalignedLMatrix4f = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_UnalignedLMatrix4f = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArrayBase_UnalignedLMatrix4f",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_UnalignedLMatrix4f,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArrayBase_UnalignedLMatrix4f,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArrayBase_UnalignedLMatrix4f,
    &Dtool_SequenceMethods_PointerToArrayBase_UnalignedLMatrix4f,
    &Dtool_MappingMethods_PointerToArrayBase_UnalignedLMatrix4f,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArrayBase_UnalignedLMatrix4f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArrayBase_UnalignedLMatrix4f,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_UnalignedLMatrix4f,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_UnalignedLMatrix4f,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLMatrix4f,
  Dtool_UpcastInterface_PointerToArrayBase_UnalignedLMatrix4f,
  Dtool_DowncastInterface_PointerToArrayBase_UnalignedLMatrix4f,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLMatrix4f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f(nullptr);
    Dtool_PointerToArrayBase_UnalignedLMatrix4f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f);
    Dtool_PointerToArrayBase_UnalignedLMatrix4f._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_UnalignedLMatrix4f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLMatrix4f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_UnalignedLMatrix4f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLMatrix4f);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f (PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f_clear_176, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f_clear_176_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f_output_177, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f_output_177_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f(PyObject *self) {
  PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PointerToVoid != nullptr);
    assert(Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit(nullptr);
    Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PointerToVoid);
    Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f);
  }
}

/**
 * Python method tables for ConstPointerToArray_UnalignedLVecBase4d (ConstPointerToArray_UnalignedLVecBase4d)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_UnalignedLVecBase4d[] = {
  {"clear", &Dtool_ConstPointerToArray_UnalignedLVecBase4d_clear_199, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4d_clear_199_comment},
  {"get_element", &Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_element_201, METH_O, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_element_201_comment},
  {"getElement", &Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_element_201, METH_O, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_element_201_comment},
  {"get_data", &Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_data_203, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_data_203_comment},
  {"getData", &Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_data_203, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_data_203_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_subdata_204, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_subdata_204_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_subdata_204, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_subdata_204_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_ref_count_205, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_ref_count_205_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_ref_count_205, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_ref_count_205_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_node_ref_count_206, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_node_ref_count_206_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_node_ref_count_206, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4d_get_node_ref_count_206_comment},
  {"count", &Dtool_ConstPointerToArray_UnalignedLVecBase4d_count_207, METH_O, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4d_count_207_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLVecBase4d slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_UnalignedLVecBase4d_getbuffer_208_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< UnalignedLVecBase4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4d, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< UnalignedLVecBase4d > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLVecBase4d slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_UnalignedLVecBase4d_releasebuffer_209_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< UnalignedLVecBase4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4d, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< UnalignedLVecBase4d > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLVecBase4d slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4d_getitem_202_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< UnalignedLVecBase4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4d, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_UnalignedLVecBase4d index out of range");
    return nullptr;
  }
  // 1-UnalignedLVecBase4d const &ConstPointerToArray< UnalignedLVecBase4d >::__getitem__(unsigned long int n) const
  UnalignedLVecBase4d const *return_value = &(invoke_extension((const ConstPointerToArray< UnalignedLVecBase4d >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLVecBase4d, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLVecBase4d slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_UnalignedLVecBase4d_size_200_sq_length(PyObject *self) {
  ConstPointerToArray< UnalignedLVecBase4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4d, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_UnalignedLVecBase4d = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_UnalignedLVecBase4d = {
  &Dtool_ConstPointerToArray_UnalignedLVecBase4d_size_200_sq_length,
  nullptr,
  nullptr,
  &Dtool_ConstPointerToArray_UnalignedLVecBase4d_getitem_202_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_UnalignedLVecBase4d = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_UnalignedLVecBase4d = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_UnalignedLVecBase4d_getbuffer_208_bf_getbuffer,
  &Dtool_ConstPointerToArray_UnalignedLVecBase4d_releasebuffer_209_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConstPointerToArray_UnalignedLVecBase4d = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_UnalignedLVecBase4d = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConstPointerToArray_UnalignedLVecBase4d",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_UnalignedLVecBase4d,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConstPointerToArray_UnalignedLVecBase4d,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ConstPointerToArray_UnalignedLVecBase4d,
    &Dtool_SequenceMethods_ConstPointerToArray_UnalignedLVecBase4d,
    &Dtool_MappingMethods_ConstPointerToArray_UnalignedLVecBase4d,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConstPointerToArray_UnalignedLVecBase4d,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConstPointerToArray_UnalignedLVecBase4d,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_UnalignedLVecBase4d,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_UnalignedLVecBase4d,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4d,
  Dtool_UpcastInterface_ConstPointerToArray_UnalignedLVecBase4d,
  Dtool_DowncastInterface_ConstPointerToArray_UnalignedLVecBase4d,
  nullptr,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_UnalignedLVecBase4d,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4d(nullptr);
    Dtool_ConstPointerToArray_UnalignedLVecBase4d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4d);
    Dtool_ConstPointerToArray_UnalignedLVecBase4d._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_UnalignedLVecBase4d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_UnalignedLVecBase4d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4d);
  }
}

/**
 * Python method tables for PointerToArrayBase_UnalignedLVecBase4d (PointerToArrayBase_UnalignedLVecBase4d)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_UnalignedLVecBase4d[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_UnalignedLVecBase4d = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_UnalignedLVecBase4d = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_UnalignedLVecBase4d = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_UnalignedLVecBase4d = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArrayBase_UnalignedLVecBase4d = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_UnalignedLVecBase4d = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArrayBase_UnalignedLVecBase4d",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_UnalignedLVecBase4d,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArrayBase_UnalignedLVecBase4d,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArrayBase_UnalignedLVecBase4d,
    &Dtool_SequenceMethods_PointerToArrayBase_UnalignedLVecBase4d,
    &Dtool_MappingMethods_PointerToArrayBase_UnalignedLVecBase4d,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArrayBase_UnalignedLVecBase4d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArrayBase_UnalignedLVecBase4d,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_UnalignedLVecBase4d,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_UnalignedLVecBase4d,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4d,
  Dtool_UpcastInterface_PointerToArrayBase_UnalignedLVecBase4d,
  Dtool_DowncastInterface_PointerToArrayBase_UnalignedLVecBase4d,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d(nullptr);
    Dtool_PointerToArrayBase_UnalignedLVecBase4d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d);
    Dtool_PointerToArrayBase_UnalignedLVecBase4d._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_UnalignedLVecBase4d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_UnalignedLVecBase4d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4d);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d (PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d_clear_195, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d_clear_195_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d_output_196, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d_output_196_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d(PyObject *self) {
  PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PointerToVoid != nullptr);
    assert(Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit(nullptr);
    Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PointerToVoid);
    Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d);
  }
}

/**
 * Python method tables for ConstPointerToArray_UnalignedLVecBase4f (ConstPointerToArray_UnalignedLVecBase4f)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_UnalignedLVecBase4f[] = {
  {"clear", &Dtool_ConstPointerToArray_UnalignedLVecBase4f_clear_218, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4f_clear_218_comment},
  {"get_element", &Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_element_220, METH_O, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_element_220_comment},
  {"getElement", &Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_element_220, METH_O, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_element_220_comment},
  {"get_data", &Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_data_222, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_data_222_comment},
  {"getData", &Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_data_222, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_data_222_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_subdata_223, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_subdata_223_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_subdata_223, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_subdata_223_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_ref_count_224, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_ref_count_224_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_ref_count_224, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_ref_count_224_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_node_ref_count_225, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_node_ref_count_225_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_node_ref_count_225, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4f_get_node_ref_count_225_comment},
  {"count", &Dtool_ConstPointerToArray_UnalignedLVecBase4f_count_226, METH_O, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4f_count_226_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLVecBase4f slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_UnalignedLVecBase4f_getbuffer_227_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< UnalignedLVecBase4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4f, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< UnalignedLVecBase4f > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLVecBase4f slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_UnalignedLVecBase4f_releasebuffer_228_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< UnalignedLVecBase4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4f, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< UnalignedLVecBase4f > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLVecBase4f slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4f_getitem_221_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< UnalignedLVecBase4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4f, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_UnalignedLVecBase4f index out of range");
    return nullptr;
  }
  // 1-UnalignedLVecBase4f const &ConstPointerToArray< UnalignedLVecBase4f >::__getitem__(unsigned long int n) const
  UnalignedLVecBase4f const *return_value = &(invoke_extension((const ConstPointerToArray< UnalignedLVecBase4f >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLVecBase4f, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLVecBase4f slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_UnalignedLVecBase4f_size_219_sq_length(PyObject *self) {
  ConstPointerToArray< UnalignedLVecBase4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4f, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_UnalignedLVecBase4f = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_UnalignedLVecBase4f = {
  &Dtool_ConstPointerToArray_UnalignedLVecBase4f_size_219_sq_length,
  nullptr,
  nullptr,
  &Dtool_ConstPointerToArray_UnalignedLVecBase4f_getitem_221_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_UnalignedLVecBase4f = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_UnalignedLVecBase4f = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_UnalignedLVecBase4f_getbuffer_227_bf_getbuffer,
  &Dtool_ConstPointerToArray_UnalignedLVecBase4f_releasebuffer_228_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConstPointerToArray_UnalignedLVecBase4f = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_UnalignedLVecBase4f = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConstPointerToArray_UnalignedLVecBase4f",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_UnalignedLVecBase4f,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConstPointerToArray_UnalignedLVecBase4f,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ConstPointerToArray_UnalignedLVecBase4f,
    &Dtool_SequenceMethods_ConstPointerToArray_UnalignedLVecBase4f,
    &Dtool_MappingMethods_ConstPointerToArray_UnalignedLVecBase4f,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConstPointerToArray_UnalignedLVecBase4f,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConstPointerToArray_UnalignedLVecBase4f,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_UnalignedLVecBase4f,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_UnalignedLVecBase4f,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4f,
  Dtool_UpcastInterface_ConstPointerToArray_UnalignedLVecBase4f,
  Dtool_DowncastInterface_ConstPointerToArray_UnalignedLVecBase4f,
  nullptr,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_UnalignedLVecBase4f,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4f(nullptr);
    Dtool_ConstPointerToArray_UnalignedLVecBase4f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4f);
    Dtool_ConstPointerToArray_UnalignedLVecBase4f._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_UnalignedLVecBase4f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_UnalignedLVecBase4f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4f);
  }
}

/**
 * Python method tables for PointerToArrayBase_UnalignedLVecBase4f (PointerToArrayBase_UnalignedLVecBase4f)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_UnalignedLVecBase4f[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_UnalignedLVecBase4f = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_UnalignedLVecBase4f = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_UnalignedLVecBase4f = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_UnalignedLVecBase4f = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArrayBase_UnalignedLVecBase4f = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_UnalignedLVecBase4f = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArrayBase_UnalignedLVecBase4f",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_UnalignedLVecBase4f,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArrayBase_UnalignedLVecBase4f,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArrayBase_UnalignedLVecBase4f,
    &Dtool_SequenceMethods_PointerToArrayBase_UnalignedLVecBase4f,
    &Dtool_MappingMethods_PointerToArrayBase_UnalignedLVecBase4f,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArrayBase_UnalignedLVecBase4f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArrayBase_UnalignedLVecBase4f,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_UnalignedLVecBase4f,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_UnalignedLVecBase4f,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4f,
  Dtool_UpcastInterface_PointerToArrayBase_UnalignedLVecBase4f,
  Dtool_DowncastInterface_PointerToArrayBase_UnalignedLVecBase4f,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f(nullptr);
    Dtool_PointerToArrayBase_UnalignedLVecBase4f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f);
    Dtool_PointerToArrayBase_UnalignedLVecBase4f._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_UnalignedLVecBase4f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_UnalignedLVecBase4f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4f);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f (PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f_clear_214, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f_clear_214_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f_output_215, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f_output_215_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f(PyObject *self) {
  PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PointerToVoid != nullptr);
    assert(Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit(nullptr);
    Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PointerToVoid);
    Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f);
  }
}

/**
 * Python method tables for ConstPointerToArray_UnalignedLVecBase4i (ConstPointerToArray_UnalignedLVecBase4i)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_UnalignedLVecBase4i[] = {
  {"clear", &Dtool_ConstPointerToArray_UnalignedLVecBase4i_clear_237, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4i_clear_237_comment},
  {"get_element", &Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_element_239, METH_O, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_element_239_comment},
  {"getElement", &Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_element_239, METH_O, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_element_239_comment},
  {"get_data", &Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_data_241, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_data_241_comment},
  {"getData", &Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_data_241, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_data_241_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_subdata_242, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_subdata_242_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_subdata_242, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_subdata_242_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_ref_count_243, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_ref_count_243_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_ref_count_243, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_ref_count_243_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_node_ref_count_244, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_node_ref_count_244_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_node_ref_count_244, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4i_get_node_ref_count_244_comment},
  {"count", &Dtool_ConstPointerToArray_UnalignedLVecBase4i_count_245, METH_O, (const char *)Dtool_ConstPointerToArray_UnalignedLVecBase4i_count_245_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLVecBase4i slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_UnalignedLVecBase4i_getbuffer_246_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< UnalignedLVecBase4i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4i, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< UnalignedLVecBase4i > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLVecBase4i slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_UnalignedLVecBase4i_releasebuffer_247_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< UnalignedLVecBase4i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4i, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< UnalignedLVecBase4i > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLVecBase4i slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_UnalignedLVecBase4i_getitem_240_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< UnalignedLVecBase4i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4i, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_UnalignedLVecBase4i index out of range");
    return nullptr;
  }
  // 1-UnalignedLVecBase4i const &ConstPointerToArray< UnalignedLVecBase4i >::__getitem__(unsigned long int n) const
  UnalignedLVecBase4i const *return_value = &(invoke_extension((const ConstPointerToArray< UnalignedLVecBase4i >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLVecBase4i, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_UnalignedLVecBase4i slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_UnalignedLVecBase4i_size_238_sq_length(PyObject *self) {
  ConstPointerToArray< UnalignedLVecBase4i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_UnalignedLVecBase4i, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_UnalignedLVecBase4i = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_UnalignedLVecBase4i = {
  &Dtool_ConstPointerToArray_UnalignedLVecBase4i_size_238_sq_length,
  nullptr,
  nullptr,
  &Dtool_ConstPointerToArray_UnalignedLVecBase4i_getitem_240_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_UnalignedLVecBase4i = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_UnalignedLVecBase4i = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_UnalignedLVecBase4i_getbuffer_246_bf_getbuffer,
  &Dtool_ConstPointerToArray_UnalignedLVecBase4i_releasebuffer_247_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConstPointerToArray_UnalignedLVecBase4i = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_UnalignedLVecBase4i = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConstPointerToArray_UnalignedLVecBase4i",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_UnalignedLVecBase4i,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConstPointerToArray_UnalignedLVecBase4i,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ConstPointerToArray_UnalignedLVecBase4i,
    &Dtool_SequenceMethods_ConstPointerToArray_UnalignedLVecBase4i,
    &Dtool_MappingMethods_ConstPointerToArray_UnalignedLVecBase4i,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConstPointerToArray_UnalignedLVecBase4i,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConstPointerToArray_UnalignedLVecBase4i,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_UnalignedLVecBase4i,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_UnalignedLVecBase4i,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4i,
  Dtool_UpcastInterface_ConstPointerToArray_UnalignedLVecBase4i,
  Dtool_DowncastInterface_ConstPointerToArray_UnalignedLVecBase4i,
  nullptr,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_UnalignedLVecBase4i,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4i(nullptr);
    Dtool_ConstPointerToArray_UnalignedLVecBase4i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4i);
    Dtool_ConstPointerToArray_UnalignedLVecBase4i._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_UnalignedLVecBase4i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_UnalignedLVecBase4i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4i);
  }
}

/**
 * Python method tables for PointerToArrayBase_UnalignedLVecBase4i (PointerToArrayBase_UnalignedLVecBase4i)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_UnalignedLVecBase4i[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_UnalignedLVecBase4i = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_UnalignedLVecBase4i = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_UnalignedLVecBase4i = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_UnalignedLVecBase4i = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArrayBase_UnalignedLVecBase4i = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_UnalignedLVecBase4i = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArrayBase_UnalignedLVecBase4i",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_UnalignedLVecBase4i,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArrayBase_UnalignedLVecBase4i,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArrayBase_UnalignedLVecBase4i,
    &Dtool_SequenceMethods_PointerToArrayBase_UnalignedLVecBase4i,
    &Dtool_MappingMethods_PointerToArrayBase_UnalignedLVecBase4i,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArrayBase_UnalignedLVecBase4i,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArrayBase_UnalignedLVecBase4i,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_UnalignedLVecBase4i,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_UnalignedLVecBase4i,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4i,
  Dtool_UpcastInterface_PointerToArrayBase_UnalignedLVecBase4i,
  Dtool_DowncastInterface_PointerToArrayBase_UnalignedLVecBase4i,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i(nullptr);
    Dtool_PointerToArrayBase_UnalignedLVecBase4i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i);
    Dtool_PointerToArrayBase_UnalignedLVecBase4i._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_UnalignedLVecBase4i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_UnalignedLVecBase4i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4i);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i (PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i_clear_233, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i_clear_233_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i_output_234, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i_output_234_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i(PyObject *self) {
  PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PointerToVoid != nullptr);
    assert(Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit(nullptr);
    Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PointerToVoid);
    Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i);
  }
}

/**
 * Python method tables for PointerToArray_LMatrix3d (PointerToArray_LMatrix3d)
 */
static PyMethodDef Dtool_Methods_PointerToArray_LMatrix3d[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_LMatrix3d_empty_array_251, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LMatrix3d_empty_array_251_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_LMatrix3d_empty_array_251, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LMatrix3d_empty_array_251_comment},
  {"clear", &Dtool_PointerToArray_LMatrix3d_clear_252, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3d_clear_252_comment},
  {"push_back", &Dtool_PointerToArray_LMatrix3d_push_back_254, METH_O, (const char *)Dtool_PointerToArray_LMatrix3d_push_back_254_comment},
  {"pushBack", &Dtool_PointerToArray_LMatrix3d_push_back_254, METH_O, (const char *)Dtool_PointerToArray_LMatrix3d_push_back_254_comment},
  {"pop_back", &Dtool_PointerToArray_LMatrix3d_pop_back_255, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3d_pop_back_255_comment},
  {"popBack", &Dtool_PointerToArray_LMatrix3d_pop_back_255, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3d_pop_back_255_comment},
  {"get_element", &Dtool_PointerToArray_LMatrix3d_get_element_256, METH_O, (const char *)Dtool_PointerToArray_LMatrix3d_get_element_256_comment},
  {"getElement", &Dtool_PointerToArray_LMatrix3d_get_element_256, METH_O, (const char *)Dtool_PointerToArray_LMatrix3d_get_element_256_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_LMatrix3d_set_element_257, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LMatrix3d_set_element_257_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_LMatrix3d_set_element_257, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LMatrix3d_set_element_257_comment},
  {"get_data", &Dtool_PointerToArray_LMatrix3d_get_data_260, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3d_get_data_260_comment},
  {"getData", &Dtool_PointerToArray_LMatrix3d_get_data_260, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3d_get_data_260_comment},
  {"set_data", &Dtool_PointerToArray_LMatrix3d_set_data_261, METH_O, (const char *)Dtool_PointerToArray_LMatrix3d_set_data_261_comment},
  {"setData", &Dtool_PointerToArray_LMatrix3d_set_data_261, METH_O, (const char *)Dtool_PointerToArray_LMatrix3d_set_data_261_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_LMatrix3d_get_subdata_262, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LMatrix3d_get_subdata_262_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_LMatrix3d_get_subdata_262, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LMatrix3d_get_subdata_262_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_LMatrix3d_set_subdata_263, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LMatrix3d_set_subdata_263_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_LMatrix3d_set_subdata_263, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LMatrix3d_set_subdata_263_comment},
  {"get_ref_count", &Dtool_PointerToArray_LMatrix3d_get_ref_count_264, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3d_get_ref_count_264_comment},
  {"getRefCount", &Dtool_PointerToArray_LMatrix3d_get_ref_count_264, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3d_get_ref_count_264_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_LMatrix3d_get_node_ref_count_265, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3d_get_node_ref_count_265_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_LMatrix3d_get_node_ref_count_265, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3d_get_node_ref_count_265_comment},
  {"count", &Dtool_PointerToArray_LMatrix3d_count_266, METH_O, (const char *)Dtool_PointerToArray_LMatrix3d_count_266_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LMatrix3d slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_LMatrix3d_getbuffer_267_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< LMatrix3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LMatrix3d, (void **)&local_this)) {
    return -1;
  }

  if (!DtoolInstance_IS_CONST(self)) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_LMatrix3d.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LMatrix3d slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_LMatrix3d_releasebuffer_268_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< LMatrix3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LMatrix3d, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< LMatrix3d > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LMatrix3d slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_LMatrix3d_setitem_259_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< LMatrix3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LMatrix3d, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LMatrix3d index out of range");
    return -1;
  }
  if (arg != nullptr) { // __setitem__
    if (!DtoolInstance_IS_CONST(self)) {
      // 1-void PointerToArray< LMatrix3d >::__setitem__(unsigned long int n, LMatrix3d const &value)
      LMatrix3d arg_local;
      LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
      if (!(arg_this != nullptr)) {
        Dtool_Raise_ArgTypeError(arg, 2, "PointerToArray.__setitem__", "LMatrix3d");
        return -1;
      }
      invoke_extension(local_this).__setitem__(index, *arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, const LMatrix3d value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LMatrix3d slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_LMatrix3d_getitem_258_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< LMatrix3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LMatrix3d, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LMatrix3d index out of range");
    return nullptr;
  }
  // 1-LMatrix3d const &PointerToArray< LMatrix3d >::__getitem__(unsigned long int n) const
  LMatrix3d const *return_value = &(invoke_extension((const PointerToArray< LMatrix3d >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LMatrix3d slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_LMatrix3d_size_253_sq_length(PyObject *self) {
  PointerToArray< LMatrix3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LMatrix3d, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_LMatrix3d = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_LMatrix3d = {
  &Dtool_PointerToArray_LMatrix3d_size_253_sq_length,
  nullptr,
  nullptr,
  &Dtool_PointerToArray_LMatrix3d_getitem_258_sq_item,
  nullptr, // sq_slice
  &Dtool_PointerToArray_LMatrix3d_setitem_259_sq_ass_item,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_LMatrix3d = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_LMatrix3d = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_LMatrix3d_getbuffer_267_bf_getbuffer,
  &Dtool_PointerToArray_LMatrix3d_releasebuffer_268_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArray_LMatrix3d = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArray_LMatrix3d = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArray_LMatrix3d",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_LMatrix3d,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArray_LMatrix3d,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArray_LMatrix3d,
    &Dtool_SequenceMethods_PointerToArray_LMatrix3d,
    &Dtool_MappingMethods_PointerToArray_LMatrix3d,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArray_LMatrix3d,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArray_LMatrix3d,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_LMatrix3d,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_LMatrix3d,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_LMatrix3d,
  Dtool_UpcastInterface_PointerToArray_LMatrix3d,
  Dtool_DowncastInterface_PointerToArray_LMatrix3d,
  nullptr,
  (CoerceFunction)Dtool_Coerce_PointerToArray_LMatrix3d,
};

static void Dtool_PyModuleClassInit_PointerToArray_LMatrix3d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LMatrix3d(nullptr);
    Dtool_PointerToArray_LMatrix3d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LMatrix3d);
    Dtool_PointerToArray_LMatrix3d._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_LMatrix3d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_LMatrix3d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_LMatrix3d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_LMatrix3d);
  }
}

/**
 * Python method tables for PointerToArray_LMatrix3f (PointerToArray_LMatrix3f)
 */
static PyMethodDef Dtool_Methods_PointerToArray_LMatrix3f[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_LMatrix3f_empty_array_272, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LMatrix3f_empty_array_272_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_LMatrix3f_empty_array_272, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LMatrix3f_empty_array_272_comment},
  {"clear", &Dtool_PointerToArray_LMatrix3f_clear_273, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3f_clear_273_comment},
  {"push_back", &Dtool_PointerToArray_LMatrix3f_push_back_275, METH_O, (const char *)Dtool_PointerToArray_LMatrix3f_push_back_275_comment},
  {"pushBack", &Dtool_PointerToArray_LMatrix3f_push_back_275, METH_O, (const char *)Dtool_PointerToArray_LMatrix3f_push_back_275_comment},
  {"pop_back", &Dtool_PointerToArray_LMatrix3f_pop_back_276, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3f_pop_back_276_comment},
  {"popBack", &Dtool_PointerToArray_LMatrix3f_pop_back_276, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3f_pop_back_276_comment},
  {"get_element", &Dtool_PointerToArray_LMatrix3f_get_element_277, METH_O, (const char *)Dtool_PointerToArray_LMatrix3f_get_element_277_comment},
  {"getElement", &Dtool_PointerToArray_LMatrix3f_get_element_277, METH_O, (const char *)Dtool_PointerToArray_LMatrix3f_get_element_277_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_LMatrix3f_set_element_278, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LMatrix3f_set_element_278_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_LMatrix3f_set_element_278, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LMatrix3f_set_element_278_comment},
  {"get_data", &Dtool_PointerToArray_LMatrix3f_get_data_281, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3f_get_data_281_comment},
  {"getData", &Dtool_PointerToArray_LMatrix3f_get_data_281, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3f_get_data_281_comment},
  {"set_data", &Dtool_PointerToArray_LMatrix3f_set_data_282, METH_O, (const char *)Dtool_PointerToArray_LMatrix3f_set_data_282_comment},
  {"setData", &Dtool_PointerToArray_LMatrix3f_set_data_282, METH_O, (const char *)Dtool_PointerToArray_LMatrix3f_set_data_282_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_LMatrix3f_get_subdata_283, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LMatrix3f_get_subdata_283_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_LMatrix3f_get_subdata_283, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LMatrix3f_get_subdata_283_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_LMatrix3f_set_subdata_284, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LMatrix3f_set_subdata_284_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_LMatrix3f_set_subdata_284, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LMatrix3f_set_subdata_284_comment},
  {"get_ref_count", &Dtool_PointerToArray_LMatrix3f_get_ref_count_285, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3f_get_ref_count_285_comment},
  {"getRefCount", &Dtool_PointerToArray_LMatrix3f_get_ref_count_285, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3f_get_ref_count_285_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_LMatrix3f_get_node_ref_count_286, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3f_get_node_ref_count_286_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_LMatrix3f_get_node_ref_count_286, METH_NOARGS, (const char *)Dtool_PointerToArray_LMatrix3f_get_node_ref_count_286_comment},
  {"count", &Dtool_PointerToArray_LMatrix3f_count_287, METH_O, (const char *)Dtool_PointerToArray_LMatrix3f_count_287_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LMatrix3f slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_LMatrix3f_getbuffer_288_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< LMatrix3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LMatrix3f, (void **)&local_this)) {
    return -1;
  }

  if (!DtoolInstance_IS_CONST(self)) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_LMatrix3f.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LMatrix3f slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_LMatrix3f_releasebuffer_289_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< LMatrix3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LMatrix3f, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< LMatrix3f > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LMatrix3f slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_LMatrix3f_setitem_280_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< LMatrix3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LMatrix3f, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LMatrix3f index out of range");
    return -1;
  }
  if (arg != nullptr) { // __setitem__
    if (!DtoolInstance_IS_CONST(self)) {
      // 1-void PointerToArray< LMatrix3f >::__setitem__(unsigned long int n, LMatrix3f const &value)
      LMatrix3f arg_local;
      LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
      if (!(arg_this != nullptr)) {
        Dtool_Raise_ArgTypeError(arg, 2, "PointerToArray.__setitem__", "LMatrix3f");
        return -1;
      }
      invoke_extension(local_this).__setitem__(index, *arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, const LMatrix3f value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LMatrix3f slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_LMatrix3f_getitem_279_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< LMatrix3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LMatrix3f, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LMatrix3f index out of range");
    return nullptr;
  }
  // 1-LMatrix3f const &PointerToArray< LMatrix3f >::__getitem__(unsigned long int n) const
  LMatrix3f const *return_value = &(invoke_extension((const PointerToArray< LMatrix3f >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LMatrix3f slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_LMatrix3f_size_274_sq_length(PyObject *self) {
  PointerToArray< LMatrix3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LMatrix3f, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_LMatrix3f = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_LMatrix3f = {
  &Dtool_PointerToArray_LMatrix3f_size_274_sq_length,
  nullptr,
  nullptr,
  &Dtool_PointerToArray_LMatrix3f_getitem_279_sq_item,
  nullptr, // sq_slice
  &Dtool_PointerToArray_LMatrix3f_setitem_280_sq_ass_item,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_LMatrix3f = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_LMatrix3f = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_LMatrix3f_getbuffer_288_bf_getbuffer,
  &Dtool_PointerToArray_LMatrix3f_releasebuffer_289_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArray_LMatrix3f = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArray_LMatrix3f = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArray_LMatrix3f",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_LMatrix3f,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArray_LMatrix3f,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArray_LMatrix3f,
    &Dtool_SequenceMethods_PointerToArray_LMatrix3f,
    &Dtool_MappingMethods_PointerToArray_LMatrix3f,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArray_LMatrix3f,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArray_LMatrix3f,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_LMatrix3f,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_LMatrix3f,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_LMatrix3f,
  Dtool_UpcastInterface_PointerToArray_LMatrix3f,
  Dtool_DowncastInterface_PointerToArray_LMatrix3f,
  nullptr,
  (CoerceFunction)Dtool_Coerce_PointerToArray_LMatrix3f,
};

static void Dtool_PyModuleClassInit_PointerToArray_LMatrix3f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LMatrix3f(nullptr);
    Dtool_PointerToArray_LMatrix3f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LMatrix3f);
    Dtool_PointerToArray_LMatrix3f._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_LMatrix3f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_LMatrix3f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_LMatrix3f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_LMatrix3f);
  }
}

/**
 * Python method tables for PointerToArray_LVecBase2d (PointerToArray_LVecBase2d)
 */
static PyMethodDef Dtool_Methods_PointerToArray_LVecBase2d[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_LVecBase2d_empty_array_293, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LVecBase2d_empty_array_293_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_LVecBase2d_empty_array_293, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LVecBase2d_empty_array_293_comment},
  {"clear", &Dtool_PointerToArray_LVecBase2d_clear_294, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2d_clear_294_comment},
  {"push_back", &Dtool_PointerToArray_LVecBase2d_push_back_296, METH_O, (const char *)Dtool_PointerToArray_LVecBase2d_push_back_296_comment},
  {"pushBack", &Dtool_PointerToArray_LVecBase2d_push_back_296, METH_O, (const char *)Dtool_PointerToArray_LVecBase2d_push_back_296_comment},
  {"pop_back", &Dtool_PointerToArray_LVecBase2d_pop_back_297, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2d_pop_back_297_comment},
  {"popBack", &Dtool_PointerToArray_LVecBase2d_pop_back_297, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2d_pop_back_297_comment},
  {"get_element", &Dtool_PointerToArray_LVecBase2d_get_element_298, METH_O, (const char *)Dtool_PointerToArray_LVecBase2d_get_element_298_comment},
  {"getElement", &Dtool_PointerToArray_LVecBase2d_get_element_298, METH_O, (const char *)Dtool_PointerToArray_LVecBase2d_get_element_298_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_LVecBase2d_set_element_299, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2d_set_element_299_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_LVecBase2d_set_element_299, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2d_set_element_299_comment},
  {"get_data", &Dtool_PointerToArray_LVecBase2d_get_data_302, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2d_get_data_302_comment},
  {"getData", &Dtool_PointerToArray_LVecBase2d_get_data_302, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2d_get_data_302_comment},
  {"set_data", &Dtool_PointerToArray_LVecBase2d_set_data_303, METH_O, (const char *)Dtool_PointerToArray_LVecBase2d_set_data_303_comment},
  {"setData", &Dtool_PointerToArray_LVecBase2d_set_data_303, METH_O, (const char *)Dtool_PointerToArray_LVecBase2d_set_data_303_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_LVecBase2d_get_subdata_304, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2d_get_subdata_304_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_LVecBase2d_get_subdata_304, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2d_get_subdata_304_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_LVecBase2d_set_subdata_305, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2d_set_subdata_305_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_LVecBase2d_set_subdata_305, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2d_set_subdata_305_comment},
  {"get_ref_count", &Dtool_PointerToArray_LVecBase2d_get_ref_count_306, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2d_get_ref_count_306_comment},
  {"getRefCount", &Dtool_PointerToArray_LVecBase2d_get_ref_count_306, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2d_get_ref_count_306_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_LVecBase2d_get_node_ref_count_307, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2d_get_node_ref_count_307_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_LVecBase2d_get_node_ref_count_307, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2d_get_node_ref_count_307_comment},
  {"count", &Dtool_PointerToArray_LVecBase2d_count_308, METH_O, (const char *)Dtool_PointerToArray_LVecBase2d_count_308_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase2d slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_LVecBase2d_getbuffer_309_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< LVecBase2d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2d, (void **)&local_this)) {
    return -1;
  }

  if (!DtoolInstance_IS_CONST(self)) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_LVecBase2d.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase2d slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_LVecBase2d_releasebuffer_310_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< LVecBase2d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2d, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< LVecBase2d > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase2d slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_LVecBase2d_setitem_301_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< LVecBase2d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2d, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LVecBase2d index out of range");
    return -1;
  }
  if (arg != nullptr) { // __setitem__
    if (!DtoolInstance_IS_CONST(self)) {
      // 1-void PointerToArray< LVecBase2d >::__setitem__(unsigned long int n, LVecBase2d const &value)
      LVecBase2d arg_local;
      LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
      if (!(arg_this != nullptr)) {
        Dtool_Raise_ArgTypeError(arg, 2, "PointerToArray.__setitem__", "LVecBase2d");
        return -1;
      }
      invoke_extension(local_this).__setitem__(index, *arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, const LVecBase2d value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase2d slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_LVecBase2d_getitem_300_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< LVecBase2d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2d, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LVecBase2d index out of range");
    return nullptr;
  }
  // 1-LVecBase2d const &PointerToArray< LVecBase2d >::__getitem__(unsigned long int n) const
  LVecBase2d const *return_value = &(invoke_extension((const PointerToArray< LVecBase2d >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase2d slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_LVecBase2d_size_295_sq_length(PyObject *self) {
  PointerToArray< LVecBase2d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2d, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_LVecBase2d = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_LVecBase2d = {
  &Dtool_PointerToArray_LVecBase2d_size_295_sq_length,
  nullptr,
  nullptr,
  &Dtool_PointerToArray_LVecBase2d_getitem_300_sq_item,
  nullptr, // sq_slice
  &Dtool_PointerToArray_LVecBase2d_setitem_301_sq_ass_item,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_LVecBase2d = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_LVecBase2d = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_LVecBase2d_getbuffer_309_bf_getbuffer,
  &Dtool_PointerToArray_LVecBase2d_releasebuffer_310_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArray_LVecBase2d = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArray_LVecBase2d = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArray_LVecBase2d",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_LVecBase2d,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArray_LVecBase2d,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArray_LVecBase2d,
    &Dtool_SequenceMethods_PointerToArray_LVecBase2d,
    &Dtool_MappingMethods_PointerToArray_LVecBase2d,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArray_LVecBase2d,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArray_LVecBase2d,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_LVecBase2d,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_LVecBase2d,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_LVecBase2d,
  Dtool_UpcastInterface_PointerToArray_LVecBase2d,
  Dtool_DowncastInterface_PointerToArray_LVecBase2d,
  nullptr,
  (CoerceFunction)Dtool_Coerce_PointerToArray_LVecBase2d,
};

static void Dtool_PyModuleClassInit_PointerToArray_LVecBase2d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2d(nullptr);
    Dtool_PointerToArray_LVecBase2d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase2d);
    Dtool_PointerToArray_LVecBase2d._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_LVecBase2d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_LVecBase2d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_LVecBase2d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_LVecBase2d);
  }
}

/**
 * Python method tables for PointerToArray_LVecBase2f (PointerToArray_LVecBase2f)
 */
static PyMethodDef Dtool_Methods_PointerToArray_LVecBase2f[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_LVecBase2f_empty_array_314, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LVecBase2f_empty_array_314_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_LVecBase2f_empty_array_314, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LVecBase2f_empty_array_314_comment},
  {"clear", &Dtool_PointerToArray_LVecBase2f_clear_315, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2f_clear_315_comment},
  {"push_back", &Dtool_PointerToArray_LVecBase2f_push_back_317, METH_O, (const char *)Dtool_PointerToArray_LVecBase2f_push_back_317_comment},
  {"pushBack", &Dtool_PointerToArray_LVecBase2f_push_back_317, METH_O, (const char *)Dtool_PointerToArray_LVecBase2f_push_back_317_comment},
  {"pop_back", &Dtool_PointerToArray_LVecBase2f_pop_back_318, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2f_pop_back_318_comment},
  {"popBack", &Dtool_PointerToArray_LVecBase2f_pop_back_318, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2f_pop_back_318_comment},
  {"get_element", &Dtool_PointerToArray_LVecBase2f_get_element_319, METH_O, (const char *)Dtool_PointerToArray_LVecBase2f_get_element_319_comment},
  {"getElement", &Dtool_PointerToArray_LVecBase2f_get_element_319, METH_O, (const char *)Dtool_PointerToArray_LVecBase2f_get_element_319_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_LVecBase2f_set_element_320, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2f_set_element_320_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_LVecBase2f_set_element_320, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2f_set_element_320_comment},
  {"get_data", &Dtool_PointerToArray_LVecBase2f_get_data_323, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2f_get_data_323_comment},
  {"getData", &Dtool_PointerToArray_LVecBase2f_get_data_323, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2f_get_data_323_comment},
  {"set_data", &Dtool_PointerToArray_LVecBase2f_set_data_324, METH_O, (const char *)Dtool_PointerToArray_LVecBase2f_set_data_324_comment},
  {"setData", &Dtool_PointerToArray_LVecBase2f_set_data_324, METH_O, (const char *)Dtool_PointerToArray_LVecBase2f_set_data_324_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_LVecBase2f_get_subdata_325, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2f_get_subdata_325_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_LVecBase2f_get_subdata_325, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2f_get_subdata_325_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_LVecBase2f_set_subdata_326, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2f_set_subdata_326_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_LVecBase2f_set_subdata_326, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2f_set_subdata_326_comment},
  {"get_ref_count", &Dtool_PointerToArray_LVecBase2f_get_ref_count_327, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2f_get_ref_count_327_comment},
  {"getRefCount", &Dtool_PointerToArray_LVecBase2f_get_ref_count_327, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2f_get_ref_count_327_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_LVecBase2f_get_node_ref_count_328, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2f_get_node_ref_count_328_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_LVecBase2f_get_node_ref_count_328, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2f_get_node_ref_count_328_comment},
  {"count", &Dtool_PointerToArray_LVecBase2f_count_329, METH_O, (const char *)Dtool_PointerToArray_LVecBase2f_count_329_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase2f slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_LVecBase2f_getbuffer_330_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< LVecBase2f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2f, (void **)&local_this)) {
    return -1;
  }

  if (!DtoolInstance_IS_CONST(self)) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_LVecBase2f.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase2f slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_LVecBase2f_releasebuffer_331_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< LVecBase2f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2f, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< LVecBase2f > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase2f slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_LVecBase2f_setitem_322_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< LVecBase2f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2f, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LVecBase2f index out of range");
    return -1;
  }
  if (arg != nullptr) { // __setitem__
    if (!DtoolInstance_IS_CONST(self)) {
      // 1-void PointerToArray< LVecBase2f >::__setitem__(unsigned long int n, LVecBase2f const &value)
      LVecBase2f arg_local;
      LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
      if (!(arg_this != nullptr)) {
        Dtool_Raise_ArgTypeError(arg, 2, "PointerToArray.__setitem__", "LVecBase2f");
        return -1;
      }
      invoke_extension(local_this).__setitem__(index, *arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, const LVecBase2f value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase2f slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_LVecBase2f_getitem_321_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< LVecBase2f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2f, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LVecBase2f index out of range");
    return nullptr;
  }
  // 1-LVecBase2f const &PointerToArray< LVecBase2f >::__getitem__(unsigned long int n) const
  LVecBase2f const *return_value = &(invoke_extension((const PointerToArray< LVecBase2f >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase2f slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_LVecBase2f_size_316_sq_length(PyObject *self) {
  PointerToArray< LVecBase2f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2f, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_LVecBase2f = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_LVecBase2f = {
  &Dtool_PointerToArray_LVecBase2f_size_316_sq_length,
  nullptr,
  nullptr,
  &Dtool_PointerToArray_LVecBase2f_getitem_321_sq_item,
  nullptr, // sq_slice
  &Dtool_PointerToArray_LVecBase2f_setitem_322_sq_ass_item,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_LVecBase2f = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_LVecBase2f = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_LVecBase2f_getbuffer_330_bf_getbuffer,
  &Dtool_PointerToArray_LVecBase2f_releasebuffer_331_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArray_LVecBase2f = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArray_LVecBase2f = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArray_LVecBase2f",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_LVecBase2f,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArray_LVecBase2f,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArray_LVecBase2f,
    &Dtool_SequenceMethods_PointerToArray_LVecBase2f,
    &Dtool_MappingMethods_PointerToArray_LVecBase2f,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArray_LVecBase2f,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArray_LVecBase2f,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_LVecBase2f,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_LVecBase2f,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_LVecBase2f,
  Dtool_UpcastInterface_PointerToArray_LVecBase2f,
  Dtool_DowncastInterface_PointerToArray_LVecBase2f,
  nullptr,
  (CoerceFunction)Dtool_Coerce_PointerToArray_LVecBase2f,
};

static void Dtool_PyModuleClassInit_PointerToArray_LVecBase2f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2f(nullptr);
    Dtool_PointerToArray_LVecBase2f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase2f);
    Dtool_PointerToArray_LVecBase2f._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_LVecBase2f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_LVecBase2f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_LVecBase2f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_LVecBase2f);
  }
}

/**
 * Python method tables for PointerToArray_LVecBase2i (PointerToArray_LVecBase2i)
 */
static PyMethodDef Dtool_Methods_PointerToArray_LVecBase2i[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_LVecBase2i_empty_array_335, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LVecBase2i_empty_array_335_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_LVecBase2i_empty_array_335, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LVecBase2i_empty_array_335_comment},
  {"clear", &Dtool_PointerToArray_LVecBase2i_clear_336, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2i_clear_336_comment},
  {"push_back", &Dtool_PointerToArray_LVecBase2i_push_back_338, METH_O, (const char *)Dtool_PointerToArray_LVecBase2i_push_back_338_comment},
  {"pushBack", &Dtool_PointerToArray_LVecBase2i_push_back_338, METH_O, (const char *)Dtool_PointerToArray_LVecBase2i_push_back_338_comment},
  {"pop_back", &Dtool_PointerToArray_LVecBase2i_pop_back_339, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2i_pop_back_339_comment},
  {"popBack", &Dtool_PointerToArray_LVecBase2i_pop_back_339, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2i_pop_back_339_comment},
  {"get_element", &Dtool_PointerToArray_LVecBase2i_get_element_340, METH_O, (const char *)Dtool_PointerToArray_LVecBase2i_get_element_340_comment},
  {"getElement", &Dtool_PointerToArray_LVecBase2i_get_element_340, METH_O, (const char *)Dtool_PointerToArray_LVecBase2i_get_element_340_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_LVecBase2i_set_element_341, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2i_set_element_341_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_LVecBase2i_set_element_341, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2i_set_element_341_comment},
  {"get_data", &Dtool_PointerToArray_LVecBase2i_get_data_344, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2i_get_data_344_comment},
  {"getData", &Dtool_PointerToArray_LVecBase2i_get_data_344, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2i_get_data_344_comment},
  {"set_data", &Dtool_PointerToArray_LVecBase2i_set_data_345, METH_O, (const char *)Dtool_PointerToArray_LVecBase2i_set_data_345_comment},
  {"setData", &Dtool_PointerToArray_LVecBase2i_set_data_345, METH_O, (const char *)Dtool_PointerToArray_LVecBase2i_set_data_345_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_LVecBase2i_get_subdata_346, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2i_get_subdata_346_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_LVecBase2i_get_subdata_346, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2i_get_subdata_346_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_LVecBase2i_set_subdata_347, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2i_set_subdata_347_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_LVecBase2i_set_subdata_347, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase2i_set_subdata_347_comment},
  {"get_ref_count", &Dtool_PointerToArray_LVecBase2i_get_ref_count_348, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2i_get_ref_count_348_comment},
  {"getRefCount", &Dtool_PointerToArray_LVecBase2i_get_ref_count_348, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2i_get_ref_count_348_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_LVecBase2i_get_node_ref_count_349, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2i_get_node_ref_count_349_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_LVecBase2i_get_node_ref_count_349, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase2i_get_node_ref_count_349_comment},
  {"count", &Dtool_PointerToArray_LVecBase2i_count_350, METH_O, (const char *)Dtool_PointerToArray_LVecBase2i_count_350_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase2i slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_LVecBase2i_getbuffer_351_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< LVecBase2i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2i, (void **)&local_this)) {
    return -1;
  }

  if (!DtoolInstance_IS_CONST(self)) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_LVecBase2i.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase2i slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_LVecBase2i_releasebuffer_352_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< LVecBase2i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2i, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< LVecBase2i > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase2i slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_LVecBase2i_setitem_343_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< LVecBase2i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2i, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LVecBase2i index out of range");
    return -1;
  }
  if (arg != nullptr) { // __setitem__
    if (!DtoolInstance_IS_CONST(self)) {
      // 1-void PointerToArray< LVecBase2i >::__setitem__(unsigned long int n, LVecBase2i const &value)
      LVecBase2i arg_local;
      LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
      if (!(arg_this != nullptr)) {
        Dtool_Raise_ArgTypeError(arg, 2, "PointerToArray.__setitem__", "LVecBase2i");
        return -1;
      }
      invoke_extension(local_this).__setitem__(index, *arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, const LVecBase2i value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase2i slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_LVecBase2i_getitem_342_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< LVecBase2i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2i, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LVecBase2i index out of range");
    return nullptr;
  }
  // 1-LVecBase2i const &PointerToArray< LVecBase2i >::__getitem__(unsigned long int n) const
  LVecBase2i const *return_value = &(invoke_extension((const PointerToArray< LVecBase2i >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase2i slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_LVecBase2i_size_337_sq_length(PyObject *self) {
  PointerToArray< LVecBase2i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase2i, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_LVecBase2i = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_LVecBase2i = {
  &Dtool_PointerToArray_LVecBase2i_size_337_sq_length,
  nullptr,
  nullptr,
  &Dtool_PointerToArray_LVecBase2i_getitem_342_sq_item,
  nullptr, // sq_slice
  &Dtool_PointerToArray_LVecBase2i_setitem_343_sq_ass_item,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_LVecBase2i = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_LVecBase2i = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_LVecBase2i_getbuffer_351_bf_getbuffer,
  &Dtool_PointerToArray_LVecBase2i_releasebuffer_352_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArray_LVecBase2i = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArray_LVecBase2i = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArray_LVecBase2i",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_LVecBase2i,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArray_LVecBase2i,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArray_LVecBase2i,
    &Dtool_SequenceMethods_PointerToArray_LVecBase2i,
    &Dtool_MappingMethods_PointerToArray_LVecBase2i,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArray_LVecBase2i,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArray_LVecBase2i,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_LVecBase2i,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_LVecBase2i,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_LVecBase2i,
  Dtool_UpcastInterface_PointerToArray_LVecBase2i,
  Dtool_DowncastInterface_PointerToArray_LVecBase2i,
  nullptr,
  (CoerceFunction)Dtool_Coerce_PointerToArray_LVecBase2i,
};

static void Dtool_PyModuleClassInit_PointerToArray_LVecBase2i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2i(nullptr);
    Dtool_PointerToArray_LVecBase2i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase2i);
    Dtool_PointerToArray_LVecBase2i._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_LVecBase2i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_LVecBase2i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_LVecBase2i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_LVecBase2i);
  }
}

/**
 * Python method tables for PointerToArray_LVecBase3d (PointerToArray_LVecBase3d)
 */
static PyMethodDef Dtool_Methods_PointerToArray_LVecBase3d[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_LVecBase3d_empty_array_356, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LVecBase3d_empty_array_356_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_LVecBase3d_empty_array_356, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LVecBase3d_empty_array_356_comment},
  {"clear", &Dtool_PointerToArray_LVecBase3d_clear_357, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3d_clear_357_comment},
  {"push_back", &Dtool_PointerToArray_LVecBase3d_push_back_359, METH_O, (const char *)Dtool_PointerToArray_LVecBase3d_push_back_359_comment},
  {"pushBack", &Dtool_PointerToArray_LVecBase3d_push_back_359, METH_O, (const char *)Dtool_PointerToArray_LVecBase3d_push_back_359_comment},
  {"pop_back", &Dtool_PointerToArray_LVecBase3d_pop_back_360, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3d_pop_back_360_comment},
  {"popBack", &Dtool_PointerToArray_LVecBase3d_pop_back_360, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3d_pop_back_360_comment},
  {"get_element", &Dtool_PointerToArray_LVecBase3d_get_element_361, METH_O, (const char *)Dtool_PointerToArray_LVecBase3d_get_element_361_comment},
  {"getElement", &Dtool_PointerToArray_LVecBase3d_get_element_361, METH_O, (const char *)Dtool_PointerToArray_LVecBase3d_get_element_361_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_LVecBase3d_set_element_362, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3d_set_element_362_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_LVecBase3d_set_element_362, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3d_set_element_362_comment},
  {"get_data", &Dtool_PointerToArray_LVecBase3d_get_data_365, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3d_get_data_365_comment},
  {"getData", &Dtool_PointerToArray_LVecBase3d_get_data_365, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3d_get_data_365_comment},
  {"set_data", &Dtool_PointerToArray_LVecBase3d_set_data_366, METH_O, (const char *)Dtool_PointerToArray_LVecBase3d_set_data_366_comment},
  {"setData", &Dtool_PointerToArray_LVecBase3d_set_data_366, METH_O, (const char *)Dtool_PointerToArray_LVecBase3d_set_data_366_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_LVecBase3d_get_subdata_367, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3d_get_subdata_367_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_LVecBase3d_get_subdata_367, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3d_get_subdata_367_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_LVecBase3d_set_subdata_368, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3d_set_subdata_368_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_LVecBase3d_set_subdata_368, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3d_set_subdata_368_comment},
  {"get_ref_count", &Dtool_PointerToArray_LVecBase3d_get_ref_count_369, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3d_get_ref_count_369_comment},
  {"getRefCount", &Dtool_PointerToArray_LVecBase3d_get_ref_count_369, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3d_get_ref_count_369_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_LVecBase3d_get_node_ref_count_370, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3d_get_node_ref_count_370_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_LVecBase3d_get_node_ref_count_370, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3d_get_node_ref_count_370_comment},
  {"count", &Dtool_PointerToArray_LVecBase3d_count_371, METH_O, (const char *)Dtool_PointerToArray_LVecBase3d_count_371_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase3d slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_LVecBase3d_getbuffer_372_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< LVecBase3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3d, (void **)&local_this)) {
    return -1;
  }

  if (!DtoolInstance_IS_CONST(self)) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_LVecBase3d.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase3d slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_LVecBase3d_releasebuffer_373_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< LVecBase3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3d, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< LVecBase3d > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase3d slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_LVecBase3d_setitem_364_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< LVecBase3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3d, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LVecBase3d index out of range");
    return -1;
  }
  if (arg != nullptr) { // __setitem__
    if (!DtoolInstance_IS_CONST(self)) {
      // 1-void PointerToArray< LVecBase3d >::__setitem__(unsigned long int n, LVecBase3d const &value)
      LVecBase3d arg_local;
      LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
      if (!(arg_this != nullptr)) {
        Dtool_Raise_ArgTypeError(arg, 2, "PointerToArray.__setitem__", "LVecBase3d");
        return -1;
      }
      invoke_extension(local_this).__setitem__(index, *arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, const LVecBase3d value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase3d slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_LVecBase3d_getitem_363_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< LVecBase3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3d, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LVecBase3d index out of range");
    return nullptr;
  }
  // 1-LVecBase3d const &PointerToArray< LVecBase3d >::__getitem__(unsigned long int n) const
  LVecBase3d const *return_value = &(invoke_extension((const PointerToArray< LVecBase3d >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase3d slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_LVecBase3d_size_358_sq_length(PyObject *self) {
  PointerToArray< LVecBase3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3d, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_LVecBase3d = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_LVecBase3d = {
  &Dtool_PointerToArray_LVecBase3d_size_358_sq_length,
  nullptr,
  nullptr,
  &Dtool_PointerToArray_LVecBase3d_getitem_363_sq_item,
  nullptr, // sq_slice
  &Dtool_PointerToArray_LVecBase3d_setitem_364_sq_ass_item,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_LVecBase3d = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_LVecBase3d = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_LVecBase3d_getbuffer_372_bf_getbuffer,
  &Dtool_PointerToArray_LVecBase3d_releasebuffer_373_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArray_LVecBase3d = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArray_LVecBase3d = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArray_LVecBase3d",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_LVecBase3d,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArray_LVecBase3d,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArray_LVecBase3d,
    &Dtool_SequenceMethods_PointerToArray_LVecBase3d,
    &Dtool_MappingMethods_PointerToArray_LVecBase3d,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArray_LVecBase3d,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArray_LVecBase3d,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_LVecBase3d,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_LVecBase3d,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_LVecBase3d,
  Dtool_UpcastInterface_PointerToArray_LVecBase3d,
  Dtool_DowncastInterface_PointerToArray_LVecBase3d,
  nullptr,
  (CoerceFunction)Dtool_Coerce_PointerToArray_LVecBase3d,
};

static void Dtool_PyModuleClassInit_PointerToArray_LVecBase3d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3d(nullptr);
    Dtool_PointerToArray_LVecBase3d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase3d);
    Dtool_PointerToArray_LVecBase3d._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_LVecBase3d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_LVecBase3d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_LVecBase3d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_LVecBase3d);
  }
}

/**
 * Python method tables for PointerToArray_LVecBase3f (PointerToArray_LVecBase3f)
 */
static PyMethodDef Dtool_Methods_PointerToArray_LVecBase3f[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_LVecBase3f_empty_array_377, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LVecBase3f_empty_array_377_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_LVecBase3f_empty_array_377, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LVecBase3f_empty_array_377_comment},
  {"clear", &Dtool_PointerToArray_LVecBase3f_clear_378, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3f_clear_378_comment},
  {"push_back", &Dtool_PointerToArray_LVecBase3f_push_back_380, METH_O, (const char *)Dtool_PointerToArray_LVecBase3f_push_back_380_comment},
  {"pushBack", &Dtool_PointerToArray_LVecBase3f_push_back_380, METH_O, (const char *)Dtool_PointerToArray_LVecBase3f_push_back_380_comment},
  {"pop_back", &Dtool_PointerToArray_LVecBase3f_pop_back_381, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3f_pop_back_381_comment},
  {"popBack", &Dtool_PointerToArray_LVecBase3f_pop_back_381, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3f_pop_back_381_comment},
  {"get_element", &Dtool_PointerToArray_LVecBase3f_get_element_382, METH_O, (const char *)Dtool_PointerToArray_LVecBase3f_get_element_382_comment},
  {"getElement", &Dtool_PointerToArray_LVecBase3f_get_element_382, METH_O, (const char *)Dtool_PointerToArray_LVecBase3f_get_element_382_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_LVecBase3f_set_element_383, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3f_set_element_383_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_LVecBase3f_set_element_383, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3f_set_element_383_comment},
  {"get_data", &Dtool_PointerToArray_LVecBase3f_get_data_386, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3f_get_data_386_comment},
  {"getData", &Dtool_PointerToArray_LVecBase3f_get_data_386, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3f_get_data_386_comment},
  {"set_data", &Dtool_PointerToArray_LVecBase3f_set_data_387, METH_O, (const char *)Dtool_PointerToArray_LVecBase3f_set_data_387_comment},
  {"setData", &Dtool_PointerToArray_LVecBase3f_set_data_387, METH_O, (const char *)Dtool_PointerToArray_LVecBase3f_set_data_387_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_LVecBase3f_get_subdata_388, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3f_get_subdata_388_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_LVecBase3f_get_subdata_388, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3f_get_subdata_388_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_LVecBase3f_set_subdata_389, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3f_set_subdata_389_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_LVecBase3f_set_subdata_389, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3f_set_subdata_389_comment},
  {"get_ref_count", &Dtool_PointerToArray_LVecBase3f_get_ref_count_390, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3f_get_ref_count_390_comment},
  {"getRefCount", &Dtool_PointerToArray_LVecBase3f_get_ref_count_390, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3f_get_ref_count_390_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_LVecBase3f_get_node_ref_count_391, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3f_get_node_ref_count_391_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_LVecBase3f_get_node_ref_count_391, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3f_get_node_ref_count_391_comment},
  {"count", &Dtool_PointerToArray_LVecBase3f_count_392, METH_O, (const char *)Dtool_PointerToArray_LVecBase3f_count_392_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase3f slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_LVecBase3f_getbuffer_393_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< LVecBase3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3f, (void **)&local_this)) {
    return -1;
  }

  if (!DtoolInstance_IS_CONST(self)) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_LVecBase3f.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase3f slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_LVecBase3f_releasebuffer_394_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< LVecBase3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3f, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< LVecBase3f > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase3f slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_LVecBase3f_setitem_385_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< LVecBase3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3f, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LVecBase3f index out of range");
    return -1;
  }
  if (arg != nullptr) { // __setitem__
    if (!DtoolInstance_IS_CONST(self)) {
      // 1-void PointerToArray< LVecBase3f >::__setitem__(unsigned long int n, LVecBase3f const &value)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != nullptr)) {
        Dtool_Raise_ArgTypeError(arg, 2, "PointerToArray.__setitem__", "LVecBase3f");
        return -1;
      }
      invoke_extension(local_this).__setitem__(index, *arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, const LVecBase3f value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase3f slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_LVecBase3f_getitem_384_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< LVecBase3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3f, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LVecBase3f index out of range");
    return nullptr;
  }
  // 1-LVecBase3f const &PointerToArray< LVecBase3f >::__getitem__(unsigned long int n) const
  LVecBase3f const *return_value = &(invoke_extension((const PointerToArray< LVecBase3f >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase3f slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_LVecBase3f_size_379_sq_length(PyObject *self) {
  PointerToArray< LVecBase3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3f, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_LVecBase3f = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_LVecBase3f = {
  &Dtool_PointerToArray_LVecBase3f_size_379_sq_length,
  nullptr,
  nullptr,
  &Dtool_PointerToArray_LVecBase3f_getitem_384_sq_item,
  nullptr, // sq_slice
  &Dtool_PointerToArray_LVecBase3f_setitem_385_sq_ass_item,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_LVecBase3f = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_LVecBase3f = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_LVecBase3f_getbuffer_393_bf_getbuffer,
  &Dtool_PointerToArray_LVecBase3f_releasebuffer_394_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArray_LVecBase3f = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArray_LVecBase3f = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArray_LVecBase3f",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_LVecBase3f,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArray_LVecBase3f,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArray_LVecBase3f,
    &Dtool_SequenceMethods_PointerToArray_LVecBase3f,
    &Dtool_MappingMethods_PointerToArray_LVecBase3f,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArray_LVecBase3f,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArray_LVecBase3f,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_LVecBase3f,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_LVecBase3f,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_LVecBase3f,
  Dtool_UpcastInterface_PointerToArray_LVecBase3f,
  Dtool_DowncastInterface_PointerToArray_LVecBase3f,
  nullptr,
  (CoerceFunction)Dtool_Coerce_PointerToArray_LVecBase3f,
};

static void Dtool_PyModuleClassInit_PointerToArray_LVecBase3f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3f(nullptr);
    Dtool_PointerToArray_LVecBase3f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase3f);
    Dtool_PointerToArray_LVecBase3f._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_LVecBase3f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_LVecBase3f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_LVecBase3f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_LVecBase3f);
  }
}

/**
 * Python method tables for PointerToArray_LVecBase3i (PointerToArray_LVecBase3i)
 */
static PyMethodDef Dtool_Methods_PointerToArray_LVecBase3i[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_LVecBase3i_empty_array_398, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LVecBase3i_empty_array_398_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_LVecBase3i_empty_array_398, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_LVecBase3i_empty_array_398_comment},
  {"clear", &Dtool_PointerToArray_LVecBase3i_clear_399, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3i_clear_399_comment},
  {"push_back", &Dtool_PointerToArray_LVecBase3i_push_back_401, METH_O, (const char *)Dtool_PointerToArray_LVecBase3i_push_back_401_comment},
  {"pushBack", &Dtool_PointerToArray_LVecBase3i_push_back_401, METH_O, (const char *)Dtool_PointerToArray_LVecBase3i_push_back_401_comment},
  {"pop_back", &Dtool_PointerToArray_LVecBase3i_pop_back_402, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3i_pop_back_402_comment},
  {"popBack", &Dtool_PointerToArray_LVecBase3i_pop_back_402, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3i_pop_back_402_comment},
  {"get_element", &Dtool_PointerToArray_LVecBase3i_get_element_403, METH_O, (const char *)Dtool_PointerToArray_LVecBase3i_get_element_403_comment},
  {"getElement", &Dtool_PointerToArray_LVecBase3i_get_element_403, METH_O, (const char *)Dtool_PointerToArray_LVecBase3i_get_element_403_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_LVecBase3i_set_element_404, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3i_set_element_404_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_LVecBase3i_set_element_404, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3i_set_element_404_comment},
  {"get_data", &Dtool_PointerToArray_LVecBase3i_get_data_407, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3i_get_data_407_comment},
  {"getData", &Dtool_PointerToArray_LVecBase3i_get_data_407, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3i_get_data_407_comment},
  {"set_data", &Dtool_PointerToArray_LVecBase3i_set_data_408, METH_O, (const char *)Dtool_PointerToArray_LVecBase3i_set_data_408_comment},
  {"setData", &Dtool_PointerToArray_LVecBase3i_set_data_408, METH_O, (const char *)Dtool_PointerToArray_LVecBase3i_set_data_408_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_LVecBase3i_get_subdata_409, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3i_get_subdata_409_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_LVecBase3i_get_subdata_409, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3i_get_subdata_409_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_LVecBase3i_set_subdata_410, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3i_set_subdata_410_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_LVecBase3i_set_subdata_410, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_LVecBase3i_set_subdata_410_comment},
  {"get_ref_count", &Dtool_PointerToArray_LVecBase3i_get_ref_count_411, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3i_get_ref_count_411_comment},
  {"getRefCount", &Dtool_PointerToArray_LVecBase3i_get_ref_count_411, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3i_get_ref_count_411_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_LVecBase3i_get_node_ref_count_412, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3i_get_node_ref_count_412_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_LVecBase3i_get_node_ref_count_412, METH_NOARGS, (const char *)Dtool_PointerToArray_LVecBase3i_get_node_ref_count_412_comment},
  {"count", &Dtool_PointerToArray_LVecBase3i_count_413, METH_O, (const char *)Dtool_PointerToArray_LVecBase3i_count_413_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase3i slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_LVecBase3i_getbuffer_414_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< LVecBase3i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3i, (void **)&local_this)) {
    return -1;
  }

  if (!DtoolInstance_IS_CONST(self)) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_LVecBase3i.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase3i slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_LVecBase3i_releasebuffer_415_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< LVecBase3i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3i, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< LVecBase3i > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase3i slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_LVecBase3i_setitem_406_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< LVecBase3i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3i, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LVecBase3i index out of range");
    return -1;
  }
  if (arg != nullptr) { // __setitem__
    if (!DtoolInstance_IS_CONST(self)) {
      // 1-void PointerToArray< LVecBase3i >::__setitem__(unsigned long int n, LVecBase3i const &value)
      LVecBase3i arg_local;
      LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
      if (!(arg_this != nullptr)) {
        Dtool_Raise_ArgTypeError(arg, 2, "PointerToArray.__setitem__", "LVecBase3i");
        return -1;
      }
      invoke_extension(local_this).__setitem__(index, *arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, const LVecBase3i value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase3i slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_LVecBase3i_getitem_405_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< LVecBase3i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3i, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_LVecBase3i index out of range");
    return nullptr;
  }
  // 1-LVecBase3i const &PointerToArray< LVecBase3i >::__getitem__(unsigned long int n) const
  LVecBase3i const *return_value = &(invoke_extension((const PointerToArray< LVecBase3i >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_LVecBase3i slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_LVecBase3i_size_400_sq_length(PyObject *self) {
  PointerToArray< LVecBase3i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_LVecBase3i, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_LVecBase3i = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_LVecBase3i = {
  &Dtool_PointerToArray_LVecBase3i_size_400_sq_length,
  nullptr,
  nullptr,
  &Dtool_PointerToArray_LVecBase3i_getitem_405_sq_item,
  nullptr, // sq_slice
  &Dtool_PointerToArray_LVecBase3i_setitem_406_sq_ass_item,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_LVecBase3i = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_LVecBase3i = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_LVecBase3i_getbuffer_414_bf_getbuffer,
  &Dtool_PointerToArray_LVecBase3i_releasebuffer_415_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArray_LVecBase3i = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArray_LVecBase3i = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArray_LVecBase3i",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_LVecBase3i,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArray_LVecBase3i,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArray_LVecBase3i,
    &Dtool_SequenceMethods_PointerToArray_LVecBase3i,
    &Dtool_MappingMethods_PointerToArray_LVecBase3i,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArray_LVecBase3i,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArray_LVecBase3i,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_LVecBase3i,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_LVecBase3i,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_LVecBase3i,
  Dtool_UpcastInterface_PointerToArray_LVecBase3i,
  Dtool_DowncastInterface_PointerToArray_LVecBase3i,
  nullptr,
  (CoerceFunction)Dtool_Coerce_PointerToArray_LVecBase3i,
};

static void Dtool_PyModuleClassInit_PointerToArray_LVecBase3i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3i(nullptr);
    Dtool_PointerToArray_LVecBase3i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_LVecBase3i);
    Dtool_PointerToArray_LVecBase3i._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_LVecBase3i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_LVecBase3i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_LVecBase3i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_LVecBase3i);
  }
}

/**
 * Python method tables for PointerToArray_UnalignedLMatrix4d (PointerToArray_UnalignedLMatrix4d)
 */
static PyMethodDef Dtool_Methods_PointerToArray_UnalignedLMatrix4d[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4d_empty_array_419, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_empty_array_419_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4d_empty_array_419, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_empty_array_419_comment},
  {"clear", &Dtool_PointerToArray_UnalignedLMatrix4d_clear_420, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_clear_420_comment},
  {"push_back", &Dtool_PointerToArray_UnalignedLMatrix4d_push_back_422, METH_O, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_push_back_422_comment},
  {"pushBack", &Dtool_PointerToArray_UnalignedLMatrix4d_push_back_422, METH_O, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_push_back_422_comment},
  {"pop_back", &Dtool_PointerToArray_UnalignedLMatrix4d_pop_back_423, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_pop_back_423_comment},
  {"popBack", &Dtool_PointerToArray_UnalignedLMatrix4d_pop_back_423, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_pop_back_423_comment},
  {"get_element", &Dtool_PointerToArray_UnalignedLMatrix4d_get_element_424, METH_O, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_get_element_424_comment},
  {"getElement", &Dtool_PointerToArray_UnalignedLMatrix4d_get_element_424, METH_O, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_get_element_424_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4d_set_element_425, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_set_element_425_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4d_set_element_425, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_set_element_425_comment},
  {"get_data", &Dtool_PointerToArray_UnalignedLMatrix4d_get_data_428, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_get_data_428_comment},
  {"getData", &Dtool_PointerToArray_UnalignedLMatrix4d_get_data_428, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_get_data_428_comment},
  {"set_data", &Dtool_PointerToArray_UnalignedLMatrix4d_set_data_429, METH_O, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_set_data_429_comment},
  {"setData", &Dtool_PointerToArray_UnalignedLMatrix4d_set_data_429, METH_O, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_set_data_429_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4d_get_subdata_430, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_get_subdata_430_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4d_get_subdata_430, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_get_subdata_430_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4d_set_subdata_431, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_set_subdata_431_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4d_set_subdata_431, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_set_subdata_431_comment},
  {"get_ref_count", &Dtool_PointerToArray_UnalignedLMatrix4d_get_ref_count_432, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_get_ref_count_432_comment},
  {"getRefCount", &Dtool_PointerToArray_UnalignedLMatrix4d_get_ref_count_432, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_get_ref_count_432_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_UnalignedLMatrix4d_get_node_ref_count_433, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_get_node_ref_count_433_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_UnalignedLMatrix4d_get_node_ref_count_433, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_get_node_ref_count_433_comment},
  {"count", &Dtool_PointerToArray_UnalignedLMatrix4d_count_434, METH_O, (const char *)Dtool_PointerToArray_UnalignedLMatrix4d_count_434_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLMatrix4d slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_UnalignedLMatrix4d_getbuffer_435_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< UnalignedLMatrix4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLMatrix4d, (void **)&local_this)) {
    return -1;
  }

  if (!DtoolInstance_IS_CONST(self)) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_UnalignedLMatrix4d.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLMatrix4d slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_UnalignedLMatrix4d_releasebuffer_436_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< UnalignedLMatrix4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLMatrix4d, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< UnalignedLMatrix4d > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLMatrix4d slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_UnalignedLMatrix4d_setitem_427_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< UnalignedLMatrix4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLMatrix4d, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_UnalignedLMatrix4d index out of range");
    return -1;
  }
  if (arg != nullptr) { // __setitem__
    if (!DtoolInstance_IS_CONST(self)) {
      // 1-void PointerToArray< UnalignedLMatrix4d >::__setitem__(unsigned long int n, UnalignedLMatrix4d const &value)
      UnalignedLMatrix4d arg_local;
      UnalignedLMatrix4d const *arg_this = Dtool_Coerce_UnalignedLMatrix4d(arg, arg_local);
      if (!(arg_this != nullptr)) {
        Dtool_Raise_ArgTypeError(arg, 2, "PointerToArray.__setitem__", "UnalignedLMatrix4d");
        return -1;
      }
      invoke_extension(local_this).__setitem__(index, *arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, const UnalignedLMatrix4d value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLMatrix4d slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4d_getitem_426_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< UnalignedLMatrix4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLMatrix4d, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_UnalignedLMatrix4d index out of range");
    return nullptr;
  }
  // 1-UnalignedLMatrix4d const &PointerToArray< UnalignedLMatrix4d >::__getitem__(unsigned long int n) const
  UnalignedLMatrix4d const *return_value = &(invoke_extension((const PointerToArray< UnalignedLMatrix4d >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLMatrix4d, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLMatrix4d slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_UnalignedLMatrix4d_size_421_sq_length(PyObject *self) {
  PointerToArray< UnalignedLMatrix4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLMatrix4d, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_UnalignedLMatrix4d = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_UnalignedLMatrix4d = {
  &Dtool_PointerToArray_UnalignedLMatrix4d_size_421_sq_length,
  nullptr,
  nullptr,
  &Dtool_PointerToArray_UnalignedLMatrix4d_getitem_426_sq_item,
  nullptr, // sq_slice
  &Dtool_PointerToArray_UnalignedLMatrix4d_setitem_427_sq_ass_item,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_UnalignedLMatrix4d = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_UnalignedLMatrix4d = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_UnalignedLMatrix4d_getbuffer_435_bf_getbuffer,
  &Dtool_PointerToArray_UnalignedLMatrix4d_releasebuffer_436_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArray_UnalignedLMatrix4d = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArray_UnalignedLMatrix4d = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArray_UnalignedLMatrix4d",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_UnalignedLMatrix4d,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArray_UnalignedLMatrix4d,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArray_UnalignedLMatrix4d,
    &Dtool_SequenceMethods_PointerToArray_UnalignedLMatrix4d,
    &Dtool_MappingMethods_PointerToArray_UnalignedLMatrix4d,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArray_UnalignedLMatrix4d,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArray_UnalignedLMatrix4d,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_UnalignedLMatrix4d,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_UnalignedLMatrix4d,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLMatrix4d,
  Dtool_UpcastInterface_PointerToArray_UnalignedLMatrix4d,
  Dtool_DowncastInterface_PointerToArray_UnalignedLMatrix4d,
  nullptr,
  (CoerceFunction)Dtool_Coerce_PointerToArray_UnalignedLMatrix4d,
};

static void Dtool_PyModuleClassInit_PointerToArray_UnalignedLMatrix4d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLMatrix4d(nullptr);
    Dtool_PointerToArray_UnalignedLMatrix4d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLMatrix4d);
    Dtool_PointerToArray_UnalignedLMatrix4d._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_UnalignedLMatrix4d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_UnalignedLMatrix4d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_UnalignedLMatrix4d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_UnalignedLMatrix4d);
  }
}

/**
 * Python method tables for PointerToArray_UnalignedLMatrix4f (PointerToArray_UnalignedLMatrix4f)
 */
static PyMethodDef Dtool_Methods_PointerToArray_UnalignedLMatrix4f[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4f_empty_array_440, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_empty_array_440_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4f_empty_array_440, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_empty_array_440_comment},
  {"clear", &Dtool_PointerToArray_UnalignedLMatrix4f_clear_441, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_clear_441_comment},
  {"push_back", &Dtool_PointerToArray_UnalignedLMatrix4f_push_back_443, METH_O, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_push_back_443_comment},
  {"pushBack", &Dtool_PointerToArray_UnalignedLMatrix4f_push_back_443, METH_O, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_push_back_443_comment},
  {"pop_back", &Dtool_PointerToArray_UnalignedLMatrix4f_pop_back_444, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_pop_back_444_comment},
  {"popBack", &Dtool_PointerToArray_UnalignedLMatrix4f_pop_back_444, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_pop_back_444_comment},
  {"get_element", &Dtool_PointerToArray_UnalignedLMatrix4f_get_element_445, METH_O, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_get_element_445_comment},
  {"getElement", &Dtool_PointerToArray_UnalignedLMatrix4f_get_element_445, METH_O, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_get_element_445_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4f_set_element_446, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_set_element_446_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4f_set_element_446, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_set_element_446_comment},
  {"get_data", &Dtool_PointerToArray_UnalignedLMatrix4f_get_data_449, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_get_data_449_comment},
  {"getData", &Dtool_PointerToArray_UnalignedLMatrix4f_get_data_449, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_get_data_449_comment},
  {"set_data", &Dtool_PointerToArray_UnalignedLMatrix4f_set_data_450, METH_O, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_set_data_450_comment},
  {"setData", &Dtool_PointerToArray_UnalignedLMatrix4f_set_data_450, METH_O, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_set_data_450_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4f_get_subdata_451, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_get_subdata_451_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4f_get_subdata_451, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_get_subdata_451_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4f_set_subdata_452, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_set_subdata_452_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLMatrix4f_set_subdata_452, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_set_subdata_452_comment},
  {"get_ref_count", &Dtool_PointerToArray_UnalignedLMatrix4f_get_ref_count_453, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_get_ref_count_453_comment},
  {"getRefCount", &Dtool_PointerToArray_UnalignedLMatrix4f_get_ref_count_453, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_get_ref_count_453_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_UnalignedLMatrix4f_get_node_ref_count_454, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_get_node_ref_count_454_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_UnalignedLMatrix4f_get_node_ref_count_454, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_get_node_ref_count_454_comment},
  {"count", &Dtool_PointerToArray_UnalignedLMatrix4f_count_455, METH_O, (const char *)Dtool_PointerToArray_UnalignedLMatrix4f_count_455_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLMatrix4f slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_UnalignedLMatrix4f_getbuffer_456_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< UnalignedLMatrix4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLMatrix4f, (void **)&local_this)) {
    return -1;
  }

  if (!DtoolInstance_IS_CONST(self)) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_UnalignedLMatrix4f.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLMatrix4f slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_UnalignedLMatrix4f_releasebuffer_457_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< UnalignedLMatrix4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLMatrix4f, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< UnalignedLMatrix4f > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLMatrix4f slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_UnalignedLMatrix4f_setitem_448_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< UnalignedLMatrix4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLMatrix4f, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_UnalignedLMatrix4f index out of range");
    return -1;
  }
  if (arg != nullptr) { // __setitem__
    if (!DtoolInstance_IS_CONST(self)) {
      // 1-void PointerToArray< UnalignedLMatrix4f >::__setitem__(unsigned long int n, UnalignedLMatrix4f const &value)
      UnalignedLMatrix4f arg_local;
      UnalignedLMatrix4f const *arg_this = Dtool_Coerce_UnalignedLMatrix4f(arg, arg_local);
      if (!(arg_this != nullptr)) {
        Dtool_Raise_ArgTypeError(arg, 2, "PointerToArray.__setitem__", "UnalignedLMatrix4f");
        return -1;
      }
      invoke_extension(local_this).__setitem__(index, *arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, const UnalignedLMatrix4f value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLMatrix4f slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_UnalignedLMatrix4f_getitem_447_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< UnalignedLMatrix4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLMatrix4f, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_UnalignedLMatrix4f index out of range");
    return nullptr;
  }
  // 1-UnalignedLMatrix4f const &PointerToArray< UnalignedLMatrix4f >::__getitem__(unsigned long int n) const
  UnalignedLMatrix4f const *return_value = &(invoke_extension((const PointerToArray< UnalignedLMatrix4f >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLMatrix4f, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLMatrix4f slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_UnalignedLMatrix4f_size_442_sq_length(PyObject *self) {
  PointerToArray< UnalignedLMatrix4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLMatrix4f, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_UnalignedLMatrix4f = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_UnalignedLMatrix4f = {
  &Dtool_PointerToArray_UnalignedLMatrix4f_size_442_sq_length,
  nullptr,
  nullptr,
  &Dtool_PointerToArray_UnalignedLMatrix4f_getitem_447_sq_item,
  nullptr, // sq_slice
  &Dtool_PointerToArray_UnalignedLMatrix4f_setitem_448_sq_ass_item,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_UnalignedLMatrix4f = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_UnalignedLMatrix4f = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_UnalignedLMatrix4f_getbuffer_456_bf_getbuffer,
  &Dtool_PointerToArray_UnalignedLMatrix4f_releasebuffer_457_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArray_UnalignedLMatrix4f = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArray_UnalignedLMatrix4f = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArray_UnalignedLMatrix4f",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_UnalignedLMatrix4f,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArray_UnalignedLMatrix4f,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArray_UnalignedLMatrix4f,
    &Dtool_SequenceMethods_PointerToArray_UnalignedLMatrix4f,
    &Dtool_MappingMethods_PointerToArray_UnalignedLMatrix4f,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArray_UnalignedLMatrix4f,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArray_UnalignedLMatrix4f,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_UnalignedLMatrix4f,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_UnalignedLMatrix4f,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLMatrix4f,
  Dtool_UpcastInterface_PointerToArray_UnalignedLMatrix4f,
  Dtool_DowncastInterface_PointerToArray_UnalignedLMatrix4f,
  nullptr,
  (CoerceFunction)Dtool_Coerce_PointerToArray_UnalignedLMatrix4f,
};

static void Dtool_PyModuleClassInit_PointerToArray_UnalignedLMatrix4f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLMatrix4f(nullptr);
    Dtool_PointerToArray_UnalignedLMatrix4f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLMatrix4f);
    Dtool_PointerToArray_UnalignedLMatrix4f._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_UnalignedLMatrix4f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_UnalignedLMatrix4f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_UnalignedLMatrix4f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_UnalignedLMatrix4f);
  }
}

/**
 * Python method tables for PointerToArray_UnalignedLVecBase4d (PointerToArray_UnalignedLVecBase4d)
 */
static PyMethodDef Dtool_Methods_PointerToArray_UnalignedLVecBase4d[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4d_empty_array_461, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_empty_array_461_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4d_empty_array_461, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_empty_array_461_comment},
  {"clear", &Dtool_PointerToArray_UnalignedLVecBase4d_clear_462, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_clear_462_comment},
  {"push_back", &Dtool_PointerToArray_UnalignedLVecBase4d_push_back_464, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_push_back_464_comment},
  {"pushBack", &Dtool_PointerToArray_UnalignedLVecBase4d_push_back_464, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_push_back_464_comment},
  {"pop_back", &Dtool_PointerToArray_UnalignedLVecBase4d_pop_back_465, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_pop_back_465_comment},
  {"popBack", &Dtool_PointerToArray_UnalignedLVecBase4d_pop_back_465, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_pop_back_465_comment},
  {"get_element", &Dtool_PointerToArray_UnalignedLVecBase4d_get_element_466, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_get_element_466_comment},
  {"getElement", &Dtool_PointerToArray_UnalignedLVecBase4d_get_element_466, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_get_element_466_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4d_set_element_467, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_set_element_467_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4d_set_element_467, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_set_element_467_comment},
  {"get_data", &Dtool_PointerToArray_UnalignedLVecBase4d_get_data_470, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_get_data_470_comment},
  {"getData", &Dtool_PointerToArray_UnalignedLVecBase4d_get_data_470, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_get_data_470_comment},
  {"set_data", &Dtool_PointerToArray_UnalignedLVecBase4d_set_data_471, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_set_data_471_comment},
  {"setData", &Dtool_PointerToArray_UnalignedLVecBase4d_set_data_471, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_set_data_471_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4d_get_subdata_472, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_get_subdata_472_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4d_get_subdata_472, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_get_subdata_472_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4d_set_subdata_473, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_set_subdata_473_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4d_set_subdata_473, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_set_subdata_473_comment},
  {"get_ref_count", &Dtool_PointerToArray_UnalignedLVecBase4d_get_ref_count_474, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_get_ref_count_474_comment},
  {"getRefCount", &Dtool_PointerToArray_UnalignedLVecBase4d_get_ref_count_474, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_get_ref_count_474_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_UnalignedLVecBase4d_get_node_ref_count_475, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_get_node_ref_count_475_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_UnalignedLVecBase4d_get_node_ref_count_475, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_get_node_ref_count_475_comment},
  {"count", &Dtool_PointerToArray_UnalignedLVecBase4d_count_476, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4d_count_476_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLVecBase4d slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_UnalignedLVecBase4d_getbuffer_477_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< UnalignedLVecBase4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4d, (void **)&local_this)) {
    return -1;
  }

  if (!DtoolInstance_IS_CONST(self)) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_UnalignedLVecBase4d.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLVecBase4d slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_UnalignedLVecBase4d_releasebuffer_478_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< UnalignedLVecBase4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4d, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< UnalignedLVecBase4d > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLVecBase4d slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_UnalignedLVecBase4d_setitem_469_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< UnalignedLVecBase4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4d, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_UnalignedLVecBase4d index out of range");
    return -1;
  }
  if (arg != nullptr) { // __setitem__
    if (!DtoolInstance_IS_CONST(self)) {
      // 1-void PointerToArray< UnalignedLVecBase4d >::__setitem__(unsigned long int n, UnalignedLVecBase4d const &value)
      UnalignedLVecBase4d arg_local;
      UnalignedLVecBase4d const *arg_this = Dtool_Coerce_UnalignedLVecBase4d(arg, arg_local);
      if (!(arg_this != nullptr)) {
        Dtool_Raise_ArgTypeError(arg, 2, "PointerToArray.__setitem__", "UnalignedLVecBase4d");
        return -1;
      }
      invoke_extension(local_this).__setitem__(index, *arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, const UnalignedLVecBase4d value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLVecBase4d slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4d_getitem_468_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< UnalignedLVecBase4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4d, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_UnalignedLVecBase4d index out of range");
    return nullptr;
  }
  // 1-UnalignedLVecBase4d const &PointerToArray< UnalignedLVecBase4d >::__getitem__(unsigned long int n) const
  UnalignedLVecBase4d const *return_value = &(invoke_extension((const PointerToArray< UnalignedLVecBase4d >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLVecBase4d, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLVecBase4d slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_UnalignedLVecBase4d_size_463_sq_length(PyObject *self) {
  PointerToArray< UnalignedLVecBase4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4d, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_UnalignedLVecBase4d = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_UnalignedLVecBase4d = {
  &Dtool_PointerToArray_UnalignedLVecBase4d_size_463_sq_length,
  nullptr,
  nullptr,
  &Dtool_PointerToArray_UnalignedLVecBase4d_getitem_468_sq_item,
  nullptr, // sq_slice
  &Dtool_PointerToArray_UnalignedLVecBase4d_setitem_469_sq_ass_item,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_UnalignedLVecBase4d = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_UnalignedLVecBase4d = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_UnalignedLVecBase4d_getbuffer_477_bf_getbuffer,
  &Dtool_PointerToArray_UnalignedLVecBase4d_releasebuffer_478_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArray_UnalignedLVecBase4d = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArray_UnalignedLVecBase4d = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArray_UnalignedLVecBase4d",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_UnalignedLVecBase4d,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArray_UnalignedLVecBase4d,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArray_UnalignedLVecBase4d,
    &Dtool_SequenceMethods_PointerToArray_UnalignedLVecBase4d,
    &Dtool_MappingMethods_PointerToArray_UnalignedLVecBase4d,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArray_UnalignedLVecBase4d,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArray_UnalignedLVecBase4d,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_UnalignedLVecBase4d,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_UnalignedLVecBase4d,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4d,
  Dtool_UpcastInterface_PointerToArray_UnalignedLVecBase4d,
  Dtool_DowncastInterface_PointerToArray_UnalignedLVecBase4d,
  nullptr,
  (CoerceFunction)Dtool_Coerce_PointerToArray_UnalignedLVecBase4d,
};

static void Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4d(nullptr);
    Dtool_PointerToArray_UnalignedLVecBase4d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4d);
    Dtool_PointerToArray_UnalignedLVecBase4d._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_UnalignedLVecBase4d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_UnalignedLVecBase4d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_UnalignedLVecBase4d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_UnalignedLVecBase4d);
  }
}

/**
 * Python method tables for PointerToArray_UnalignedLVecBase4f (PointerToArray_UnalignedLVecBase4f)
 */
static PyMethodDef Dtool_Methods_PointerToArray_UnalignedLVecBase4f[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4f_empty_array_482, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_empty_array_482_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4f_empty_array_482, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_empty_array_482_comment},
  {"clear", &Dtool_PointerToArray_UnalignedLVecBase4f_clear_483, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_clear_483_comment},
  {"push_back", &Dtool_PointerToArray_UnalignedLVecBase4f_push_back_485, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_push_back_485_comment},
  {"pushBack", &Dtool_PointerToArray_UnalignedLVecBase4f_push_back_485, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_push_back_485_comment},
  {"pop_back", &Dtool_PointerToArray_UnalignedLVecBase4f_pop_back_486, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_pop_back_486_comment},
  {"popBack", &Dtool_PointerToArray_UnalignedLVecBase4f_pop_back_486, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_pop_back_486_comment},
  {"get_element", &Dtool_PointerToArray_UnalignedLVecBase4f_get_element_487, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_get_element_487_comment},
  {"getElement", &Dtool_PointerToArray_UnalignedLVecBase4f_get_element_487, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_get_element_487_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4f_set_element_488, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_set_element_488_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4f_set_element_488, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_set_element_488_comment},
  {"get_data", &Dtool_PointerToArray_UnalignedLVecBase4f_get_data_491, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_get_data_491_comment},
  {"getData", &Dtool_PointerToArray_UnalignedLVecBase4f_get_data_491, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_get_data_491_comment},
  {"set_data", &Dtool_PointerToArray_UnalignedLVecBase4f_set_data_492, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_set_data_492_comment},
  {"setData", &Dtool_PointerToArray_UnalignedLVecBase4f_set_data_492, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_set_data_492_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4f_get_subdata_493, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_get_subdata_493_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4f_get_subdata_493, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_get_subdata_493_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4f_set_subdata_494, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_set_subdata_494_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4f_set_subdata_494, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_set_subdata_494_comment},
  {"get_ref_count", &Dtool_PointerToArray_UnalignedLVecBase4f_get_ref_count_495, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_get_ref_count_495_comment},
  {"getRefCount", &Dtool_PointerToArray_UnalignedLVecBase4f_get_ref_count_495, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_get_ref_count_495_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_UnalignedLVecBase4f_get_node_ref_count_496, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_get_node_ref_count_496_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_UnalignedLVecBase4f_get_node_ref_count_496, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_get_node_ref_count_496_comment},
  {"count", &Dtool_PointerToArray_UnalignedLVecBase4f_count_497, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4f_count_497_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLVecBase4f slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_UnalignedLVecBase4f_getbuffer_498_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< UnalignedLVecBase4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4f, (void **)&local_this)) {
    return -1;
  }

  if (!DtoolInstance_IS_CONST(self)) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_UnalignedLVecBase4f.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLVecBase4f slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_UnalignedLVecBase4f_releasebuffer_499_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< UnalignedLVecBase4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4f, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< UnalignedLVecBase4f > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLVecBase4f slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_UnalignedLVecBase4f_setitem_490_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< UnalignedLVecBase4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4f, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_UnalignedLVecBase4f index out of range");
    return -1;
  }
  if (arg != nullptr) { // __setitem__
    if (!DtoolInstance_IS_CONST(self)) {
      // 1-void PointerToArray< UnalignedLVecBase4f >::__setitem__(unsigned long int n, UnalignedLVecBase4f const &value)
      UnalignedLVecBase4f arg_local;
      UnalignedLVecBase4f const *arg_this = Dtool_Coerce_UnalignedLVecBase4f(arg, arg_local);
      if (!(arg_this != nullptr)) {
        Dtool_Raise_ArgTypeError(arg, 2, "PointerToArray.__setitem__", "UnalignedLVecBase4f");
        return -1;
      }
      invoke_extension(local_this).__setitem__(index, *arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, const UnalignedLVecBase4f value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLVecBase4f slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4f_getitem_489_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< UnalignedLVecBase4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4f, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_UnalignedLVecBase4f index out of range");
    return nullptr;
  }
  // 1-UnalignedLVecBase4f const &PointerToArray< UnalignedLVecBase4f >::__getitem__(unsigned long int n) const
  UnalignedLVecBase4f const *return_value = &(invoke_extension((const PointerToArray< UnalignedLVecBase4f >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLVecBase4f, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLVecBase4f slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_UnalignedLVecBase4f_size_484_sq_length(PyObject *self) {
  PointerToArray< UnalignedLVecBase4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4f, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_UnalignedLVecBase4f = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_UnalignedLVecBase4f = {
  &Dtool_PointerToArray_UnalignedLVecBase4f_size_484_sq_length,
  nullptr,
  nullptr,
  &Dtool_PointerToArray_UnalignedLVecBase4f_getitem_489_sq_item,
  nullptr, // sq_slice
  &Dtool_PointerToArray_UnalignedLVecBase4f_setitem_490_sq_ass_item,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_UnalignedLVecBase4f = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_UnalignedLVecBase4f = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_UnalignedLVecBase4f_getbuffer_498_bf_getbuffer,
  &Dtool_PointerToArray_UnalignedLVecBase4f_releasebuffer_499_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArray_UnalignedLVecBase4f = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArray_UnalignedLVecBase4f = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArray_UnalignedLVecBase4f",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_UnalignedLVecBase4f,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArray_UnalignedLVecBase4f,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArray_UnalignedLVecBase4f,
    &Dtool_SequenceMethods_PointerToArray_UnalignedLVecBase4f,
    &Dtool_MappingMethods_PointerToArray_UnalignedLVecBase4f,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArray_UnalignedLVecBase4f,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArray_UnalignedLVecBase4f,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_UnalignedLVecBase4f,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_UnalignedLVecBase4f,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4f,
  Dtool_UpcastInterface_PointerToArray_UnalignedLVecBase4f,
  Dtool_DowncastInterface_PointerToArray_UnalignedLVecBase4f,
  nullptr,
  (CoerceFunction)Dtool_Coerce_PointerToArray_UnalignedLVecBase4f,
};

static void Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4f(nullptr);
    Dtool_PointerToArray_UnalignedLVecBase4f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4f);
    Dtool_PointerToArray_UnalignedLVecBase4f._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_UnalignedLVecBase4f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_UnalignedLVecBase4f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_UnalignedLVecBase4f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_UnalignedLVecBase4f);
  }
}

/**
 * Python method tables for PointerToArray_UnalignedLVecBase4i (PointerToArray_UnalignedLVecBase4i)
 */
static PyMethodDef Dtool_Methods_PointerToArray_UnalignedLVecBase4i[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4i_empty_array_503, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_empty_array_503_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4i_empty_array_503, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_empty_array_503_comment},
  {"clear", &Dtool_PointerToArray_UnalignedLVecBase4i_clear_504, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_clear_504_comment},
  {"push_back", &Dtool_PointerToArray_UnalignedLVecBase4i_push_back_506, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_push_back_506_comment},
  {"pushBack", &Dtool_PointerToArray_UnalignedLVecBase4i_push_back_506, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_push_back_506_comment},
  {"pop_back", &Dtool_PointerToArray_UnalignedLVecBase4i_pop_back_507, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_pop_back_507_comment},
  {"popBack", &Dtool_PointerToArray_UnalignedLVecBase4i_pop_back_507, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_pop_back_507_comment},
  {"get_element", &Dtool_PointerToArray_UnalignedLVecBase4i_get_element_508, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_get_element_508_comment},
  {"getElement", &Dtool_PointerToArray_UnalignedLVecBase4i_get_element_508, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_get_element_508_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4i_set_element_509, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_set_element_509_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4i_set_element_509, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_set_element_509_comment},
  {"get_data", &Dtool_PointerToArray_UnalignedLVecBase4i_get_data_512, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_get_data_512_comment},
  {"getData", &Dtool_PointerToArray_UnalignedLVecBase4i_get_data_512, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_get_data_512_comment},
  {"set_data", &Dtool_PointerToArray_UnalignedLVecBase4i_set_data_513, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_set_data_513_comment},
  {"setData", &Dtool_PointerToArray_UnalignedLVecBase4i_set_data_513, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_set_data_513_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4i_get_subdata_514, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_get_subdata_514_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4i_get_subdata_514, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_get_subdata_514_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4i_set_subdata_515, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_set_subdata_515_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_UnalignedLVecBase4i_set_subdata_515, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_set_subdata_515_comment},
  {"get_ref_count", &Dtool_PointerToArray_UnalignedLVecBase4i_get_ref_count_516, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_get_ref_count_516_comment},
  {"getRefCount", &Dtool_PointerToArray_UnalignedLVecBase4i_get_ref_count_516, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_get_ref_count_516_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_UnalignedLVecBase4i_get_node_ref_count_517, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_get_node_ref_count_517_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_UnalignedLVecBase4i_get_node_ref_count_517, METH_NOARGS, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_get_node_ref_count_517_comment},
  {"count", &Dtool_PointerToArray_UnalignedLVecBase4i_count_518, METH_O, (const char *)Dtool_PointerToArray_UnalignedLVecBase4i_count_518_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLVecBase4i slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_UnalignedLVecBase4i_getbuffer_519_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< UnalignedLVecBase4i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4i, (void **)&local_this)) {
    return -1;
  }

  if (!DtoolInstance_IS_CONST(self)) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_UnalignedLVecBase4i.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLVecBase4i slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_UnalignedLVecBase4i_releasebuffer_520_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< UnalignedLVecBase4i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4i, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< UnalignedLVecBase4i > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLVecBase4i slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_UnalignedLVecBase4i_setitem_511_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< UnalignedLVecBase4i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4i, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_UnalignedLVecBase4i index out of range");
    return -1;
  }
  if (arg != nullptr) { // __setitem__
    if (!DtoolInstance_IS_CONST(self)) {
      // 1-void PointerToArray< UnalignedLVecBase4i >::__setitem__(unsigned long int n, UnalignedLVecBase4i const &value)
      UnalignedLVecBase4i arg_local;
      UnalignedLVecBase4i const *arg_this = Dtool_Coerce_UnalignedLVecBase4i(arg, arg_local);
      if (!(arg_this != nullptr)) {
        Dtool_Raise_ArgTypeError(arg, 2, "PointerToArray.__setitem__", "UnalignedLVecBase4i");
        return -1;
      }
      invoke_extension(local_this).__setitem__(index, *arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, const UnalignedLVecBase4i value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLVecBase4i slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_UnalignedLVecBase4i_getitem_510_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< UnalignedLVecBase4i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4i, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_UnalignedLVecBase4i index out of range");
    return nullptr;
  }
  // 1-UnalignedLVecBase4i const &PointerToArray< UnalignedLVecBase4i >::__getitem__(unsigned long int n) const
  UnalignedLVecBase4i const *return_value = &(invoke_extension((const PointerToArray< UnalignedLVecBase4i >*)local_this).__getitem__(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLVecBase4i, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_UnalignedLVecBase4i slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_UnalignedLVecBase4i_size_505_sq_length(PyObject *self) {
  PointerToArray< UnalignedLVecBase4i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_UnalignedLVecBase4i, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_UnalignedLVecBase4i = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_UnalignedLVecBase4i = {
  &Dtool_PointerToArray_UnalignedLVecBase4i_size_505_sq_length,
  nullptr,
  nullptr,
  &Dtool_PointerToArray_UnalignedLVecBase4i_getitem_510_sq_item,
  nullptr, // sq_slice
  &Dtool_PointerToArray_UnalignedLVecBase4i_setitem_511_sq_ass_item,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_UnalignedLVecBase4i = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_UnalignedLVecBase4i = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_UnalignedLVecBase4i_getbuffer_519_bf_getbuffer,
  &Dtool_PointerToArray_UnalignedLVecBase4i_releasebuffer_520_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArray_UnalignedLVecBase4i = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArray_UnalignedLVecBase4i = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArray_UnalignedLVecBase4i",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_UnalignedLVecBase4i,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArray_UnalignedLVecBase4i,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArray_UnalignedLVecBase4i,
    &Dtool_SequenceMethods_PointerToArray_UnalignedLVecBase4i,
    &Dtool_MappingMethods_PointerToArray_UnalignedLVecBase4i,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArray_UnalignedLVecBase4i,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArray_UnalignedLVecBase4i,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_UnalignedLVecBase4i,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_UnalignedLVecBase4i,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4i,
  Dtool_UpcastInterface_PointerToArray_UnalignedLVecBase4i,
  Dtool_DowncastInterface_PointerToArray_UnalignedLVecBase4i,
  nullptr,
  (CoerceFunction)Dtool_Coerce_PointerToArray_UnalignedLVecBase4i,
};

static void Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4i(nullptr);
    Dtool_PointerToArray_UnalignedLVecBase4i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4i);
    Dtool_PointerToArray_UnalignedLVecBase4i._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_UnalignedLVecBase4i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_UnalignedLVecBase4i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_UnalignedLVecBase4i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_UnalignedLVecBase4i);
  }
}

/**
 * Python method tables for BoundingVolume (BoundingVolume)
 */
static PyMethodDef Dtool_Methods_BoundingVolume[] = {
  {"make_copy", &Dtool_BoundingVolume_make_copy_524, METH_NOARGS, (const char *)Dtool_BoundingVolume_make_copy_524_comment},
  {"makeCopy", &Dtool_BoundingVolume_make_copy_524, METH_NOARGS, (const char *)Dtool_BoundingVolume_make_copy_524_comment},
  {"is_empty", &Dtool_BoundingVolume_is_empty_525, METH_NOARGS, (const char *)Dtool_BoundingVolume_is_empty_525_comment},
  {"isEmpty", &Dtool_BoundingVolume_is_empty_525, METH_NOARGS, (const char *)Dtool_BoundingVolume_is_empty_525_comment},
  {"is_infinite", &Dtool_BoundingVolume_is_infinite_526, METH_NOARGS, (const char *)Dtool_BoundingVolume_is_infinite_526_comment},
  {"isInfinite", &Dtool_BoundingVolume_is_infinite_526, METH_NOARGS, (const char *)Dtool_BoundingVolume_is_infinite_526_comment},
  {"set_infinite", &Dtool_BoundingVolume_set_infinite_527, METH_NOARGS, (const char *)Dtool_BoundingVolume_set_infinite_527_comment},
  {"setInfinite", &Dtool_BoundingVolume_set_infinite_527, METH_NOARGS, (const char *)Dtool_BoundingVolume_set_infinite_527_comment},
  {"extend_by", &Dtool_BoundingVolume_extend_by_528, METH_O, (const char *)Dtool_BoundingVolume_extend_by_528_comment},
  {"extendBy", &Dtool_BoundingVolume_extend_by_528, METH_O, (const char *)Dtool_BoundingVolume_extend_by_528_comment},
  {"contains", &Dtool_BoundingVolume_contains_530, METH_O, (const char *)Dtool_BoundingVolume_contains_530_comment},
  {"output", &Dtool_BoundingVolume_output_531, METH_O, (const char *)Dtool_BoundingVolume_output_531_comment},
  {"write", (PyCFunction) &Dtool_BoundingVolume_write_532, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BoundingVolume_write_532_comment},
  {"get_class_type", &Dtool_BoundingVolume_get_class_type_534, METH_NOARGS | METH_STATIC, (const char *)Dtool_BoundingVolume_get_class_type_534_comment},
  {"getClassType", &Dtool_BoundingVolume_get_class_type_534, METH_NOARGS | METH_STATIC, (const char *)Dtool_BoundingVolume_get_class_type_534_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     BoundingVolume
//////////////////
static PyObject *Dtool_Repr_BoundingVolume(PyObject *self) {
  BoundingVolume *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingVolume, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     BoundingVolume
//////////////////
static PyObject *Dtool_Str_BoundingVolume(PyObject *self) {
  BoundingVolume *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BoundingVolume, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_BoundingVolume = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BoundingVolume = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BoundingVolume = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BoundingVolume = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BoundingVolume = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BoundingVolume = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.BoundingVolume",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BoundingVolume,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BoundingVolume,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_BoundingVolume,
    &Dtool_NumberMethods_BoundingVolume,
    &Dtool_SequenceMethods_BoundingVolume,
    &Dtool_MappingMethods_BoundingVolume,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_BoundingVolume,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BoundingVolume,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is an abstract class for any volume in any sense which can be said to\n"
    " * define the locality of reference of a node in a graph, along with all of\n"
    " * its descendants.  It is not necessarily a geometric volume (although see\n"
    " * GeometricBoundingVolume); this is simply an abstract interface for bounds\n"
    " * of any sort.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BoundingVolume,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BoundingVolume,
    PyType_GenericAlloc,
    Dtool_new_BoundingVolume,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BoundingVolume,
  Dtool_UpcastInterface_BoundingVolume,
  Dtool_DowncastInterface_BoundingVolume,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_BoundingVolume(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_BoundingVolume._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_BoundingVolume._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(21);
    Dtool_BoundingVolume._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum BoundingVolume::IntersectionFlags;
    PyDict_SetItemString(dict, "IF_no_intersection", Dtool_WrapValue(BoundingVolume::IF_no_intersection));
    PyDict_SetItemString(dict, "IFNoIntersection", Dtool_WrapValue(BoundingVolume::IF_no_intersection));
    PyDict_SetItemString(dict, "IF_possible", Dtool_WrapValue(BoundingVolume::IF_possible));
    PyDict_SetItemString(dict, "IFPossible", Dtool_WrapValue(BoundingVolume::IF_possible));
    PyDict_SetItemString(dict, "IF_some", Dtool_WrapValue(BoundingVolume::IF_some));
    PyDict_SetItemString(dict, "IFSome", Dtool_WrapValue(BoundingVolume::IF_some));
    PyDict_SetItemString(dict, "IF_all", Dtool_WrapValue(BoundingVolume::IF_all));
    PyDict_SetItemString(dict, "IFAll", Dtool_WrapValue(BoundingVolume::IF_all));
    PyDict_SetItemString(dict, "IF_dont_understand", Dtool_WrapValue(BoundingVolume::IF_dont_understand));
    PyDict_SetItemString(dict, "IFDontUnderstand", Dtool_WrapValue(BoundingVolume::IF_dont_understand));
    // enum BoundingVolume::BoundsType;
    PyDict_SetItemString(dict, "BT_default", Dtool_WrapValue(BoundingVolume::BT_default));
    PyDict_SetItemString(dict, "BTDefault", Dtool_WrapValue(BoundingVolume::BT_default));
    PyDict_SetItemString(dict, "BT_best", Dtool_WrapValue(BoundingVolume::BT_best));
    PyDict_SetItemString(dict, "BTBest", Dtool_WrapValue(BoundingVolume::BT_best));
    PyDict_SetItemString(dict, "BT_sphere", Dtool_WrapValue(BoundingVolume::BT_sphere));
    PyDict_SetItemString(dict, "BTSphere", Dtool_WrapValue(BoundingVolume::BT_sphere));
    PyDict_SetItemString(dict, "BT_box", Dtool_WrapValue(BoundingVolume::BT_box));
    PyDict_SetItemString(dict, "BTBox", Dtool_WrapValue(BoundingVolume::BT_box));
    PyDict_SetItemString(dict, "BT_fastest", Dtool_WrapValue(BoundingVolume::BT_fastest));
    PyDict_SetItemString(dict, "BTFastest", Dtool_WrapValue(BoundingVolume::BT_fastest));
    if (PyType_Ready((PyTypeObject *)&Dtool_BoundingVolume) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BoundingVolume)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BoundingVolume);
  }
}

/**
 * Python method tables for GeometricBoundingVolume (GeometricBoundingVolume)
 */
static PyMethodDef Dtool_Methods_GeometricBoundingVolume[] = {
  {"extend_by", &Dtool_GeometricBoundingVolume_extend_by_537, METH_O, (const char *)Dtool_GeometricBoundingVolume_extend_by_537_comment},
  {"extendBy", &Dtool_GeometricBoundingVolume_extend_by_537, METH_O, (const char *)Dtool_GeometricBoundingVolume_extend_by_537_comment},
  {"contains", (PyCFunction) &Dtool_GeometricBoundingVolume_contains_538, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GeometricBoundingVolume_contains_538_comment},
  {"get_approx_center", &Dtool_GeometricBoundingVolume_get_approx_center_539, METH_NOARGS, (const char *)Dtool_GeometricBoundingVolume_get_approx_center_539_comment},
  {"getApproxCenter", &Dtool_GeometricBoundingVolume_get_approx_center_539, METH_NOARGS, (const char *)Dtool_GeometricBoundingVolume_get_approx_center_539_comment},
  {"xform", &Dtool_GeometricBoundingVolume_xform_540, METH_O, (const char *)Dtool_GeometricBoundingVolume_xform_540_comment},
  {"get_class_type", &Dtool_GeometricBoundingVolume_get_class_type_541, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeometricBoundingVolume_get_class_type_541_comment},
  {"getClassType", &Dtool_GeometricBoundingVolume_get_class_type_541, METH_NOARGS | METH_STATIC, (const char *)Dtool_GeometricBoundingVolume_get_class_type_541_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_GeometricBoundingVolume = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GeometricBoundingVolume = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GeometricBoundingVolume = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GeometricBoundingVolume = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GeometricBoundingVolume = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GeometricBoundingVolume = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GeometricBoundingVolume",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GeometricBoundingVolume,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GeometricBoundingVolume,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GeometricBoundingVolume,
    &Dtool_SequenceMethods_GeometricBoundingVolume,
    &Dtool_MappingMethods_GeometricBoundingVolume,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GeometricBoundingVolume,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is another abstract class, for a general class of bounding volumes\n"
    " * that actually enclose points in 3-d space, such as BSP's and bounding\n"
    " * spheres.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GeometricBoundingVolume,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GeometricBoundingVolume,
    PyType_GenericAlloc,
    Dtool_new_GeometricBoundingVolume,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GeometricBoundingVolume,
  Dtool_UpcastInterface_GeometricBoundingVolume,
  Dtool_DowncastInterface_GeometricBoundingVolume,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GeometricBoundingVolume(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BoundingVolume(nullptr);
    Dtool_GeometricBoundingVolume._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BoundingVolume);
    Dtool_GeometricBoundingVolume._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GeometricBoundingVolume._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GeometricBoundingVolume) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GeometricBoundingVolume)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GeometricBoundingVolume);
  }
}

/**
 * Python method tables for FiniteBoundingVolume (FiniteBoundingVolume)
 */
static PyMethodDef Dtool_Methods_FiniteBoundingVolume[] = {
  {"get_min", &Dtool_FiniteBoundingVolume_get_min_544, METH_NOARGS, (const char *)Dtool_FiniteBoundingVolume_get_min_544_comment},
  {"getMin", &Dtool_FiniteBoundingVolume_get_min_544, METH_NOARGS, (const char *)Dtool_FiniteBoundingVolume_get_min_544_comment},
  {"get_max", &Dtool_FiniteBoundingVolume_get_max_545, METH_NOARGS, (const char *)Dtool_FiniteBoundingVolume_get_max_545_comment},
  {"getMax", &Dtool_FiniteBoundingVolume_get_max_545, METH_NOARGS, (const char *)Dtool_FiniteBoundingVolume_get_max_545_comment},
  {"get_volume", &Dtool_FiniteBoundingVolume_get_volume_546, METH_NOARGS, (const char *)Dtool_FiniteBoundingVolume_get_volume_546_comment},
  {"getVolume", &Dtool_FiniteBoundingVolume_get_volume_546, METH_NOARGS, (const char *)Dtool_FiniteBoundingVolume_get_volume_546_comment},
  {"get_class_type", &Dtool_FiniteBoundingVolume_get_class_type_554, METH_NOARGS | METH_STATIC, (const char *)Dtool_FiniteBoundingVolume_get_class_type_554_comment},
  {"getClassType", &Dtool_FiniteBoundingVolume_get_class_type_554, METH_NOARGS | METH_STATIC, (const char *)Dtool_FiniteBoundingVolume_get_class_type_554_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_FiniteBoundingVolume[] = {
  {(char *)"min", &Dtool_FiniteBoundingVolume_min_Getter, nullptr, nullptr, nullptr},
  {(char *)"max", &Dtool_FiniteBoundingVolume_max_Getter, nullptr, nullptr, nullptr},
  {(char *)"volume", &Dtool_FiniteBoundingVolume_volume_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_FiniteBoundingVolume = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_FiniteBoundingVolume = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_FiniteBoundingVolume = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_FiniteBoundingVolume = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_FiniteBoundingVolume = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_FiniteBoundingVolume = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.FiniteBoundingVolume",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_FiniteBoundingVolume,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_FiniteBoundingVolume,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_FiniteBoundingVolume,
    &Dtool_SequenceMethods_FiniteBoundingVolume,
    &Dtool_MappingMethods_FiniteBoundingVolume,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_FiniteBoundingVolume,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A special kind of GeometricBoundingVolume that is known to be finite.  It\n"
    " * is possible to query this kind of volume for its minimum and maximum\n"
    " * extents.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_FiniteBoundingVolume,
    nullptr, // tp_members
    Dtool_Properties_FiniteBoundingVolume,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_FiniteBoundingVolume,
    PyType_GenericAlloc,
    Dtool_new_FiniteBoundingVolume,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_FiniteBoundingVolume,
  Dtool_UpcastInterface_FiniteBoundingVolume,
  Dtool_DowncastInterface_FiniteBoundingVolume,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_FiniteBoundingVolume(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GeometricBoundingVolume(nullptr);
    Dtool_FiniteBoundingVolume._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GeometricBoundingVolume);
    Dtool_FiniteBoundingVolume._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_FiniteBoundingVolume._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_FiniteBoundingVolume) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(FiniteBoundingVolume)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_FiniteBoundingVolume);
  }
}

/**
 * Python method tables for LParabolaf (LParabolaf)
 */
static PyMethodDef Dtool_Methods_LParabolaf[] = {
  {"assign", &Dtool_LParabolaf_operator_558, METH_O, (const char *)Dtool_LParabolaf_operator_558_comment},
  {"xform", &Dtool_LParabolaf_xform_560, METH_O, (const char *)Dtool_LParabolaf_xform_560_comment},
  {"get_a", &Dtool_LParabolaf_get_a_561, METH_NOARGS, (const char *)Dtool_LParabolaf_get_a_561_comment},
  {"getA", &Dtool_LParabolaf_get_a_561, METH_NOARGS, (const char *)Dtool_LParabolaf_get_a_561_comment},
  {"get_b", &Dtool_LParabolaf_get_b_562, METH_NOARGS, (const char *)Dtool_LParabolaf_get_b_562_comment},
  {"getB", &Dtool_LParabolaf_get_b_562, METH_NOARGS, (const char *)Dtool_LParabolaf_get_b_562_comment},
  {"get_c", &Dtool_LParabolaf_get_c_563, METH_NOARGS, (const char *)Dtool_LParabolaf_get_c_563_comment},
  {"getC", &Dtool_LParabolaf_get_c_563, METH_NOARGS, (const char *)Dtool_LParabolaf_get_c_563_comment},
  {"calc_point", &Dtool_LParabolaf_calc_point_564, METH_O, (const char *)Dtool_LParabolaf_calc_point_564_comment},
  {"calcPoint", &Dtool_LParabolaf_calc_point_564, METH_O, (const char *)Dtool_LParabolaf_calc_point_564_comment},
  {"output", &Dtool_LParabolaf_output_565, METH_O, (const char *)Dtool_LParabolaf_output_565_comment},
  {"write", (PyCFunction) &Dtool_LParabolaf_write_566, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LParabolaf_write_566_comment},
  {"write_datagram_fixed", &Dtool_LParabolaf_write_datagram_fixed_567, METH_O, (const char *)Dtool_LParabolaf_write_datagram_fixed_567_comment},
  {"writeDatagramFixed", &Dtool_LParabolaf_write_datagram_fixed_567, METH_O, (const char *)Dtool_LParabolaf_write_datagram_fixed_567_comment},
  {"read_datagram_fixed", &Dtool_LParabolaf_read_datagram_fixed_568, METH_O, (const char *)Dtool_LParabolaf_read_datagram_fixed_568_comment},
  {"readDatagramFixed", &Dtool_LParabolaf_read_datagram_fixed_568, METH_O, (const char *)Dtool_LParabolaf_read_datagram_fixed_568_comment},
  {"write_datagram", &Dtool_LParabolaf_write_datagram_569, METH_O, (const char *)Dtool_LParabolaf_write_datagram_569_comment},
  {"writeDatagram", &Dtool_LParabolaf_write_datagram_569, METH_O, (const char *)Dtool_LParabolaf_write_datagram_569_comment},
  {"read_datagram", &Dtool_LParabolaf_read_datagram_570, METH_O, (const char *)Dtool_LParabolaf_read_datagram_570_comment},
  {"readDatagram", &Dtool_LParabolaf_read_datagram_570, METH_O, (const char *)Dtool_LParabolaf_read_datagram_570_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     LParabolaf
//////////////////
static PyObject *Dtool_Repr_LParabolaf(PyObject *self) {
  LParabolaf *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LParabolaf, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     LParabolaf
//////////////////
static PyObject *Dtool_Str_LParabolaf(PyObject *self) {
  LParabolaf *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LParabolaf, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_LParabolaf = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_LParabolaf = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.LParabolaf",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LParabolaf,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_LParabolaf,
    &Dtool_NumberMethods_LParabolaf,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_LParabolaf,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An abstract mathematical description of a parabola, particularly useful for\n"
    " * describing arcs of projectiles.\n"
    " *\n"
    " * The parabolic equation, given parametrically here, is P = At^2 + Bt + C.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LParabolaf,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LParabolaf,
    PyType_GenericAlloc,
    Dtool_new_LParabolaf,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LParabolaf,
  Dtool_UpcastInterface_LParabolaf,
  Dtool_DowncastInterface_LParabolaf,
  nullptr,
  (CoerceFunction)Dtool_Coerce_LParabolaf,
};

static void Dtool_PyModuleClassInit_LParabolaf(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LParabolaf._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LParabolaf._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LParabolaf) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LParabolaf)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LParabolaf);
  }
}

/**
 * Python method tables for LParabolad (LParabolad)
 */
static PyMethodDef Dtool_Methods_LParabolad[] = {
  {"assign", &Dtool_LParabolad_operator_573, METH_O, (const char *)Dtool_LParabolad_operator_573_comment},
  {"xform", &Dtool_LParabolad_xform_575, METH_O, (const char *)Dtool_LParabolad_xform_575_comment},
  {"get_a", &Dtool_LParabolad_get_a_576, METH_NOARGS, (const char *)Dtool_LParabolad_get_a_576_comment},
  {"getA", &Dtool_LParabolad_get_a_576, METH_NOARGS, (const char *)Dtool_LParabolad_get_a_576_comment},
  {"get_b", &Dtool_LParabolad_get_b_577, METH_NOARGS, (const char *)Dtool_LParabolad_get_b_577_comment},
  {"getB", &Dtool_LParabolad_get_b_577, METH_NOARGS, (const char *)Dtool_LParabolad_get_b_577_comment},
  {"get_c", &Dtool_LParabolad_get_c_578, METH_NOARGS, (const char *)Dtool_LParabolad_get_c_578_comment},
  {"getC", &Dtool_LParabolad_get_c_578, METH_NOARGS, (const char *)Dtool_LParabolad_get_c_578_comment},
  {"calc_point", &Dtool_LParabolad_calc_point_579, METH_O, (const char *)Dtool_LParabolad_calc_point_579_comment},
  {"calcPoint", &Dtool_LParabolad_calc_point_579, METH_O, (const char *)Dtool_LParabolad_calc_point_579_comment},
  {"output", &Dtool_LParabolad_output_580, METH_O, (const char *)Dtool_LParabolad_output_580_comment},
  {"write", (PyCFunction) &Dtool_LParabolad_write_581, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LParabolad_write_581_comment},
  {"write_datagram_fixed", &Dtool_LParabolad_write_datagram_fixed_582, METH_O, (const char *)Dtool_LParabolad_write_datagram_fixed_582_comment},
  {"writeDatagramFixed", &Dtool_LParabolad_write_datagram_fixed_582, METH_O, (const char *)Dtool_LParabolad_write_datagram_fixed_582_comment},
  {"read_datagram_fixed", &Dtool_LParabolad_read_datagram_fixed_583, METH_O, (const char *)Dtool_LParabolad_read_datagram_fixed_583_comment},
  {"readDatagramFixed", &Dtool_LParabolad_read_datagram_fixed_583, METH_O, (const char *)Dtool_LParabolad_read_datagram_fixed_583_comment},
  {"write_datagram", &Dtool_LParabolad_write_datagram_584, METH_O, (const char *)Dtool_LParabolad_write_datagram_584_comment},
  {"writeDatagram", &Dtool_LParabolad_write_datagram_584, METH_O, (const char *)Dtool_LParabolad_write_datagram_584_comment},
  {"read_datagram", &Dtool_LParabolad_read_datagram_585, METH_O, (const char *)Dtool_LParabolad_read_datagram_585_comment},
  {"readDatagram", &Dtool_LParabolad_read_datagram_585, METH_O, (const char *)Dtool_LParabolad_read_datagram_585_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     LParabolad
//////////////////
static PyObject *Dtool_Repr_LParabolad(PyObject *self) {
  LParabolad *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LParabolad, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     LParabolad
//////////////////
static PyObject *Dtool_Str_LParabolad(PyObject *self) {
  LParabolad *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LParabolad, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_LParabolad = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_LParabolad = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.LParabolad",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LParabolad,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_LParabolad,
    &Dtool_NumberMethods_LParabolad,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_LParabolad,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An abstract mathematical description of a parabola, particularly useful for\n"
    " * describing arcs of projectiles.\n"
    " *\n"
    " * The parabolic equation, given parametrically here, is P = At^2 + Bt + C.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LParabolad,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LParabolad,
    PyType_GenericAlloc,
    Dtool_new_LParabolad,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LParabolad,
  Dtool_UpcastInterface_LParabolad,
  Dtool_DowncastInterface_LParabolad,
  nullptr,
  (CoerceFunction)Dtool_Coerce_LParabolad,
};

static void Dtool_PyModuleClassInit_LParabolad(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LParabolad._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LParabolad._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LParabolad) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LParabolad)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LParabolad);
  }
}

/**
 * Python method tables for LPlanef (LPlanef)
 */
static PyMethodDef Dtool_Methods_LPlanef[] = {
  {"xform", &Dtool_LPlanef_xform_592, METH_O, (const char *)Dtool_LPlanef_xform_592_comment},
  {"get_reflection_mat", &Dtool_LPlanef_get_reflection_mat_594, METH_NOARGS, (const char *)Dtool_LPlanef_get_reflection_mat_594_comment},
  {"getReflectionMat", &Dtool_LPlanef_get_reflection_mat_594, METH_NOARGS, (const char *)Dtool_LPlanef_get_reflection_mat_594_comment},
  {"get_normal", &Dtool_LPlanef_get_normal_595, METH_NOARGS, (const char *)Dtool_LPlanef_get_normal_595_comment},
  {"getNormal", &Dtool_LPlanef_get_normal_595, METH_NOARGS, (const char *)Dtool_LPlanef_get_normal_595_comment},
  {"get_point", &Dtool_LPlanef_get_point_596, METH_NOARGS, (const char *)Dtool_LPlanef_get_point_596_comment},
  {"getPoint", &Dtool_LPlanef_get_point_596, METH_NOARGS, (const char *)Dtool_LPlanef_get_point_596_comment},
  {"dist_to_plane", &Dtool_LPlanef_dist_to_plane_597, METH_O, (const char *)Dtool_LPlanef_dist_to_plane_597_comment},
  {"distToPlane", &Dtool_LPlanef_dist_to_plane_597, METH_O, (const char *)Dtool_LPlanef_dist_to_plane_597_comment},
  {"normalize", &Dtool_LPlanef_normalize_598, METH_NOARGS, (const char *)Dtool_LPlanef_normalize_598_comment},
  {"normalized", &Dtool_LPlanef_normalized_599, METH_NOARGS, (const char *)Dtool_LPlanef_normalized_599_comment},
  {"project", &Dtool_LPlanef_project_600, METH_O, (const char *)Dtool_LPlanef_project_600_comment},
  {"flip", &Dtool_LPlanef_flip_601, METH_NOARGS, (const char *)Dtool_LPlanef_flip_601_comment},
  {"intersects_line", (PyCFunction) &Dtool_LPlanef_intersects_line_602, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LPlanef_intersects_line_602_comment},
  {"intersectsLine", (PyCFunction) &Dtool_LPlanef_intersects_line_602, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LPlanef_intersects_line_602_comment},
  {"intersects_plane", (PyCFunction) &Dtool_LPlanef_intersects_plane_603, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LPlanef_intersects_plane_603_comment},
  {"intersectsPlane", (PyCFunction) &Dtool_LPlanef_intersects_plane_603, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LPlanef_intersects_plane_603_comment},
  {"output", &Dtool_LPlanef_output_605, METH_O, (const char *)Dtool_LPlanef_output_605_comment},
  {"write", (PyCFunction) &Dtool_LPlanef_write_606, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LPlanef_write_606_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPlanef slot nb_inplace_multiply -> operator *=
//////////////////
static PyObject *Dtool_LPlanef_operator_591_nb_inplace_multiply(PyObject *self, PyObject *arg) {
  LPlanef *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPlanef, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void LPlanef::operator *=(LMatrix4f const &mat)
  LMatrix4f arg_local;
  LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "LPlanef.__imul__", "LMatrix4f");
    return nullptr;
  }
  ((*local_this).operator *=)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  Py_INCREF(self);
  return self;
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPlanef slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LPlanef_operator_590_nb_multiply(PyObject *self, PyObject *arg) {
  LPlanef *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPlanef, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LPlanef LPlanef::operator *(LMatrix3f const &mat) const
    LMatrix3f const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LMatrix3f);
    if (arg_this != nullptr) {
      LPlanef *return_value = new LPlanef(((*(const LPlanef*)local_this).operator *)(*arg_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, true, false);
    }
  }

  {
    // -2 inline LPlanef LPlanef::operator *(LMatrix4f const &mat) const
    LMatrix4f const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LMatrix4f);
    if (arg_this != nullptr) {
      LPlanef *return_value = new LPlanef(((*(const LPlanef*)local_this).operator *)(*arg_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, true, false);
    }
  }

  {
    // -2 inline LPlanef LPlanef::operator *(LMatrix3f const &mat) const
    LMatrix3f arg_local;
    LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
    if ((arg_this != nullptr)) {
      LPlanef *return_value = new LPlanef(((*(const LPlanef*)local_this).operator *)(*arg_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, true, false);
    }
  }

  {
    // -2 inline LPlanef LPlanef::operator *(LMatrix4f const &mat) const
    LMatrix4f arg_local;
    LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
    if ((arg_this != nullptr)) {
      LPlanef *return_value = new LPlanef(((*(const LPlanef*)local_this).operator *)(*arg_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPlanef slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LPlanef_operator_593_nb_negative(PyObject *self) {
  LPlanef *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPlanef, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LPlanef LPlanef::operator -(void) const
  LPlanef *return_value = new LPlanef(((*(const LPlanef*)local_this).operator -)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LPlanef self)\n");
  }
  return nullptr;
}

//////////////////
//  A __repr__ function
//     LPlanef
//////////////////
static PyObject *Dtool_Repr_LPlanef(PyObject *self) {
  LPlanef *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPlanef, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     LPlanef
//////////////////
static PyObject *Dtool_Str_LPlanef(PyObject *self) {
  LPlanef *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPlanef, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_LPlanef = {
  nullptr,
  nullptr,
  &Dtool_LPlanef_operator_590_nb_multiply,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  &Dtool_LPlanef_operator_593_nb_negative,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  &Dtool_LPlanef_operator_591_nb_inplace_multiply,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LPlanef = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LPlanef = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LPlanef = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LPlanef = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LPlanef = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.LPlanef",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LPlanef,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LPlanef,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_LPlanef,
    &Dtool_NumberMethods_LPlanef,
    &Dtool_SequenceMethods_LPlanef,
    &Dtool_MappingMethods_LPlanef,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_LPlanef,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LPlanef,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An abstract mathematical description of a plane.  A plane is defined by the\n"
    " * equation Ax + By + Cz + D = 0.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LPlanef,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LPlanef,
    PyType_GenericAlloc,
    Dtool_new_LPlanef,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LPlanef,
  Dtool_UpcastInterface_LPlanef,
  Dtool_DowncastInterface_LPlanef,
  nullptr,
  (CoerceFunction)Dtool_Coerce_LPlanef,
};

static void Dtool_PyModuleClassInit_LPlanef(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_LVecBase4f != nullptr);
    assert(Dtool_Ptr_LVecBase4f->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_LVecBase4f->_Dtool_ModuleClassInit(nullptr);
    Dtool_LPlanef._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_LVecBase4f);
    Dtool_LPlanef._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LPlanef._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LPlanef) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LPlanef)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LPlanef);
  }
}

/**
 * Python method tables for LPlaned (LPlaned)
 */
static PyMethodDef Dtool_Methods_LPlaned[] = {
  {"xform", &Dtool_LPlaned_xform_613, METH_O, (const char *)Dtool_LPlaned_xform_613_comment},
  {"get_reflection_mat", &Dtool_LPlaned_get_reflection_mat_615, METH_NOARGS, (const char *)Dtool_LPlaned_get_reflection_mat_615_comment},
  {"getReflectionMat", &Dtool_LPlaned_get_reflection_mat_615, METH_NOARGS, (const char *)Dtool_LPlaned_get_reflection_mat_615_comment},
  {"get_normal", &Dtool_LPlaned_get_normal_616, METH_NOARGS, (const char *)Dtool_LPlaned_get_normal_616_comment},
  {"getNormal", &Dtool_LPlaned_get_normal_616, METH_NOARGS, (const char *)Dtool_LPlaned_get_normal_616_comment},
  {"get_point", &Dtool_LPlaned_get_point_617, METH_NOARGS, (const char *)Dtool_LPlaned_get_point_617_comment},
  {"getPoint", &Dtool_LPlaned_get_point_617, METH_NOARGS, (const char *)Dtool_LPlaned_get_point_617_comment},
  {"dist_to_plane", &Dtool_LPlaned_dist_to_plane_618, METH_O, (const char *)Dtool_LPlaned_dist_to_plane_618_comment},
  {"distToPlane", &Dtool_LPlaned_dist_to_plane_618, METH_O, (const char *)Dtool_LPlaned_dist_to_plane_618_comment},
  {"normalize", &Dtool_LPlaned_normalize_619, METH_NOARGS, (const char *)Dtool_LPlaned_normalize_619_comment},
  {"normalized", &Dtool_LPlaned_normalized_620, METH_NOARGS, (const char *)Dtool_LPlaned_normalized_620_comment},
  {"project", &Dtool_LPlaned_project_621, METH_O, (const char *)Dtool_LPlaned_project_621_comment},
  {"flip", &Dtool_LPlaned_flip_622, METH_NOARGS, (const char *)Dtool_LPlaned_flip_622_comment},
  {"intersects_line", (PyCFunction) &Dtool_LPlaned_intersects_line_623, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LPlaned_intersects_line_623_comment},
  {"intersectsLine", (PyCFunction) &Dtool_LPlaned_intersects_line_623, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LPlaned_intersects_line_623_comment},
  {"intersects_plane", (PyCFunction) &Dtool_LPlaned_intersects_plane_624, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LPlaned_intersects_plane_624_comment},
  {"intersectsPlane", (PyCFunction) &Dtool_LPlaned_intersects_plane_624, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LPlaned_intersects_plane_624_comment},
  {"output", &Dtool_LPlaned_output_626, METH_O, (const char *)Dtool_LPlaned_output_626_comment},
  {"write", (PyCFunction) &Dtool_LPlaned_write_627, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LPlaned_write_627_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPlaned slot nb_inplace_multiply -> operator *=
//////////////////
static PyObject *Dtool_LPlaned_operator_612_nb_inplace_multiply(PyObject *self, PyObject *arg) {
  LPlaned *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPlaned, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void LPlaned::operator *=(LMatrix4d const &mat)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "LPlaned.__imul__", "LMatrix4d");
    return nullptr;
  }
  ((*local_this).operator *=)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  Py_INCREF(self);
  return self;
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPlaned slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LPlaned_operator_611_nb_multiply(PyObject *self, PyObject *arg) {
  LPlaned *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPlaned, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LPlaned LPlaned::operator *(LMatrix3d const &mat) const
    LMatrix3d const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LMatrix3d);
    if (arg_this != nullptr) {
      LPlaned *return_value = new LPlaned(((*(const LPlaned*)local_this).operator *)(*arg_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlaned, true, false);
    }
  }

  {
    // -2 inline LPlaned LPlaned::operator *(LMatrix4d const &mat) const
    LMatrix4d const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LMatrix4d);
    if (arg_this != nullptr) {
      LPlaned *return_value = new LPlaned(((*(const LPlaned*)local_this).operator *)(*arg_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlaned, true, false);
    }
  }

  {
    // -2 inline LPlaned LPlaned::operator *(LMatrix3d const &mat) const
    LMatrix3d arg_local;
    LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
    if ((arg_this != nullptr)) {
      LPlaned *return_value = new LPlaned(((*(const LPlaned*)local_this).operator *)(*arg_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlaned, true, false);
    }
  }

  {
    // -2 inline LPlaned LPlaned::operator *(LMatrix4d const &mat) const
    LMatrix4d arg_local;
    LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
    if ((arg_this != nullptr)) {
      LPlaned *return_value = new LPlaned(((*(const LPlaned*)local_this).operator *)(*arg_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlaned, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPlaned slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LPlaned_operator_614_nb_negative(PyObject *self) {
  LPlaned *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPlaned, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LPlaned LPlaned::operator -(void) const
  LPlaned *return_value = new LPlaned(((*(const LPlaned*)local_this).operator -)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlaned, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LPlaned self)\n");
  }
  return nullptr;
}

//////////////////
//  A __repr__ function
//     LPlaned
//////////////////
static PyObject *Dtool_Repr_LPlaned(PyObject *self) {
  LPlaned *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPlaned, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     LPlaned
//////////////////
static PyObject *Dtool_Str_LPlaned(PyObject *self) {
  LPlaned *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPlaned, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_LPlaned = {
  nullptr,
  nullptr,
  &Dtool_LPlaned_operator_611_nb_multiply,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  &Dtool_LPlaned_operator_614_nb_negative,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  &Dtool_LPlaned_operator_612_nb_inplace_multiply,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LPlaned = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LPlaned = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LPlaned = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LPlaned = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LPlaned = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.LPlaned",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LPlaned,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LPlaned,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_LPlaned,
    &Dtool_NumberMethods_LPlaned,
    &Dtool_SequenceMethods_LPlaned,
    &Dtool_MappingMethods_LPlaned,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_LPlaned,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LPlaned,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An abstract mathematical description of a plane.  A plane is defined by the\n"
    " * equation Ax + By + Cz + D = 0.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LPlaned,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LPlaned,
    PyType_GenericAlloc,
    Dtool_new_LPlaned,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LPlaned,
  Dtool_UpcastInterface_LPlaned,
  Dtool_DowncastInterface_LPlaned,
  nullptr,
  (CoerceFunction)Dtool_Coerce_LPlaned,
};

static void Dtool_PyModuleClassInit_LPlaned(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_LVecBase4d != nullptr);
    assert(Dtool_Ptr_LVecBase4d->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_LVecBase4d->_Dtool_ModuleClassInit(nullptr);
    Dtool_LPlaned._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_LVecBase4d);
    Dtool_LPlaned._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LPlaned._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LPlaned) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LPlaned)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LPlaned);
  }
}

/**
 * Python method tables for BoundingBox (BoundingBox)
 */
static PyMethodDef Dtool_Methods_BoundingBox[] = {
  {"get_num_points", &Dtool_BoundingBox_get_num_points_638, METH_NOARGS, (const char *)Dtool_BoundingBox_get_num_points_638_comment},
  {"getNumPoints", &Dtool_BoundingBox_get_num_points_638, METH_NOARGS, (const char *)Dtool_BoundingBox_get_num_points_638_comment},
  {"get_point", &Dtool_BoundingBox_get_point_639, METH_O, (const char *)Dtool_BoundingBox_get_point_639_comment},
  {"getPoint", &Dtool_BoundingBox_get_point_639, METH_O, (const char *)Dtool_BoundingBox_get_point_639_comment},
  {"get_num_planes", &Dtool_BoundingBox_get_num_planes_641, METH_NOARGS, (const char *)Dtool_BoundingBox_get_num_planes_641_comment},
  {"getNumPlanes", &Dtool_BoundingBox_get_num_planes_641, METH_NOARGS, (const char *)Dtool_BoundingBox_get_num_planes_641_comment},
  {"get_plane", &Dtool_BoundingBox_get_plane_642, METH_O, (const char *)Dtool_BoundingBox_get_plane_642_comment},
  {"getPlane", &Dtool_BoundingBox_get_plane_642, METH_O, (const char *)Dtool_BoundingBox_get_plane_642_comment},
  {"set_min_max", (PyCFunction) &Dtool_BoundingBox_set_min_max_646, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BoundingBox_set_min_max_646_comment},
  {"setMinMax", (PyCFunction) &Dtool_BoundingBox_set_min_max_646, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BoundingBox_set_min_max_646_comment},
  {"get_class_type", &Dtool_BoundingBox_get_class_type_647, METH_NOARGS | METH_STATIC, (const char *)Dtool_BoundingBox_get_class_type_647_comment},
  {"getClassType", &Dtool_BoundingBox_get_class_type_647, METH_NOARGS | METH_STATIC, (const char *)Dtool_BoundingBox_get_class_type_647_comment},
  {"get_points", (PyCFunction) &MakeSeq_BoundingBox_get_points, METH_NOARGS, nullptr},
  { "getPoints", (PyCFunction) &MakeSeq_BoundingBox_get_points, METH_NOARGS, nullptr},
  {"get_planes", (PyCFunction) &MakeSeq_BoundingBox_get_planes, METH_NOARGS, nullptr},
  { "getPlanes", (PyCFunction) &MakeSeq_BoundingBox_get_planes, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_BoundingBox[] = {
  {(char *)"points", &Dtool_BoundingBox_points_Getter, nullptr, nullptr, nullptr},
  {(char *)"planes", &Dtool_BoundingBox_planes_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_BoundingBox = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BoundingBox = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BoundingBox = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BoundingBox = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BoundingBox = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BoundingBox = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.BoundingBox",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BoundingBox,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BoundingBox,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BoundingBox,
    &Dtool_SequenceMethods_BoundingBox,
    &Dtool_MappingMethods_BoundingBox,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BoundingBox,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An axis-aligned bounding box; that is, a minimum and maximum coordinate\n"
    " * triple.\n"
    " *\n"
    " * This box is always axis-aligned.  If you need a more general bounding box,\n"
    " * try BoundingHexahedron.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BoundingBox,
    nullptr, // tp_members
    Dtool_Properties_BoundingBox,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BoundingBox,
    PyType_GenericAlloc,
    Dtool_new_BoundingBox,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BoundingBox,
  Dtool_UpcastInterface_BoundingBox,
  Dtool_DowncastInterface_BoundingBox,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_BoundingBox(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_FiniteBoundingVolume(nullptr);
    Dtool_BoundingBox._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_FiniteBoundingVolume);
    Dtool_BoundingBox._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BoundingBox._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BoundingBox) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BoundingBox)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BoundingBox);
  }
}

/**
 * Python method tables for LFrustumf (LFrustumf)
 */
static PyMethodDef Dtool_Methods_LFrustumf[] = {
  {"make_ortho_2D", (PyCFunction) &Dtool_LFrustumf_make_ortho_2D_651, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumf_make_ortho_2D_651_comment},
  {"makeOrtho2D", (PyCFunction) &Dtool_LFrustumf_make_ortho_2D_651, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumf_make_ortho_2D_651_comment},
  {"make_ortho", (PyCFunction) &Dtool_LFrustumf_make_ortho_652, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumf_make_ortho_652_comment},
  {"makeOrtho", (PyCFunction) &Dtool_LFrustumf_make_ortho_652, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumf_make_ortho_652_comment},
  {"make_perspective_hfov", (PyCFunction) &Dtool_LFrustumf_make_perspective_hfov_653, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumf_make_perspective_hfov_653_comment},
  {"makePerspectiveHfov", (PyCFunction) &Dtool_LFrustumf_make_perspective_hfov_653, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumf_make_perspective_hfov_653_comment},
  {"make_perspective_vfov", (PyCFunction) &Dtool_LFrustumf_make_perspective_vfov_654, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumf_make_perspective_vfov_654_comment},
  {"makePerspectiveVfov", (PyCFunction) &Dtool_LFrustumf_make_perspective_vfov_654, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumf_make_perspective_vfov_654_comment},
  {"make_perspective", (PyCFunction) &Dtool_LFrustumf_make_perspective_655, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumf_make_perspective_655_comment},
  {"makePerspective", (PyCFunction) &Dtool_LFrustumf_make_perspective_655, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumf_make_perspective_655_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LFrustumf = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_LFrustumf = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.LFrustumf",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LFrustumf,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LFrustumf,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LFrustumf,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LFrustumf,
    PyType_GenericAlloc,
    Dtool_new_LFrustumf,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LFrustumf,
  Dtool_UpcastInterface_LFrustumf,
  Dtool_DowncastInterface_LFrustumf,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LFrustumf(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LFrustumf._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LFrustumf._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LFrustumf) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LFrustumf)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LFrustumf);
  }
}

/**
 * Python method tables for LFrustumd (LFrustumd)
 */
static PyMethodDef Dtool_Methods_LFrustumd[] = {
  {"make_ortho_2D", (PyCFunction) &Dtool_LFrustumd_make_ortho_2D_660, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumd_make_ortho_2D_660_comment},
  {"makeOrtho2D", (PyCFunction) &Dtool_LFrustumd_make_ortho_2D_660, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumd_make_ortho_2D_660_comment},
  {"make_ortho", (PyCFunction) &Dtool_LFrustumd_make_ortho_661, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumd_make_ortho_661_comment},
  {"makeOrtho", (PyCFunction) &Dtool_LFrustumd_make_ortho_661, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumd_make_ortho_661_comment},
  {"make_perspective_hfov", (PyCFunction) &Dtool_LFrustumd_make_perspective_hfov_662, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumd_make_perspective_hfov_662_comment},
  {"makePerspectiveHfov", (PyCFunction) &Dtool_LFrustumd_make_perspective_hfov_662, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumd_make_perspective_hfov_662_comment},
  {"make_perspective_vfov", (PyCFunction) &Dtool_LFrustumd_make_perspective_vfov_663, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumd_make_perspective_vfov_663_comment},
  {"makePerspectiveVfov", (PyCFunction) &Dtool_LFrustumd_make_perspective_vfov_663, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumd_make_perspective_vfov_663_comment},
  {"make_perspective", (PyCFunction) &Dtool_LFrustumd_make_perspective_664, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumd_make_perspective_664_comment},
  {"makePerspective", (PyCFunction) &Dtool_LFrustumd_make_perspective_664, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LFrustumd_make_perspective_664_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LFrustumd = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_LFrustumd = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.LFrustumd",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LFrustumd,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LFrustumd,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LFrustumd,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LFrustumd,
    PyType_GenericAlloc,
    Dtool_new_LFrustumd,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LFrustumd,
  Dtool_UpcastInterface_LFrustumd,
  Dtool_DowncastInterface_LFrustumd,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LFrustumd(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LFrustumd._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LFrustumd._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LFrustumd) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LFrustumd)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LFrustumd);
  }
}

/**
 * Python method tables for BoundingHexahedron (BoundingHexahedron)
 */
static PyMethodDef Dtool_Methods_BoundingHexahedron[] = {
  {"get_num_points", &Dtool_BoundingHexahedron_get_num_points_673, METH_NOARGS, (const char *)Dtool_BoundingHexahedron_get_num_points_673_comment},
  {"getNumPoints", &Dtool_BoundingHexahedron_get_num_points_673, METH_NOARGS, (const char *)Dtool_BoundingHexahedron_get_num_points_673_comment},
  {"get_point", &Dtool_BoundingHexahedron_get_point_674, METH_O, (const char *)Dtool_BoundingHexahedron_get_point_674_comment},
  {"getPoint", &Dtool_BoundingHexahedron_get_point_674, METH_O, (const char *)Dtool_BoundingHexahedron_get_point_674_comment},
  {"get_num_planes", &Dtool_BoundingHexahedron_get_num_planes_676, METH_NOARGS, (const char *)Dtool_BoundingHexahedron_get_num_planes_676_comment},
  {"getNumPlanes", &Dtool_BoundingHexahedron_get_num_planes_676, METH_NOARGS, (const char *)Dtool_BoundingHexahedron_get_num_planes_676_comment},
  {"get_plane", &Dtool_BoundingHexahedron_get_plane_677, METH_O, (const char *)Dtool_BoundingHexahedron_get_plane_677_comment},
  {"getPlane", &Dtool_BoundingHexahedron_get_plane_677, METH_O, (const char *)Dtool_BoundingHexahedron_get_plane_677_comment},
  {"get_class_type", &Dtool_BoundingHexahedron_get_class_type_681, METH_NOARGS | METH_STATIC, (const char *)Dtool_BoundingHexahedron_get_class_type_681_comment},
  {"getClassType", &Dtool_BoundingHexahedron_get_class_type_681, METH_NOARGS | METH_STATIC, (const char *)Dtool_BoundingHexahedron_get_class_type_681_comment},
  {"get_points", (PyCFunction) &MakeSeq_BoundingHexahedron_get_points, METH_NOARGS, nullptr},
  { "getPoints", (PyCFunction) &MakeSeq_BoundingHexahedron_get_points, METH_NOARGS, nullptr},
  {"get_planes", (PyCFunction) &MakeSeq_BoundingHexahedron_get_planes, METH_NOARGS, nullptr},
  { "getPlanes", (PyCFunction) &MakeSeq_BoundingHexahedron_get_planes, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_BoundingHexahedron[] = {
  {(char *)"points", &Dtool_BoundingHexahedron_points_Getter, nullptr, nullptr, nullptr},
  {(char *)"planes", &Dtool_BoundingHexahedron_planes_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_BoundingHexahedron = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BoundingHexahedron = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BoundingHexahedron = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BoundingHexahedron = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BoundingHexahedron = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BoundingHexahedron = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.BoundingHexahedron",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BoundingHexahedron,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BoundingHexahedron,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BoundingHexahedron,
    &Dtool_SequenceMethods_BoundingHexahedron,
    &Dtool_MappingMethods_BoundingHexahedron,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BoundingHexahedron,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This defines a bounding convex hexahedron.  It is typically used to\n"
    " * represent a frustum, but may represent any enclosing convex hexahedron,\n"
    " * including simple boxes.  However, if all you want is an axis-aligned\n"
    " * bounding box, you may be better off with the simpler BoundingBox class.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BoundingHexahedron,
    nullptr, // tp_members
    Dtool_Properties_BoundingHexahedron,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BoundingHexahedron,
    PyType_GenericAlloc,
    Dtool_new_BoundingHexahedron,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BoundingHexahedron,
  Dtool_UpcastInterface_BoundingHexahedron,
  Dtool_DowncastInterface_BoundingHexahedron,
  (CoerceFunction)Dtool_ConstCoerce_BoundingHexahedron,
  (CoerceFunction)Dtool_Coerce_BoundingHexahedron,
};

static void Dtool_PyModuleClassInit_BoundingHexahedron(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_FiniteBoundingVolume(nullptr);
    Dtool_BoundingHexahedron._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_FiniteBoundingVolume);
    Dtool_BoundingHexahedron._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BoundingHexahedron._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BoundingHexahedron) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BoundingHexahedron)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BoundingHexahedron);
  }
}

/**
 * Python method tables for BoundingLine (BoundingLine)
 */
static PyMethodDef Dtool_Methods_BoundingLine[] = {
  {"get_point_a", &Dtool_BoundingLine_get_point_a_688, METH_NOARGS, (const char *)Dtool_BoundingLine_get_point_a_688_comment},
  {"getPointA", &Dtool_BoundingLine_get_point_a_688, METH_NOARGS, (const char *)Dtool_BoundingLine_get_point_a_688_comment},
  {"get_point_b", &Dtool_BoundingLine_get_point_b_689, METH_NOARGS, (const char *)Dtool_BoundingLine_get_point_b_689_comment},
  {"getPointB", &Dtool_BoundingLine_get_point_b_689, METH_NOARGS, (const char *)Dtool_BoundingLine_get_point_b_689_comment},
  {"get_class_type", &Dtool_BoundingLine_get_class_type_690, METH_NOARGS | METH_STATIC, (const char *)Dtool_BoundingLine_get_class_type_690_comment},
  {"getClassType", &Dtool_BoundingLine_get_class_type_690, METH_NOARGS | METH_STATIC, (const char *)Dtool_BoundingLine_get_class_type_690_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_BoundingLine = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BoundingLine = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BoundingLine = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BoundingLine = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BoundingLine = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BoundingLine = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.BoundingLine",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BoundingLine,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BoundingLine,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BoundingLine,
    &Dtool_SequenceMethods_BoundingLine,
    &Dtool_MappingMethods_BoundingLine,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BoundingLine,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This funny bounding volume is an infinite line with no thickness and\n"
    " * extending to infinity in both directions.\n"
    " *\n"
    " * Note that it *always* extends in both directions, despite the fact that you\n"
    " * specify two points to the constructor.  These are not endpoints, they are\n"
    " * two arbitrary points on the line.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BoundingLine,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BoundingLine,
    PyType_GenericAlloc,
    Dtool_new_BoundingLine,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BoundingLine,
  Dtool_UpcastInterface_BoundingLine,
  Dtool_DowncastInterface_BoundingLine,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_BoundingLine(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GeometricBoundingVolume(nullptr);
    Dtool_BoundingLine._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GeometricBoundingVolume);
    Dtool_BoundingLine._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BoundingLine._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BoundingLine) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BoundingLine)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BoundingLine);
  }
}

/**
 * Python method tables for BoundingPlane (BoundingPlane)
 */
static PyMethodDef Dtool_Methods_BoundingPlane[] = {
  {"get_plane", &Dtool_BoundingPlane_get_plane_697, METH_NOARGS, (const char *)Dtool_BoundingPlane_get_plane_697_comment},
  {"getPlane", &Dtool_BoundingPlane_get_plane_697, METH_NOARGS, (const char *)Dtool_BoundingPlane_get_plane_697_comment},
  {"get_class_type", &Dtool_BoundingPlane_get_class_type_700, METH_NOARGS | METH_STATIC, (const char *)Dtool_BoundingPlane_get_class_type_700_comment},
  {"getClassType", &Dtool_BoundingPlane_get_class_type_700, METH_NOARGS | METH_STATIC, (const char *)Dtool_BoundingPlane_get_class_type_700_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_BoundingPlane[] = {
  {(char *)"plane", &Dtool_BoundingPlane_plane_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_BoundingPlane = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BoundingPlane = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BoundingPlane = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BoundingPlane = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BoundingPlane = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BoundingPlane = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.BoundingPlane",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BoundingPlane,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BoundingPlane,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BoundingPlane,
    &Dtool_SequenceMethods_BoundingPlane,
    &Dtool_MappingMethods_BoundingPlane,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BoundingPlane,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This funny bounding volume is an infinite plane that divides space into two\n"
    " * regions: the part behind the normal, which is \"inside\" the bounding volume,\n"
    " * and the part in front of the normal, which is \"outside\" the bounding\n"
    " * volume.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BoundingPlane,
    nullptr, // tp_members
    Dtool_Properties_BoundingPlane,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BoundingPlane,
    PyType_GenericAlloc,
    Dtool_new_BoundingPlane,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BoundingPlane,
  Dtool_UpcastInterface_BoundingPlane,
  Dtool_DowncastInterface_BoundingPlane,
  (CoerceFunction)Dtool_ConstCoerce_BoundingPlane,
  (CoerceFunction)Dtool_Coerce_BoundingPlane,
};

static void Dtool_PyModuleClassInit_BoundingPlane(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GeometricBoundingVolume(nullptr);
    Dtool_BoundingPlane._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GeometricBoundingVolume);
    Dtool_BoundingPlane._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BoundingPlane._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BoundingPlane) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BoundingPlane)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BoundingPlane);
  }
}

/**
 * Python method tables for BoundingSphere (BoundingSphere)
 */
static PyMethodDef Dtool_Methods_BoundingSphere[] = {
  {"get_center", &Dtool_BoundingSphere_get_center_707, METH_NOARGS, (const char *)Dtool_BoundingSphere_get_center_707_comment},
  {"getCenter", &Dtool_BoundingSphere_get_center_707, METH_NOARGS, (const char *)Dtool_BoundingSphere_get_center_707_comment},
  {"get_radius", &Dtool_BoundingSphere_get_radius_708, METH_NOARGS, (const char *)Dtool_BoundingSphere_get_radius_708_comment},
  {"getRadius", &Dtool_BoundingSphere_get_radius_708, METH_NOARGS, (const char *)Dtool_BoundingSphere_get_radius_708_comment},
  {"set_center", &Dtool_BoundingSphere_set_center_709, METH_O, (const char *)Dtool_BoundingSphere_set_center_709_comment},
  {"setCenter", &Dtool_BoundingSphere_set_center_709, METH_O, (const char *)Dtool_BoundingSphere_set_center_709_comment},
  {"set_radius", &Dtool_BoundingSphere_set_radius_710, METH_O, (const char *)Dtool_BoundingSphere_set_radius_710_comment},
  {"setRadius", &Dtool_BoundingSphere_set_radius_710, METH_O, (const char *)Dtool_BoundingSphere_set_radius_710_comment},
  {"get_class_type", &Dtool_BoundingSphere_get_class_type_713, METH_NOARGS | METH_STATIC, (const char *)Dtool_BoundingSphere_get_class_type_713_comment},
  {"getClassType", &Dtool_BoundingSphere_get_class_type_713, METH_NOARGS | METH_STATIC, (const char *)Dtool_BoundingSphere_get_class_type_713_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_BoundingSphere[] = {
  {(char *)"center", &Dtool_BoundingSphere_center_Getter, &Dtool_BoundingSphere_center_Setter, nullptr, nullptr},
  {(char *)"radius", &Dtool_BoundingSphere_radius_Getter, &Dtool_BoundingSphere_radius_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_BoundingSphere = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BoundingSphere = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BoundingSphere = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BoundingSphere = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BoundingSphere = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BoundingSphere = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.BoundingSphere",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BoundingSphere,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BoundingSphere,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BoundingSphere,
    &Dtool_SequenceMethods_BoundingSphere,
    &Dtool_MappingMethods_BoundingSphere,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BoundingSphere,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This defines a bounding sphere, consisting of a center and a radius.  It is\n"
    " * always a sphere, and never an ellipsoid or other quadric.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BoundingSphere,
    nullptr, // tp_members
    Dtool_Properties_BoundingSphere,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BoundingSphere,
    PyType_GenericAlloc,
    Dtool_new_BoundingSphere,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BoundingSphere,
  Dtool_UpcastInterface_BoundingSphere,
  Dtool_DowncastInterface_BoundingSphere,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_BoundingSphere(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_FiniteBoundingVolume(nullptr);
    Dtool_BoundingSphere._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_FiniteBoundingVolume);
    Dtool_BoundingSphere._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BoundingSphere._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BoundingSphere) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BoundingSphere)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BoundingSphere);
  }
}

/**
 * Python method tables for IntersectionBoundingVolume (IntersectionBoundingVolume)
 */
static PyMethodDef Dtool_Methods_IntersectionBoundingVolume[] = {
  {"get_num_components", &Dtool_IntersectionBoundingVolume_get_num_components_720, METH_NOARGS, (const char *)Dtool_IntersectionBoundingVolume_get_num_components_720_comment},
  {"getNumComponents", &Dtool_IntersectionBoundingVolume_get_num_components_720, METH_NOARGS, (const char *)Dtool_IntersectionBoundingVolume_get_num_components_720_comment},
  {"get_component", &Dtool_IntersectionBoundingVolume_get_component_721, METH_O, (const char *)Dtool_IntersectionBoundingVolume_get_component_721_comment},
  {"getComponent", &Dtool_IntersectionBoundingVolume_get_component_721, METH_O, (const char *)Dtool_IntersectionBoundingVolume_get_component_721_comment},
  {"clear_components", &Dtool_IntersectionBoundingVolume_clear_components_726, METH_NOARGS, (const char *)Dtool_IntersectionBoundingVolume_clear_components_726_comment},
  {"clearComponents", &Dtool_IntersectionBoundingVolume_clear_components_726, METH_NOARGS, (const char *)Dtool_IntersectionBoundingVolume_clear_components_726_comment},
  {"add_component", &Dtool_IntersectionBoundingVolume_add_component_727, METH_O, (const char *)Dtool_IntersectionBoundingVolume_add_component_727_comment},
  {"addComponent", &Dtool_IntersectionBoundingVolume_add_component_727, METH_O, (const char *)Dtool_IntersectionBoundingVolume_add_component_727_comment},
  {"get_class_type", &Dtool_IntersectionBoundingVolume_get_class_type_728, METH_NOARGS | METH_STATIC, (const char *)Dtool_IntersectionBoundingVolume_get_class_type_728_comment},
  {"getClassType", &Dtool_IntersectionBoundingVolume_get_class_type_728, METH_NOARGS | METH_STATIC, (const char *)Dtool_IntersectionBoundingVolume_get_class_type_728_comment},
  {"get_components", (PyCFunction) &MakeSeq_IntersectionBoundingVolume_get_components, METH_NOARGS, nullptr},
  { "getComponents", (PyCFunction) &MakeSeq_IntersectionBoundingVolume_get_components, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_IntersectionBoundingVolume[] = {
  {(char *)"components", &Dtool_IntersectionBoundingVolume_components_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_IntersectionBoundingVolume = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_IntersectionBoundingVolume = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_IntersectionBoundingVolume = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_IntersectionBoundingVolume = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_IntersectionBoundingVolume = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_IntersectionBoundingVolume = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.IntersectionBoundingVolume",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_IntersectionBoundingVolume,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_IntersectionBoundingVolume,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_IntersectionBoundingVolume,
    &Dtool_SequenceMethods_IntersectionBoundingVolume,
    &Dtool_MappingMethods_IntersectionBoundingVolume,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_IntersectionBoundingVolume,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This special bounding volume is the intersection of all of its constituent\n"
    " * bounding volumes.\n"
    " *\n"
    " * A point is defined to be within an IntersectionBoundingVolume if it is\n"
    " * within all of its component bounding volumes.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_IntersectionBoundingVolume,
    nullptr, // tp_members
    Dtool_Properties_IntersectionBoundingVolume,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_IntersectionBoundingVolume,
    PyType_GenericAlloc,
    Dtool_new_IntersectionBoundingVolume,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_IntersectionBoundingVolume,
  Dtool_UpcastInterface_IntersectionBoundingVolume,
  Dtool_DowncastInterface_IntersectionBoundingVolume,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_IntersectionBoundingVolume(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GeometricBoundingVolume(nullptr);
    Dtool_IntersectionBoundingVolume._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GeometricBoundingVolume);
    Dtool_IntersectionBoundingVolume._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_IntersectionBoundingVolume._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_IntersectionBoundingVolume) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(IntersectionBoundingVolume)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_IntersectionBoundingVolume);
  }
}

/**
 * Python method tables for Mersenne (Mersenne)
 */
static PyMethodDef Dtool_Methods_Mersenne[] = {
  {"get_uint31", &Dtool_Mersenne_get_uint31_734, METH_NOARGS, (const char *)Dtool_Mersenne_get_uint31_734_comment},
  {"getUint31", &Dtool_Mersenne_get_uint31_734, METH_NOARGS, (const char *)Dtool_Mersenne_get_uint31_734_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_Mersenne = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_Mersenne = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Mersenne",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Mersenne,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Mersenne,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Mersenne,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Mersenne,
    PyType_GenericAlloc,
    Dtool_new_Mersenne,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Mersenne,
  Dtool_UpcastInterface_Mersenne,
  Dtool_DowncastInterface_Mersenne,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Mersenne(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_Mersenne._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Mersenne._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum Mersenne::;
    PyDict_SetItemString(dict, "max_value", Dtool_WrapValue(Mersenne::max_value));
    if (PyType_Ready((PyTypeObject *)&Dtool_Mersenne) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Mersenne)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Mersenne);
  }
}

/**
 * Python method tables for OmniBoundingVolume (OmniBoundingVolume)
 */
static PyMethodDef Dtool_Methods_OmniBoundingVolume[] = {
  {"get_class_type", &Dtool_OmniBoundingVolume_get_class_type_739, METH_NOARGS | METH_STATIC, (const char *)Dtool_OmniBoundingVolume_get_class_type_739_comment},
  {"getClassType", &Dtool_OmniBoundingVolume_get_class_type_739, METH_NOARGS | METH_STATIC, (const char *)Dtool_OmniBoundingVolume_get_class_type_739_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OmniBoundingVolume = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OmniBoundingVolume = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OmniBoundingVolume = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OmniBoundingVolume = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OmniBoundingVolume = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OmniBoundingVolume = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.OmniBoundingVolume",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OmniBoundingVolume,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OmniBoundingVolume,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OmniBoundingVolume,
    &Dtool_SequenceMethods_OmniBoundingVolume,
    &Dtool_MappingMethods_OmniBoundingVolume,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OmniBoundingVolume,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a special kind of GeometricBoundingVolume that fills all of space.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OmniBoundingVolume,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OmniBoundingVolume,
    PyType_GenericAlloc,
    Dtool_new_OmniBoundingVolume,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OmniBoundingVolume,
  Dtool_UpcastInterface_OmniBoundingVolume,
  Dtool_DowncastInterface_OmniBoundingVolume,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OmniBoundingVolume(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GeometricBoundingVolume(nullptr);
    Dtool_OmniBoundingVolume._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GeometricBoundingVolume);
    Dtool_OmniBoundingVolume._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OmniBoundingVolume._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OmniBoundingVolume) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OmniBoundingVolume)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OmniBoundingVolume);
  }
}

/**
 * Python method tables for UnionBoundingVolume (UnionBoundingVolume)
 */
static PyMethodDef Dtool_Methods_UnionBoundingVolume[] = {
  {"get_num_components", &Dtool_UnionBoundingVolume_get_num_components_746, METH_NOARGS, (const char *)Dtool_UnionBoundingVolume_get_num_components_746_comment},
  {"getNumComponents", &Dtool_UnionBoundingVolume_get_num_components_746, METH_NOARGS, (const char *)Dtool_UnionBoundingVolume_get_num_components_746_comment},
  {"get_component", &Dtool_UnionBoundingVolume_get_component_747, METH_O, (const char *)Dtool_UnionBoundingVolume_get_component_747_comment},
  {"getComponent", &Dtool_UnionBoundingVolume_get_component_747, METH_O, (const char *)Dtool_UnionBoundingVolume_get_component_747_comment},
  {"clear_components", &Dtool_UnionBoundingVolume_clear_components_750, METH_NOARGS, (const char *)Dtool_UnionBoundingVolume_clear_components_750_comment},
  {"clearComponents", &Dtool_UnionBoundingVolume_clear_components_750, METH_NOARGS, (const char *)Dtool_UnionBoundingVolume_clear_components_750_comment},
  {"add_component", &Dtool_UnionBoundingVolume_add_component_751, METH_O, (const char *)Dtool_UnionBoundingVolume_add_component_751_comment},
  {"addComponent", &Dtool_UnionBoundingVolume_add_component_751, METH_O, (const char *)Dtool_UnionBoundingVolume_add_component_751_comment},
  {"filter_intersection", &Dtool_UnionBoundingVolume_filter_intersection_752, METH_O, (const char *)Dtool_UnionBoundingVolume_filter_intersection_752_comment},
  {"filterIntersection", &Dtool_UnionBoundingVolume_filter_intersection_752, METH_O, (const char *)Dtool_UnionBoundingVolume_filter_intersection_752_comment},
  {"get_class_type", &Dtool_UnionBoundingVolume_get_class_type_753, METH_NOARGS | METH_STATIC, (const char *)Dtool_UnionBoundingVolume_get_class_type_753_comment},
  {"getClassType", &Dtool_UnionBoundingVolume_get_class_type_753, METH_NOARGS | METH_STATIC, (const char *)Dtool_UnionBoundingVolume_get_class_type_753_comment},
  {"get_components", (PyCFunction) &MakeSeq_UnionBoundingVolume_get_components, METH_NOARGS, nullptr},
  { "getComponents", (PyCFunction) &MakeSeq_UnionBoundingVolume_get_components, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_UnionBoundingVolume[] = {
  {(char *)"components", &Dtool_UnionBoundingVolume_components_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_UnionBoundingVolume = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_UnionBoundingVolume = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_UnionBoundingVolume = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_UnionBoundingVolume = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_UnionBoundingVolume = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_UnionBoundingVolume = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.UnionBoundingVolume",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_UnionBoundingVolume,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_UnionBoundingVolume,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_UnionBoundingVolume,
    &Dtool_SequenceMethods_UnionBoundingVolume,
    &Dtool_MappingMethods_UnionBoundingVolume,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_UnionBoundingVolume,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This special bounding volume is the union of all of its constituent\n"
    " * bounding volumes.\n"
    " *\n"
    " * A point is defined to be within a UnionBoundingVolume if it is within any\n"
    " * one or more of its component bounding volumes.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_UnionBoundingVolume,
    nullptr, // tp_members
    Dtool_Properties_UnionBoundingVolume,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_UnionBoundingVolume,
    PyType_GenericAlloc,
    Dtool_new_UnionBoundingVolume,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_UnionBoundingVolume,
  Dtool_UpcastInterface_UnionBoundingVolume,
  Dtool_DowncastInterface_UnionBoundingVolume,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_UnionBoundingVolume(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GeometricBoundingVolume(nullptr);
    Dtool_UnionBoundingVolume._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GeometricBoundingVolume);
    Dtool_UnionBoundingVolume._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_UnionBoundingVolume._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_UnionBoundingVolume) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(UnionBoundingVolume)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_UnionBoundingVolume);
  }
}

/**
 * Python method tables for Randomizer (Randomizer)
 */
static PyMethodDef Dtool_Methods_Randomizer[] = {
  {"assign", &Dtool_Randomizer_operator_757, METH_O, (const char *)Dtool_Randomizer_operator_757_comment},
  {"random_int", &Dtool_Randomizer_random_int_758, METH_O, (const char *)Dtool_Randomizer_random_int_758_comment},
  {"randomInt", &Dtool_Randomizer_random_int_758, METH_O, (const char *)Dtool_Randomizer_random_int_758_comment},
  {"random_real", &Dtool_Randomizer_random_real_759, METH_O, (const char *)Dtool_Randomizer_random_real_759_comment},
  {"randomReal", &Dtool_Randomizer_random_real_759, METH_O, (const char *)Dtool_Randomizer_random_real_759_comment},
  {"random_real_unit", &Dtool_Randomizer_random_real_unit_760, METH_NOARGS, (const char *)Dtool_Randomizer_random_real_unit_760_comment},
  {"randomRealUnit", &Dtool_Randomizer_random_real_unit_760, METH_NOARGS, (const char *)Dtool_Randomizer_random_real_unit_760_comment},
  {"get_next_seed", &Dtool_Randomizer_get_next_seed_761, METH_NOARGS | METH_STATIC, (const char *)Dtool_Randomizer_get_next_seed_761_comment},
  {"getNextSeed", &Dtool_Randomizer_get_next_seed_761, METH_NOARGS | METH_STATIC, (const char *)Dtool_Randomizer_get_next_seed_761_comment},
  {"get_seed", &Dtool_Randomizer_get_seed_762, METH_NOARGS, (const char *)Dtool_Randomizer_get_seed_762_comment},
  {"getSeed", &Dtool_Randomizer_get_seed_762, METH_NOARGS, (const char *)Dtool_Randomizer_get_seed_762_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_Randomizer = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_Randomizer = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Randomizer",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Randomizer,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Randomizer,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A handy class to return random numbers.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Randomizer,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Randomizer,
    PyType_GenericAlloc,
    Dtool_new_Randomizer,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Randomizer,
  Dtool_UpcastInterface_Randomizer,
  Dtool_DowncastInterface_Randomizer,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Randomizer(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_Randomizer._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Randomizer._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Randomizer) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Randomizer)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Randomizer);
  }
}

/**
 * Python method tables for PerlinNoise (PerlinNoise)
 */
static PyMethodDef Dtool_Methods_PerlinNoise[] = {
  {"get_seed", &Dtool_PerlinNoise_get_seed_765, METH_NOARGS, (const char *)Dtool_PerlinNoise_get_seed_765_comment},
  {"getSeed", &Dtool_PerlinNoise_get_seed_765, METH_NOARGS, (const char *)Dtool_PerlinNoise_get_seed_765_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PerlinNoise = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_PerlinNoise = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PerlinNoise",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PerlinNoise,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PerlinNoise,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base class for PerlinNoise2 and PerlinNoise3, different\n"
    " * dimensions of Perlin noise implementation.  The base class just collects\n"
    " * the common functionality.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PerlinNoise,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PerlinNoise,
    PyType_GenericAlloc,
    Dtool_new_PerlinNoise,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PerlinNoise,
  Dtool_UpcastInterface_PerlinNoise,
  Dtool_DowncastInterface_PerlinNoise,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PerlinNoise(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PerlinNoise._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PerlinNoise._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PerlinNoise) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PerlinNoise)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PerlinNoise);
  }
}

/**
 * Python method tables for PerlinNoise2 (PerlinNoise2)
 */
static PyMethodDef Dtool_Methods_PerlinNoise2[] = {
  {"assign", &Dtool_PerlinNoise2_operator_769, METH_O, (const char *)Dtool_PerlinNoise2_operator_769_comment},
  {"set_scale", (PyCFunction) &Dtool_PerlinNoise2_set_scale_770, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PerlinNoise2_set_scale_770_comment},
  {"setScale", (PyCFunction) &Dtool_PerlinNoise2_set_scale_770, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PerlinNoise2_set_scale_770_comment},
  {"noise", (PyCFunction) &Dtool_PerlinNoise2_noise_771, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PerlinNoise2_noise_771_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

/**
 * Python function wrapper for:
 * inline double PerlinNoise2::operator ()(LVecBase2d const &value) const
 * inline float PerlinNoise2::operator ()(LVecBase2f const &value) const
 * inline double PerlinNoise2::operator ()(double x, double y) const
 */
static PyObject *Dtool_PerlinNoise2_operator_772(PyObject *self, PyObject *args, PyObject *kwds)
 {
  PerlinNoise2 *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PerlinNoise2)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "value")) {
        {
          // -2 inline double PerlinNoise2::operator ()(LVecBase2d const &value) const
          LVecBase2d const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase2d);
          if (arg_this != nullptr) {
            double return_value = ((*(const PerlinNoise2*)local_this).operator ())(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

        {
          // -2 inline float PerlinNoise2::operator ()(LVecBase2f const &value) const
          LVecBase2f const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase2f);
          if (arg_this != nullptr) {
            float return_value = ((*(const PerlinNoise2*)local_this).operator ())(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

        {
          // -2 inline double PerlinNoise2::operator ()(LVecBase2d const &value) const
          LVecBase2d arg_local;
          LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
          if ((arg_this != nullptr)) {
            double return_value = ((*(const PerlinNoise2*)local_this).operator ())(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

        {
          // -2 inline float PerlinNoise2::operator ()(LVecBase2f const &value) const
          LVecBase2f arg_local;
          LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
          if ((arg_this != nullptr)) {
            float return_value = ((*(const PerlinNoise2*)local_this).operator ())(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

      }
    }
    break;
  case 2:
    {
      // 1-inline double PerlinNoise2::operator ()(double x, double y) const
      double param1;
      double param2;
      static const char *keyword_list[] = {"x", "y", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:__call__", (char **)keyword_list, &param1, &param2)) {
        double return_value = ((*(const PerlinNoise2*)local_this).operator ())((double)param1, (double)param2);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "__call__() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__call__(PerlinNoise2 self, const LVecBase2d value)\n"
      "__call__(PerlinNoise2 self, const LVecBase2f value)\n"
      "__call__(PerlinNoise2 self, double x, double y)\n");
  }
  return nullptr;
}

static PyNumberMethods Dtool_NumberMethods_PerlinNoise2 = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PerlinNoise2 = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PerlinNoise2 = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PerlinNoise2 = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PerlinNoise2 = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PerlinNoise2 = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PerlinNoise2",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PerlinNoise2,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PerlinNoise2,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PerlinNoise2,
    &Dtool_SequenceMethods_PerlinNoise2,
    &Dtool_MappingMethods_PerlinNoise2,
    nullptr, // tp_hash
    &Dtool_PerlinNoise2_operator_772,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PerlinNoise2,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class provides an implementation of Perlin noise for 2 variables.\n"
    " * This code is loosely based on the reference implementation at\n"
    " * https://mrl.nyu.edu/~perlin/noise/ .\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PerlinNoise2,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PerlinNoise2,
    PyType_GenericAlloc,
    Dtool_new_PerlinNoise2,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PerlinNoise2,
  Dtool_UpcastInterface_PerlinNoise2,
  Dtool_DowncastInterface_PerlinNoise2,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PerlinNoise2(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PerlinNoise(nullptr);
    Dtool_PerlinNoise2._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PerlinNoise);
    Dtool_PerlinNoise2._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PerlinNoise2._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PerlinNoise2) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PerlinNoise2)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PerlinNoise2);
  }
}

/**
 * Python method tables for PerlinNoise3 (PerlinNoise3)
 */
static PyMethodDef Dtool_Methods_PerlinNoise3[] = {
  {"assign", &Dtool_PerlinNoise3_operator_776, METH_O, (const char *)Dtool_PerlinNoise3_operator_776_comment},
  {"set_scale", (PyCFunction) &Dtool_PerlinNoise3_set_scale_777, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PerlinNoise3_set_scale_777_comment},
  {"setScale", (PyCFunction) &Dtool_PerlinNoise3_set_scale_777, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PerlinNoise3_set_scale_777_comment},
  {"noise", (PyCFunction) &Dtool_PerlinNoise3_noise_778, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PerlinNoise3_noise_778_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

/**
 * Python function wrapper for:
 * inline double PerlinNoise3::operator ()(LVecBase3d const &value) const
 * inline float PerlinNoise3::operator ()(LVecBase3f const &value) const
 * inline double PerlinNoise3::operator ()(double x, double y, double z) const
 */
static PyObject *Dtool_PerlinNoise3_operator_779(PyObject *self, PyObject *args, PyObject *kwds)
 {
  PerlinNoise3 *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PerlinNoise3)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "value")) {
        {
          // -2 inline double PerlinNoise3::operator ()(LVecBase3d const &value) const
          LVecBase3d const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase3d);
          if (arg_this != nullptr) {
            double return_value = ((*(const PerlinNoise3*)local_this).operator ())(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

        {
          // -2 inline float PerlinNoise3::operator ()(LVecBase3f const &value) const
          LVecBase3f const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase3f);
          if (arg_this != nullptr) {
            float return_value = ((*(const PerlinNoise3*)local_this).operator ())(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

        {
          // -2 inline double PerlinNoise3::operator ()(LVecBase3d const &value) const
          LVecBase3d arg_local;
          LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
          if ((arg_this != nullptr)) {
            double return_value = ((*(const PerlinNoise3*)local_this).operator ())(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

        {
          // -2 inline float PerlinNoise3::operator ()(LVecBase3f const &value) const
          LVecBase3f arg_local;
          LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
          if ((arg_this != nullptr)) {
            float return_value = ((*(const PerlinNoise3*)local_this).operator ())(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

      }
    }
    break;
  case 3:
    {
      // 1-inline double PerlinNoise3::operator ()(double x, double y, double z) const
      double param1;
      double param2;
      double param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ddd:__call__", (char **)keyword_list, &param1, &param2, &param3)) {
        double return_value = ((*(const PerlinNoise3*)local_this).operator ())((double)param1, (double)param2, (double)param3);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "__call__() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__call__(PerlinNoise3 self, const LVecBase3d value)\n"
      "__call__(PerlinNoise3 self, const LVecBase3f value)\n"
      "__call__(PerlinNoise3 self, double x, double y, double z)\n");
  }
  return nullptr;
}

static PyNumberMethods Dtool_NumberMethods_PerlinNoise3 = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PerlinNoise3 = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PerlinNoise3 = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PerlinNoise3 = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PerlinNoise3 = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PerlinNoise3 = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PerlinNoise3",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PerlinNoise3,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PerlinNoise3,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PerlinNoise3,
    &Dtool_SequenceMethods_PerlinNoise3,
    &Dtool_MappingMethods_PerlinNoise3,
    nullptr, // tp_hash
    &Dtool_PerlinNoise3_operator_779,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PerlinNoise3,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class provides an implementation of Perlin noise for 3 variables.\n"
    " * This code is loosely based on the reference implementation at\n"
    " * http://mrl.nyu.edu/~perlin/noise/ .\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PerlinNoise3,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PerlinNoise3,
    PyType_GenericAlloc,
    Dtool_new_PerlinNoise3,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PerlinNoise3,
  Dtool_UpcastInterface_PerlinNoise3,
  Dtool_DowncastInterface_PerlinNoise3,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PerlinNoise3(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PerlinNoise(nullptr);
    Dtool_PerlinNoise3._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PerlinNoise);
    Dtool_PerlinNoise3._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PerlinNoise3._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PerlinNoise3) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PerlinNoise3)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PerlinNoise3);
  }
}

/**
 * Python method tables for StackedPerlinNoise2 (StackedPerlinNoise2)
 */
static PyMethodDef Dtool_Methods_StackedPerlinNoise2[] = {
  {"assign", &Dtool_StackedPerlinNoise2_operator_840, METH_O, (const char *)Dtool_StackedPerlinNoise2_operator_840_comment},
  {"add_level", (PyCFunction) &Dtool_StackedPerlinNoise2_add_level_841, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_StackedPerlinNoise2_add_level_841_comment},
  {"addLevel", (PyCFunction) &Dtool_StackedPerlinNoise2_add_level_841, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_StackedPerlinNoise2_add_level_841_comment},
  {"clear", &Dtool_StackedPerlinNoise2_clear_842, METH_NOARGS, (const char *)Dtool_StackedPerlinNoise2_clear_842_comment},
  {"noise", (PyCFunction) &Dtool_StackedPerlinNoise2_noise_843, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_StackedPerlinNoise2_noise_843_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

/**
 * Python function wrapper for:
 * inline double StackedPerlinNoise2::operator ()(LVecBase2d const &value)
 * inline float StackedPerlinNoise2::operator ()(LVecBase2f const &value)
 * inline double StackedPerlinNoise2::operator ()(double x, double y)
 */
static PyObject *Dtool_StackedPerlinNoise2_operator_844(PyObject *self, PyObject *args, PyObject *kwds)
 {
  StackedPerlinNoise2 *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StackedPerlinNoise2, (void **)&local_this, "StackedPerlinNoise2.__call__")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "value")) {
        {
          // -2 inline double StackedPerlinNoise2::operator ()(LVecBase2d const &value)
          LVecBase2d const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase2d);
          if (arg_this != nullptr) {
            double return_value = ((*local_this).operator ())(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

        {
          // -2 inline float StackedPerlinNoise2::operator ()(LVecBase2f const &value)
          LVecBase2f const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase2f);
          if (arg_this != nullptr) {
            float return_value = ((*local_this).operator ())(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

        {
          // -2 inline double StackedPerlinNoise2::operator ()(LVecBase2d const &value)
          LVecBase2d arg_local;
          LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
          if ((arg_this != nullptr)) {
            double return_value = ((*local_this).operator ())(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

        {
          // -2 inline float StackedPerlinNoise2::operator ()(LVecBase2f const &value)
          LVecBase2f arg_local;
          LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
          if ((arg_this != nullptr)) {
            float return_value = ((*local_this).operator ())(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

      }
    }
    break;
  case 2:
    {
      // 1-inline double StackedPerlinNoise2::operator ()(double x, double y)
      double param1;
      double param2;
      static const char *keyword_list[] = {"x", "y", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:__call__", (char **)keyword_list, &param1, &param2)) {
        double return_value = ((*local_this).operator ())((double)param1, (double)param2);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "__call__() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__call__(const StackedPerlinNoise2 self, const LVecBase2d value)\n"
      "__call__(const StackedPerlinNoise2 self, const LVecBase2f value)\n"
      "__call__(const StackedPerlinNoise2 self, double x, double y)\n");
  }
  return nullptr;
}

static PyNumberMethods Dtool_NumberMethods_StackedPerlinNoise2 = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_StackedPerlinNoise2 = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.StackedPerlinNoise2",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_StackedPerlinNoise2,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_StackedPerlinNoise2,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    &Dtool_StackedPerlinNoise2_operator_844,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Implements a multi-layer PerlinNoise, with one or more high-frequency noise\n"
    " * functions added to a lower-frequency base noise function.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_StackedPerlinNoise2,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_StackedPerlinNoise2,
    PyType_GenericAlloc,
    Dtool_new_StackedPerlinNoise2,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_StackedPerlinNoise2,
  Dtool_UpcastInterface_StackedPerlinNoise2,
  Dtool_DowncastInterface_StackedPerlinNoise2,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_StackedPerlinNoise2(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_StackedPerlinNoise2._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_StackedPerlinNoise2._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_StackedPerlinNoise2) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(StackedPerlinNoise2)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_StackedPerlinNoise2);
  }
}

/**
 * Python method tables for StackedPerlinNoise3 (StackedPerlinNoise3)
 */
static PyMethodDef Dtool_Methods_StackedPerlinNoise3[] = {
  {"assign", &Dtool_StackedPerlinNoise3_operator_848, METH_O, (const char *)Dtool_StackedPerlinNoise3_operator_848_comment},
  {"add_level", (PyCFunction) &Dtool_StackedPerlinNoise3_add_level_849, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_StackedPerlinNoise3_add_level_849_comment},
  {"addLevel", (PyCFunction) &Dtool_StackedPerlinNoise3_add_level_849, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_StackedPerlinNoise3_add_level_849_comment},
  {"clear", &Dtool_StackedPerlinNoise3_clear_850, METH_NOARGS, (const char *)Dtool_StackedPerlinNoise3_clear_850_comment},
  {"noise", (PyCFunction) &Dtool_StackedPerlinNoise3_noise_851, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_StackedPerlinNoise3_noise_851_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

/**
 * Python function wrapper for:
 * inline double StackedPerlinNoise3::operator ()(LVecBase3d const &value)
 * inline float StackedPerlinNoise3::operator ()(LVecBase3f const &value)
 * inline double StackedPerlinNoise3::operator ()(double x, double y, double z)
 */
static PyObject *Dtool_StackedPerlinNoise3_operator_852(PyObject *self, PyObject *args, PyObject *kwds)
 {
  StackedPerlinNoise3 *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StackedPerlinNoise3, (void **)&local_this, "StackedPerlinNoise3.__call__")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "value")) {
        {
          // -2 inline double StackedPerlinNoise3::operator ()(LVecBase3d const &value)
          LVecBase3d const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase3d);
          if (arg_this != nullptr) {
            double return_value = ((*local_this).operator ())(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

        {
          // -2 inline float StackedPerlinNoise3::operator ()(LVecBase3f const &value)
          LVecBase3f const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase3f);
          if (arg_this != nullptr) {
            float return_value = ((*local_this).operator ())(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

        {
          // -2 inline double StackedPerlinNoise3::operator ()(LVecBase3d const &value)
          LVecBase3d arg_local;
          LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
          if ((arg_this != nullptr)) {
            double return_value = ((*local_this).operator ())(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

        {
          // -2 inline float StackedPerlinNoise3::operator ()(LVecBase3f const &value)
          LVecBase3f arg_local;
          LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
          if ((arg_this != nullptr)) {
            float return_value = ((*local_this).operator ())(*arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return Dtool_WrapValue(return_value);
          }
        }

      }
    }
    break;
  case 3:
    {
      // 1-inline double StackedPerlinNoise3::operator ()(double x, double y, double z)
      double param1;
      double param2;
      double param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ddd:__call__", (char **)keyword_list, &param1, &param2, &param3)) {
        double return_value = ((*local_this).operator ())((double)param1, (double)param2, (double)param3);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "__call__() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__call__(const StackedPerlinNoise3 self, const LVecBase3d value)\n"
      "__call__(const StackedPerlinNoise3 self, const LVecBase3f value)\n"
      "__call__(const StackedPerlinNoise3 self, double x, double y, double z)\n");
  }
  return nullptr;
}

static PyNumberMethods Dtool_NumberMethods_StackedPerlinNoise3 = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_StackedPerlinNoise3 = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.StackedPerlinNoise3",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_StackedPerlinNoise3,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_StackedPerlinNoise3,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    &Dtool_StackedPerlinNoise3_operator_852,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Implements a multi-layer PerlinNoise, with one or more high-frequency noise\n"
    " * functions added to a lower-frequency base noise function.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_StackedPerlinNoise3,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_StackedPerlinNoise3,
    PyType_GenericAlloc,
    Dtool_new_StackedPerlinNoise3,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_StackedPerlinNoise3,
  Dtool_UpcastInterface_StackedPerlinNoise3,
  Dtool_DowncastInterface_StackedPerlinNoise3,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_StackedPerlinNoise3(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_StackedPerlinNoise3._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_StackedPerlinNoise3._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_StackedPerlinNoise3) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(StackedPerlinNoise3)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_StackedPerlinNoise3);
  }
}

/**
 * Python method tables for Triangulator (Triangulator)
 */
static PyMethodDef Dtool_Methods_Triangulator[] = {
  {"clear", &Dtool_Triangulator_clear_856, METH_NOARGS, (const char *)Dtool_Triangulator_clear_856_comment},
  {"add_vertex", (PyCFunction) &Dtool_Triangulator_add_vertex_857, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Triangulator_add_vertex_857_comment},
  {"addVertex", (PyCFunction) &Dtool_Triangulator_add_vertex_857, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Triangulator_add_vertex_857_comment},
  {"get_num_vertices", &Dtool_Triangulator_get_num_vertices_858, METH_NOARGS, (const char *)Dtool_Triangulator_get_num_vertices_858_comment},
  {"getNumVertices", &Dtool_Triangulator_get_num_vertices_858, METH_NOARGS, (const char *)Dtool_Triangulator_get_num_vertices_858_comment},
  {"get_vertex", &Dtool_Triangulator_get_vertex_859, METH_O, (const char *)Dtool_Triangulator_get_vertex_859_comment},
  {"getVertex", &Dtool_Triangulator_get_vertex_859, METH_O, (const char *)Dtool_Triangulator_get_vertex_859_comment},
  {"clear_polygon", &Dtool_Triangulator_clear_polygon_864, METH_NOARGS, (const char *)Dtool_Triangulator_clear_polygon_864_comment},
  {"clearPolygon", &Dtool_Triangulator_clear_polygon_864, METH_NOARGS, (const char *)Dtool_Triangulator_clear_polygon_864_comment},
  {"add_polygon_vertex", &Dtool_Triangulator_add_polygon_vertex_865, METH_O, (const char *)Dtool_Triangulator_add_polygon_vertex_865_comment},
  {"addPolygonVertex", &Dtool_Triangulator_add_polygon_vertex_865, METH_O, (const char *)Dtool_Triangulator_add_polygon_vertex_865_comment},
  {"is_left_winding", &Dtool_Triangulator_is_left_winding_866, METH_NOARGS, (const char *)Dtool_Triangulator_is_left_winding_866_comment},
  {"isLeftWinding", &Dtool_Triangulator_is_left_winding_866, METH_NOARGS, (const char *)Dtool_Triangulator_is_left_winding_866_comment},
  {"begin_hole", &Dtool_Triangulator_begin_hole_867, METH_NOARGS, (const char *)Dtool_Triangulator_begin_hole_867_comment},
  {"beginHole", &Dtool_Triangulator_begin_hole_867, METH_NOARGS, (const char *)Dtool_Triangulator_begin_hole_867_comment},
  {"add_hole_vertex", &Dtool_Triangulator_add_hole_vertex_868, METH_O, (const char *)Dtool_Triangulator_add_hole_vertex_868_comment},
  {"addHoleVertex", &Dtool_Triangulator_add_hole_vertex_868, METH_O, (const char *)Dtool_Triangulator_add_hole_vertex_868_comment},
  {"triangulate", &Dtool_Triangulator_triangulate_869, METH_NOARGS, (const char *)Dtool_Triangulator_triangulate_869_comment},
  {"get_num_triangles", &Dtool_Triangulator_get_num_triangles_870, METH_NOARGS, (const char *)Dtool_Triangulator_get_num_triangles_870_comment},
  {"getNumTriangles", &Dtool_Triangulator_get_num_triangles_870, METH_NOARGS, (const char *)Dtool_Triangulator_get_num_triangles_870_comment},
  {"get_triangle_v0", &Dtool_Triangulator_get_triangle_v0_871, METH_O, (const char *)Dtool_Triangulator_get_triangle_v0_871_comment},
  {"getTriangleV0", &Dtool_Triangulator_get_triangle_v0_871, METH_O, (const char *)Dtool_Triangulator_get_triangle_v0_871_comment},
  {"get_triangle_v1", &Dtool_Triangulator_get_triangle_v1_872, METH_O, (const char *)Dtool_Triangulator_get_triangle_v1_872_comment},
  {"getTriangleV1", &Dtool_Triangulator_get_triangle_v1_872, METH_O, (const char *)Dtool_Triangulator_get_triangle_v1_872_comment},
  {"get_triangle_v2", &Dtool_Triangulator_get_triangle_v2_873, METH_O, (const char *)Dtool_Triangulator_get_triangle_v2_873_comment},
  {"getTriangleV2", &Dtool_Triangulator_get_triangle_v2_873, METH_O, (const char *)Dtool_Triangulator_get_triangle_v2_873_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_vertices", (PyCFunction) &MakeSeq_Triangulator_get_vertices, METH_NOARGS, nullptr},
  { "getVertices", (PyCFunction) &MakeSeq_Triangulator_get_vertices, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_Triangulator[] = {
  {(char *)"vertices", &Dtool_Triangulator_vertices_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_Triangulator = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_Triangulator = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Triangulator",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Triangulator,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Triangulator,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class can triangulate a convex or concave polygon, even one with\n"
    " * holes.  It is adapted from an algorithm published as:\n"
    " *\n"
    " * Narkhede A. and Manocha D., Fast polygon triangulation algorithm based on\n"
    " * Seidel's Algorithm, UNC-CH, 1994.\n"
    " *\n"
    " * http://www.cs.unc.edu/~dm/CODE/GEM/chapter.html\n"
    " *\n"
    " * It works strictly on 2-d points.  See Triangulator3 for 3-d points.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Triangulator,
    nullptr, // tp_members
    Dtool_Properties_Triangulator,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Triangulator,
    PyType_GenericAlloc,
    Dtool_new_Triangulator,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Triangulator,
  Dtool_UpcastInterface_Triangulator,
  Dtool_DowncastInterface_Triangulator,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Triangulator(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_Triangulator._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Triangulator._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Triangulator) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Triangulator)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Triangulator);
  }
}

/**
 * Python method tables for Triangulator3 (Triangulator3)
 */
static PyMethodDef Dtool_Methods_Triangulator3[] = {
  {"clear", &Dtool_Triangulator3_clear_877, METH_NOARGS, (const char *)Dtool_Triangulator3_clear_877_comment},
  {"add_vertex", (PyCFunction) &Dtool_Triangulator3_add_vertex_878, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Triangulator3_add_vertex_878_comment},
  {"addVertex", (PyCFunction) &Dtool_Triangulator3_add_vertex_878, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Triangulator3_add_vertex_878_comment},
  {"get_num_vertices", &Dtool_Triangulator3_get_num_vertices_879, METH_NOARGS, (const char *)Dtool_Triangulator3_get_num_vertices_879_comment},
  {"getNumVertices", &Dtool_Triangulator3_get_num_vertices_879, METH_NOARGS, (const char *)Dtool_Triangulator3_get_num_vertices_879_comment},
  {"get_vertex", &Dtool_Triangulator3_get_vertex_880, METH_O, (const char *)Dtool_Triangulator3_get_vertex_880_comment},
  {"getVertex", &Dtool_Triangulator3_get_vertex_880, METH_O, (const char *)Dtool_Triangulator3_get_vertex_880_comment},
  {"triangulate", &Dtool_Triangulator3_triangulate_882, METH_NOARGS, (const char *)Dtool_Triangulator3_triangulate_882_comment},
  {"get_plane", &Dtool_Triangulator3_get_plane_883, METH_NOARGS, (const char *)Dtool_Triangulator3_get_plane_883_comment},
  {"getPlane", &Dtool_Triangulator3_get_plane_883, METH_NOARGS, (const char *)Dtool_Triangulator3_get_plane_883_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_vertices", (PyCFunction) &MakeSeq_Triangulator3_get_vertices, METH_NOARGS, nullptr},
  { "getVertices", (PyCFunction) &MakeSeq_Triangulator3_get_vertices, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_Triangulator3[] = {
  {(char *)"vertices", &Dtool_Triangulator3_vertices_Getter, nullptr, nullptr, nullptr},
  {(char *)"plane", &Dtool_Triangulator3_plane_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_Triangulator3 = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Triangulator3 = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Triangulator3 = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Triangulator3 = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Triangulator3 = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Triangulator3 = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Triangulator3",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Triangulator3,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Triangulator3,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Triangulator3,
    &Dtool_SequenceMethods_Triangulator3,
    &Dtool_MappingMethods_Triangulator3,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Triangulator3,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is an extension of Triangulator to handle polygons with three-\n"
    " * dimensional points.  It assumes all of the points lie in a single plane,\n"
    " * and internally projects the supplied points into 2-D for passing to the\n"
    " * underlying Triangulator object.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Triangulator3,
    nullptr, // tp_members
    Dtool_Properties_Triangulator3,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Triangulator3,
    PyType_GenericAlloc,
    Dtool_new_Triangulator3,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Triangulator3,
  Dtool_UpcastInterface_Triangulator3,
  Dtool_DowncastInterface_Triangulator3,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Triangulator3(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_Triangulator(nullptr);
    Dtool_Triangulator3._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_Triangulator);
    Dtool_Triangulator3._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Triangulator3._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Triangulator3) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Triangulator3)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Triangulator3);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3mathutil_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    BoundingVolume::init_type();
    TypeHandle handle = BoundingVolume::get_class_type();
    Dtool_BoundingVolume._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BoundingVolume);
  }
  {
    GeometricBoundingVolume::init_type();
    TypeHandle handle = GeometricBoundingVolume::get_class_type();
    Dtool_GeometricBoundingVolume._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GeometricBoundingVolume);
  }
  {
    FiniteBoundingVolume::init_type();
    TypeHandle handle = FiniteBoundingVolume::get_class_type();
    Dtool_FiniteBoundingVolume._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_FiniteBoundingVolume);
  }
  {
    BoundingBox::init_type();
    TypeHandle handle = BoundingBox::get_class_type();
    Dtool_BoundingBox._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BoundingBox);
  }
  {
    BoundingHexahedron::init_type();
    TypeHandle handle = BoundingHexahedron::get_class_type();
    Dtool_BoundingHexahedron._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BoundingHexahedron);
  }
  {
    BoundingLine::init_type();
    TypeHandle handle = BoundingLine::get_class_type();
    Dtool_BoundingLine._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BoundingLine);
  }
  {
    BoundingPlane::init_type();
    TypeHandle handle = BoundingPlane::get_class_type();
    Dtool_BoundingPlane._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BoundingPlane);
  }
  {
    BoundingSphere::init_type();
    TypeHandle handle = BoundingSphere::get_class_type();
    Dtool_BoundingSphere._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BoundingSphere);
  }
  {
    IntersectionBoundingVolume::init_type();
    TypeHandle handle = IntersectionBoundingVolume::get_class_type();
    Dtool_IntersectionBoundingVolume._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_IntersectionBoundingVolume);
  }
  {
    OmniBoundingVolume::init_type();
    TypeHandle handle = OmniBoundingVolume::get_class_type();
    Dtool_OmniBoundingVolume._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OmniBoundingVolume);
  }
  {
    UnionBoundingVolume::init_type();
    TypeHandle handle = UnionBoundingVolume::get_class_type();
    Dtool_UnionBoundingVolume._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_UnionBoundingVolume);
  }
}

void Dtool_libp3mathutil_BuildInstants(PyObject *module) {
  (void) module;
  // ConstPointerToArray< LMatrix3d >
  Dtool_PyModuleClassInit_ConstPointerToArray_LMatrix3d(module);
  PyModule_AddObject(module, "ConstPointerToArray_LMatrix3d", (PyObject *)&Dtool_ConstPointerToArray_LMatrix3d);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LMatrix3d);
  PyModule_AddObject(module, "ConstPointerToArrayLMatrix3d", (PyObject *)&Dtool_ConstPointerToArray_LMatrix3d);
  // PointerToArrayBase< LMatrix3d >
  Dtool_PyModuleClassInit_PointerToArrayBase_LMatrix3d(module);
  PyModule_AddObject(module, "PointerToArrayBase_LMatrix3d", (PyObject *)&Dtool_PointerToArrayBase_LMatrix3d);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_LMatrix3d);
  PyModule_AddObject(module, "PointerToArrayBaseLMatrix3d", (PyObject *)&Dtool_PointerToArrayBase_LMatrix3d);
  // PointerToBase< ReferenceCountedVector< LMatrix3d > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LMatrix3d(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_LMatrix3d", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3d);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorLMatrix3d", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LMatrix3d);
  // ConstPointerToArray< LMatrix3f >
  Dtool_PyModuleClassInit_ConstPointerToArray_LMatrix3f(module);
  PyModule_AddObject(module, "ConstPointerToArray_LMatrix3f", (PyObject *)&Dtool_ConstPointerToArray_LMatrix3f);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LMatrix3f);
  PyModule_AddObject(module, "ConstPointerToArrayLMatrix3f", (PyObject *)&Dtool_ConstPointerToArray_LMatrix3f);
  // PointerToArrayBase< LMatrix3f >
  Dtool_PyModuleClassInit_PointerToArrayBase_LMatrix3f(module);
  PyModule_AddObject(module, "PointerToArrayBase_LMatrix3f", (PyObject *)&Dtool_PointerToArrayBase_LMatrix3f);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_LMatrix3f);
  PyModule_AddObject(module, "PointerToArrayBaseLMatrix3f", (PyObject *)&Dtool_PointerToArrayBase_LMatrix3f);
  // PointerToBase< ReferenceCountedVector< LMatrix3f > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LMatrix3f(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_LMatrix3f", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_LMatrix3f);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorLMatrix3f", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f);
  // ConstPointerToArray< LVecBase2d >
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2d(module);
  PyModule_AddObject(module, "ConstPointerToArray_LVecBase2d", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2d);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LVecBase2d);
  PyModule_AddObject(module, "ConstPointerToArrayLVecBase2d", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2d);
  // PointerToArrayBase< LVecBase2d >
  Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2d(module);
  PyModule_AddObject(module, "PointerToArrayBase_LVecBase2d", (PyObject *)&Dtool_PointerToArrayBase_LVecBase2d);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_LVecBase2d);
  PyModule_AddObject(module, "PointerToArrayBaseLVecBase2d", (PyObject *)&Dtool_PointerToArrayBase_LVecBase2d);
  // PointerToBase< ReferenceCountedVector< LVecBase2d > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2d(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_LVecBase2d", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2d);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorLVecBase2d", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2d);
  // ConstPointerToArray< LVecBase2f >
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2f(module);
  PyModule_AddObject(module, "ConstPointerToArray_LVecBase2f", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2f);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LVecBase2f);
  PyModule_AddObject(module, "ConstPointerToArrayLVecBase2f", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2f);
  // PointerToArrayBase< LVecBase2f >
  Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2f(module);
  PyModule_AddObject(module, "PointerToArrayBase_LVecBase2f", (PyObject *)&Dtool_PointerToArrayBase_LVecBase2f);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_LVecBase2f);
  PyModule_AddObject(module, "PointerToArrayBaseLVecBase2f", (PyObject *)&Dtool_PointerToArrayBase_LVecBase2f);
  // PointerToBase< ReferenceCountedVector< LVecBase2f > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2f(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_LVecBase2f", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2f);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorLVecBase2f", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f);
  // ConstPointerToArray< LVecBase2i >
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2i(module);
  PyModule_AddObject(module, "ConstPointerToArray_LVecBase2i", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2i);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LVecBase2i);
  PyModule_AddObject(module, "ConstPointerToArrayLVecBase2i", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2i);
  // PointerToArrayBase< LVecBase2i >
  Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2i(module);
  PyModule_AddObject(module, "PointerToArrayBase_LVecBase2i", (PyObject *)&Dtool_PointerToArrayBase_LVecBase2i);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_LVecBase2i);
  PyModule_AddObject(module, "PointerToArrayBaseLVecBase2i", (PyObject *)&Dtool_PointerToArrayBase_LVecBase2i);
  // PointerToBase< ReferenceCountedVector< LVecBase2i > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2i(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_LVecBase2i", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase2i);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorLVecBase2i", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2i);
  // ConstPointerToArray< LVecBase3d >
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3d(module);
  PyModule_AddObject(module, "ConstPointerToArray_LVecBase3d", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3d);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LVecBase3d);
  PyModule_AddObject(module, "ConstPointerToArrayLVecBase3d", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3d);
  // PointerToArrayBase< LVecBase3d >
  Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3d(module);
  PyModule_AddObject(module, "PointerToArrayBase_LVecBase3d", (PyObject *)&Dtool_PointerToArrayBase_LVecBase3d);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_LVecBase3d);
  PyModule_AddObject(module, "PointerToArrayBaseLVecBase3d", (PyObject *)&Dtool_PointerToArrayBase_LVecBase3d);
  // PointerToBase< ReferenceCountedVector< LVecBase3d > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3d(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_LVecBase3d", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3d);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorLVecBase3d", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3d);
  // ConstPointerToArray< LVecBase3f >
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3f(module);
  PyModule_AddObject(module, "ConstPointerToArray_LVecBase3f", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3f);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LVecBase3f);
  PyModule_AddObject(module, "ConstPointerToArrayLVecBase3f", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3f);
  // PointerToArrayBase< LVecBase3f >
  Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3f(module);
  PyModule_AddObject(module, "PointerToArrayBase_LVecBase3f", (PyObject *)&Dtool_PointerToArrayBase_LVecBase3f);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_LVecBase3f);
  PyModule_AddObject(module, "PointerToArrayBaseLVecBase3f", (PyObject *)&Dtool_PointerToArrayBase_LVecBase3f);
  // PointerToBase< ReferenceCountedVector< LVecBase3f > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3f(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_LVecBase3f", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3f);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorLVecBase3f", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f);
  // ConstPointerToArray< LVecBase3i >
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3i(module);
  PyModule_AddObject(module, "ConstPointerToArray_LVecBase3i", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3i);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LVecBase3i);
  PyModule_AddObject(module, "ConstPointerToArrayLVecBase3i", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3i);
  // PointerToArrayBase< LVecBase3i >
  Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3i(module);
  PyModule_AddObject(module, "PointerToArrayBase_LVecBase3i", (PyObject *)&Dtool_PointerToArrayBase_LVecBase3i);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_LVecBase3i);
  PyModule_AddObject(module, "PointerToArrayBaseLVecBase3i", (PyObject *)&Dtool_PointerToArrayBase_LVecBase3i);
  // PointerToBase< ReferenceCountedVector< LVecBase3i > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3i(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_LVecBase3i", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_LVecBase3i);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorLVecBase3i", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3i);
  // ConstPointerToArray< UnalignedLMatrix4d >
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLMatrix4d(module);
  PyModule_AddObject(module, "ConstPointerToArray_UnalignedLMatrix4d", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4d);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_UnalignedLMatrix4d);
  PyModule_AddObject(module, "ConstPointerToArrayUnalignedLMatrix4d", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4d);
  // PointerToArrayBase< UnalignedLMatrix4d >
  Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLMatrix4d(module);
  PyModule_AddObject(module, "PointerToArrayBase_UnalignedLMatrix4d", (PyObject *)&Dtool_PointerToArrayBase_UnalignedLMatrix4d);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4d);
  PyModule_AddObject(module, "PointerToArrayBaseUnalignedLMatrix4d", (PyObject *)&Dtool_PointerToArrayBase_UnalignedLMatrix4d);
  // PointerToBase< ReferenceCountedVector< UnalignedLMatrix4d > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorUnalignedLMatrix4d", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4d);
  // ConstPointerToArray< UnalignedLMatrix4f >
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLMatrix4f(module);
  PyModule_AddObject(module, "ConstPointerToArray_UnalignedLMatrix4f", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4f);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_UnalignedLMatrix4f);
  PyModule_AddObject(module, "ConstPointerToArrayUnalignedLMatrix4f", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4f);
  // PointerToArrayBase< UnalignedLMatrix4f >
  Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLMatrix4f(module);
  PyModule_AddObject(module, "PointerToArrayBase_UnalignedLMatrix4f", (PyObject *)&Dtool_PointerToArrayBase_UnalignedLMatrix4f);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_UnalignedLMatrix4f);
  PyModule_AddObject(module, "PointerToArrayBaseUnalignedLMatrix4f", (PyObject *)&Dtool_PointerToArrayBase_UnalignedLMatrix4f);
  // PointerToBase< ReferenceCountedVector< UnalignedLMatrix4f > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorUnalignedLMatrix4f", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLMatrix4f);
  // ConstPointerToArray< UnalignedLVecBase4d >
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4d(module);
  PyModule_AddObject(module, "ConstPointerToArray_UnalignedLVecBase4d", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4d);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4d);
  PyModule_AddObject(module, "ConstPointerToArrayUnalignedLVecBase4d", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4d);
  // PointerToArrayBase< UnalignedLVecBase4d >
  Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4d(module);
  PyModule_AddObject(module, "PointerToArrayBase_UnalignedLVecBase4d", (PyObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4d);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4d);
  PyModule_AddObject(module, "PointerToArrayBaseUnalignedLVecBase4d", (PyObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4d);
  // PointerToBase< ReferenceCountedVector< UnalignedLVecBase4d > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorUnalignedLVecBase4d", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4d);
  // ConstPointerToArray< UnalignedLVecBase4f >
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4f(module);
  PyModule_AddObject(module, "ConstPointerToArray_UnalignedLVecBase4f", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4f);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4f);
  PyModule_AddObject(module, "ConstPointerToArrayUnalignedLVecBase4f", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4f);
  // PointerToArrayBase< UnalignedLVecBase4f >
  Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4f(module);
  PyModule_AddObject(module, "PointerToArrayBase_UnalignedLVecBase4f", (PyObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4f);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4f);
  PyModule_AddObject(module, "PointerToArrayBaseUnalignedLVecBase4f", (PyObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4f);
  // PointerToBase< ReferenceCountedVector< UnalignedLVecBase4f > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorUnalignedLVecBase4f", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4f);
  // ConstPointerToArray< UnalignedLVecBase4i >
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4i(module);
  PyModule_AddObject(module, "ConstPointerToArray_UnalignedLVecBase4i", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4i);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4i);
  PyModule_AddObject(module, "ConstPointerToArrayUnalignedLVecBase4i", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4i);
  // PointerToArrayBase< UnalignedLVecBase4i >
  Dtool_PyModuleClassInit_PointerToArrayBase_UnalignedLVecBase4i(module);
  PyModule_AddObject(module, "PointerToArrayBase_UnalignedLVecBase4i", (PyObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4i);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_UnalignedLVecBase4i);
  PyModule_AddObject(module, "PointerToArrayBaseUnalignedLVecBase4i", (PyObject *)&Dtool_PointerToArrayBase_UnalignedLVecBase4i);
  // PointerToBase< ReferenceCountedVector< UnalignedLVecBase4i > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorUnalignedLVecBase4i", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_UnalignedLVecBase4i);
  // PointerToArray< LMatrix3d >
  Dtool_PyModuleClassInit_PointerToArray_LMatrix3d(module);
  PyModule_AddObject(module, "PointerToArray_LMatrix3d", (PyObject *)&Dtool_PointerToArray_LMatrix3d);
  Py_INCREF(Dtool_Ptr_PointerToArray_LMatrix3d);
  PyModule_AddObject(module, "PointerToArrayLMatrix3d", (PyObject *)&Dtool_PointerToArray_LMatrix3d);
  // PointerToArray< LMatrix3f >
  Dtool_PyModuleClassInit_PointerToArray_LMatrix3f(module);
  PyModule_AddObject(module, "PointerToArray_LMatrix3f", (PyObject *)&Dtool_PointerToArray_LMatrix3f);
  Py_INCREF(Dtool_Ptr_PointerToArray_LMatrix3f);
  PyModule_AddObject(module, "PointerToArrayLMatrix3f", (PyObject *)&Dtool_PointerToArray_LMatrix3f);
  // PointerToArray< LVecBase2d >
  Dtool_PyModuleClassInit_PointerToArray_LVecBase2d(module);
  PyModule_AddObject(module, "PointerToArray_LVecBase2d", (PyObject *)&Dtool_PointerToArray_LVecBase2d);
  Py_INCREF(Dtool_Ptr_PointerToArray_LVecBase2d);
  PyModule_AddObject(module, "PointerToArrayLVecBase2d", (PyObject *)&Dtool_PointerToArray_LVecBase2d);
  // PointerToArray< LVecBase2f >
  Dtool_PyModuleClassInit_PointerToArray_LVecBase2f(module);
  PyModule_AddObject(module, "PointerToArray_LVecBase2f", (PyObject *)&Dtool_PointerToArray_LVecBase2f);
  Py_INCREF(Dtool_Ptr_PointerToArray_LVecBase2f);
  PyModule_AddObject(module, "PointerToArrayLVecBase2f", (PyObject *)&Dtool_PointerToArray_LVecBase2f);
  // PointerToArray< LVecBase2i >
  Dtool_PyModuleClassInit_PointerToArray_LVecBase2i(module);
  PyModule_AddObject(module, "PointerToArray_LVecBase2i", (PyObject *)&Dtool_PointerToArray_LVecBase2i);
  Py_INCREF(Dtool_Ptr_PointerToArray_LVecBase2i);
  PyModule_AddObject(module, "PointerToArrayLVecBase2i", (PyObject *)&Dtool_PointerToArray_LVecBase2i);
  // PointerToArray< LVecBase3d >
  Dtool_PyModuleClassInit_PointerToArray_LVecBase3d(module);
  PyModule_AddObject(module, "PointerToArray_LVecBase3d", (PyObject *)&Dtool_PointerToArray_LVecBase3d);
  Py_INCREF(Dtool_Ptr_PointerToArray_LVecBase3d);
  PyModule_AddObject(module, "PointerToArrayLVecBase3d", (PyObject *)&Dtool_PointerToArray_LVecBase3d);
  // PointerToArray< LVecBase3f >
  Dtool_PyModuleClassInit_PointerToArray_LVecBase3f(module);
  PyModule_AddObject(module, "PointerToArray_LVecBase3f", (PyObject *)&Dtool_PointerToArray_LVecBase3f);
  Py_INCREF(Dtool_Ptr_PointerToArray_LVecBase3f);
  PyModule_AddObject(module, "PointerToArrayLVecBase3f", (PyObject *)&Dtool_PointerToArray_LVecBase3f);
  // PointerToArray< LVecBase3i >
  Dtool_PyModuleClassInit_PointerToArray_LVecBase3i(module);
  PyModule_AddObject(module, "PointerToArray_LVecBase3i", (PyObject *)&Dtool_PointerToArray_LVecBase3i);
  Py_INCREF(Dtool_Ptr_PointerToArray_LVecBase3i);
  PyModule_AddObject(module, "PointerToArrayLVecBase3i", (PyObject *)&Dtool_PointerToArray_LVecBase3i);
  // PointerToArray< UnalignedLMatrix4d >
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLMatrix4d(module);
  PyModule_AddObject(module, "PointerToArray_UnalignedLMatrix4d", (PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4d);
  Py_INCREF(Dtool_Ptr_PointerToArray_UnalignedLMatrix4d);
  PyModule_AddObject(module, "PointerToArrayUnalignedLMatrix4d", (PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4d);
  // PointerToArray< UnalignedLMatrix4f >
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLMatrix4f(module);
  PyModule_AddObject(module, "PointerToArray_UnalignedLMatrix4f", (PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4f);
  Py_INCREF(Dtool_Ptr_PointerToArray_UnalignedLMatrix4f);
  PyModule_AddObject(module, "PointerToArrayUnalignedLMatrix4f", (PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4f);
  // PointerToArray< UnalignedLVecBase4d >
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4d(module);
  PyModule_AddObject(module, "PointerToArray_UnalignedLVecBase4d", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4d);
  Py_INCREF(Dtool_Ptr_PointerToArray_UnalignedLVecBase4d);
  PyModule_AddObject(module, "PointerToArrayUnalignedLVecBase4d", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4d);
  // PointerToArray< UnalignedLVecBase4f >
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4f(module);
  PyModule_AddObject(module, "PointerToArray_UnalignedLVecBase4f", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4f);
  Py_INCREF(Dtool_Ptr_PointerToArray_UnalignedLVecBase4f);
  PyModule_AddObject(module, "PointerToArrayUnalignedLVecBase4f", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4f);
  // PointerToArray< UnalignedLVecBase4i >
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4i(module);
  PyModule_AddObject(module, "PointerToArray_UnalignedLVecBase4i", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4i);
  Py_INCREF(Dtool_Ptr_PointerToArray_UnalignedLVecBase4i);
  PyModule_AddObject(module, "PointerToArrayUnalignedLVecBase4i", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4i);
  // BoundingVolume
  Dtool_PyModuleClassInit_BoundingVolume(module);
  PyModule_AddObject(module, "BoundingVolume", (PyObject *)&Dtool_BoundingVolume);
  // GeometricBoundingVolume
  Dtool_PyModuleClassInit_GeometricBoundingVolume(module);
  PyModule_AddObject(module, "GeometricBoundingVolume", (PyObject *)&Dtool_GeometricBoundingVolume);
  // FiniteBoundingVolume
  Dtool_PyModuleClassInit_FiniteBoundingVolume(module);
  PyModule_AddObject(module, "FiniteBoundingVolume", (PyObject *)&Dtool_FiniteBoundingVolume);
  // LParabolaf
  Dtool_PyModuleClassInit_LParabolaf(module);
  PyModule_AddObject(module, "LParabolaf", (PyObject *)&Dtool_LParabolaf);
  // LParabolad
  Dtool_PyModuleClassInit_LParabolad(module);
  PyModule_AddObject(module, "LParabolad", (PyObject *)&Dtool_LParabolad);
  // typedef LParabolaf LParabola
  Dtool_PyModuleClassInit_LParabolaf(module);
  Py_INCREF((PyObject *)&Dtool_LParabolaf);
  PyModule_AddObject(module, "LParabola", (PyObject *)&Dtool_LParabolaf);
  // LPlanef
  Dtool_PyModuleClassInit_LPlanef(module);
  PyModule_AddObject(module, "LPlanef", (PyObject *)&Dtool_LPlanef);
  // LPlaned
  Dtool_PyModuleClassInit_LPlaned(module);
  PyModule_AddObject(module, "LPlaned", (PyObject *)&Dtool_LPlaned);
  // typedef LPlanef LPlane
  Dtool_PyModuleClassInit_LPlanef(module);
  Py_INCREF((PyObject *)&Dtool_LPlanef);
  PyModule_AddObject(module, "LPlane", (PyObject *)&Dtool_LPlanef);
  // typedef LPlanef PlaneF
  Dtool_PyModuleClassInit_LPlanef(module);
  Py_INCREF((PyObject *)&Dtool_LPlanef);
  PyModule_AddObject(module, "PlaneF", (PyObject *)&Dtool_LPlanef);
  // typedef LPlaned PlaneD
  Dtool_PyModuleClassInit_LPlaned(module);
  Py_INCREF((PyObject *)&Dtool_LPlaned);
  PyModule_AddObject(module, "PlaneD", (PyObject *)&Dtool_LPlaned);
  // typedef LPlanef Plane
  Dtool_PyModuleClassInit_LPlanef(module);
  Py_INCREF((PyObject *)&Dtool_LPlanef);
  PyModule_AddObject(module, "Plane", (PyObject *)&Dtool_LPlanef);
  // BoundingBox
  Dtool_PyModuleClassInit_BoundingBox(module);
  PyModule_AddObject(module, "BoundingBox", (PyObject *)&Dtool_BoundingBox);
  // LFrustumf
  Dtool_PyModuleClassInit_LFrustumf(module);
  PyModule_AddObject(module, "LFrustumf", (PyObject *)&Dtool_LFrustumf);
  // LFrustumd
  Dtool_PyModuleClassInit_LFrustumd(module);
  PyModule_AddObject(module, "LFrustumd", (PyObject *)&Dtool_LFrustumd);
  // typedef LFrustumf LFrustum
  Dtool_PyModuleClassInit_LFrustumf(module);
  Py_INCREF((PyObject *)&Dtool_LFrustumf);
  PyModule_AddObject(module, "LFrustum", (PyObject *)&Dtool_LFrustumf);
  // typedef LFrustumf FrustumF
  Dtool_PyModuleClassInit_LFrustumf(module);
  Py_INCREF((PyObject *)&Dtool_LFrustumf);
  PyModule_AddObject(module, "FrustumF", (PyObject *)&Dtool_LFrustumf);
  // typedef LFrustumd FrustumD
  Dtool_PyModuleClassInit_LFrustumd(module);
  Py_INCREF((PyObject *)&Dtool_LFrustumd);
  PyModule_AddObject(module, "FrustumD", (PyObject *)&Dtool_LFrustumd);
  // typedef LFrustumf Frustum
  Dtool_PyModuleClassInit_LFrustumf(module);
  Py_INCREF((PyObject *)&Dtool_LFrustumf);
  PyModule_AddObject(module, "Frustum", (PyObject *)&Dtool_LFrustumf);
  // BoundingHexahedron
  Dtool_PyModuleClassInit_BoundingHexahedron(module);
  PyModule_AddObject(module, "BoundingHexahedron", (PyObject *)&Dtool_BoundingHexahedron);
  // BoundingLine
  Dtool_PyModuleClassInit_BoundingLine(module);
  PyModule_AddObject(module, "BoundingLine", (PyObject *)&Dtool_BoundingLine);
  // BoundingPlane
  Dtool_PyModuleClassInit_BoundingPlane(module);
  PyModule_AddObject(module, "BoundingPlane", (PyObject *)&Dtool_BoundingPlane);
  // BoundingSphere
  Dtool_PyModuleClassInit_BoundingSphere(module);
  PyModule_AddObject(module, "BoundingSphere", (PyObject *)&Dtool_BoundingSphere);
  // IntersectionBoundingVolume
  Dtool_PyModuleClassInit_IntersectionBoundingVolume(module);
  PyModule_AddObject(module, "IntersectionBoundingVolume", (PyObject *)&Dtool_IntersectionBoundingVolume);
  // Mersenne
  Dtool_PyModuleClassInit_Mersenne(module);
  PyModule_AddObject(module, "Mersenne", (PyObject *)&Dtool_Mersenne);
  // OmniBoundingVolume
  Dtool_PyModuleClassInit_OmniBoundingVolume(module);
  PyModule_AddObject(module, "OmniBoundingVolume", (PyObject *)&Dtool_OmniBoundingVolume);
  // UnionBoundingVolume
  Dtool_PyModuleClassInit_UnionBoundingVolume(module);
  PyModule_AddObject(module, "UnionBoundingVolume", (PyObject *)&Dtool_UnionBoundingVolume);
  // Randomizer
  Dtool_PyModuleClassInit_Randomizer(module);
  PyModule_AddObject(module, "Randomizer", (PyObject *)&Dtool_Randomizer);
  // PerlinNoise
  Dtool_PyModuleClassInit_PerlinNoise(module);
  PyModule_AddObject(module, "PerlinNoise", (PyObject *)&Dtool_PerlinNoise);
  // PerlinNoise2
  Dtool_PyModuleClassInit_PerlinNoise2(module);
  PyModule_AddObject(module, "PerlinNoise2", (PyObject *)&Dtool_PerlinNoise2);
  // PerlinNoise3
  Dtool_PyModuleClassInit_PerlinNoise3(module);
  PyModule_AddObject(module, "PerlinNoise3", (PyObject *)&Dtool_PerlinNoise3);
  // typedef PointerToArray< UnalignedLMatrix4f > PTA_LMatrix4f
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLMatrix4f(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4f);
  PyModule_AddObject(module, "PTA_LMatrix4f", (PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4f);
  Py_INCREF(Dtool_Ptr_PointerToArray_UnalignedLMatrix4f);
  PyModule_AddObject(module, "PTALMatrix4f", (PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4f);
  // typedef ConstPointerToArray< UnalignedLMatrix4f > CPTA_LMatrix4f
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLMatrix4f(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4f);
  PyModule_AddObject(module, "CPTA_LMatrix4f", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4f);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_UnalignedLMatrix4f);
  PyModule_AddObject(module, "CPTALMatrix4f", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4f);
  // typedef PointerToArray< UnalignedLMatrix4d > PTA_LMatrix4d
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLMatrix4d(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4d);
  PyModule_AddObject(module, "PTA_LMatrix4d", (PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4d);
  Py_INCREF(Dtool_Ptr_PointerToArray_UnalignedLMatrix4d);
  PyModule_AddObject(module, "PTALMatrix4d", (PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4d);
  // typedef ConstPointerToArray< UnalignedLMatrix4d > CPTA_LMatrix4d
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLMatrix4d(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4d);
  PyModule_AddObject(module, "CPTA_LMatrix4d", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4d);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_UnalignedLMatrix4d);
  PyModule_AddObject(module, "CPTALMatrix4d", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4d);
  // typedef PointerToArray< UnalignedLMatrix4f > PTA_LMatrix4
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLMatrix4f(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4f);
  PyModule_AddObject(module, "PTA_LMatrix4", (PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4f);
  Py_INCREF(Dtool_Ptr_PointerToArray_UnalignedLMatrix4f);
  PyModule_AddObject(module, "PTALMatrix4", (PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4f);
  // typedef ConstPointerToArray< UnalignedLMatrix4f > CPTA_LMatrix4
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLMatrix4f(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4f);
  PyModule_AddObject(module, "CPTA_LMatrix4", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4f);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_UnalignedLMatrix4f);
  PyModule_AddObject(module, "CPTALMatrix4", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4f);
  // typedef PointerToArray< UnalignedLMatrix4f > PTAMat4
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLMatrix4f(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4f);
  PyModule_AddObject(module, "PTAMat4", (PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4f);
  // typedef ConstPointerToArray< UnalignedLMatrix4f > CPTAMat4
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLMatrix4f(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4f);
  PyModule_AddObject(module, "CPTAMat4", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4f);
  // typedef PointerToArray< UnalignedLMatrix4d > PTAMat4d
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLMatrix4d(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4d);
  PyModule_AddObject(module, "PTAMat4d", (PyObject *)&Dtool_PointerToArray_UnalignedLMatrix4d);
  // typedef ConstPointerToArray< UnalignedLMatrix4d > CPTAMat4d
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLMatrix4d(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4d);
  PyModule_AddObject(module, "CPTAMat4d", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLMatrix4d);
  // typedef PointerToArray< LMatrix3f > PTA_LMatrix3f
  Dtool_PyModuleClassInit_PointerToArray_LMatrix3f(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LMatrix3f);
  PyModule_AddObject(module, "PTA_LMatrix3f", (PyObject *)&Dtool_PointerToArray_LMatrix3f);
  Py_INCREF(Dtool_Ptr_PointerToArray_LMatrix3f);
  PyModule_AddObject(module, "PTALMatrix3f", (PyObject *)&Dtool_PointerToArray_LMatrix3f);
  // typedef ConstPointerToArray< LMatrix3f > CPTA_LMatrix3f
  Dtool_PyModuleClassInit_ConstPointerToArray_LMatrix3f(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LMatrix3f);
  PyModule_AddObject(module, "CPTA_LMatrix3f", (PyObject *)&Dtool_ConstPointerToArray_LMatrix3f);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LMatrix3f);
  PyModule_AddObject(module, "CPTALMatrix3f", (PyObject *)&Dtool_ConstPointerToArray_LMatrix3f);
  // typedef PointerToArray< LMatrix3d > PTA_LMatrix3d
  Dtool_PyModuleClassInit_PointerToArray_LMatrix3d(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LMatrix3d);
  PyModule_AddObject(module, "PTA_LMatrix3d", (PyObject *)&Dtool_PointerToArray_LMatrix3d);
  Py_INCREF(Dtool_Ptr_PointerToArray_LMatrix3d);
  PyModule_AddObject(module, "PTALMatrix3d", (PyObject *)&Dtool_PointerToArray_LMatrix3d);
  // typedef ConstPointerToArray< LMatrix3d > CPTA_LMatrix3d
  Dtool_PyModuleClassInit_ConstPointerToArray_LMatrix3d(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LMatrix3d);
  PyModule_AddObject(module, "CPTA_LMatrix3d", (PyObject *)&Dtool_ConstPointerToArray_LMatrix3d);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LMatrix3d);
  PyModule_AddObject(module, "CPTALMatrix3d", (PyObject *)&Dtool_ConstPointerToArray_LMatrix3d);
  // typedef PointerToArray< LMatrix3f > PTA_LMatrix3
  Dtool_PyModuleClassInit_PointerToArray_LMatrix3f(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LMatrix3f);
  PyModule_AddObject(module, "PTA_LMatrix3", (PyObject *)&Dtool_PointerToArray_LMatrix3f);
  Py_INCREF(Dtool_Ptr_PointerToArray_LMatrix3f);
  PyModule_AddObject(module, "PTALMatrix3", (PyObject *)&Dtool_PointerToArray_LMatrix3f);
  // typedef ConstPointerToArray< LMatrix3f > CPTA_LMatrix3
  Dtool_PyModuleClassInit_ConstPointerToArray_LMatrix3f(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LMatrix3f);
  PyModule_AddObject(module, "CPTA_LMatrix3", (PyObject *)&Dtool_ConstPointerToArray_LMatrix3f);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LMatrix3f);
  PyModule_AddObject(module, "CPTALMatrix3", (PyObject *)&Dtool_ConstPointerToArray_LMatrix3f);
  // typedef PointerToArray< LMatrix3f > PTAMat3
  Dtool_PyModuleClassInit_PointerToArray_LMatrix3f(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LMatrix3f);
  PyModule_AddObject(module, "PTAMat3", (PyObject *)&Dtool_PointerToArray_LMatrix3f);
  // typedef ConstPointerToArray< LMatrix3f > CPTAMat3
  Dtool_PyModuleClassInit_ConstPointerToArray_LMatrix3f(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LMatrix3f);
  PyModule_AddObject(module, "CPTAMat3", (PyObject *)&Dtool_ConstPointerToArray_LMatrix3f);
  // typedef PointerToArray< LMatrix3d > PTAMat3d
  Dtool_PyModuleClassInit_PointerToArray_LMatrix3d(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LMatrix3d);
  PyModule_AddObject(module, "PTAMat3d", (PyObject *)&Dtool_PointerToArray_LMatrix3d);
  // typedef ConstPointerToArray< LMatrix3d > CPTAMat3d
  Dtool_PyModuleClassInit_ConstPointerToArray_LMatrix3d(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LMatrix3d);
  PyModule_AddObject(module, "CPTAMat3d", (PyObject *)&Dtool_ConstPointerToArray_LMatrix3d);
  // typedef PointerToArray< UnalignedLVecBase4f > PTA_LVecBase4f
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4f(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4f);
  PyModule_AddObject(module, "PTA_LVecBase4f", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4f);
  Py_INCREF(Dtool_Ptr_PointerToArray_UnalignedLVecBase4f);
  PyModule_AddObject(module, "PTALVecBase4f", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4f);
  // typedef ConstPointerToArray< UnalignedLVecBase4f > CPTA_LVecBase4f
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4f(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4f);
  PyModule_AddObject(module, "CPTA_LVecBase4f", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4f);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4f);
  PyModule_AddObject(module, "CPTALVecBase4f", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4f);
  // typedef PointerToArray< UnalignedLVecBase4d > PTA_LVecBase4d
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4d(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4d);
  PyModule_AddObject(module, "PTA_LVecBase4d", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4d);
  Py_INCREF(Dtool_Ptr_PointerToArray_UnalignedLVecBase4d);
  PyModule_AddObject(module, "PTALVecBase4d", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4d);
  // typedef ConstPointerToArray< UnalignedLVecBase4d > CPTA_LVecBase4d
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4d(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4d);
  PyModule_AddObject(module, "CPTA_LVecBase4d", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4d);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4d);
  PyModule_AddObject(module, "CPTALVecBase4d", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4d);
  // typedef PointerToArray< UnalignedLVecBase4i > PTA_LVecBase4i
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4i(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4i);
  PyModule_AddObject(module, "PTA_LVecBase4i", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4i);
  Py_INCREF(Dtool_Ptr_PointerToArray_UnalignedLVecBase4i);
  PyModule_AddObject(module, "PTALVecBase4i", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4i);
  // typedef ConstPointerToArray< UnalignedLVecBase4i > CPTA_LVecBase4i
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4i(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4i);
  PyModule_AddObject(module, "CPTA_LVecBase4i", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4i);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4i);
  PyModule_AddObject(module, "CPTALVecBase4i", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4i);
  // typedef PointerToArray< UnalignedLVecBase4f > PTA_LVecBase4
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4f(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4f);
  PyModule_AddObject(module, "PTA_LVecBase4", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4f);
  Py_INCREF(Dtool_Ptr_PointerToArray_UnalignedLVecBase4f);
  PyModule_AddObject(module, "PTALVecBase4", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4f);
  // typedef ConstPointerToArray< UnalignedLVecBase4f > CPTA_LVecBase4
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4f(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4f);
  PyModule_AddObject(module, "CPTA_LVecBase4", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4f);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_UnalignedLVecBase4f);
  PyModule_AddObject(module, "CPTALVecBase4", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4f);
  // typedef PointerToArray< UnalignedLVecBase4f > PTAVecBase4f
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4f(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4f);
  PyModule_AddObject(module, "PTAVecBase4f", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4f);
  // typedef ConstPointerToArray< UnalignedLVecBase4f > CPTAVecBase4f
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4f(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4f);
  PyModule_AddObject(module, "CPTAVecBase4f", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4f);
  // typedef PointerToArray< UnalignedLVecBase4d > PTAVecBase4d
  Dtool_PyModuleClassInit_PointerToArray_UnalignedLVecBase4d(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4d);
  PyModule_AddObject(module, "PTAVecBase4d", (PyObject *)&Dtool_PointerToArray_UnalignedLVecBase4d);
  // typedef ConstPointerToArray< UnalignedLVecBase4d > CPTAVecBase4d
  Dtool_PyModuleClassInit_ConstPointerToArray_UnalignedLVecBase4d(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4d);
  PyModule_AddObject(module, "CPTAVecBase4d", (PyObject *)&Dtool_ConstPointerToArray_UnalignedLVecBase4d);
  // typedef PointerToArray< LVecBase3f > PTA_LVecBase3f
  Dtool_PyModuleClassInit_PointerToArray_LVecBase3f(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LVecBase3f);
  PyModule_AddObject(module, "PTA_LVecBase3f", (PyObject *)&Dtool_PointerToArray_LVecBase3f);
  Py_INCREF(Dtool_Ptr_PointerToArray_LVecBase3f);
  PyModule_AddObject(module, "PTALVecBase3f", (PyObject *)&Dtool_PointerToArray_LVecBase3f);
  // typedef ConstPointerToArray< LVecBase3f > CPTA_LVecBase3f
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3f(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LVecBase3f);
  PyModule_AddObject(module, "CPTA_LVecBase3f", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3f);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LVecBase3f);
  PyModule_AddObject(module, "CPTALVecBase3f", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3f);
  // typedef PointerToArray< LVecBase3d > PTA_LVecBase3d
  Dtool_PyModuleClassInit_PointerToArray_LVecBase3d(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LVecBase3d);
  PyModule_AddObject(module, "PTA_LVecBase3d", (PyObject *)&Dtool_PointerToArray_LVecBase3d);
  Py_INCREF(Dtool_Ptr_PointerToArray_LVecBase3d);
  PyModule_AddObject(module, "PTALVecBase3d", (PyObject *)&Dtool_PointerToArray_LVecBase3d);
  // typedef ConstPointerToArray< LVecBase3d > CPTA_LVecBase3d
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3d(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LVecBase3d);
  PyModule_AddObject(module, "CPTA_LVecBase3d", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3d);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LVecBase3d);
  PyModule_AddObject(module, "CPTALVecBase3d", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3d);
  // typedef PointerToArray< LVecBase3i > PTA_LVecBase3i
  Dtool_PyModuleClassInit_PointerToArray_LVecBase3i(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LVecBase3i);
  PyModule_AddObject(module, "PTA_LVecBase3i", (PyObject *)&Dtool_PointerToArray_LVecBase3i);
  Py_INCREF(Dtool_Ptr_PointerToArray_LVecBase3i);
  PyModule_AddObject(module, "PTALVecBase3i", (PyObject *)&Dtool_PointerToArray_LVecBase3i);
  // typedef ConstPointerToArray< LVecBase3i > CPTA_LVecBase3i
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3i(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LVecBase3i);
  PyModule_AddObject(module, "CPTA_LVecBase3i", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3i);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LVecBase3i);
  PyModule_AddObject(module, "CPTALVecBase3i", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3i);
  // typedef PointerToArray< LVecBase3f > PTA_LVecBase3
  Dtool_PyModuleClassInit_PointerToArray_LVecBase3f(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LVecBase3f);
  PyModule_AddObject(module, "PTA_LVecBase3", (PyObject *)&Dtool_PointerToArray_LVecBase3f);
  Py_INCREF(Dtool_Ptr_PointerToArray_LVecBase3f);
  PyModule_AddObject(module, "PTALVecBase3", (PyObject *)&Dtool_PointerToArray_LVecBase3f);
  // typedef ConstPointerToArray< LVecBase3f > CPTA_LVecBase3
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3f(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LVecBase3f);
  PyModule_AddObject(module, "CPTA_LVecBase3", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3f);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LVecBase3f);
  PyModule_AddObject(module, "CPTALVecBase3", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3f);
  // typedef PointerToArray< LVecBase3f > PTAVecBase3f
  Dtool_PyModuleClassInit_PointerToArray_LVecBase3f(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LVecBase3f);
  PyModule_AddObject(module, "PTAVecBase3f", (PyObject *)&Dtool_PointerToArray_LVecBase3f);
  // typedef ConstPointerToArray< LVecBase3f > CPTAVecBase3f
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3f(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LVecBase3f);
  PyModule_AddObject(module, "CPTAVecBase3f", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3f);
  // typedef PointerToArray< LVecBase3d > PTAVecBase3d
  Dtool_PyModuleClassInit_PointerToArray_LVecBase3d(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LVecBase3d);
  PyModule_AddObject(module, "PTAVecBase3d", (PyObject *)&Dtool_PointerToArray_LVecBase3d);
  // typedef ConstPointerToArray< LVecBase3d > CPTAVecBase3d
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3d(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LVecBase3d);
  PyModule_AddObject(module, "CPTAVecBase3d", (PyObject *)&Dtool_ConstPointerToArray_LVecBase3d);
  // typedef PointerToArray< LVecBase2f > PTA_LVecBase2f
  Dtool_PyModuleClassInit_PointerToArray_LVecBase2f(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LVecBase2f);
  PyModule_AddObject(module, "PTA_LVecBase2f", (PyObject *)&Dtool_PointerToArray_LVecBase2f);
  Py_INCREF(Dtool_Ptr_PointerToArray_LVecBase2f);
  PyModule_AddObject(module, "PTALVecBase2f", (PyObject *)&Dtool_PointerToArray_LVecBase2f);
  // typedef ConstPointerToArray< LVecBase2f > CPTA_LVecBase2f
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2f(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LVecBase2f);
  PyModule_AddObject(module, "CPTA_LVecBase2f", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2f);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LVecBase2f);
  PyModule_AddObject(module, "CPTALVecBase2f", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2f);
  // typedef PointerToArray< LVecBase2d > PTA_LVecBase2d
  Dtool_PyModuleClassInit_PointerToArray_LVecBase2d(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LVecBase2d);
  PyModule_AddObject(module, "PTA_LVecBase2d", (PyObject *)&Dtool_PointerToArray_LVecBase2d);
  Py_INCREF(Dtool_Ptr_PointerToArray_LVecBase2d);
  PyModule_AddObject(module, "PTALVecBase2d", (PyObject *)&Dtool_PointerToArray_LVecBase2d);
  // typedef ConstPointerToArray< LVecBase2d > CPTA_LVecBase2d
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2d(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LVecBase2d);
  PyModule_AddObject(module, "CPTA_LVecBase2d", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2d);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LVecBase2d);
  PyModule_AddObject(module, "CPTALVecBase2d", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2d);
  // typedef PointerToArray< LVecBase2i > PTA_LVecBase2i
  Dtool_PyModuleClassInit_PointerToArray_LVecBase2i(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LVecBase2i);
  PyModule_AddObject(module, "PTA_LVecBase2i", (PyObject *)&Dtool_PointerToArray_LVecBase2i);
  Py_INCREF(Dtool_Ptr_PointerToArray_LVecBase2i);
  PyModule_AddObject(module, "PTALVecBase2i", (PyObject *)&Dtool_PointerToArray_LVecBase2i);
  // typedef ConstPointerToArray< LVecBase2i > CPTA_LVecBase2i
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2i(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LVecBase2i);
  PyModule_AddObject(module, "CPTA_LVecBase2i", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2i);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LVecBase2i);
  PyModule_AddObject(module, "CPTALVecBase2i", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2i);
  // typedef PointerToArray< LVecBase2f > PTA_LVecBase2
  Dtool_PyModuleClassInit_PointerToArray_LVecBase2f(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LVecBase2f);
  PyModule_AddObject(module, "PTA_LVecBase2", (PyObject *)&Dtool_PointerToArray_LVecBase2f);
  Py_INCREF(Dtool_Ptr_PointerToArray_LVecBase2f);
  PyModule_AddObject(module, "PTALVecBase2", (PyObject *)&Dtool_PointerToArray_LVecBase2f);
  // typedef ConstPointerToArray< LVecBase2f > CPTA_LVecBase2
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2f(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LVecBase2f);
  PyModule_AddObject(module, "CPTA_LVecBase2", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2f);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_LVecBase2f);
  PyModule_AddObject(module, "CPTALVecBase2", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2f);
  // typedef PointerToArray< LVecBase2f > PTAVecBase2f
  Dtool_PyModuleClassInit_PointerToArray_LVecBase2f(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LVecBase2f);
  PyModule_AddObject(module, "PTAVecBase2f", (PyObject *)&Dtool_PointerToArray_LVecBase2f);
  // typedef ConstPointerToArray< LVecBase2f > CPTAVecBase2f
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2f(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LVecBase2f);
  PyModule_AddObject(module, "CPTAVecBase2f", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2f);
  // typedef PointerToArray< LVecBase2d > PTAVecBase2d
  Dtool_PyModuleClassInit_PointerToArray_LVecBase2d(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_LVecBase2d);
  PyModule_AddObject(module, "PTAVecBase2d", (PyObject *)&Dtool_PointerToArray_LVecBase2d);
  // typedef ConstPointerToArray< LVecBase2d > CPTAVecBase2d
  Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2d(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_LVecBase2d);
  PyModule_AddObject(module, "CPTAVecBase2d", (PyObject *)&Dtool_ConstPointerToArray_LVecBase2d);
  // StackedPerlinNoise2
  Dtool_PyModuleClassInit_StackedPerlinNoise2(module);
  PyModule_AddObject(module, "StackedPerlinNoise2", (PyObject *)&Dtool_StackedPerlinNoise2);
  // StackedPerlinNoise3
  Dtool_PyModuleClassInit_StackedPerlinNoise3(module);
  PyModule_AddObject(module, "StackedPerlinNoise3", (PyObject *)&Dtool_StackedPerlinNoise3);
  // Triangulator
  Dtool_PyModuleClassInit_Triangulator(module);
  PyModule_AddObject(module, "Triangulator", (PyObject *)&Dtool_Triangulator);
  // Triangulator3
  Dtool_PyModuleClassInit_Triangulator3(module);
  PyModule_AddObject(module, "Triangulator3", (PyObject *)&Dtool_Triangulator3);
}

static PyMethodDef python_simple_funcs[] = {
  {"heads_up", (PyCFunction) &Dtool_heads_up_730, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_heads_up_730_comment},
  {"headsUp", (PyCFunction) &Dtool_heads_up_730, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_heads_up_730_comment},
  {"look_at", (PyCFunction) &Dtool_look_at_731, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_look_at_731_comment},
  {"lookAt", (PyCFunction) &Dtool_look_at_731, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_look_at_731_comment},
  {"rotate_to", (PyCFunction) &Dtool_rotate_to_837, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_rotate_to_837_comment},
  {"rotateTo", (PyCFunction) &Dtool_rotate_to_837, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_rotate_to_837_comment},
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3mathutil_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3mathutil_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583613024,  /* file_identifier */
  "libp3mathutil",  /* library_name */
  "LL_p",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3mathutil.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  1932  /* next_index */
};

Configure(_in_configure_libp3mathutil);
ConfigureFn(_in_configure_libp3mathutil) {
  interrogate_request_module(&_in_module_def);
}

