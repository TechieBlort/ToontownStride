/*
 * This file was generated by:
 * built/bin/interrogate -srcdir panda/src/pnmimage -Ipanda/src/pnmimage -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3pnmimage_igate.cxx -od built/pandac/input/libp3pnmimage.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/pnmimage -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.core -library libp3pnmimage config_pnmimage.h convert_srgb.h p3pnmimage_composite1.cxx p3pnmimage_composite2.cxx pfmFile.h pfmFile_ext.h pnmBrush.h pnmFileType.h pnmFileTypeRegistry.h pnmImage.h pnmImageHeader.h pnmPainter.h pnmReader.h pnmWriter.h pnmbitio.h pnmimage_base.h ppmcmap.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "configVariableBool.h"
#include "configVariableDouble.h"
#include "config_pnmimage.h"
#include "convert_srgb.h"
#include "dtoolbase.h"
#include "extension.h"
#include "luse.h"
#include "notifyCategoryProxy.h"
#include "pandabase.h"
#include "pfmFile.h"
#include "pfmFile_ext.h"
#include "pnmBrush.h"
#include "pnmFileType.h"
#include "pnmFileTypeRegistry.h"
#include "pnmImage.h"
#include "pnmImageHeader.h"
#include "pnmPainter.h"
#include "pnmReader.h"
#include "pnmWriter.h"
#include "pnmbitio.h"
#include "pnmimage_base.h"
#include "ppmcmap.h"
#include "py_panda.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class pixel
 */
typedef pixel pixel_localtype;
Define_Module_Class(panda3d.core, pixel, pixel_localtype, pixel);
static struct Dtool_PyTypedObject *const Dtool_Ptr_pixel = &Dtool_pixel;
static void Dtool_PyModuleClassInit_pixel(PyObject *module);
pixel *Dtool_Coerce_pixel(PyObject *args, pixel &coerced);

/**
 * Forward declarations for top-level class PNMFileType
 */
typedef PNMFileType PNMFileType_localtype;
Define_Module_Class(panda3d.core, PNMFileType, PNMFileType_localtype, PNMFileType);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PNMFileType = &Dtool_PNMFileType;
static void Dtool_PyModuleClassInit_PNMFileType(PyObject *module);

/**
 * Forward declarations for top-level class PNMFileTypeRegistry
 */
typedef PNMFileTypeRegistry PNMFileTypeRegistry_localtype;
Define_Module_Class(panda3d.core, PNMFileTypeRegistry, PNMFileTypeRegistry_localtype, PNMFileTypeRegistry);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PNMFileTypeRegistry = &Dtool_PNMFileTypeRegistry;
static void Dtool_PyModuleClassInit_PNMFileTypeRegistry(PyObject *module);

/**
 * Forward declarations for top-level class PNMImageHeader
 */
typedef PNMImageHeader PNMImageHeader_localtype;
Define_Module_Class(panda3d.core, PNMImageHeader, PNMImageHeader_localtype, PNMImageHeader);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PNMImageHeader = &Dtool_PNMImageHeader;
static void Dtool_PyModuleClassInit_PNMImageHeader(PyObject *module);

/**
 * Forward declarations for top-level class PNMImageHeader_PixelSpec
 */
typedef PNMImageHeader::PixelSpec PNMImageHeader_PixelSpec_localtype;
Define_Module_Class(panda3d.core, PNMImageHeader_PixelSpec, PNMImageHeader_PixelSpec_localtype, PixelSpec);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PNMImageHeader_PixelSpec = &Dtool_PNMImageHeader_PixelSpec;
static void Dtool_PyModuleClassInit_PNMImageHeader_PixelSpec(PyObject *module);
PNMImageHeader::PixelSpec *Dtool_Coerce_PNMImageHeader_PixelSpec(PyObject *args, PNMImageHeader::PixelSpec &coerced);

/**
 * Forward declarations for top-level class PNMImageHeader_PixelSpecCount
 */
typedef PNMImageHeader::PixelSpecCount PNMImageHeader_PixelSpecCount_localtype;
Define_Module_Class(panda3d.core, PNMImageHeader_PixelSpecCount, PNMImageHeader_PixelSpecCount_localtype, PixelSpecCount);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PNMImageHeader_PixelSpecCount = &Dtool_PNMImageHeader_PixelSpecCount;
static void Dtool_PyModuleClassInit_PNMImageHeader_PixelSpecCount(PyObject *module);

/**
 * Forward declarations for top-level class PNMImageHeader_Histogram
 */
typedef PNMImageHeader::Histogram PNMImageHeader_Histogram_localtype;
Define_Module_Class(panda3d.core, PNMImageHeader_Histogram, PNMImageHeader_Histogram_localtype, Histogram);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PNMImageHeader_Histogram = &Dtool_PNMImageHeader_Histogram;
static void Dtool_PyModuleClassInit_PNMImageHeader_Histogram(PyObject *module);

/**
 * Forward declarations for top-level class PfmFile
 */
typedef PfmFile PfmFile_localtype;
Define_Module_Class(panda3d.core, PfmFile, PfmFile_localtype, PfmFile);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PfmFile = &Dtool_PfmFile;
static void Dtool_PyModuleClassInit_PfmFile(PyObject *module);

/**
 * Forward declarations for top-level class PNMBrush
 */
typedef PNMBrush PNMBrush_localtype;
Define_Module_ClassRef(panda3d.core, PNMBrush, PNMBrush_localtype, PNMBrush);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PNMBrush = &Dtool_PNMBrush;
static void Dtool_PyModuleClassInit_PNMBrush(PyObject *module);

/**
 * Forward declarations for top-level class PNMImage
 */
typedef PNMImage PNMImage_localtype;
Define_Module_Class(panda3d.core, PNMImage, PNMImage_localtype, PNMImage);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PNMImage = &Dtool_PNMImage;
static void Dtool_PyModuleClassInit_PNMImage(PyObject *module);

/**
 * Forward declarations for top-level class PNMImage_Row
 */
typedef PNMImage::Row PNMImage_Row_localtype;
Define_Module_Class_Private(panda3d.core, PNMImage_Row, PNMImage_Row_localtype, Row);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PNMImage_Row = &Dtool_PNMImage_Row;
static void Dtool_PyModuleClassInit_PNMImage_Row(PyObject *module);

/**
 * Forward declarations for top-level class PNMImage_CRow
 */
typedef PNMImage::CRow PNMImage_CRow_localtype;
Define_Module_Class_Private(panda3d.core, PNMImage_CRow, PNMImage_CRow_localtype, CRow);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PNMImage_CRow = &Dtool_PNMImage_CRow;
static void Dtool_PyModuleClassInit_PNMImage_CRow(PyObject *module);

/**
 * Forward declarations for top-level class PNMPainter
 */
typedef PNMPainter PNMPainter_localtype;
Define_Module_Class(panda3d.core, PNMPainter, PNMPainter_localtype, PNMPainter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PNMPainter = &Dtool_PNMPainter;
static void Dtool_PyModuleClassInit_PNMPainter(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"pixel", &Dtool_pixel},
  {"PNMFileType", &Dtool_PNMFileType},
  {"PNMFileTypeRegistry", &Dtool_PNMFileTypeRegistry},
  {"PNMImageHeader", &Dtool_PNMImageHeader},
  {"PNMImageHeader::PixelSpec", &Dtool_PNMImageHeader_PixelSpec},
  {"PNMImageHeader::PixelSpecCount", &Dtool_PNMImageHeader_PixelSpecCount},
  {"PNMImageHeader::Histogram", &Dtool_PNMImageHeader_Histogram},
  {"PfmFile", &Dtool_PfmFile},
  {"PNMBrush", &Dtool_PNMBrush},
  {"PNMImage", &Dtool_PNMImage},
  {"PNMImage::Row", &Dtool_PNMImage_Row},
  {"PNMImage::CRow", &Dtool_PNMImage_CRow},
  {"PNMPainter", &Dtool_PNMPainter},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"std::ostream", nullptr},
#define Dtool_Ptr_std_ostream (imports[0].type)
  {"std::istream", nullptr},
#define Dtool_Ptr_std_istream (imports[1].type)
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[2].type)
  {"Filename", nullptr},
#define Dtool_Ptr_Filename (imports[3].type)
  {"TypedObject", nullptr},
#define Dtool_Ptr_TypedObject (imports[4].type)
  {"ReferenceCount", nullptr},
#define Dtool_Ptr_ReferenceCount (imports[5].type)
  {"LVecBase2f", nullptr},
#define Dtool_Ptr_LVecBase2f (imports[6].type)
  {"LVecBase2d", nullptr},
#define Dtool_Ptr_LVecBase2d (imports[7].type)
  {"LVecBase2i", nullptr},
#define Dtool_Ptr_LVecBase2i (imports[8].type)
  {"LPoint2f", nullptr},
#define Dtool_Ptr_LPoint2f (imports[9].type)
  {"LPoint2d", nullptr},
#define Dtool_Ptr_LPoint2d (imports[10].type)
  {"LVecBase3f", nullptr},
#define Dtool_Ptr_LVecBase3f (imports[11].type)
  {"LVecBase3d", nullptr},
#define Dtool_Ptr_LVecBase3d (imports[12].type)
  {"LPoint3f", nullptr},
#define Dtool_Ptr_LPoint3f (imports[13].type)
  {"LVecBase4f", nullptr},
#define Dtool_Ptr_LVecBase4f (imports[14].type)
  {"LVecBase4d", nullptr},
#define Dtool_Ptr_LVecBase4d (imports[15].type)
  {"LPoint4f", nullptr},
#define Dtool_Ptr_LPoint4f (imports[16].type)
  {"LPoint4d", nullptr},
#define Dtool_Ptr_LPoint4d (imports[17].type)
  {"LMatrix4f", nullptr},
#define Dtool_Ptr_LMatrix4f (imports[18].type)
  {"LMatrix4d", nullptr},
#define Dtool_Ptr_LMatrix4d (imports[19].type)
  {"TypedWritable", nullptr},
#define Dtool_Ptr_TypedWritable (imports[20].type)
  {"BoundingHexahedron", nullptr},
#define Dtool_Ptr_BoundingHexahedron (imports[21].type)
  {"StackedPerlinNoise2", nullptr},
#define Dtool_Ptr_StackedPerlinNoise2 (imports[22].type)
  {nullptr, nullptr},
};
#endif

// std::ostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
#endif
// std::istream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_istream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_istream = &Dtool_std_istream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// Filename
#ifndef LINK_ALL_STATIC
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != nullptr, nullptr);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != nullptr, nullptr);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// LVecBase2f
#ifndef LINK_ALL_STATIC
inline static LVecBase2f *Dtool_Coerce_LVecBase2f(PyObject *args, LVecBase2f &coerced) {
  nassertr(Dtool_Ptr_LVecBase2f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase2f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase2f *(*)(PyObject *, LVecBase2f &))Dtool_Ptr_LVecBase2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2f = &Dtool_LVecBase2f;
extern LVecBase2f *Dtool_Coerce_LVecBase2f(PyObject *args, LVecBase2f &coerced);
#endif
// LVecBase2d
#ifndef LINK_ALL_STATIC
inline static LVecBase2d *Dtool_Coerce_LVecBase2d(PyObject *args, LVecBase2d &coerced) {
  nassertr(Dtool_Ptr_LVecBase2d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase2d->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase2d *(*)(PyObject *, LVecBase2d &))Dtool_Ptr_LVecBase2d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2d = &Dtool_LVecBase2d;
extern LVecBase2d *Dtool_Coerce_LVecBase2d(PyObject *args, LVecBase2d &coerced);
#endif
// LVecBase2i
#ifndef LINK_ALL_STATIC
inline static LVecBase2i *Dtool_Coerce_LVecBase2i(PyObject *args, LVecBase2i &coerced) {
  nassertr(Dtool_Ptr_LVecBase2i != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase2i->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase2i *(*)(PyObject *, LVecBase2i &))Dtool_Ptr_LVecBase2i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2i = &Dtool_LVecBase2i;
extern LVecBase2i *Dtool_Coerce_LVecBase2i(PyObject *args, LVecBase2i &coerced);
#endif
// LPoint2f
#ifndef LINK_ALL_STATIC
inline static LPoint2f *Dtool_Coerce_LPoint2f(PyObject *args, LPoint2f &coerced) {
  nassertr(Dtool_Ptr_LPoint2f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint2f->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint2f *(*)(PyObject *, LPoint2f &))Dtool_Ptr_LPoint2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint2f = &Dtool_LPoint2f;
extern LPoint2f *Dtool_Coerce_LPoint2f(PyObject *args, LPoint2f &coerced);
#endif
// LPoint2d
#ifndef LINK_ALL_STATIC
inline static LPoint2d *Dtool_Coerce_LPoint2d(PyObject *args, LPoint2d &coerced) {
  nassertr(Dtool_Ptr_LPoint2d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint2d->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint2d *(*)(PyObject *, LPoint2d &))Dtool_Ptr_LPoint2d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint2d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint2d = &Dtool_LPoint2d;
extern LPoint2d *Dtool_Coerce_LPoint2d(PyObject *args, LPoint2d &coerced);
#endif
// LVecBase3f
#ifndef LINK_ALL_STATIC
inline static LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  nassertr(Dtool_Ptr_LVecBase3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase3f *(*)(PyObject *, LVecBase3f &))Dtool_Ptr_LVecBase3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
extern LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);
#endif
// LVecBase3d
#ifndef LINK_ALL_STATIC
inline static LVecBase3d *Dtool_Coerce_LVecBase3d(PyObject *args, LVecBase3d &coerced) {
  nassertr(Dtool_Ptr_LVecBase3d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase3d->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase3d *(*)(PyObject *, LVecBase3d &))Dtool_Ptr_LVecBase3d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3d = &Dtool_LVecBase3d;
extern LVecBase3d *Dtool_Coerce_LVecBase3d(PyObject *args, LVecBase3d &coerced);
#endif
// LPoint3f
#ifndef LINK_ALL_STATIC
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// LVecBase4d
#ifndef LINK_ALL_STATIC
inline static LVecBase4d *Dtool_Coerce_LVecBase4d(PyObject *args, LVecBase4d &coerced) {
  nassertr(Dtool_Ptr_LVecBase4d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase4d->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase4d *(*)(PyObject *, LVecBase4d &))Dtool_Ptr_LVecBase4d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4d = &Dtool_LVecBase4d;
extern LVecBase4d *Dtool_Coerce_LVecBase4d(PyObject *args, LVecBase4d &coerced);
#endif
// LPoint4f
#ifndef LINK_ALL_STATIC
inline static LPoint4f *Dtool_Coerce_LPoint4f(PyObject *args, LPoint4f &coerced) {
  nassertr(Dtool_Ptr_LPoint4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint4f *(*)(PyObject *, LPoint4f &))Dtool_Ptr_LPoint4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint4f = &Dtool_LPoint4f;
extern LPoint4f *Dtool_Coerce_LPoint4f(PyObject *args, LPoint4f &coerced);
#endif
// LPoint4d
#ifndef LINK_ALL_STATIC
inline static LPoint4d *Dtool_Coerce_LPoint4d(PyObject *args, LPoint4d &coerced) {
  nassertr(Dtool_Ptr_LPoint4d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint4d->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint4d *(*)(PyObject *, LPoint4d &))Dtool_Ptr_LPoint4d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint4d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint4d = &Dtool_LPoint4d;
extern LPoint4d *Dtool_Coerce_LPoint4d(PyObject *args, LPoint4d &coerced);
#endif
// LMatrix4f
#ifndef LINK_ALL_STATIC
inline static LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced) {
  nassertr(Dtool_Ptr_LMatrix4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LMatrix4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LMatrix4f *(*)(PyObject *, LMatrix4f &))Dtool_Ptr_LMatrix4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4f = &Dtool_LMatrix4f;
extern LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced);
#endif
// LMatrix4d
#ifndef LINK_ALL_STATIC
inline static LMatrix4d *Dtool_Coerce_LMatrix4d(PyObject *args, LMatrix4d &coerced) {
  nassertr(Dtool_Ptr_LMatrix4d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LMatrix4d->_Dtool_Coerce != nullptr, nullptr);
  return ((LMatrix4d *(*)(PyObject *, LMatrix4d &))Dtool_Ptr_LMatrix4d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4d = &Dtool_LMatrix4d;
extern LMatrix4d *Dtool_Coerce_LMatrix4d(PyObject *args, LMatrix4d &coerced);
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// BoundingHexahedron
#ifndef LINK_ALL_STATIC
inline static bool Dtool_ConstCoerce_BoundingHexahedron(PyObject *args, CPT(BoundingHexahedron) &coerced) {
  nassertr(Dtool_Ptr_BoundingHexahedron != nullptr, false);
  nassertr(Dtool_Ptr_BoundingHexahedron->_Dtool_ConstCoerce != nullptr, false);
  return ((bool (*)(PyObject *, CPT(BoundingHexahedron) &))Dtool_Ptr_BoundingHexahedron->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_BoundingHexahedron(PyObject *args, PT(BoundingHexahedron) &coerced) {
  nassertr(Dtool_Ptr_BoundingHexahedron != nullptr, false);
  nassertr(Dtool_Ptr_BoundingHexahedron->_Dtool_Coerce != nullptr, false);
  return ((bool (*)(PyObject *, PT(BoundingHexahedron) &))Dtool_Ptr_BoundingHexahedron->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_BoundingHexahedron;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BoundingHexahedron = &Dtool_BoundingHexahedron;
extern bool Dtool_ConstCoerce_BoundingHexahedron(PyObject *args, CPT(BoundingHexahedron) &coerced);
extern bool Dtool_Coerce_BoundingHexahedron(PyObject *args, PT(BoundingHexahedron) &coerced);
#endif
// StackedPerlinNoise2
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_StackedPerlinNoise2;
static struct Dtool_PyTypedObject *const Dtool_Ptr_StackedPerlinNoise2 = &Dtool_StackedPerlinNoise2;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python function wrapper for:
 * inline float decode_sRGB_float(float val)
 * inline float decode_sRGB_float(unsigned char val)
 */
static PyObject *Dtool_decode_sRGB_float_28(PyObject *, PyObject *arg) {
  {
    // -2 inline float decode_sRGB_float(unsigned char val)
    if (PyLongOrInt_Check(arg)) {
      long param0 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
      if (param0 < 0 || param0 > UCHAR_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for unsigned byte",
                            param0);
      }
#endif
      float return_value = (::decode_sRGB_float)((unsigned char)param0);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 inline float decode_sRGB_float(float val)
    if (PyNumber_Check(arg)) {
      float return_value = (::decode_sRGB_float)((float)PyFloat_AsDouble(arg));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: inline float decode_sRGB_float(unsigned char val)
  // No coercion possible: inline float decode_sRGB_float(float val)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "decode_sRGB_float(int val)\n"
      "decode_sRGB_float(float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_decode_sRGB_float_28_comment =
  "C++ Interface:\n"
  "decode_sRGB_float(int val)\n"
  "decode_sRGB_float(float val)\n";
#else
static const char *Dtool_decode_sRGB_float_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned char decode_sRGB_uchar(float val)
 * inline unsigned char decode_sRGB_uchar(unsigned char val)
 */
static PyObject *Dtool_decode_sRGB_uchar_29(PyObject *, PyObject *arg) {
  {
    // -2 inline unsigned char decode_sRGB_uchar(unsigned char val)
    if (PyLongOrInt_Check(arg)) {
      long param0 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
      if (param0 < 0 || param0 > UCHAR_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for unsigned byte",
                            param0);
      }
#endif
      unsigned char return_value = (::decode_sRGB_uchar)((unsigned char)param0);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 inline unsigned char decode_sRGB_uchar(float val)
    if (PyNumber_Check(arg)) {
      unsigned char return_value = (::decode_sRGB_uchar)((float)PyFloat_AsDouble(arg));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: inline unsigned char decode_sRGB_uchar(unsigned char val)
  // No coercion possible: inline unsigned char decode_sRGB_uchar(float val)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "decode_sRGB_uchar(int val)\n"
      "decode_sRGB_uchar(float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_decode_sRGB_uchar_29_comment =
  "C++ Interface:\n"
  "decode_sRGB_uchar(int val)\n"
  "decode_sRGB_uchar(float val)\n";
#else
static const char *Dtool_decode_sRGB_uchar_29_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float encode_sRGB_float(float val)
 * inline float encode_sRGB_float(unsigned char val)
 */
static PyObject *Dtool_encode_sRGB_float_30(PyObject *, PyObject *arg) {
  {
    // -2 inline float encode_sRGB_float(unsigned char val)
    if (PyLongOrInt_Check(arg)) {
      long param0 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
      if (param0 < 0 || param0 > UCHAR_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for unsigned byte",
                            param0);
      }
#endif
      float return_value = (::encode_sRGB_float)((unsigned char)param0);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 inline float encode_sRGB_float(float val)
    if (PyNumber_Check(arg)) {
      float return_value = (::encode_sRGB_float)((float)PyFloat_AsDouble(arg));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: inline float encode_sRGB_float(unsigned char val)
  // No coercion possible: inline float encode_sRGB_float(float val)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "encode_sRGB_float(int val)\n"
      "encode_sRGB_float(float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_encode_sRGB_float_30_comment =
  "C++ Interface:\n"
  "encode_sRGB_float(int val)\n"
  "encode_sRGB_float(float val)\n";
#else
static const char *Dtool_encode_sRGB_float_30_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned char encode_sRGB_uchar(float val)
 * inline unsigned char encode_sRGB_uchar(unsigned char val)
 */
static PyObject *Dtool_encode_sRGB_uchar_31(PyObject *, PyObject *arg) {
  {
    // -2 inline unsigned char encode_sRGB_uchar(unsigned char val)
    if (PyLongOrInt_Check(arg)) {
      long param0 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
      if (param0 < 0 || param0 > UCHAR_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for unsigned byte",
                            param0);
      }
#endif
      unsigned char return_value = (::encode_sRGB_uchar)((unsigned char)param0);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 inline unsigned char encode_sRGB_uchar(float val)
    if (PyNumber_Check(arg)) {
      unsigned char return_value = (::encode_sRGB_uchar)((float)PyFloat_AsDouble(arg));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: inline unsigned char encode_sRGB_uchar(unsigned char val)
  // No coercion possible: inline unsigned char encode_sRGB_uchar(float val)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "encode_sRGB_uchar(int val)\n"
      "encode_sRGB_uchar(float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_encode_sRGB_uchar_31_comment =
  "C++ Interface:\n"
  "encode_sRGB_uchar(int val)\n"
  "encode_sRGB_uchar(float val)\n";
#else
static const char *Dtool_encode_sRGB_uchar_31_comment = nullptr;
#endif

/**
 * Python wrappers for functions of class pixel
 */
/**
 * Python function wrapper for:
 * void pixel::output(std::ostream &out)
 */
static PyObject *Dtool_pixel_output_14(PyObject *self, PyObject *arg) {
  pixel *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_pixel, (void **)&local_this, "pixel.output")) {
    return nullptr;
  }
  // 1-void pixel::output(std::ostream &out)
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "pixel.output", false, true);
  if (arg_this != nullptr) {
    ((*local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(const pixel self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_pixel_output_14_comment =
  "C++ Interface:\n"
  "output(const pixel self, ostream out)\n";
#else
static const char *Dtool_pixel_output_14_comment = nullptr;
#endif

static PyObject *Dtool_pixel_b_Getter(PyObject *self, void *) {
  const pixel *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_pixel, (void **)&local_this)) {
    return nullptr;
  }

  // 1-gray pixel::get_b(void) const
  gray return_value = ((const pixel*)local_this)->b;
  return Dtool_WrapValue(return_value);
}

static int Dtool_pixel_b_Setter(PyObject *self, PyObject *arg, void *) {
  pixel *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_pixel, (void **)&local_this, "pixel.b")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete b attribute");
    return -1;
  }
  // 1-void pixel::set_b(gray value)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for unsigned short integer",
                   param1);
      return -1;
    }
#endif
    (local_this)->b = (gray)param1;
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_b(const pixel self, int value)\n");
  }
  return -1;
}

static PyObject *Dtool_pixel_g_Getter(PyObject *self, void *) {
  const pixel *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_pixel, (void **)&local_this)) {
    return nullptr;
  }

  // 1-gray pixel::get_g(void) const
  gray return_value = ((const pixel*)local_this)->g;
  return Dtool_WrapValue(return_value);
}

static int Dtool_pixel_g_Setter(PyObject *self, PyObject *arg, void *) {
  pixel *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_pixel, (void **)&local_this, "pixel.g")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete g attribute");
    return -1;
  }
  // 1-void pixel::set_g(gray value)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for unsigned short integer",
                   param1);
      return -1;
    }
#endif
    (local_this)->g = (gray)param1;
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_g(const pixel self, int value)\n");
  }
  return -1;
}

static PyObject *Dtool_pixel_r_Getter(PyObject *self, void *) {
  const pixel *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_pixel, (void **)&local_this)) {
    return nullptr;
  }

  // 1-gray pixel::get_r(void) const
  gray return_value = ((const pixel*)local_this)->r;
  return Dtool_WrapValue(return_value);
}

static int Dtool_pixel_r_Setter(PyObject *self, PyObject *arg, void *) {
  pixel *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_pixel, (void **)&local_this, "pixel.r")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete r attribute");
    return -1;
  }
  // 1-void pixel::set_r(gray value)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for unsigned short integer",
                   param1);
      return -1;
    }
#endif
    (local_this)->r = (gray)param1;
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_r(const pixel self, int value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * pixel::pixel(void) = default
 * pixel::pixel(gray fill)
 * pixel::pixel(gray r, gray g, gray b)
 * inline pixel::pixel(pixel const &) = default
 */
static int Dtool_Init_pixel(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-pixel::pixel(void) = default
      pixel *return_value = new pixel();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_pixel, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline pixel::pixel(pixel const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          pixel const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_pixel);
          if (param0_this != nullptr) {
            pixel *return_value = new pixel(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_pixel, true, false);
          }
        }
      }

      {
        // -2 pixel::pixel(gray fill)
        long param0;
        static const char *keyword_list[] = {"fill", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "l:pixel", (char **)keyword_list, &param0)) {
#ifndef NDEBUG
          if (param0 < 0 || param0 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param0);
            return -1;
          }
#endif
          pixel *return_value = new pixel((gray)param0);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_pixel, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline pixel::pixel(pixel const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          pixel param0_local;
          pixel const *param0_this = Dtool_Coerce_pixel(param0, param0_local);
          if ((param0_this != nullptr)) {
            pixel *return_value = new pixel(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_pixel, true, false);
          }
        }
      }

      // No coercion possible: pixel::pixel(gray fill)
    }
    break;
  case 3:
    {
      // 1-pixel::pixel(gray r, gray g, gray b)
      long param0;
      long param1;
      long param2;
      static const char *keyword_list[] = {"r", "g", "b", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "lll:pixel", (char **)keyword_list, &param0, &param1, &param2)) {
#ifndef NDEBUG
        if (param0 < 0 || param0 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param0);
          return -1;
        }
#endif
#ifndef NDEBUG
        if (param1 < 0 || param1 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param1);
          return -1;
        }
#endif
#ifndef NDEBUG
        if (param2 < 0 || param2 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param2);
          return -1;
        }
#endif
        pixel *return_value = new pixel((gray)param0, (gray)param1, (gray)param2);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_pixel, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "pixel() takes 0, 1 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "pixel()\n"
      "pixel(const pixel param0)\n"
      "pixel(int fill)\n"
      "pixel(int r, int g, int b)\n");
  }
  return -1;
}

pixel *Dtool_Coerce_pixel(PyObject *args, pixel &coerced) {
  pixel *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_pixel)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const pixel *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-pixel::pixel(gray fill)
    if (PyLongOrInt_Check(arg)) {
      long param0 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
      if (param0 < 0 || param0 > USHRT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for unsigned short integer",
                     param0);
        return nullptr;
      }
#endif
      coerced = pixel((gray)param0);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-pixel::pixel(gray r, gray g, gray b)
      long param0;
      long param1;
      long param2;
      if (PyArg_ParseTuple(args, "lll:pixel", &param0, &param1, &param2)) {
#ifndef NDEBUG
        if (param0 < 0 || param0 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param0);
          return nullptr;
        }
#endif
#ifndef NDEBUG
        if (param1 < 0 || param1 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param1);
          return nullptr;
        }
#endif
#ifndef NDEBUG
        if (param2 < 0 || param2 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param2);
          return nullptr;
        }
#endif
        coerced = pixel((gray)param0, (gray)param1, (gray)param2);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }
  }

  return nullptr;
}

static void *Dtool_UpcastInterface_pixel(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_pixel) {
    printf("pixel ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  pixel *local_this = (pixel *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_pixel) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_pixel(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_pixel) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PNMFileType
 */
/**
 * Python function wrapper for:
 * virtual std::string PNMFileType::get_name(void) const = 0
 */
static PyObject *Dtool_PNMFileType_get_name_34(PyObject *self, PyObject *) {
  PNMFileType *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMFileType)) {
    return nullptr;
  }
  // 1-virtual std::string PNMFileType::get_name(void) const = 0
  std::string return_value = ((*(const PNMFileType*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMFileType_get_name_34_comment =
  "C++ Interface:\n"
  "get_name(PNMFileType self)\n";
#else
static const char *Dtool_PNMFileType_get_name_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual int PNMFileType::get_num_extensions(void) const
 */
static PyObject *Dtool_PNMFileType_get_num_extensions_35(PyObject *self, PyObject *) {
  PNMFileType *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMFileType)) {
    return nullptr;
  }
  // 1-virtual int PNMFileType::get_num_extensions(void) const
  int return_value = ((*(const PNMFileType*)local_this).get_num_extensions)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMFileType_get_num_extensions_35_comment =
  "C++ Interface:\n"
  "get_num_extensions(PNMFileType self)\n"
  "\n"
  "/**\n"
  " * Returns the number of different possible filename extensions associated\n"
  " * with this particular file type.\n"
  " */";
#else
static const char *Dtool_PNMFileType_get_num_extensions_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual std::string PNMFileType::get_extension(int n) const
 */
static PyObject *Dtool_PNMFileType_get_extension_36(PyObject *self, PyObject *arg) {
  PNMFileType *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMFileType)) {
    return nullptr;
  }
  // 1-virtual std::string PNMFileType::get_extension(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = ((*(const PNMFileType*)local_this).get_extension)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_extension(PNMFileType self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMFileType_get_extension_36_comment =
  "C++ Interface:\n"
  "get_extension(PNMFileType self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth possible filename extension associated with this particular\n"
  " * file type, without a leading dot.\n"
  " */";
#else
static const char *Dtool_PNMFileType_get_extension_36_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual std::string PNMFileType::get_suggested_extension(void) const
 */
static PyObject *Dtool_PNMFileType_get_suggested_extension_38(PyObject *self, PyObject *) {
  PNMFileType *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMFileType)) {
    return nullptr;
  }
  // 1-virtual std::string PNMFileType::get_suggested_extension(void) const
  std::string return_value = ((*(const PNMFileType*)local_this).get_suggested_extension)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMFileType_get_suggested_extension_38_comment =
  "C++ Interface:\n"
  "get_suggested_extension(PNMFileType self)\n"
  "\n"
  "/**\n"
  " * Returns a suitable filename extension (without a leading dot) to suggest\n"
  " * for files of this type, or empty string if no suggestions are available.\n"
  " */";
#else
static const char *Dtool_PNMFileType_get_suggested_extension_38_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PNMFileType::get_class_type(void)
 */
static PyObject *Dtool_PNMFileType_get_class_type_44(PyObject *, PyObject *) {
  // 1-static TypeHandle PNMFileType::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((PNMFileType::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PNMFileType_get_class_type_44_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PNMFileType_get_class_type_44_comment = nullptr;
#endif

static PyObject *Dtool_PNMFileType_name_Getter(PyObject *self, void *) {
  const PNMFileType *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMFileType, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual std::string PNMFileType::get_name(void) const = 0
  std::string return_value = ((*(const PNMFileType*)local_this).get_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * sequence length function for property PNMFileType::extensions
 */
static Py_ssize_t Dtool_PNMFileType_extensions_Len(PyObject *self) {
  PNMFileType *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMFileType, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_extensions)();
}

/**
 * sequence getter for property PNMFileType::extensions
 */
static PyObject *Dtool_PNMFileType_extensions_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  PNMFileType *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMFileType, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_extensions)()) {
    PyErr_SetString(PyExc_IndexError, "PNMFileType.extensions[] index out of range");
    return nullptr;
  }
  // 1-virtual std::string PNMFileType::get_extension(int n) const
  std::string return_value = ((*(const PNMFileType*)local_this).get_extension)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_extension(PNMFileType self, index)\n");
  }
}

static PyObject *Dtool_PNMFileType_extensions_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "PNMFileType.extensions");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_PNMFileType_extensions_Len;
    wrap->_getitem_func = &Dtool_PNMFileType_extensions_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

static PyObject *Dtool_PNMFileType_suggested_extension_Getter(PyObject *self, void *) {
  const PNMFileType *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMFileType, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual std::string PNMFileType::get_suggested_extension(void) const
  std::string return_value = ((*(const PNMFileType*)local_this).get_suggested_extension)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_PNMFileType(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_PNMFileType_get_extensions(PyObject *self, PyObject *) {
  PNMFileType *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMFileType, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_extensions)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_PNMFileType_get_extension_36(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_PNMFileType(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PNMFileType) {
    printf("PNMFileType ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PNMFileType *local_this = (PNMFileType *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PNMFileType) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PNMFileType(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PNMFileType) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PNMFileType*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PNMFileType*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PNMFileTypeRegistry
 */
/**
 * Python function wrapper for:
 * int PNMFileTypeRegistry::get_num_types(void) const
 */
static PyObject *Dtool_PNMFileTypeRegistry_get_num_types_47(PyObject *self, PyObject *) {
  PNMFileTypeRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMFileTypeRegistry)) {
    return nullptr;
  }
  // 1-int PNMFileTypeRegistry::get_num_types(void) const
  int return_value = ((*(const PNMFileTypeRegistry*)local_this).get_num_types)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMFileTypeRegistry_get_num_types_47_comment =
  "C++ Interface:\n"
  "get_num_types(PNMFileTypeRegistry self)\n"
  "\n"
  "/**\n"
  " * Returns the total number of types registered.\n"
  " */";
#else
static const char *Dtool_PNMFileTypeRegistry_get_num_types_47_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PNMFileType *PNMFileTypeRegistry::get_type(int n) const
 */
static PyObject *Dtool_PNMFileTypeRegistry_get_type_48(PyObject *self, PyObject *arg) {
  PNMFileTypeRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMFileTypeRegistry)) {
    return nullptr;
  }
  // 1-PNMFileType *PNMFileTypeRegistry::get_type(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PNMFileType *return_value = ((*(const PNMFileTypeRegistry*)local_this).get_type)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PNMFileType, false, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_type(PNMFileTypeRegistry self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMFileTypeRegistry_get_type_48_comment =
  "C++ Interface:\n"
  "get_type(PNMFileTypeRegistry self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth type registered.\n"
  " */";
#else
static const char *Dtool_PNMFileTypeRegistry_get_type_48_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PNMFileType *PNMFileTypeRegistry::get_type_from_extension(std::string const &filename) const
 */
static PyObject *Dtool_PNMFileTypeRegistry_get_type_from_extension_52(PyObject *self, PyObject *arg) {
  PNMFileTypeRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMFileTypeRegistry)) {
    return nullptr;
  }
  // 1-PNMFileType *PNMFileTypeRegistry::get_type_from_extension(std::string const &filename) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    PNMFileType *return_value = ((*(const PNMFileTypeRegistry*)local_this).get_type_from_extension)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PNMFileType, false, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_type_from_extension(PNMFileTypeRegistry self, str filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMFileTypeRegistry_get_type_from_extension_52_comment =
  "C++ Interface:\n"
  "get_type_from_extension(PNMFileTypeRegistry self, str filename)\n"
  "\n"
  "/**\n"
  " * Tries to determine what the PNMFileType is likely to be for a particular\n"
  " * image file based on its extension.  Returns a suitable PNMFileType pointer,\n"
  " * or NULL if no type can be determined.\n"
  " */";
#else
static const char *Dtool_PNMFileTypeRegistry_get_type_from_extension_52_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PNMFileType *PNMFileTypeRegistry::get_type_from_magic_number(std::string const &magic_number) const
 */
static PyObject *Dtool_PNMFileTypeRegistry_get_type_from_magic_number_53(PyObject *self, PyObject *arg) {
  PNMFileTypeRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMFileTypeRegistry)) {
    return nullptr;
  }
  // 1-PNMFileType *PNMFileTypeRegistry::get_type_from_magic_number(std::string const &magic_number) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    PNMFileType *return_value = ((*(const PNMFileTypeRegistry*)local_this).get_type_from_magic_number)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PNMFileType, false, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_type_from_magic_number(PNMFileTypeRegistry self, str magic_number)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMFileTypeRegistry_get_type_from_magic_number_53_comment =
  "C++ Interface:\n"
  "get_type_from_magic_number(PNMFileTypeRegistry self, str magic_number)\n"
  "\n"
  "/**\n"
  " * Tries to determine what the PNMFileType is likely to be for a particular\n"
  " * image file based on its magic number, the first two bytes read from the\n"
  " * file.  Returns a suitable PNMFileType pointer, or NULL if no type can be\n"
  " * determined.\n"
  " */";
#else
static const char *Dtool_PNMFileTypeRegistry_get_type_from_magic_number_53_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PNMFileType *PNMFileTypeRegistry::get_type_by_handle(TypeHandle handle) const
 */
static PyObject *Dtool_PNMFileTypeRegistry_get_type_by_handle_54(PyObject *self, PyObject *arg) {
  PNMFileTypeRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMFileTypeRegistry)) {
    return nullptr;
  }
  // 1-PNMFileType *PNMFileTypeRegistry::get_type_by_handle(TypeHandle handle) const
  TypeHandle arg_local;
  TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PNMFileTypeRegistry.get_type_by_handle", "TypeHandle");
  }
  PNMFileType *return_value = ((*(const PNMFileTypeRegistry*)local_this).get_type_by_handle)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PNMFileType, false, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_type_by_handle(PNMFileTypeRegistry self, TypeHandle handle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMFileTypeRegistry_get_type_by_handle_54_comment =
  "C++ Interface:\n"
  "get_type_by_handle(PNMFileTypeRegistry self, TypeHandle handle)\n"
  "\n"
  "/**\n"
  " * Returns the PNMFileType instance stored in the registry for the given\n"
  " * TypeHandle, e.g.  as retrieved by a previous call to get_type() on the type\n"
  " * instance.\n"
  " */";
#else
static const char *Dtool_PNMFileTypeRegistry_get_type_by_handle_54_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMFileTypeRegistry::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_PNMFileTypeRegistry_write_55(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMFileTypeRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMFileTypeRegistry)) {
    return nullptr;
  }
  // 1-void PNMFileTypeRegistry::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "PNMFileTypeRegistry.write", false, true);
    if (param1_this != nullptr) {
      ((*(const PNMFileTypeRegistry*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(PNMFileTypeRegistry self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMFileTypeRegistry_write_55_comment =
  "C++ Interface:\n"
  "write(PNMFileTypeRegistry self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes a list of supported image file types to the indicated output stream,\n"
  " * one per line.\n"
  " */";
#else
static const char *Dtool_PNMFileTypeRegistry_write_55_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PNMFileTypeRegistry *PNMFileTypeRegistry::get_global_ptr(void)
 */
static PyObject *Dtool_PNMFileTypeRegistry_get_global_ptr_56(PyObject *, PyObject *) {
  // 1-static PNMFileTypeRegistry *PNMFileTypeRegistry::get_global_ptr(void)
  PNMFileTypeRegistry *return_value = (PNMFileTypeRegistry::get_global_ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMFileTypeRegistry, false, false);
}

#ifndef NDEBUG
static const char *Dtool_PNMFileTypeRegistry_get_global_ptr_56_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the global PNMFileTypeRegistry object.\n"
  " */";
#else
static const char *Dtool_PNMFileTypeRegistry_get_global_ptr_56_comment = nullptr;
#endif

/**
 * sequence length function for property PNMFileTypeRegistry::types
 */
static Py_ssize_t Dtool_PNMFileTypeRegistry_types_Len(PyObject *self) {
  PNMFileTypeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMFileTypeRegistry, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_types)();
}

/**
 * sequence getter for property PNMFileTypeRegistry::types
 */
static PyObject *Dtool_PNMFileTypeRegistry_types_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  PNMFileTypeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMFileTypeRegistry, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_types)()) {
    PyErr_SetString(PyExc_IndexError, "PNMFileTypeRegistry.types[] index out of range");
    return nullptr;
  }
  // 1-PNMFileType *PNMFileTypeRegistry::get_type(int n) const
  PNMFileType *return_value = ((*(const PNMFileTypeRegistry*)local_this).get_type)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PNMFileType, false, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_type(PNMFileTypeRegistry self, index)\n");
  }
}

static PyObject *Dtool_PNMFileTypeRegistry_types_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "PNMFileTypeRegistry.types");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_PNMFileTypeRegistry_types_Len;
    wrap->_getitem_func = &Dtool_PNMFileTypeRegistry_types_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * inline PNMFileTypeRegistry::PNMFileTypeRegistry(PNMFileTypeRegistry const &) = default
 */
static int Dtool_Init_PNMFileTypeRegistry(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("PNMFileTypeRegistry() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline PNMFileTypeRegistry::PNMFileTypeRegistry(PNMFileTypeRegistry const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    PNMFileTypeRegistry const *param0_this = (PNMFileTypeRegistry *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PNMFileTypeRegistry, 0, "PNMFileTypeRegistry.PNMFileTypeRegistry", true, true);
    if (param0_this != nullptr) {
      PNMFileTypeRegistry *return_value = new PNMFileTypeRegistry(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMFileTypeRegistry, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PNMFileTypeRegistry(const PNMFileTypeRegistry param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_PNMFileTypeRegistry_get_types(PyObject *self, PyObject *) {
  PNMFileTypeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMFileTypeRegistry, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_types)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_PNMFileTypeRegistry_get_type_48(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_PNMFileTypeRegistry(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PNMFileTypeRegistry) {
    printf("PNMFileTypeRegistry ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PNMFileTypeRegistry *local_this = (PNMFileTypeRegistry *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PNMFileTypeRegistry) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PNMFileTypeRegistry(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PNMFileTypeRegistry) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PNMImageHeader
 */
/**
 * Python function wrapper for:
 * inline void PNMImageHeader::operator =(PNMImageHeader const &copy)
 */
static PyObject *Dtool_PNMImageHeader_operator_60(PyObject *self, PyObject *arg) {
  PNMImageHeader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImageHeader, (void **)&local_this, "PNMImageHeader.assign")) {
    return nullptr;
  }
  // 1-inline void PNMImageHeader::operator =(PNMImageHeader const &copy)
  PNMImageHeader const *arg_this = (PNMImageHeader *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImageHeader, 1, "PNMImageHeader.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    PNMImageHeader *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImageHeader, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const PNMImageHeader self, const PNMImageHeader copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_operator_60_comment =
  "C++ Interface:\n"
  "assign(const PNMImageHeader self, const PNMImageHeader copy)\n";
#else
static const char *Dtool_PNMImageHeader_operator_60_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PNMImageHeader::ColorType PNMImageHeader::get_color_type(void) const
 */
static PyObject *Dtool_PNMImageHeader_get_color_type_63(PyObject *self, PyObject *) {
  PNMImageHeader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImageHeader)) {
    return nullptr;
  }
  // 1-inline PNMImageHeader::ColorType PNMImageHeader::get_color_type(void) const
  PNMImageHeader::ColorType return_value = ((*(const PNMImageHeader*)local_this).get_color_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_get_color_type_63_comment =
  "C++ Interface:\n"
  "get_color_type(PNMImageHeader self)\n"
  "\n"
  "/**\n"
  " * Returns the image type of the image, as an enumerated value.  This is\n"
  " * really just the number of channels cast to the enumerated type.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_get_color_type_63_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PNMImageHeader::get_num_channels(void) const
 */
static PyObject *Dtool_PNMImageHeader_get_num_channels_64(PyObject *self, PyObject *) {
  PNMImageHeader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImageHeader)) {
    return nullptr;
  }
  // 1-inline int PNMImageHeader::get_num_channels(void) const
  int return_value = ((*(const PNMImageHeader*)local_this).get_num_channels)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_get_num_channels_64_comment =
  "C++ Interface:\n"
  "get_num_channels(PNMImageHeader self)\n"
  "\n"
  "/**\n"
  " * Returns the number of channels in the image.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_get_num_channels_64_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PNMImageHeader::is_grayscale(void) const
 * static inline bool PNMImageHeader::is_grayscale(PNMImageHeader::ColorType color_type)
 */
static PyObject *Dtool_PNMImageHeader_is_grayscale_67(PyObject *self, PyObject *args) {
  PNMImageHeader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImageHeader)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline bool PNMImageHeader::is_grayscale(void) const
      bool return_value = ((*(const PNMImageHeader*)local_this).is_grayscale)();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-static inline bool PNMImageHeader::is_grayscale(PNMImageHeader::ColorType color_type)
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        bool return_value = (PNMImageHeader::is_grayscale)((PNMImageHeader::ColorType)arg_val);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "is_grayscale() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_grayscale(PNMImageHeader self)\n"
      "is_grayscale(int color_type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_is_grayscale_67_comment =
  "C++ Interface:\n"
  "is_grayscale(PNMImageHeader self)\n"
  "is_grayscale(int color_type)\n"
  "\n"
  "/**\n"
  " * This static variant of is_grayscale() returns true if the indicated image\n"
  " * type represents a grayscale image, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns false if the image is a full-color image, and has red, green, and\n"
  " * blue components; true if it is a grayscale image and has only a gray\n"
  " * component.  (The gray color is actually stored in the blue channel, and the\n"
  " * red and green channels are ignored.)\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_is_grayscale_67_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PNMImageHeader::has_alpha(void) const
 * static inline bool PNMImageHeader::has_alpha(PNMImageHeader::ColorType color_type)
 */
static PyObject *Dtool_PNMImageHeader_has_alpha_68(PyObject *self, PyObject *args) {
  PNMImageHeader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImageHeader)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline bool PNMImageHeader::has_alpha(void) const
      bool return_value = ((*(const PNMImageHeader*)local_this).has_alpha)();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-static inline bool PNMImageHeader::has_alpha(PNMImageHeader::ColorType color_type)
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        bool return_value = (PNMImageHeader::has_alpha)((PNMImageHeader::ColorType)arg_val);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "has_alpha() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_alpha(PNMImageHeader self)\n"
      "has_alpha(int color_type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_has_alpha_68_comment =
  "C++ Interface:\n"
  "has_alpha(PNMImageHeader self)\n"
  "has_alpha(int color_type)\n"
  "\n"
  "/**\n"
  " * This static variant of has_alpha() returns true if the indicated image type\n"
  " * includes an alpha channel, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if the image includes an alpha channel, false otherwise.\n"
  " * Unlike is_grayscale(), if this returns false it is an error to call any of\n"
  " * the functions accessing the alpha channel.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_has_alpha_68_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline xelval PNMImageHeader::get_maxval(void) const
 */
static PyObject *Dtool_PNMImageHeader_get_maxval_69(PyObject *self, PyObject *) {
  PNMImageHeader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImageHeader)) {
    return nullptr;
  }
  // 1-inline xelval PNMImageHeader::get_maxval(void) const
  xelval return_value = ((*(const PNMImageHeader*)local_this).get_maxval)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_get_maxval_69_comment =
  "C++ Interface:\n"
  "get_maxval(PNMImageHeader self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum channel value allowable for any pixel in this image;\n"
  " * for instance, 255 for a typical 8-bit-per-channel image.  A pixel with this\n"
  " * value is full on.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_get_maxval_69_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ColorSpace PNMImageHeader::get_color_space(void) const
 */
static PyObject *Dtool_PNMImageHeader_get_color_space_70(PyObject *self, PyObject *) {
  PNMImageHeader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImageHeader)) {
    return nullptr;
  }
  // 1-inline ColorSpace PNMImageHeader::get_color_space(void) const
  ColorSpace return_value = ((*(const PNMImageHeader*)local_this).get_color_space)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_get_color_space_70_comment =
  "C++ Interface:\n"
  "get_color_space(PNMImageHeader self)\n"
  "\n"
  "/**\n"
  " * Returns the color space that the image is encoded in, or CS_unspecified if\n"
  " * unknown.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_get_color_space_70_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PNMImageHeader::get_x_size(void) const
 */
static PyObject *Dtool_PNMImageHeader_get_x_size_75(PyObject *self, PyObject *) {
  PNMImageHeader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImageHeader)) {
    return nullptr;
  }
  // 1-inline int PNMImageHeader::get_x_size(void) const
  int return_value = ((*(const PNMImageHeader*)local_this).get_x_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_get_x_size_75_comment =
  "C++ Interface:\n"
  "get_x_size(PNMImageHeader self)\n"
  "\n"
  "/**\n"
  " * Returns the number of pixels in the X direction.  This is one more than the\n"
  " * largest allowable X coordinate.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_get_x_size_75_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PNMImageHeader::get_y_size(void) const
 */
static PyObject *Dtool_PNMImageHeader_get_y_size_76(PyObject *self, PyObject *) {
  PNMImageHeader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImageHeader)) {
    return nullptr;
  }
  // 1-inline int PNMImageHeader::get_y_size(void) const
  int return_value = ((*(const PNMImageHeader*)local_this).get_y_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_get_y_size_76_comment =
  "C++ Interface:\n"
  "get_y_size(PNMImageHeader self)\n"
  "\n"
  "/**\n"
  " * Returns the number of pixels in the Y direction.  This is one more than the\n"
  " * largest allowable Y coordinate.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_get_y_size_76_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2i PNMImageHeader::get_size(void) const
 */
static PyObject *Dtool_PNMImageHeader_get_size_77(PyObject *self, PyObject *) {
  PNMImageHeader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImageHeader)) {
    return nullptr;
  }
  // 1-inline LVecBase2i PNMImageHeader::get_size(void) const
  LVecBase2i *return_value = new LVecBase2i(((*(const PNMImageHeader*)local_this).get_size)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_get_size_77_comment =
  "C++ Interface:\n"
  "get_size(PNMImageHeader self)\n"
  "\n"
  "/**\n"
  " * Returns the number of pixels in each direction.  This is one more than the\n"
  " * largest allowable coordinates.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_get_size_77_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string PNMImageHeader::get_comment(void) const
 */
static PyObject *Dtool_PNMImageHeader_get_comment_80(PyObject *self, PyObject *) {
  PNMImageHeader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImageHeader)) {
    return nullptr;
  }
  // 1-inline std::string PNMImageHeader::get_comment(void) const
  std::string return_value = ((*(const PNMImageHeader*)local_this).get_comment)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_get_comment_80_comment =
  "C++ Interface:\n"
  "get_comment(PNMImageHeader self)\n"
  "\n"
  "/**\n"
  " * Gets the user comment from the file.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_get_comment_80_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImageHeader::set_comment(std::string const &comment)
 */
static PyObject *Dtool_PNMImageHeader_set_comment_81(PyObject *self, PyObject *arg) {
  PNMImageHeader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImageHeader, (void **)&local_this, "PNMImageHeader.set_comment")) {
    return nullptr;
  }
  // 1-inline void PNMImageHeader::set_comment(std::string const &comment)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_comment)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_comment(const PNMImageHeader self, str comment)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_set_comment_81_comment =
  "C++ Interface:\n"
  "set_comment(const PNMImageHeader self, str comment)\n"
  "\n"
  "/**\n"
  " * Writes a user comment string to the image (header).\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_set_comment_81_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PNMImageHeader::has_type(void) const
 */
static PyObject *Dtool_PNMImageHeader_has_type_83(PyObject *self, PyObject *) {
  PNMImageHeader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImageHeader)) {
    return nullptr;
  }
  // 1-inline bool PNMImageHeader::has_type(void) const
  bool return_value = ((*(const PNMImageHeader*)local_this).has_type)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_has_type_83_comment =
  "C++ Interface:\n"
  "has_type(PNMImageHeader self)\n"
  "\n"
  "/**\n"
  " * Returns true if the PNMImageHeader knows what type it is, false otherwise.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_has_type_83_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PNMFileType *PNMImageHeader::get_type(void) const
 */
static PyObject *Dtool_PNMImageHeader_get_type_84(PyObject *self, PyObject *) {
  PNMImageHeader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImageHeader)) {
    return nullptr;
  }
  // 1-inline PNMFileType *PNMImageHeader::get_type(void) const
  PNMFileType *return_value = ((*(const PNMImageHeader*)local_this).get_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PNMFileType, false, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_get_type_84_comment =
  "C++ Interface:\n"
  "get_type(PNMImageHeader self)\n"
  "\n"
  "/**\n"
  " * If the file type is known (e.g.  has_type() returns true), returns its\n"
  " * PNMFileType pointer; otherwise, returns NULL.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_get_type_84_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImageHeader::set_type(PNMFileType *type)
 */
static PyObject *Dtool_PNMImageHeader_set_type_85(PyObject *self, PyObject *arg) {
  PNMImageHeader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImageHeader, (void **)&local_this, "PNMImageHeader.set_type")) {
    return nullptr;
  }
  // 1-inline void PNMImageHeader::set_type(PNMFileType *type)
  PNMFileType *arg_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMFileType, 1, "PNMImageHeader.set_type", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_type)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_type(const PNMImageHeader self, PNMFileType type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_set_type_85_comment =
  "C++ Interface:\n"
  "set_type(const PNMImageHeader self, PNMFileType type)\n"
  "\n"
  "/**\n"
  " * Sets the file type of this PNMImage.  This will be the default type used\n"
  " * when an image is read, if the type cannot be determined by magic number or\n"
  " * inferred by extension, or the type used when the image is written, if the\n"
  " * type cannot be inferred from the filename extension.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_set_type_85_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PNMImageHeader::read_header(Filename const &filename, PNMFileType *type = nullptr, bool report_unknown_type = true)
 * bool PNMImageHeader::read_header(std::istream &data, std::string const &filename = string(), PNMFileType *type = nullptr, bool report_unknown_type = true)
 */
static PyObject *Dtool_PNMImageHeader_read_header_87(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImageHeader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImageHeader, (void **)&local_this, "PNMImageHeader.read_header")) {
    return nullptr;
  }
  {
    // -2 bool PNMImageHeader::read_header(std::istream &data, std::string const &filename = string(), PNMFileType *type = nullptr, bool report_unknown_type = true)
    PyObject *param1;
    const char *param2_str = "";
    Py_ssize_t param2_len = 0;
    PyObject *param3 = nullptr;
    PyObject *param4 = Py_True;
    static const char *keyword_list[] = {"data", "filename", "type", "report_unknown_type", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#OO:read_header", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3, &param4)) {
      std::istream *param1_this = (std::istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_istream, 1, "PNMImageHeader.read_header", false, false);
      PNMFileType *param3_this = nullptr;
      if (param3 != nullptr && param3 != Py_None) {
        param3_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_PNMFileType, 3, "PNMImageHeader.read_header", false, false);
      }
      if (param1_this != nullptr && (param3 == nullptr || param3 == Py_None || param3_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = ((*local_this).read_header)(*param1_this, std::string(param2_str, param2_len), param3_this, (PyObject_IsTrue(param4) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: bool PNMImageHeader::read_header(std::istream &data, std::string const &filename = string(), PNMFileType *type = nullptr, bool report_unknown_type = true)
  {
    // -2 bool PNMImageHeader::read_header(Filename const &filename, PNMFileType *type = nullptr, bool report_unknown_type = true)
    PyObject *param1;
    PyObject *param2 = nullptr;
    PyObject *param3 = Py_True;
    static const char *keyword_list[] = {"filename", "type", "report_unknown_type", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|OO:read_header", (char **)keyword_list, &param1, &param2, &param3)) {
      Filename param1_local;
      Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
      PNMFileType *param2_this = nullptr;
      if (param2 != nullptr && param2 != Py_None) {
        param2_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PNMFileType, 2, "PNMImageHeader.read_header", false, false);
      }
      if ((param1_this != nullptr) && (param2 == nullptr || param2 == Py_None || param2_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = ((*local_this).read_header)(*param1_this, param2_this, (PyObject_IsTrue(param3) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_header(const PNMImageHeader self, istream data, str filename, PNMFileType type, bool report_unknown_type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_read_header_87_comment =
  "C++ Interface:\n"
  "read_header(const PNMImageHeader self, istream data, str filename, PNMFileType type, bool report_unknown_type)\n"
  "\n"
  "/**\n"
  " * Opens up the image file and tries to read its header information to\n"
  " * determine its size, number of channels, etc.  If successful, updates the\n"
  " * header information and returns true; otherwise, returns false.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Reads the image header information only from the indicated stream.\n"
  " *\n"
  " * The filename is advisory only, and may be used to suggest a type if it has\n"
  " * a known extension.\n"
  " *\n"
  " * If type is non-NULL, it is a suggestion for the type of file it is (and a\n"
  " * non-NULL type will override any magic number test or filename extension\n"
  " * lookup).\n"
  " *\n"
  " * Returns true if successful, false on error.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_read_header_87_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImageHeader::output(std::ostream &out) const
 */
static PyObject *Dtool_PNMImageHeader_output_91(PyObject *self, PyObject *arg) {
  PNMImageHeader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImageHeader)) {
    return nullptr;
  }
  // 1-void PNMImageHeader::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PNMImageHeader.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PNMImageHeader*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PNMImageHeader self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_output_91_comment =
  "C++ Interface:\n"
  "output(PNMImageHeader self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_output_91_comment = nullptr;
#endif

static PyObject *Dtool_PNMImageHeader_num_channels_Getter(PyObject *self, void *) {
  const PNMImageHeader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int PNMImageHeader::get_num_channels(void) const
  int return_value = ((*(const PNMImageHeader*)local_this).get_num_channels)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PNMImageHeader_maxval_Getter(PyObject *self, void *) {
  const PNMImageHeader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline xelval PNMImageHeader::get_maxval(void) const
  xelval return_value = ((*(const PNMImageHeader*)local_this).get_maxval)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PNMImageHeader_color_space_Getter(PyObject *self, void *) {
  const PNMImageHeader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline ColorSpace PNMImageHeader::get_color_space(void) const
  ColorSpace return_value = ((*(const PNMImageHeader*)local_this).get_color_space)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PNMImageHeader_size_Getter(PyObject *self, void *) {
  const PNMImageHeader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVecBase2i PNMImageHeader::get_size(void) const
  LVecBase2i *return_value = new LVecBase2i(((*(const PNMImageHeader*)local_this).get_size)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
}

static PyObject *Dtool_PNMImageHeader_comment_Getter(PyObject *self, void *) {
  const PNMImageHeader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string PNMImageHeader::get_comment(void) const
  std::string return_value = ((*(const PNMImageHeader*)local_this).get_comment)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_PNMImageHeader_comment_Setter(PyObject *self, PyObject *arg, void *) {
  PNMImageHeader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImageHeader, (void **)&local_this, "PNMImageHeader.comment")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete comment attribute");
    return -1;
  }
  // 1-inline void PNMImageHeader::set_comment(std::string const &comment)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_comment)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_comment(const PNMImageHeader self, str comment)\n");
  }
  return -1;
}

static PyObject *Dtool_PNMImageHeader_type_Getter(PyObject *self, void *) {
  const PNMImageHeader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_type()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline PNMFileType *PNMImageHeader::get_type(void) const
  PNMFileType *return_value = ((*(const PNMImageHeader*)local_this).get_type)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PNMFileType, false, false, return_value->as_typed_object()->get_type_index());
  }
}

/**
 * Python function wrapper for:
 * inline PNMImageHeader::PNMImageHeader(void)
 * inline PNMImageHeader::PNMImageHeader(PNMImageHeader const &copy)
 */
static int Dtool_Init_PNMImageHeader(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PNMImageHeader::PNMImageHeader(void)
      PNMImageHeader *return_value = new PNMImageHeader();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImageHeader, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-inline PNMImageHeader::PNMImageHeader(PNMImageHeader const &copy)
        PNMImageHeader const *arg_this = (PNMImageHeader *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImageHeader, 0, "PNMImageHeader.PNMImageHeader", true, true);
        if (arg_this != nullptr) {
          PNMImageHeader *return_value = new PNMImageHeader(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImageHeader, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PNMImageHeader() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PNMImageHeader()\n"
      "PNMImageHeader(const PNMImageHeader copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PNMImageHeader(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PNMImageHeader) {
    printf("PNMImageHeader ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PNMImageHeader *local_this = (PNMImageHeader *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PNMImageHeader) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PNMImageHeader(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PNMImageHeader) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PNMImageHeader::PixelSpec
 */
/**
 * Python function wrapper for:
 * inline int PNMImageHeader::PixelSpec::compare_to(PNMImageHeader::PixelSpec const &other) const
 */
static PyObject *Dtool_PNMImageHeader_PixelSpec_compare_to_97(PyObject *self, PyObject *arg) {
  PNMImageHeader::PixelSpec *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImageHeader_PixelSpec)) {
    return nullptr;
  }
  // 1-inline int PNMImageHeader::PixelSpec::compare_to(PNMImageHeader::PixelSpec const &other) const
  PNMImageHeader::PixelSpec arg_local;
  PNMImageHeader::PixelSpec const *arg_this = Dtool_Coerce_PNMImageHeader_PixelSpec(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PixelSpec.compare_to", "PixelSpec");
  }
  int return_value = ((*(const PNMImageHeader::PixelSpec*)local_this).compare_to)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(PixelSpec self, const PixelSpec other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_PixelSpec_compare_to_97_comment =
  "C++ Interface:\n"
  "compare_to(PixelSpec self, const PixelSpec other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_PixelSpec_compare_to_97_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline xelval PNMImageHeader::PixelSpec::get_red(void) const
 */
static PyObject *Dtool_PNMImageHeader_PixelSpec_get_red_98(PyObject *self, PyObject *) {
  PNMImageHeader::PixelSpec *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImageHeader_PixelSpec)) {
    return nullptr;
  }
  // 1-inline xelval PNMImageHeader::PixelSpec::get_red(void) const
  xelval return_value = ((*(const PNMImageHeader::PixelSpec*)local_this).get_red)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_PixelSpec_get_red_98_comment =
  "C++ Interface:\n"
  "get_red(PixelSpec self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_PixelSpec_get_red_98_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline xelval PNMImageHeader::PixelSpec::get_green(void) const
 */
static PyObject *Dtool_PNMImageHeader_PixelSpec_get_green_99(PyObject *self, PyObject *) {
  PNMImageHeader::PixelSpec *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImageHeader_PixelSpec)) {
    return nullptr;
  }
  // 1-inline xelval PNMImageHeader::PixelSpec::get_green(void) const
  xelval return_value = ((*(const PNMImageHeader::PixelSpec*)local_this).get_green)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_PixelSpec_get_green_99_comment =
  "C++ Interface:\n"
  "get_green(PixelSpec self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_PixelSpec_get_green_99_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline xelval PNMImageHeader::PixelSpec::get_blue(void) const
 */
static PyObject *Dtool_PNMImageHeader_PixelSpec_get_blue_100(PyObject *self, PyObject *) {
  PNMImageHeader::PixelSpec *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImageHeader_PixelSpec)) {
    return nullptr;
  }
  // 1-inline xelval PNMImageHeader::PixelSpec::get_blue(void) const
  xelval return_value = ((*(const PNMImageHeader::PixelSpec*)local_this).get_blue)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_PixelSpec_get_blue_100_comment =
  "C++ Interface:\n"
  "get_blue(PixelSpec self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_PixelSpec_get_blue_100_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline xelval PNMImageHeader::PixelSpec::get_alpha(void) const
 */
static PyObject *Dtool_PNMImageHeader_PixelSpec_get_alpha_101(PyObject *self, PyObject *) {
  PNMImageHeader::PixelSpec *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImageHeader_PixelSpec)) {
    return nullptr;
  }
  // 1-inline xelval PNMImageHeader::PixelSpec::get_alpha(void) const
  xelval return_value = ((*(const PNMImageHeader::PixelSpec*)local_this).get_alpha)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_PixelSpec_get_alpha_101_comment =
  "C++ Interface:\n"
  "get_alpha(PixelSpec self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_PixelSpec_get_alpha_101_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImageHeader::PixelSpec::set_red(xelval red)
 */
static PyObject *Dtool_PNMImageHeader_PixelSpec_set_red_102(PyObject *self, PyObject *arg) {
  PNMImageHeader::PixelSpec *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImageHeader_PixelSpec, (void **)&local_this, "PNMImageHeader::PixelSpec.set_red")) {
    return nullptr;
  }
  // 1-inline void PNMImageHeader::PixelSpec::set_red(xelval red)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    ((*local_this).set_red)((xelval)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_red(const PixelSpec self, int red)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_PixelSpec_set_red_102_comment =
  "C++ Interface:\n"
  "set_red(const PixelSpec self, int red)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_PixelSpec_set_red_102_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImageHeader::PixelSpec::set_green(xelval green)
 */
static PyObject *Dtool_PNMImageHeader_PixelSpec_set_green_103(PyObject *self, PyObject *arg) {
  PNMImageHeader::PixelSpec *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImageHeader_PixelSpec, (void **)&local_this, "PNMImageHeader::PixelSpec.set_green")) {
    return nullptr;
  }
  // 1-inline void PNMImageHeader::PixelSpec::set_green(xelval green)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    ((*local_this).set_green)((xelval)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_green(const PixelSpec self, int green)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_PixelSpec_set_green_103_comment =
  "C++ Interface:\n"
  "set_green(const PixelSpec self, int green)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_PixelSpec_set_green_103_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImageHeader::PixelSpec::set_blue(xelval blue)
 */
static PyObject *Dtool_PNMImageHeader_PixelSpec_set_blue_104(PyObject *self, PyObject *arg) {
  PNMImageHeader::PixelSpec *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImageHeader_PixelSpec, (void **)&local_this, "PNMImageHeader::PixelSpec.set_blue")) {
    return nullptr;
  }
  // 1-inline void PNMImageHeader::PixelSpec::set_blue(xelval blue)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    ((*local_this).set_blue)((xelval)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_blue(const PixelSpec self, int blue)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_PixelSpec_set_blue_104_comment =
  "C++ Interface:\n"
  "set_blue(const PixelSpec self, int blue)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_PixelSpec_set_blue_104_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImageHeader::PixelSpec::set_alpha(xelval alpha)
 */
static PyObject *Dtool_PNMImageHeader_PixelSpec_set_alpha_105(PyObject *self, PyObject *arg) {
  PNMImageHeader::PixelSpec *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImageHeader_PixelSpec, (void **)&local_this, "PNMImageHeader::PixelSpec.set_alpha")) {
    return nullptr;
  }
  // 1-inline void PNMImageHeader::PixelSpec::set_alpha(xelval alpha)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    ((*local_this).set_alpha)((xelval)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_alpha(const PixelSpec self, int alpha)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_PixelSpec_set_alpha_105_comment =
  "C++ Interface:\n"
  "set_alpha(const PixelSpec self, int alpha)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_PixelSpec_set_alpha_105_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImageHeader::PixelSpec::output(std::ostream &out) const
 */
static PyObject *Dtool_PNMImageHeader_PixelSpec_output_108(PyObject *self, PyObject *arg) {
  PNMImageHeader::PixelSpec *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImageHeader_PixelSpec)) {
    return nullptr;
  }
  // 1-void PNMImageHeader::PixelSpec::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PixelSpec.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PNMImageHeader::PixelSpec*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PixelSpec self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_PixelSpec_output_108_comment =
  "C++ Interface:\n"
  "output(PixelSpec self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_PixelSpec_output_108_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PNMImageHeader::PixelSpec::PixelSpec(PNMImageHeader::PixelSpec const &) = default
 * inline PNMImageHeader::PixelSpec::PixelSpec(xel const &rgb)
 * inline PNMImageHeader::PixelSpec::PixelSpec(xel const &rgb, xelval alpha)
 * inline PNMImageHeader::PixelSpec::PixelSpec(xelval gray_value)
 * inline PNMImageHeader::PixelSpec::PixelSpec(xelval gray_value, xelval alpha)
 * inline PNMImageHeader::PixelSpec::PixelSpec(xelval red, xelval green, xelval blue)
 * inline PNMImageHeader::PixelSpec::PixelSpec(xelval red, xelval green, xelval blue, xelval alpha)
 */
static int Dtool_Init_PNMImageHeader_PixelSpec(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline PNMImageHeader::PixelSpec::PixelSpec(PNMImageHeader::PixelSpec const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          PNMImageHeader::PixelSpec const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_PNMImageHeader_PixelSpec);
          if (param0_this != nullptr) {
            PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImageHeader_PixelSpec, true, false);
          }
        }
      }

      {
        // -2 inline PNMImageHeader::PixelSpec::PixelSpec(xel const &rgb)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "rgb")) {
          xel const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_pixel);
          if (param0_this != nullptr) {
            PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImageHeader_PixelSpec, true, false);
          }
        }
      }

      {
        // -2 inline PNMImageHeader::PixelSpec::PixelSpec(xelval gray_value)
        long param0;
        static const char *keyword_list[] = {"gray_value", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "l:PixelSpec", (char **)keyword_list, &param0)) {
#ifndef NDEBUG
          if (param0 < 0 || param0 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param0);
            return -1;
          }
#endif
          PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec((xelval)param0);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImageHeader_PixelSpec, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline PNMImageHeader::PixelSpec::PixelSpec(PNMImageHeader::PixelSpec const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          PNMImageHeader::PixelSpec param0_local;
          PNMImageHeader::PixelSpec const *param0_this = Dtool_Coerce_PNMImageHeader_PixelSpec(param0, param0_local);
          if ((param0_this != nullptr)) {
            PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImageHeader_PixelSpec, true, false);
          }
        }
      }

      {
        // -2 inline PNMImageHeader::PixelSpec::PixelSpec(xel const &rgb)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "rgb")) {
          pixel param0_local;
          xel const *param0_this = Dtool_Coerce_pixel(param0, param0_local);
          if ((param0_this != nullptr)) {
            PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImageHeader_PixelSpec, true, false);
          }
        }
      }

      // No coercion possible: inline PNMImageHeader::PixelSpec::PixelSpec(xelval gray_value)
    }
    break;
  case 2:
    {
      {
        // -2 inline PNMImageHeader::PixelSpec::PixelSpec(xel const &rgb, xelval alpha)
        PyObject *param0;
        long param1;
        static const char *keyword_list[] = {"rgb", "alpha", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Ol:PixelSpec", (char **)keyword_list, &param0, &param1)) {
          xel const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_pixel);
#ifndef NDEBUG
          if (param1 < 0 || param1 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param1);
            return -1;
          }
#endif
          if (param0_this != nullptr) {
            PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec(*param0_this, (xelval)param1);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImageHeader_PixelSpec, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PNMImageHeader::PixelSpec::PixelSpec(xelval gray_value, xelval alpha)
        long param0;
        long param1;
        static const char *keyword_list[] = {"gray_value", "alpha", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "ll:PixelSpec", (char **)keyword_list, &param0, &param1)) {
#ifndef NDEBUG
          if (param0 < 0 || param0 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param0);
            return -1;
          }
#endif
#ifndef NDEBUG
          if (param1 < 0 || param1 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param1);
            return -1;
          }
#endif
          PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec((xelval)param0, (xelval)param1);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImageHeader_PixelSpec, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline PNMImageHeader::PixelSpec::PixelSpec(xel const &rgb, xelval alpha)
        PyObject *param0;
        long param1;
        static const char *keyword_list[] = {"rgb", "alpha", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Ol:PixelSpec", (char **)keyword_list, &param0, &param1)) {
          pixel param0_local;
          xel const *param0_this = Dtool_Coerce_pixel(param0, param0_local);
#ifndef NDEBUG
          if (param1 < 0 || param1 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param1);
            return -1;
          }
#endif
          if ((param0_this != nullptr)) {
            PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec(*param0_this, (xelval)param1);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImageHeader_PixelSpec, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline PNMImageHeader::PixelSpec::PixelSpec(xelval gray_value, xelval alpha)
    }
    break;
  case 3:
    {
      // 1-inline PNMImageHeader::PixelSpec::PixelSpec(xelval red, xelval green, xelval blue)
      long param0;
      long param1;
      long param2;
      static const char *keyword_list[] = {"red", "green", "blue", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "lll:PixelSpec", (char **)keyword_list, &param0, &param1, &param2)) {
#ifndef NDEBUG
        if (param0 < 0 || param0 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param0);
          return -1;
        }
#endif
#ifndef NDEBUG
        if (param1 < 0 || param1 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param1);
          return -1;
        }
#endif
#ifndef NDEBUG
        if (param2 < 0 || param2 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param2);
          return -1;
        }
#endif
        PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec((xelval)param0, (xelval)param1, (xelval)param2);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImageHeader_PixelSpec, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline PNMImageHeader::PixelSpec::PixelSpec(xelval red, xelval green, xelval blue, xelval alpha)
      long param0;
      long param1;
      long param2;
      long param3;
      static const char *keyword_list[] = {"red", "green", "blue", "alpha", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "llll:PixelSpec", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
#ifndef NDEBUG
        if (param0 < 0 || param0 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param0);
          return -1;
        }
#endif
#ifndef NDEBUG
        if (param1 < 0 || param1 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param1);
          return -1;
        }
#endif
#ifndef NDEBUG
        if (param2 < 0 || param2 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param2);
          return -1;
        }
#endif
#ifndef NDEBUG
        if (param3 < 0 || param3 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param3);
          return -1;
        }
#endif
        PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec((xelval)param0, (xelval)param1, (xelval)param2, (xelval)param3);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImageHeader_PixelSpec, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PixelSpec() takes 1, 2, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PixelSpec(const PixelSpec param0)\n"
      "PixelSpec(const pixel rgb)\n"
      "PixelSpec(int gray_value)\n"
      "PixelSpec(const pixel rgb, int alpha)\n"
      "PixelSpec(int gray_value, int alpha)\n"
      "PixelSpec(int red, int green, int blue)\n"
      "PixelSpec(int red, int green, int blue, int alpha)\n");
  }
  return -1;
}

PNMImageHeader::PixelSpec *Dtool_Coerce_PNMImageHeader_PixelSpec(PyObject *args, PNMImageHeader::PixelSpec &coerced) {
  PNMImageHeader::PixelSpec *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_PNMImageHeader_PixelSpec)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const PNMImageHeader::PixelSpec *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PNMImageHeader::PixelSpec::PixelSpec(xel const &rgb)
      xel const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_pixel);
      if (arg_this != nullptr) {
        coerced = PNMImageHeader::PixelSpec(*arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline PNMImageHeader::PixelSpec::PixelSpec(xelval gray_value)
      if (PyLongOrInt_Check(arg)) {
        long param0 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
        if (param0 < 0 || param0 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param0);
          return nullptr;
        }
#endif
        coerced = PNMImageHeader::PixelSpec((xelval)param0);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        {
          // -2 inline PNMImageHeader::PixelSpec::PixelSpec(xel const &rgb, xelval alpha)
          PyObject *param0;
          long param1;
          if (PyArg_ParseTuple(args, "Ol:PixelSpec", &param0, &param1)) {
            xel const *param0_this = nullptr;
            DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_pixel);
#ifndef NDEBUG
            if (param1 < 0 || param1 > USHRT_MAX) {
              PyErr_Format(PyExc_OverflowError,
                           "value %ld out of range for unsigned short integer",
                           param1);
              return nullptr;
            }
#endif
            if (param0_this != nullptr) {
              coerced = PNMImageHeader::PixelSpec(*param0_this, (xelval)param1);
              if (_PyErr_OCCURRED()) {
                return nullptr;
              } else {
                return &coerced;
              }
            }
          }
          PyErr_Clear();
        }

        {
          // -2 inline PNMImageHeader::PixelSpec::PixelSpec(xelval gray_value, xelval alpha)
          long param0;
          long param1;
          if (PyArg_ParseTuple(args, "ll:PixelSpec", &param0, &param1)) {
#ifndef NDEBUG
            if (param0 < 0 || param0 > USHRT_MAX) {
              PyErr_Format(PyExc_OverflowError,
                           "value %ld out of range for unsigned short integer",
                           param0);
              return nullptr;
            }
#endif
#ifndef NDEBUG
            if (param1 < 0 || param1 > USHRT_MAX) {
              PyErr_Format(PyExc_OverflowError,
                           "value %ld out of range for unsigned short integer",
                           param1);
              return nullptr;
            }
#endif
            coerced = PNMImageHeader::PixelSpec((xelval)param0, (xelval)param1);
            if (_PyErr_OCCURRED()) {
              return nullptr;
            } else {
              return &coerced;
            }
          }
          PyErr_Clear();
        }

        break;
      }
      case 3: {
        // 1-inline PNMImageHeader::PixelSpec::PixelSpec(xelval red, xelval green, xelval blue)
        long param0;
        long param1;
        long param2;
        if (PyArg_ParseTuple(args, "lll:PixelSpec", &param0, &param1, &param2)) {
#ifndef NDEBUG
          if (param0 < 0 || param0 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param0);
            return nullptr;
          }
#endif
#ifndef NDEBUG
          if (param1 < 0 || param1 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param1);
            return nullptr;
          }
#endif
#ifndef NDEBUG
          if (param2 < 0 || param2 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param2);
            return nullptr;
          }
#endif
          coerced = PNMImageHeader::PixelSpec((xelval)param0, (xelval)param1, (xelval)param2);
          if (_PyErr_OCCURRED()) {
            return nullptr;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline PNMImageHeader::PixelSpec::PixelSpec(xelval red, xelval green, xelval blue, xelval alpha)
        long param0;
        long param1;
        long param2;
        long param3;
        if (PyArg_ParseTuple(args, "llll:PixelSpec", &param0, &param1, &param2, &param3)) {
#ifndef NDEBUG
          if (param0 < 0 || param0 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param0);
            return nullptr;
          }
#endif
#ifndef NDEBUG
          if (param1 < 0 || param1 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param1);
            return nullptr;
          }
#endif
#ifndef NDEBUG
          if (param2 < 0 || param2 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param2);
            return nullptr;
          }
#endif
#ifndef NDEBUG
          if (param3 < 0 || param3 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param3);
            return nullptr;
          }
#endif
          coerced = PNMImageHeader::PixelSpec((xelval)param0, (xelval)param1, (xelval)param2, (xelval)param3);
          if (_PyErr_OCCURRED()) {
            return nullptr;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return nullptr;
}

static void *Dtool_UpcastInterface_PNMImageHeader_PixelSpec(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PNMImageHeader_PixelSpec) {
    printf("PNMImageHeader_PixelSpec ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PNMImageHeader::PixelSpec *local_this = (PNMImageHeader::PixelSpec *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PNMImageHeader_PixelSpec) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PNMImageHeader_PixelSpec(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PNMImageHeader_PixelSpec) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PNMImageHeader::PixelSpecCount
 */
/**
 * Python function wrapper for:
 * inline PNMImageHeader::PixelSpecCount::PixelSpecCount(PNMImageHeader::PixelSpecCount const &) = default
 */
static int Dtool_Init_PNMImageHeader_PixelSpecCount(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("PixelSpecCount() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline PNMImageHeader::PixelSpecCount::PixelSpecCount(PNMImageHeader::PixelSpecCount const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    PNMImageHeader::PixelSpecCount const *param0_this = (PNMImageHeader::PixelSpecCount *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PNMImageHeader_PixelSpecCount, 0, "PixelSpecCount.PixelSpecCount", true, true);
    if (param0_this != nullptr) {
      PNMImageHeader::PixelSpecCount *return_value = new PNMImageHeader::PixelSpecCount(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImageHeader_PixelSpecCount, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PixelSpecCount(const PixelSpecCount param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PNMImageHeader_PixelSpecCount(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PNMImageHeader_PixelSpecCount) {
    printf("PNMImageHeader_PixelSpecCount ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PNMImageHeader::PixelSpecCount *local_this = (PNMImageHeader::PixelSpecCount *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PNMImageHeader_PixelSpecCount) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PNMImageHeader_PixelSpecCount(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PNMImageHeader_PixelSpecCount) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PNMImageHeader::Histogram
 */
/**
 * Python function wrapper for:
 * inline int PNMImageHeader::Histogram::get_num_pixels(void) const
 */
static PyObject *Dtool_PNMImageHeader_Histogram_get_num_pixels_121(PyObject *self, PyObject *) {
  PNMImageHeader::Histogram *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImageHeader_Histogram)) {
    return nullptr;
  }
  // 1-inline int PNMImageHeader::Histogram::get_num_pixels(void) const
  int return_value = ((*(const PNMImageHeader::Histogram*)local_this).get_num_pixels)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_Histogram_get_num_pixels_121_comment =
  "C++ Interface:\n"
  "get_num_pixels(Histogram self)\n"
  "\n"
  "/**\n"
  " * Returns the number of unique pixel colors in the histogram.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_Histogram_get_num_pixels_121_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PNMImageHeader::PixelSpec const &PNMImageHeader::Histogram::get_pixel(int n) const
 */
static PyObject *Dtool_PNMImageHeader_Histogram_get_pixel_122(PyObject *self, PyObject *arg) {
  PNMImageHeader::Histogram *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImageHeader_Histogram)) {
    return nullptr;
  }
  // 1-inline PNMImageHeader::PixelSpec const &PNMImageHeader::Histogram::get_pixel(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PNMImageHeader::PixelSpec const *return_value = &(((*(const PNMImageHeader::Histogram*)local_this).get_pixel)((int)arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImageHeader_PixelSpec, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pixel(Histogram self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_Histogram_get_pixel_122_comment =
  "C++ Interface:\n"
  "get_pixel(Histogram self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth unique pixel color in the histogram.  These are ordered by\n"
  " * default from most common to least common.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_Histogram_get_pixel_122_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PNMImageHeader::Histogram::get_count(PNMImageHeader::PixelSpec const &pixel) const
 * inline int PNMImageHeader::Histogram::get_count(int n) const
 */
static PyObject *Dtool_PNMImageHeader_Histogram_get_count_123(PyObject *self, PyObject *arg) {
  PNMImageHeader::Histogram *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImageHeader_Histogram)) {
    return nullptr;
  }
  {
    // -2 inline int PNMImageHeader::Histogram::get_count(PNMImageHeader::PixelSpec const &pixel) const
    PNMImageHeader::PixelSpec const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PNMImageHeader_PixelSpec);
    if (arg_this != nullptr) {
      int return_value = ((*(const PNMImageHeader::Histogram*)local_this).get_count)(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 inline int PNMImageHeader::Histogram::get_count(int n) const
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      int return_value = ((*(const PNMImageHeader::Histogram*)local_this).get_count)((int)arg_val);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 inline int PNMImageHeader::Histogram::get_count(PNMImageHeader::PixelSpec const &pixel) const
    PNMImageHeader::PixelSpec arg_local;
    PNMImageHeader::PixelSpec const *arg_this = Dtool_Coerce_PNMImageHeader_PixelSpec(arg, arg_local);
    if ((arg_this != nullptr)) {
      int return_value = ((*(const PNMImageHeader::Histogram*)local_this).get_count)(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: inline int PNMImageHeader::Histogram::get_count(int n) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_count(Histogram self, const PixelSpec pixel)\n"
      "get_count(Histogram self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_Histogram_get_count_123_comment =
  "C++ Interface:\n"
  "get_count(Histogram self, const PixelSpec pixel)\n"
  "get_count(Histogram self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the number of occurrences in the image of the nth unique pixel\n"
  " * color in the histogram.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the number of occurrences in the image of the indicated pixel\n"
  " * color.\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_Histogram_get_count_123_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImageHeader::Histogram::write(std::ostream &out) const
 */
static PyObject *Dtool_PNMImageHeader_Histogram_write_125(PyObject *self, PyObject *arg) {
  PNMImageHeader::Histogram *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImageHeader_Histogram)) {
    return nullptr;
  }
  // 1-void PNMImageHeader::Histogram::write(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "Histogram.write", false, true);
  if (arg_this != nullptr) {
    ((*(const PNMImageHeader::Histogram*)local_this).write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(Histogram self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImageHeader_Histogram_write_125_comment =
  "C++ Interface:\n"
  "write(Histogram self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PNMImageHeader_Histogram_write_125_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PNMImageHeader::Histogram::Histogram(void)
 * inline PNMImageHeader::Histogram::Histogram(PNMImageHeader::Histogram const &) = default
 */
static int Dtool_Init_PNMImageHeader_Histogram(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("Histogram() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PNMImageHeader::Histogram::Histogram(void)
      PNMImageHeader::Histogram *return_value = new PNMImageHeader::Histogram();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImageHeader_Histogram, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline PNMImageHeader::Histogram::Histogram(PNMImageHeader::Histogram const &) = default
      PNMImageHeader::Histogram const *arg_this = (PNMImageHeader::Histogram *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImageHeader_Histogram, 0, "Histogram.Histogram", true, true);
      if (arg_this != nullptr) {
        PNMImageHeader::Histogram *return_value = new PNMImageHeader::Histogram(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImageHeader_Histogram, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Histogram() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Histogram()\n"
      "Histogram(const Histogram param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_PNMImageHeader_Histogram_get_pixels(PyObject *self, PyObject *) {
  PNMImageHeader::Histogram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader_Histogram, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_pixels)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_PNMImageHeader_Histogram_get_pixel_122(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_PNMImageHeader_Histogram(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PNMImageHeader_Histogram) {
    printf("PNMImageHeader_Histogram ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PNMImageHeader::Histogram *local_this = (PNMImageHeader::Histogram *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PNMImageHeader_Histogram) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PNMImageHeader_Histogram(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PNMImageHeader_Histogram) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PfmFile
 */
/**
 * Python function wrapper for:
 * void PfmFile::operator =(PfmFile const &copy)
 */
static PyObject *Dtool_PfmFile_operator_129(PyObject *self, PyObject *arg) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.assign")) {
    return nullptr;
  }
  // 1-void PfmFile::operator =(PfmFile const &copy)
  PfmFile const *arg_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PfmFile, 1, "PfmFile.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    PfmFile *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PfmFile, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const PfmFile self, const PfmFile copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_operator_129_comment =
  "C++ Interface:\n"
  "assign(const PfmFile self, const PfmFile copy)\n";
#else
static const char *Dtool_PfmFile_operator_129_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::clear(void)
 * void PfmFile::clear(int x_size, int y_size, int num_channels)
 */
static PyObject *Dtool_PfmFile_clear_130(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.clear")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-void PfmFile::clear(void)
      ((*local_this).clear)();
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-void PfmFile::clear(int x_size, int y_size, int num_channels)
      int param1;
      int param2;
      int param3;
      static const char *keyword_list[] = {"x_size", "y_size", "num_channels", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:clear", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).clear)((int)param1, (int)param2, (int)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "clear() takes 1 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear(const PfmFile self)\n"
      "clear(const PfmFile self, int x_size, int y_size, int num_channels)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_clear_130_comment =
  "C++ Interface:\n"
  "clear(const PfmFile self)\n"
  "clear(const PfmFile self, int x_size, int y_size, int num_channels)\n"
  "\n"
  "/**\n"
  " * Eliminates all data in the file.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Resets to an empty table with a specific size.  The case of num_channels ==\n"
  " * 0 is allowed only in the case that x_size and y_size are also == 0; and\n"
  " * this makes an empty (and invalid) PfmFile.\n"
  " */";
#else
static const char *Dtool_PfmFile_clear_130_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PfmFile::read(Filename const &fullpath)
 * Rejected Remap [bool PfmFile::read(PNMReader *reader)]
 * bool PfmFile::read(std::istream &in, Filename const &fullpath = Filename())
 */
static PyObject *Dtool_PfmFile_read_131(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.read")) {
    return nullptr;
  }
  {
    // -2 bool PfmFile::read(std::istream &in, Filename const &fullpath = Filename())
    PyObject *param1;
    PyObject *param2 = nullptr;
    static const char *keyword_list[] = {"in", "fullpath", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:read", (char **)keyword_list, &param1, &param2)) {
      std::istream *param1_this = (std::istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_istream, 1, "PfmFile.read", false, false);
      Filename const *param2_this;
      const Filename &param2_ref = Filename();
      if (param2 == nullptr) {
        param2_this = &param2_ref;
      } else {
        param2_this = nullptr;
        DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_Filename);
      }
      if (param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = ((*local_this).read)(*param1_this, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool PfmFile::read(Filename const &fullpath)
    PyObject *param1;
    if (Dtool_ExtractArg(&param1, args, kwds, "fullpath")) {
      Filename const *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_Filename);
      if (param1_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = ((*local_this).read)(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
  }

  {
    // -2 bool PfmFile::read(std::istream &in, Filename const &fullpath = Filename())
    PyObject *param1;
    PyObject *param2 = nullptr;
    static const char *keyword_list[] = {"in", "fullpath", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:read", (char **)keyword_list, &param1, &param2)) {
      std::istream *param1_this = (std::istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_istream, 1, "PfmFile.read", false, false);
      Filename param2_local;
      Filename const *param2_this;
      if (param2 != nullptr) {
        param2_this = Dtool_Coerce_Filename(param2, param2_local);
      } else {
        param2_local = Filename();
        param2_this = &param2_local;
      }
      if (param1_this != nullptr && (param2 == nullptr || (param2_this != nullptr))) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = ((*local_this).read)(*param1_this, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool PfmFile::read(Filename const &fullpath)
    PyObject *param1;
    if (Dtool_ExtractArg(&param1, args, kwds, "fullpath")) {
      Filename param1_local;
      Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
      if ((param1_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = ((*local_this).read)(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read(const PfmFile self, istream in, const Filename fullpath)\n"
      "read(const PfmFile self, const Filename fullpath)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_read_131_comment =
  "C++ Interface:\n"
  "read(const PfmFile self, istream in, const Filename fullpath)\n"
  "read(const PfmFile self, const Filename fullpath)\n"
  "\n"
  "/**\n"
  " * Reads the PFM data from the indicated file, returning true on success,\n"
  " * false on failure.\n"
  " *\n"
  " * This can also handle reading a standard image file supported by PNMImage;\n"
  " * it will be quietly converted to a floating-point type.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Reads the PFM data from the indicated stream, returning true on success,\n"
  " * false on failure.\n"
  " *\n"
  " * This can also handle reading a standard image file supported by PNMImage;\n"
  " * it will be quietly converted to a floating-point type.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Reads the PFM data using the indicated PNMReader.\n"
  " *\n"
  " * The PNMReader is always deleted upon completion, whether successful or not.\n"
  " */";
#else
static const char *Dtool_PfmFile_read_131_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PfmFile::write(Filename const &fullpath)
 * Rejected Remap [bool PfmFile::write(PNMWriter *writer)]
 * bool PfmFile::write(std::ostream &out, Filename const &fullpath = Filename())
 */
static PyObject *Dtool_PfmFile_write_132(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.write")) {
    return nullptr;
  }
  {
    // -2 bool PfmFile::write(std::ostream &out, Filename const &fullpath = Filename())
    PyObject *param1;
    PyObject *param2 = nullptr;
    static const char *keyword_list[] = {"out", "fullpath", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:write", (char **)keyword_list, &param1, &param2)) {
      std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "PfmFile.write", false, false);
      Filename const *param2_this;
      const Filename &param2_ref = Filename();
      if (param2 == nullptr) {
        param2_this = &param2_ref;
      } else {
        param2_this = nullptr;
        DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_Filename);
      }
      if (param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = ((*local_this).write)(*param1_this, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool PfmFile::write(Filename const &fullpath)
    PyObject *param1;
    if (Dtool_ExtractArg(&param1, args, kwds, "fullpath")) {
      Filename const *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_Filename);
      if (param1_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = ((*local_this).write)(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
  }

  {
    // -2 bool PfmFile::write(std::ostream &out, Filename const &fullpath = Filename())
    PyObject *param1;
    PyObject *param2 = nullptr;
    static const char *keyword_list[] = {"out", "fullpath", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:write", (char **)keyword_list, &param1, &param2)) {
      std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "PfmFile.write", false, false);
      Filename param2_local;
      Filename const *param2_this;
      if (param2 != nullptr) {
        param2_this = Dtool_Coerce_Filename(param2, param2_local);
      } else {
        param2_local = Filename();
        param2_this = &param2_local;
      }
      if (param1_this != nullptr && (param2 == nullptr || (param2_this != nullptr))) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = ((*local_this).write)(*param1_this, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool PfmFile::write(Filename const &fullpath)
    PyObject *param1;
    if (Dtool_ExtractArg(&param1, args, kwds, "fullpath")) {
      Filename param1_local;
      Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
      if ((param1_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = ((*local_this).write)(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(const PfmFile self, ostream out, const Filename fullpath)\n"
      "write(const PfmFile self, const Filename fullpath)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_write_132_comment =
  "C++ Interface:\n"
  "write(const PfmFile self, ostream out, const Filename fullpath)\n"
  "write(const PfmFile self, const Filename fullpath)\n"
  "\n"
  "/**\n"
  " * Writes the PFM data to the indicated file, returning true on success, false\n"
  " * on failure.\n"
  " *\n"
  " * If the type implied by the filename extension supports floating-point, the\n"
  " * data will be written directly; otherwise, the floating-point data will be\n"
  " * quietly converted to the appropriate integer type.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Writes the PFM data to the indicated stream, returning true on success,\n"
  " * false on failure.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Writes the PFM data using the indicated PNMWriter.\n"
  " *\n"
  " * The PNMWriter is always deleted upon completion, whether successful or not.\n"
  " */";
#else
static const char *Dtool_PfmFile_write_132_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PfmFile::load(PNMImage const &pnmimage)
 */
static PyObject *Dtool_PfmFile_load_133(PyObject *self, PyObject *arg) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.load")) {
    return nullptr;
  }
  // 1-bool PfmFile::load(PNMImage const &pnmimage)
  PNMImage const *arg_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImage, 1, "PfmFile.load", true, true);
  if (arg_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = ((*local_this).load)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load(const PfmFile self, const PNMImage pnmimage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_load_133_comment =
  "C++ Interface:\n"
  "load(const PfmFile self, const PNMImage pnmimage)\n"
  "\n"
  "/**\n"
  " * Fills the PfmFile with the data from the indicated PNMImage, converted to\n"
  " * floating-point values.\n"
  " */";
#else
static const char *Dtool_PfmFile_load_133_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PfmFile::store(PNMImage &pnmimage) const
 */
static PyObject *Dtool_PfmFile_store_134(PyObject *self, PyObject *arg) {
  PfmFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PfmFile)) {
    return nullptr;
  }
  // 1-bool PfmFile::store(PNMImage &pnmimage) const
  PNMImage *arg_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImage, 1, "PfmFile.store", false, true);
  if (arg_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = ((*(const PfmFile*)local_this).store)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "store(PfmFile self, PNMImage pnmimage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_store_134_comment =
  "C++ Interface:\n"
  "store(PfmFile self, PNMImage pnmimage)\n"
  "\n"
  "/**\n"
  " * Copies the data to the indicated PNMImage, converting to RGB values.\n"
  " */";
#else
static const char *Dtool_PfmFile_store_134_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PfmFile::store_mask(PNMImage &pnmimage) const
 * bool PfmFile::store_mask(PNMImage &pnmimage, LVecBase4f const &min_point, LVecBase4f const &max_point) const
 */
static PyObject *Dtool_PfmFile_store_mask_135(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PfmFile)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "pnmimage")) {
        // 1-bool PfmFile::store_mask(PNMImage &pnmimage) const
        PNMImage *arg_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImage, 1, "PfmFile.store_mask", false, true);
        if (arg_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
          PyThreadState *_save;
          Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
          bool return_value = ((*(const PfmFile*)local_this).store_mask)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
          Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
          return Dtool_Return_Bool(return_value);
        }
      }
    }
    break;
  case 3:
    {
      // 1-bool PfmFile::store_mask(PNMImage &pnmimage, LVecBase4f const &min_point, LVecBase4f const &max_point) const
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"pnmimage", "min_point", "max_point", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:store_mask", (char **)keyword_list, &param1, &param2, &param3)) {
        PNMImage *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PfmFile.store_mask", false, true);
        LVecBase4f param2_local;
        LVecBase4f const *param2_this = Dtool_Coerce_LVecBase4f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "PfmFile.store_mask", "LVecBase4f");
        }
        LVecBase4f param3_local;
        LVecBase4f const *param3_this = Dtool_Coerce_LVecBase4f(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "PfmFile.store_mask", "LVecBase4f");
        }
        if (param1_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
          PyThreadState *_save;
          Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
          bool return_value = ((*(const PfmFile*)local_this).store_mask)(*param1_this, *param2_this, *param3_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
          Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
          return Dtool_Return_Bool(return_value);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "store_mask() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "store_mask(PfmFile self, PNMImage pnmimage)\n"
      "store_mask(PfmFile self, PNMImage pnmimage, const LVecBase4f min_point, const LVecBase4f max_point)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_store_mask_135_comment =
  "C++ Interface:\n"
  "store_mask(PfmFile self, PNMImage pnmimage)\n"
  "store_mask(PfmFile self, PNMImage pnmimage, const LVecBase4f min_point, const LVecBase4f max_point)\n"
  "\n"
  "/**\n"
  " * Stores 1 or 0 values into the indicated PNMImage, according to has_point()\n"
  " * for each pixel.  Each valid point gets a 1 value; each nonexistent point\n"
  " * gets a 0 value.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Stores 1 or 0 values into the indicated PNMImage, according to has_point()\n"
  " * for each pixel.  Each valid point gets a 1 value; each nonexistent point\n"
  " * gets a 0 value.\n"
  " *\n"
  " * This flavor of store_mask also checks whether the valid points are within\n"
  " * the specified min/max range.  Any valid points without the condition\n"
  " * min_point[c] <= value[c] <= max_point[c], for any c, are stored with a 0 in\n"
  " * the mask.\n"
  " */";
#else
static const char *Dtool_PfmFile_store_mask_135_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PfmFile::is_valid(void) const
 */
static PyObject *Dtool_PfmFile_is_valid_136(PyObject *self, PyObject *) {
  PfmFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PfmFile)) {
    return nullptr;
  }
  // 1-inline bool PfmFile::is_valid(void) const
  bool return_value = ((*(const PfmFile*)local_this).is_valid)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_is_valid_136_comment =
  "C++ Interface:\n"
  "is_valid(PfmFile self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PfmFile_is_valid_136_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_float32 PfmFile::get_scale(void) const
 */
static PyObject *Dtool_PfmFile_get_scale_139(PyObject *self, PyObject *) {
  PfmFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PfmFile)) {
    return nullptr;
  }
  // 1-inline PN_float32 PfmFile::get_scale(void) const
  PN_float32 return_value = ((*(const PfmFile*)local_this).get_scale)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_get_scale_139_comment =
  "C++ Interface:\n"
  "get_scale(PfmFile self)\n"
  "\n"
  "/**\n"
  " * The \"scale\" is reported in the pfm header and is probably meaningless.\n"
  " */";
#else
static const char *Dtool_PfmFile_get_scale_139_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::set_scale(PN_float32 scale)
 */
static PyObject *Dtool_PfmFile_set_scale_140(PyObject *self, PyObject *arg) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.set_scale")) {
    return nullptr;
  }
  // 1-inline void PfmFile::set_scale(PN_float32 scale)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_scale)((PN_float32)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scale(const PfmFile self, float scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_set_scale_140_comment =
  "C++ Interface:\n"
  "set_scale(const PfmFile self, float scale)\n"
  "\n"
  "/**\n"
  " * The \"scale\" is reported in the pfm header and is probably meaningless.\n"
  " */";
#else
static const char *Dtool_PfmFile_set_scale_140_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PfmFile::has_point(int x, int y) const
 */
static PyObject *Dtool_PfmFile_has_point_144(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PfmFile)) {
    return nullptr;
  }
  // 1-inline bool PfmFile::has_point(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_point", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*(const PfmFile*)local_this).has_point)((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_point(PfmFile self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_has_point_144_comment =
  "C++ Interface:\n"
  "has_point(PfmFile self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns true if there is a valid point at x, y.  This always returns true\n"
  " * unless a \"no data\" value has been set, in which case it returns false if\n"
  " * the point at x, y is the \"no data\" value.\n"
  " */";
#else
static const char *Dtool_PfmFile_has_point_144_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_float32 PfmFile::get_channel(int x, int y, int c) const
 */
static PyObject *Dtool_PfmFile_get_channel_145(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PfmFile)) {
    return nullptr;
  }
  // 1-inline PN_float32 PfmFile::get_channel(int x, int y, int c) const
  int param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"x", "y", "c", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:get_channel", (char **)keyword_list, &param1, &param2, &param3)) {
    PN_float32 return_value = ((*(const PfmFile*)local_this).get_channel)((int)param1, (int)param2, (int)param3);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_channel(PfmFile self, int x, int y, int c)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_get_channel_145_comment =
  "C++ Interface:\n"
  "get_channel(PfmFile self, int x, int y, int c)\n"
  "\n"
  "/**\n"
  " * Returns the cth channel of the point value at the indicated point.\n"
  " */";
#else
static const char *Dtool_PfmFile_get_channel_145_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::set_channel(int x, int y, int c, PN_float32 value)
 */
static PyObject *Dtool_PfmFile_set_channel_146(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.set_channel")) {
    return nullptr;
  }
  // 1-inline void PfmFile::set_channel(int x, int y, int c, PN_float32 value)
  int param1;
  int param2;
  int param3;
  float param4;
  static const char *keyword_list[] = {"x", "y", "c", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiif:set_channel", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    ((*local_this).set_channel)((int)param1, (int)param2, (int)param3, (PN_float32)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_channel(const PfmFile self, int x, int y, int c, float value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_set_channel_146_comment =
  "C++ Interface:\n"
  "set_channel(const PfmFile self, int x, int y, int c, float value)\n"
  "\n"
  "/**\n"
  " * Replaces the cth channel of the point value at the indicated point.\n"
  " */";
#else
static const char *Dtool_PfmFile_set_channel_146_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_float32 PfmFile::get_point1(int x, int y) const
 */
static PyObject *Dtool_PfmFile_get_point1_147(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PfmFile)) {
    return nullptr;
  }
  // 1-inline PN_float32 PfmFile::get_point1(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_point1", (char **)keyword_list, &param1, &param2)) {
    PN_float32 return_value = ((*(const PfmFile*)local_this).get_point1)((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point1(PfmFile self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_get_point1_147_comment =
  "C++ Interface:\n"
  "get_point1(PfmFile self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the 1-component point value at the indicated point.\n"
  " */";
#else
static const char *Dtool_PfmFile_get_point1_147_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::set_point1(int x, int y, PN_float32 point)
 */
static PyObject *Dtool_PfmFile_set_point1_148(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.set_point1")) {
    return nullptr;
  }
  // 1-inline void PfmFile::set_point1(int x, int y, PN_float32 point)
  int param1;
  int param2;
  float param3;
  static const char *keyword_list[] = {"x", "y", "point", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iif:set_point1", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).set_point1)((int)param1, (int)param2, (PN_float32)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_point1(const PfmFile self, int x, int y, float point)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_set_point1_148_comment =
  "C++ Interface:\n"
  "set_point1(const PfmFile self, int x, int y, float point)\n"
  "\n"
  "/**\n"
  " * Replaces the 1-component point value at the indicated point.\n"
  " */";
#else
static const char *Dtool_PfmFile_set_point1_148_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2f const &PfmFile::get_point2(int x, int y) const
 */
static PyObject *Dtool_PfmFile_get_point2_149(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PfmFile)) {
    return nullptr;
  }
  // 1-inline LPoint2f const &PfmFile::get_point2(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_point2", (char **)keyword_list, &param1, &param2)) {
    LPoint2f const *return_value = &(((*(const PfmFile*)local_this).get_point2)((int)param1, (int)param2));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point2(PfmFile self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_get_point2_149_comment =
  "C++ Interface:\n"
  "get_point2(PfmFile self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the 2-component point value at the indicated point.  In a 1-channel\n"
  " * image, the channel value is in the x component.\n"
  " */";
#else
static const char *Dtool_PfmFile_get_point2_149_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::set_point2(int x, int y, LVecBase2d const &point)
 * inline void PfmFile::set_point2(int x, int y, LVecBase2f const &point)
 */
static PyObject *Dtool_PfmFile_set_point2_150(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.set_point2")) {
    return nullptr;
  }
  {
    // -2 inline void PfmFile::set_point2(int x, int y, LVecBase2d const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point2", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase2d const *param3_this = nullptr;
      DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_LVecBase2d);
      if (param3_this != nullptr) {
        ((*local_this).set_point2)((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void PfmFile::set_point2(int x, int y, LVecBase2f const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point2", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase2f const *param3_this = nullptr;
      DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_LVecBase2f);
      if (param3_this != nullptr) {
        ((*local_this).set_point2)((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void PfmFile::set_point2(int x, int y, LVecBase2d const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point2", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase2d param3_local;
      LVecBase2d const *param3_this = Dtool_Coerce_LVecBase2d(param3, param3_local);
      if ((param3_this != nullptr)) {
        ((*local_this).set_point2)((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void PfmFile::set_point2(int x, int y, LVecBase2f const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point2", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase2f param3_local;
      LVecBase2f const *param3_this = Dtool_Coerce_LVecBase2f(param3, param3_local);
      if ((param3_this != nullptr)) {
        ((*local_this).set_point2)((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_point2(const PfmFile self, int x, int y, const LVecBase2d point)\n"
      "set_point2(const PfmFile self, int x, int y, const LVecBase2f point)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_set_point2_150_comment =
  "C++ Interface:\n"
  "set_point2(const PfmFile self, int x, int y, const LVecBase2d point)\n"
  "set_point2(const PfmFile self, int x, int y, const LVecBase2f point)\n"
  "\n"
  "/**\n"
  " * Replaces the 2-component point value at the indicated point.  In a\n"
  " * 1-channel image, the channel value is in the x component.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Replaces the 2-component point value at the indicated point.  In a\n"
  " * 1-channel image, the channel value is in the x component.\n"
  " */";
#else
static const char *Dtool_PfmFile_set_point2_150_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2f &PfmFile::modify_point2(int x, int y)
 */
static PyObject *Dtool_PfmFile_modify_point2_151(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.modify_point2")) {
    return nullptr;
  }
  // 1-inline LPoint2f &PfmFile::modify_point2(int x, int y)
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:modify_point2", (char **)keyword_list, &param1, &param2)) {
    LPoint2f *return_value = &(((*local_this).modify_point2)((int)param1, (int)param2));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "modify_point2(const PfmFile self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_modify_point2_151_comment =
  "C++ Interface:\n"
  "modify_point2(const PfmFile self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns a modifiable 2-component point value at the indicated point.\n"
  " */";
#else
static const char *Dtool_PfmFile_modify_point2_151_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f const &PfmFile::get_point(int x, int y) const
 */
static PyObject *Dtool_PfmFile_get_point_152(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PfmFile)) {
    return nullptr;
  }
  // 1-inline LPoint3f const &PfmFile::get_point(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_point", (char **)keyword_list, &param1, &param2)) {
    LPoint3f const *return_value = &(((*(const PfmFile*)local_this).get_point)((int)param1, (int)param2));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point(PfmFile self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_get_point_152_comment =
  "C++ Interface:\n"
  "get_point(PfmFile self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the 3-component point value at the indicated point.  In a 1-channel\n"
  " * image, the channel value is in the x component.\n"
  " */";
#else
static const char *Dtool_PfmFile_get_point_152_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::set_point(int x, int y, LVecBase3d const &point)
 * inline void PfmFile::set_point(int x, int y, LVecBase3f const &point)
 */
static PyObject *Dtool_PfmFile_set_point_153(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.set_point")) {
    return nullptr;
  }
  {
    // -2 inline void PfmFile::set_point(int x, int y, LVecBase3d const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase3d const *param3_this = nullptr;
      DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_LVecBase3d);
      if (param3_this != nullptr) {
        ((*local_this).set_point)((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void PfmFile::set_point(int x, int y, LVecBase3f const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase3f const *param3_this = nullptr;
      DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_LVecBase3f);
      if (param3_this != nullptr) {
        ((*local_this).set_point)((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void PfmFile::set_point(int x, int y, LVecBase3d const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase3d param3_local;
      LVecBase3d const *param3_this = Dtool_Coerce_LVecBase3d(param3, param3_local);
      if ((param3_this != nullptr)) {
        ((*local_this).set_point)((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void PfmFile::set_point(int x, int y, LVecBase3f const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase3f param3_local;
      LVecBase3f const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
      if ((param3_this != nullptr)) {
        ((*local_this).set_point)((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_point(const PfmFile self, int x, int y, const LVecBase3d point)\n"
      "set_point(const PfmFile self, int x, int y, const LVecBase3f point)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_set_point_153_comment =
  "C++ Interface:\n"
  "set_point(const PfmFile self, int x, int y, const LVecBase3d point)\n"
  "set_point(const PfmFile self, int x, int y, const LVecBase3f point)\n"
  "\n"
  "/**\n"
  " * Replaces the 3-component point value at the indicated point.  In a\n"
  " * 1-channel image, the channel value is in the x component.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Replaces the 3-component point value at the indicated point.  In a\n"
  " * 1-channel image, the channel value is in the x component.\n"
  " */";
#else
static const char *Dtool_PfmFile_set_point_153_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f &PfmFile::modify_point(int x, int y)
 */
static PyObject *Dtool_PfmFile_modify_point_154(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.modify_point")) {
    return nullptr;
  }
  // 1-inline LPoint3f &PfmFile::modify_point(int x, int y)
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:modify_point", (char **)keyword_list, &param1, &param2)) {
    LPoint3f *return_value = &(((*local_this).modify_point)((int)param1, (int)param2));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "modify_point(const PfmFile self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_modify_point_154_comment =
  "C++ Interface:\n"
  "modify_point(const PfmFile self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns a modifiable 3-component point value at the indicated point.\n"
  " */";
#else
static const char *Dtool_PfmFile_modify_point_154_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f const &PfmFile::get_point3(int x, int y) const
 */
static PyObject *Dtool_PfmFile_get_point3_155(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PfmFile)) {
    return nullptr;
  }
  // 1-inline LPoint3f const &PfmFile::get_point3(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_point3", (char **)keyword_list, &param1, &param2)) {
    LPoint3f const *return_value = &(((*(const PfmFile*)local_this).get_point3)((int)param1, (int)param2));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point3(PfmFile self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_get_point3_155_comment =
  "C++ Interface:\n"
  "get_point3(PfmFile self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the 3-component point value at the indicated point.  In a 1-channel\n"
  " * image, the channel value is in the x component.\n"
  " */";
#else
static const char *Dtool_PfmFile_get_point3_155_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::set_point3(int x, int y, LVecBase3d const &point)
 * inline void PfmFile::set_point3(int x, int y, LVecBase3f const &point)
 */
static PyObject *Dtool_PfmFile_set_point3_156(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.set_point3")) {
    return nullptr;
  }
  {
    // -2 inline void PfmFile::set_point3(int x, int y, LVecBase3d const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point3", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase3d const *param3_this = nullptr;
      DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_LVecBase3d);
      if (param3_this != nullptr) {
        ((*local_this).set_point3)((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void PfmFile::set_point3(int x, int y, LVecBase3f const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point3", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase3f const *param3_this = nullptr;
      DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_LVecBase3f);
      if (param3_this != nullptr) {
        ((*local_this).set_point3)((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void PfmFile::set_point3(int x, int y, LVecBase3d const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point3", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase3d param3_local;
      LVecBase3d const *param3_this = Dtool_Coerce_LVecBase3d(param3, param3_local);
      if ((param3_this != nullptr)) {
        ((*local_this).set_point3)((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void PfmFile::set_point3(int x, int y, LVecBase3f const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point3", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase3f param3_local;
      LVecBase3f const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
      if ((param3_this != nullptr)) {
        ((*local_this).set_point3)((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_point3(const PfmFile self, int x, int y, const LVecBase3d point)\n"
      "set_point3(const PfmFile self, int x, int y, const LVecBase3f point)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_set_point3_156_comment =
  "C++ Interface:\n"
  "set_point3(const PfmFile self, int x, int y, const LVecBase3d point)\n"
  "set_point3(const PfmFile self, int x, int y, const LVecBase3f point)\n"
  "\n"
  "/**\n"
  " * Replaces the 3-component point value at the indicated point.  In a\n"
  " * 1-channel image, the channel value is in the x component.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Replaces the 3-component point value at the indicated point.  In a\n"
  " * 1-channel image, the channel value is in the x component.\n"
  " */";
#else
static const char *Dtool_PfmFile_set_point3_156_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f &PfmFile::modify_point3(int x, int y)
 */
static PyObject *Dtool_PfmFile_modify_point3_157(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.modify_point3")) {
    return nullptr;
  }
  // 1-inline LPoint3f &PfmFile::modify_point3(int x, int y)
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:modify_point3", (char **)keyword_list, &param1, &param2)) {
    LPoint3f *return_value = &(((*local_this).modify_point3)((int)param1, (int)param2));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "modify_point3(const PfmFile self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_modify_point3_157_comment =
  "C++ Interface:\n"
  "modify_point3(const PfmFile self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns a modifiable 3-component point value at the indicated point.\n"
  " */";
#else
static const char *Dtool_PfmFile_modify_point3_157_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint4f const &PfmFile::get_point4(int x, int y) const
 */
static PyObject *Dtool_PfmFile_get_point4_158(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PfmFile)) {
    return nullptr;
  }
  // 1-inline LPoint4f const &PfmFile::get_point4(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_point4", (char **)keyword_list, &param1, &param2)) {
    LPoint4f const *return_value = &(((*(const PfmFile*)local_this).get_point4)((int)param1, (int)param2));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point4(PfmFile self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_get_point4_158_comment =
  "C++ Interface:\n"
  "get_point4(PfmFile self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the 4-component point value at the indicated point.  In a 1-channel\n"
  " * image, the channel value is in the x component.\n"
  " */";
#else
static const char *Dtool_PfmFile_get_point4_158_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::set_point4(int x, int y, LVecBase4d const &point)
 * inline void PfmFile::set_point4(int x, int y, LVecBase4f const &point)
 */
static PyObject *Dtool_PfmFile_set_point4_159(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.set_point4")) {
    return nullptr;
  }
  {
    // -2 inline void PfmFile::set_point4(int x, int y, LVecBase4d const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point4", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase4d const *param3_this = nullptr;
      DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_LVecBase4d);
      if (param3_this != nullptr) {
        ((*local_this).set_point4)((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void PfmFile::set_point4(int x, int y, LVecBase4f const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point4", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase4f const *param3_this = nullptr;
      DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_LVecBase4f);
      if (param3_this != nullptr) {
        ((*local_this).set_point4)((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void PfmFile::set_point4(int x, int y, LVecBase4d const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point4", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase4d param3_local;
      LVecBase4d const *param3_this = Dtool_Coerce_LVecBase4d(param3, param3_local);
      if ((param3_this != nullptr)) {
        ((*local_this).set_point4)((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void PfmFile::set_point4(int x, int y, LVecBase4f const &point)
    int param1;
    int param2;
    PyObject *param3;
    static const char *keyword_list[] = {"x", "y", "point", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_point4", (char **)keyword_list, &param1, &param2, &param3)) {
      LVecBase4f param3_local;
      LVecBase4f const *param3_this = Dtool_Coerce_LVecBase4f(param3, param3_local);
      if ((param3_this != nullptr)) {
        ((*local_this).set_point4)((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_point4(const PfmFile self, int x, int y, const LVecBase4d point)\n"
      "set_point4(const PfmFile self, int x, int y, const LVecBase4f point)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_set_point4_159_comment =
  "C++ Interface:\n"
  "set_point4(const PfmFile self, int x, int y, const LVecBase4d point)\n"
  "set_point4(const PfmFile self, int x, int y, const LVecBase4f point)\n"
  "\n"
  "/**\n"
  " * Replaces the 4-component point value at the indicated point.  In a\n"
  " * 1-channel image, the channel value is in the x component.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Replaces the 4-component point value at the indicated point.  In a\n"
  " * 1-channel image, the channel value is in the x component.\n"
  " */";
#else
static const char *Dtool_PfmFile_set_point4_159_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint4f &PfmFile::modify_point4(int x, int y)
 */
static PyObject *Dtool_PfmFile_modify_point4_160(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.modify_point4")) {
    return nullptr;
  }
  // 1-inline LPoint4f &PfmFile::modify_point4(int x, int y)
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:modify_point4", (char **)keyword_list, &param1, &param2)) {
    LPoint4f *return_value = &(((*local_this).modify_point4)((int)param1, (int)param2));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4f, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "modify_point4(const PfmFile self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_modify_point4_160_comment =
  "C++ Interface:\n"
  "modify_point4(const PfmFile self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns a modifiable 4-component point value at the indicated point.\n"
  " */";
#else
static const char *Dtool_PfmFile_modify_point4_160_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::fill(LPoint2f const &value)
 * inline void PfmFile::fill(LPoint3f const &value)
 * void PfmFile::fill(LPoint4f const &value)
 * inline void PfmFile::fill(PN_float32 value)
 */
static PyObject *Dtool_PfmFile_fill_161(PyObject *self, PyObject *arg) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.fill")) {
    return nullptr;
  }
  {
    // -2 inline void PfmFile::fill(LPoint2f const &value)
    LPoint2f const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LPoint2f);
    if (arg_this != nullptr) {
      ((*local_this).fill)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void PfmFile::fill(LPoint3f const &value)
    LPoint3f const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LPoint3f);
    if (arg_this != nullptr) {
      ((*local_this).fill)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void PfmFile::fill(LPoint4f const &value)
    LPoint4f const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LPoint4f);
    if (arg_this != nullptr) {
      ((*local_this).fill)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void PfmFile::fill(PN_float32 value)
    if (PyNumber_Check(arg)) {
      ((*local_this).fill)((PN_float32)PyFloat_AsDouble(arg));
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void PfmFile::fill(LPoint2f const &value)
    LPoint2f arg_local;
    LPoint2f const *arg_this = Dtool_Coerce_LPoint2f(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).fill)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void PfmFile::fill(LPoint3f const &value)
    LPoint3f arg_local;
    LPoint3f const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).fill)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void PfmFile::fill(LPoint4f const &value)
    LPoint4f arg_local;
    LPoint4f const *arg_this = Dtool_Coerce_LPoint4f(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).fill)(*arg_this);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: inline void PfmFile::fill(PN_float32 value)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill(const PfmFile self, const LPoint2f value)\n"
      "fill(const PfmFile self, const LPoint3f value)\n"
      "fill(const PfmFile self, const LPoint4f value)\n"
      "fill(const PfmFile self, float value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_fill_161_comment =
  "C++ Interface:\n"
  "fill(const PfmFile self, const LPoint2f value)\n"
  "fill(const PfmFile self, const LPoint3f value)\n"
  "fill(const PfmFile self, const LPoint4f value)\n"
  "fill(const PfmFile self, float value)\n"
  "\n"
  "/**\n"
  " * Fills the table with all of the same value.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Fills the table with all of the same value.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Fills the table with all of the same value.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Fills the table with all of the same value.\n"
  " */";
#else
static const char *Dtool_PfmFile_fill_161_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::fill_nan(void)
 */
static PyObject *Dtool_PfmFile_fill_nan_162(PyObject *self, PyObject *) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.fill_nan")) {
    return nullptr;
  }
  // 1-void PfmFile::fill_nan(void)
  ((*local_this).fill_nan)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_fill_nan_162_comment =
  "C++ Interface:\n"
  "fill_nan(const PfmFile self)\n"
  "\n"
  "/**\n"
  " * Fills the table with all NaN.\n"
  " */";
#else
static const char *Dtool_PfmFile_fill_nan_162_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::fill_no_data_value(void)
 */
static PyObject *Dtool_PfmFile_fill_no_data_value_163(PyObject *self, PyObject *) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.fill_no_data_value")) {
    return nullptr;
  }
  // 1-void PfmFile::fill_no_data_value(void)
  ((*local_this).fill_no_data_value)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_fill_no_data_value_163_comment =
  "C++ Interface:\n"
  "fill_no_data_value(const PfmFile self)\n"
  "\n"
  "/**\n"
  " * Fills the table with the current no_data value, so that the table is empty.\n"
  " */";
#else
static const char *Dtool_PfmFile_fill_no_data_value_163_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::fill_channel(int channel, PN_float32 value)
 */
static PyObject *Dtool_PfmFile_fill_channel_164(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.fill_channel")) {
    return nullptr;
  }
  // 1-void PfmFile::fill_channel(int channel, PN_float32 value)
  int param1;
  float param2;
  static const char *keyword_list[] = {"channel", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:fill_channel", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).fill_channel)((int)param1, (PN_float32)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill_channel(const PfmFile self, int channel, float value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_fill_channel_164_comment =
  "C++ Interface:\n"
  "fill_channel(const PfmFile self, int channel, float value)\n"
  "\n"
  "/**\n"
  " * Fills the indicated channel with all of the same value, leaving the other\n"
  " * channels unchanged.\n"
  " */";
#else
static const char *Dtool_PfmFile_fill_channel_164_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::fill_channel_nan(int channel)
 */
static PyObject *Dtool_PfmFile_fill_channel_nan_165(PyObject *self, PyObject *arg) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.fill_channel_nan")) {
    return nullptr;
  }
  // 1-void PfmFile::fill_channel_nan(int channel)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).fill_channel_nan)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill_channel_nan(const PfmFile self, int channel)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_fill_channel_nan_165_comment =
  "C++ Interface:\n"
  "fill_channel_nan(const PfmFile self, int channel)\n"
  "\n"
  "/**\n"
  " * Fills the indicated channel with NaN, leaving the other channels unchanged.\n"
  " */";
#else
static const char *Dtool_PfmFile_fill_channel_nan_165_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::fill_channel_masked(int channel, PN_float32 value)
 */
static PyObject *Dtool_PfmFile_fill_channel_masked_166(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.fill_channel_masked")) {
    return nullptr;
  }
  // 1-void PfmFile::fill_channel_masked(int channel, PN_float32 value)
  int param1;
  float param2;
  static const char *keyword_list[] = {"channel", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:fill_channel_masked", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).fill_channel_masked)((int)param1, (PN_float32)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill_channel_masked(const PfmFile self, int channel, float value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_fill_channel_masked_166_comment =
  "C++ Interface:\n"
  "fill_channel_masked(const PfmFile self, int channel, float value)\n"
  "\n"
  "/**\n"
  " * Fills the indicated channel with all of the same value, but only where the\n"
  " * table already has a data point.  Leaves empty points unchanged.\n"
  " */";
#else
static const char *Dtool_PfmFile_fill_channel_masked_166_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::fill_channel_masked_nan(int channel)
 */
static PyObject *Dtool_PfmFile_fill_channel_masked_nan_167(PyObject *self, PyObject *arg) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.fill_channel_masked_nan")) {
    return nullptr;
  }
  // 1-void PfmFile::fill_channel_masked_nan(int channel)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).fill_channel_masked_nan)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill_channel_masked_nan(const PfmFile self, int channel)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_fill_channel_masked_nan_167_comment =
  "C++ Interface:\n"
  "fill_channel_masked_nan(const PfmFile self, int channel)\n"
  "\n"
  "/**\n"
  " * Fills the indicated channel with NaN, but only where the table already has\n"
  " * a data point.  Leaves empty points unchanged.\n"
  " */";
#else
static const char *Dtool_PfmFile_fill_channel_masked_nan_167_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PfmFile::calc_average_point(LPoint3f &result, PN_float32 x, PN_float32 y, PN_float32 radius) const
 */
static PyObject *Dtool_PfmFile_calc_average_point_168(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PfmFile)) {
    return nullptr;
  }
  // 1-bool PfmFile::calc_average_point(LPoint3f &result, PN_float32 x, PN_float32 y, PN_float32 radius) const
  PyObject *param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"result", "x", "y", "radius", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Offf:calc_average_point", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    LPoint3f param1_local;
    LPoint3f *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PfmFile.calc_average_point", "LPoint3f");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = ((*(const PfmFile*)local_this).calc_average_point)(*param1_this, (PN_float32)param2, (PN_float32)param3, (PN_float32)param4);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_average_point(PfmFile self, LPoint3f result, float x, float y, float radius)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_calc_average_point_168_comment =
  "C++ Interface:\n"
  "calc_average_point(PfmFile self, LPoint3f result, float x, float y, float radius)\n"
  "\n"
  "/**\n"
  " * Computes the unweighted average point of all points within the box centered\n"
  " * at (x, y) with the indicated Manhattan-distance radius.  Missing points are\n"
  " * assigned the value of their nearest neighbor.  Returns true if successful,\n"
  " * or false if the point value cannot be determined.\n"
  " */";
#else
static const char *Dtool_PfmFile_calc_average_point_168_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PfmFile::calc_bilinear_point(LPoint3f &result, PN_float32 x, PN_float32 y) const
 */
static PyObject *Dtool_PfmFile_calc_bilinear_point_169(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PfmFile)) {
    return nullptr;
  }
  // 1-bool PfmFile::calc_bilinear_point(LPoint3f &result, PN_float32 x, PN_float32 y) const
  PyObject *param1;
  float param2;
  float param3;
  static const char *keyword_list[] = {"result", "x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Off:calc_bilinear_point", (char **)keyword_list, &param1, &param2, &param3)) {
    LPoint3f param1_local;
    LPoint3f *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PfmFile.calc_bilinear_point", "LPoint3f");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = ((*(const PfmFile*)local_this).calc_bilinear_point)(*param1_this, (PN_float32)param2, (PN_float32)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_bilinear_point(PfmFile self, LPoint3f result, float x, float y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_calc_bilinear_point_169_comment =
  "C++ Interface:\n"
  "calc_bilinear_point(PfmFile self, LPoint3f result, float x, float y)\n"
  "\n"
  "/**\n"
  " * Computes the weighted average of the four nearest points to the floating-\n"
  " * point index (x, y).  Returns true if the point has any contributors, false\n"
  " * if the point is unknown.\n"
  " */";
#else
static const char *Dtool_PfmFile_calc_bilinear_point_169_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PfmFile::calc_min_max(LVecBase3f &min_points, LVecBase3f &max_points) const
 */
static PyObject *Dtool_PfmFile_calc_min_max_170(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PfmFile)) {
    return nullptr;
  }
  // 1-bool PfmFile::calc_min_max(LVecBase3f &min_points, LVecBase3f &max_points) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"min_points", "max_points", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:calc_min_max", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param1_local;
    LVecBase3f *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PfmFile.calc_min_max", "LVecBase3f");
    }
    LVecBase3f param2_local;
    LVecBase3f *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PfmFile.calc_min_max", "LVecBase3f");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = ((*(const PfmFile*)local_this).calc_min_max)(*param1_this, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_min_max(PfmFile self, LVecBase3f min_points, LVecBase3f max_points)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_calc_min_max_170_comment =
  "C++ Interface:\n"
  "calc_min_max(PfmFile self, LVecBase3f min_points, LVecBase3f max_points)\n"
  "\n"
  "/**\n"
  " * Calculates the minimum and maximum x, y, and z depth component values,\n"
  " * representing the bounding box of depth values, and places them in the\n"
  " * indicated vectors.  Returns true if successful, false if the mesh contains\n"
  " * no points.\n"
  " */";
#else
static const char *Dtool_PfmFile_calc_min_max_170_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PfmFile::calc_autocrop(LVecBase4d &range) const
 * inline bool PfmFile::calc_autocrop(LVecBase4f &range) const
 */
static PyObject *Dtool_PfmFile_calc_autocrop_171(PyObject *self, PyObject *arg) {
  PfmFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PfmFile)) {
    return nullptr;
  }
  {
    // -2 inline bool PfmFile::calc_autocrop(LVecBase4d &range) const
    LVecBase4d *arg_this = (LVecBase4d *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LVecBase4d, 1, "PfmFile.calc_autocrop", false, false);
    if (arg_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      bool return_value = ((*(const PfmFile*)local_this).calc_autocrop)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 inline bool PfmFile::calc_autocrop(LVecBase4f &range) const
    LVecBase4f *arg_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LVecBase4f, 1, "PfmFile.calc_autocrop", false, false);
    if (arg_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      bool return_value = ((*(const PfmFile*)local_this).calc_autocrop)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 inline bool PfmFile::calc_autocrop(LVecBase4d &range) const
    LVecBase4d arg_local;
    LVecBase4d *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
    if ((arg_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      bool return_value = ((*(const PfmFile*)local_this).calc_autocrop)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 inline bool PfmFile::calc_autocrop(LVecBase4f &range) const
    LVecBase4f arg_local;
    LVecBase4f *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
    if ((arg_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      bool return_value = ((*(const PfmFile*)local_this).calc_autocrop)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_Bool(return_value);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_autocrop(PfmFile self, LVecBase4d range)\n"
      "calc_autocrop(PfmFile self, LVecBase4f range)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_calc_autocrop_171_comment =
  "C++ Interface:\n"
  "calc_autocrop(PfmFile self, LVecBase4d range)\n"
  "calc_autocrop(PfmFile self, LVecBase4f range)\n"
  "\n"
  "/**\n"
  " * Computes the minimum range of x and y across the PFM file that include all\n"
  " * points.  If there are no points with no_data_value in the grid--that is,\n"
  " * all points are included--then this will return (0, get_x_size(), 0,\n"
  " * get_y_size()).\n"
  " */\n"
  "\n"
  "/**\n"
  " * Computes the minimum range of x and y across the PFM file that include all\n"
  " * points.  If there are no points with no_data_value in the grid--that is,\n"
  " * all points are included--then this will return (0, get_x_size(), 0,\n"
  " * get_y_size()).\n"
  " */\n"
  "\n"
  "/**\n"
  " * Computes the minimum range of x and y across the PFM file that include all\n"
  " * points.  If there are no points with no_data_value in the grid--that is,\n"
  " * all points are included--then this will return (0, get_x_size(), 0,\n"
  " * get_y_size()).\n"
  " */";
#else
static const char *Dtool_PfmFile_calc_autocrop_171_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PfmFile::is_row_empty(int y, int x_begin, int x_end) const
 */
static PyObject *Dtool_PfmFile_is_row_empty_172(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PfmFile)) {
    return nullptr;
  }
  // 1-bool PfmFile::is_row_empty(int y, int x_begin, int x_end) const
  int param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"y", "x_begin", "x_end", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:is_row_empty", (char **)keyword_list, &param1, &param2, &param3)) {
    bool return_value = ((*(const PfmFile*)local_this).is_row_empty)((int)param1, (int)param2, (int)param3);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_row_empty(PfmFile self, int y, int x_begin, int x_end)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_is_row_empty_172_comment =
  "C++ Interface:\n"
  "is_row_empty(PfmFile self, int y, int x_begin, int x_end)\n"
  "\n"
  "/**\n"
  " * Returns true if all of the points on row y, in the range [x_begin, x_end),\n"
  " * are the no_data value, or false if any one of these points has a value.\n"
  " */";
#else
static const char *Dtool_PfmFile_is_row_empty_172_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PfmFile::is_column_empty(int x, int y_begin, int y_end) const
 */
static PyObject *Dtool_PfmFile_is_column_empty_173(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PfmFile)) {
    return nullptr;
  }
  // 1-bool PfmFile::is_column_empty(int x, int y_begin, int y_end) const
  int param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"x", "y_begin", "y_end", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:is_column_empty", (char **)keyword_list, &param1, &param2, &param3)) {
    bool return_value = ((*(const PfmFile*)local_this).is_column_empty)((int)param1, (int)param2, (int)param3);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_column_empty(PfmFile self, int x, int y_begin, int y_end)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_is_column_empty_173_comment =
  "C++ Interface:\n"
  "is_column_empty(PfmFile self, int x, int y_begin, int y_end)\n"
  "\n"
  "/**\n"
  " * Returns true if all of the points on column x, from [y_begin, y_end), are\n"
  " * the no_data value, or false if any one of these points has a value.\n"
  " */";
#else
static const char *Dtool_PfmFile_is_column_empty_173_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::set_zero_special(bool zero_special)
 */
static PyObject *Dtool_PfmFile_set_zero_special_174(PyObject *self, PyObject *arg) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.set_zero_special")) {
    return nullptr;
  }
  // 1-inline void PfmFile::set_zero_special(bool zero_special)
  ((*local_this).set_zero_special)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_zero_special(const PfmFile self, bool zero_special)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_set_zero_special_174_comment =
  "C++ Interface:\n"
  "set_zero_special(const PfmFile self, bool zero_special)\n"
  "\n"
  "/**\n"
  " * Sets the zero_special flag.  When this flag is true, values of (0, 0, 0) in\n"
  " * the pfm file are treated as a special case, and are not processed.\n"
  " *\n"
  " * This is a special case of set_no_data_value().\n"
  " */";
#else
static const char *Dtool_PfmFile_set_zero_special_174_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::set_no_data_chan4(bool chan4)
 */
static PyObject *Dtool_PfmFile_set_no_data_chan4_175(PyObject *self, PyObject *arg) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.set_no_data_chan4")) {
    return nullptr;
  }
  // 1-inline void PfmFile::set_no_data_chan4(bool chan4)
  ((*local_this).set_no_data_chan4)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_no_data_chan4(const PfmFile self, bool chan4)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_set_no_data_chan4_175_comment =
  "C++ Interface:\n"
  "set_no_data_chan4(const PfmFile self, bool chan4)\n"
  "\n"
  "/**\n"
  " * Sets the no_data_chan4 flag.  When this flag is true, and the pfm file has\n"
  " * 4 channels, then a negative value in the fourth channel indicates no data.\n"
  " * When it is false, all points are valid.\n"
  " *\n"
  " * This is a special case of set_no_data_value().\n"
  " */";
#else
static const char *Dtool_PfmFile_set_no_data_chan4_175_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::set_no_data_nan(int num_channels)
 */
static PyObject *Dtool_PfmFile_set_no_data_nan_176(PyObject *self, PyObject *arg) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.set_no_data_nan")) {
    return nullptr;
  }
  // 1-void PfmFile::set_no_data_nan(int num_channels)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_no_data_nan)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_no_data_nan(const PfmFile self, int num_channels)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_set_no_data_nan_176_comment =
  "C++ Interface:\n"
  "set_no_data_nan(const PfmFile self, int num_channels)\n"
  "\n"
  "/**\n"
  " * Sets the no_data_nan flag.  When num_channels is nonzero, then a NaN value\n"
  " * in any of the first num_channels channels indicates no data for that point.\n"
  " * If num_channels is zero, then all points are valid.\n"
  " *\n"
  " * This is a special case of set_no_data_value().\n"
  " */";
#else
static const char *Dtool_PfmFile_set_no_data_nan_176_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::set_no_data_value(LPoint4d const &no_data_value)
 * void PfmFile::set_no_data_value(LPoint4f const &no_data_value)
 */
static PyObject *Dtool_PfmFile_set_no_data_value_177(PyObject *self, PyObject *arg) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.set_no_data_value")) {
    return nullptr;
  }
  {
    // -2 inline void PfmFile::set_no_data_value(LPoint4d const &no_data_value)
    LPoint4d const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LPoint4d);
    if (arg_this != nullptr) {
      ((*local_this).set_no_data_value)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void PfmFile::set_no_data_value(LPoint4f const &no_data_value)
    LPoint4f const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LPoint4f);
    if (arg_this != nullptr) {
      ((*local_this).set_no_data_value)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void PfmFile::set_no_data_value(LPoint4d const &no_data_value)
    LPoint4d arg_local;
    LPoint4d const *arg_this = Dtool_Coerce_LPoint4d(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).set_no_data_value)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void PfmFile::set_no_data_value(LPoint4f const &no_data_value)
    LPoint4f arg_local;
    LPoint4f const *arg_this = Dtool_Coerce_LPoint4f(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).set_no_data_value)(*arg_this);
      return Dtool_Return_None();
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_no_data_value(const PfmFile self, const LPoint4d no_data_value)\n"
      "set_no_data_value(const PfmFile self, const LPoint4f no_data_value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_set_no_data_value_177_comment =
  "C++ Interface:\n"
  "set_no_data_value(const PfmFile self, const LPoint4d no_data_value)\n"
  "set_no_data_value(const PfmFile self, const LPoint4f no_data_value)\n"
  "\n"
  "/**\n"
  " * Sets the special value that means \"no data\" when it appears in the pfm\n"
  " * file.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the special value that means \"no data\" when it appears in the pfm\n"
  " * file.\n"
  " */";
#else
static const char *Dtool_PfmFile_set_no_data_value_177_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::set_no_data_threshold(LPoint4d const &no_data_value)
 * void PfmFile::set_no_data_threshold(LPoint4f const &no_data_value)
 */
static PyObject *Dtool_PfmFile_set_no_data_threshold_178(PyObject *self, PyObject *arg) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.set_no_data_threshold")) {
    return nullptr;
  }
  {
    // -2 inline void PfmFile::set_no_data_threshold(LPoint4d const &no_data_value)
    LPoint4d const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LPoint4d);
    if (arg_this != nullptr) {
      ((*local_this).set_no_data_threshold)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void PfmFile::set_no_data_threshold(LPoint4f const &no_data_value)
    LPoint4f const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LPoint4f);
    if (arg_this != nullptr) {
      ((*local_this).set_no_data_threshold)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void PfmFile::set_no_data_threshold(LPoint4d const &no_data_value)
    LPoint4d arg_local;
    LPoint4d const *arg_this = Dtool_Coerce_LPoint4d(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).set_no_data_threshold)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void PfmFile::set_no_data_threshold(LPoint4f const &no_data_value)
    LPoint4f arg_local;
    LPoint4f const *arg_this = Dtool_Coerce_LPoint4f(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).set_no_data_threshold)(*arg_this);
      return Dtool_Return_None();
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_no_data_threshold(const PfmFile self, const LPoint4d no_data_value)\n"
      "set_no_data_threshold(const PfmFile self, const LPoint4f no_data_value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_set_no_data_threshold_178_comment =
  "C++ Interface:\n"
  "set_no_data_threshold(const PfmFile self, const LPoint4d no_data_value)\n"
  "set_no_data_threshold(const PfmFile self, const LPoint4f no_data_value)\n"
  "\n"
  "/**\n"
  " * Sets the special threshold value.  Points that are below this value in all\n"
  " * components are considered \"no value\".\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the special threshold value.  Points that are below this value in all\n"
  " * components are considered \"no value\".\n"
  " */";
#else
static const char *Dtool_PfmFile_set_no_data_threshold_178_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::clear_no_data_value(void)
 */
static PyObject *Dtool_PfmFile_clear_no_data_value_179(PyObject *self, PyObject *) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.clear_no_data_value")) {
    return nullptr;
  }
  // 1-inline void PfmFile::clear_no_data_value(void)
  ((*local_this).clear_no_data_value)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_clear_no_data_value_179_comment =
  "C++ Interface:\n"
  "clear_no_data_value(const PfmFile self)\n"
  "\n"
  "/**\n"
  " * Removes the special value that means \"no data\" when it appears in the pfm\n"
  " * file.  All points will thus be considered valid.\n"
  " */";
#else
static const char *Dtool_PfmFile_clear_no_data_value_179_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PfmFile::has_no_data_value(void) const
 */
static PyObject *Dtool_PfmFile_has_no_data_value_180(PyObject *self, PyObject *) {
  PfmFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PfmFile)) {
    return nullptr;
  }
  // 1-inline bool PfmFile::has_no_data_value(void) const
  bool return_value = ((*(const PfmFile*)local_this).has_no_data_value)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_has_no_data_value_180_comment =
  "C++ Interface:\n"
  "has_no_data_value(PfmFile self)\n"
  "\n"
  "/**\n"
  " * Returns whether a \"no data\" value has been established by\n"
  " * set_no_data_value().\n"
  " */";
#else
static const char *Dtool_PfmFile_has_no_data_value_180_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PfmFile::has_no_data_threshold(void) const
 */
static PyObject *Dtool_PfmFile_has_no_data_threshold_181(PyObject *self, PyObject *) {
  PfmFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PfmFile)) {
    return nullptr;
  }
  // 1-inline bool PfmFile::has_no_data_threshold(void) const
  bool return_value = ((*(const PfmFile*)local_this).has_no_data_threshold)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_has_no_data_threshold_181_comment =
  "C++ Interface:\n"
  "has_no_data_threshold(PfmFile self)\n"
  "\n"
  "/**\n"
  " * Returns whether a \"no data\" threshold value has been established by\n"
  " * set_no_data_threshold().\n"
  " */";
#else
static const char *Dtool_PfmFile_has_no_data_threshold_181_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint4f const &PfmFile::get_no_data_value(void) const
 */
static PyObject *Dtool_PfmFile_get_no_data_value_182(PyObject *self, PyObject *) {
  PfmFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PfmFile)) {
    return nullptr;
  }
  // 1-inline LPoint4f const &PfmFile::get_no_data_value(void) const
  LPoint4f const *return_value = &(((*(const PfmFile*)local_this).get_no_data_value)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_get_no_data_value_182_comment =
  "C++ Interface:\n"
  "get_no_data_value(PfmFile self)\n"
  "\n"
  "/**\n"
  " * If has_no_data_value() returns true, this returns the particular \"no data\"\n"
  " * value.\n"
  " */";
#else
static const char *Dtool_PfmFile_get_no_data_value_182_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::resize(int new_x_size, int new_y_size)
 */
static PyObject *Dtool_PfmFile_resize_183(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.resize")) {
    return nullptr;
  }
  // 1-void PfmFile::resize(int new_x_size, int new_y_size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"new_x_size", "new_y_size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:resize", (char **)keyword_list, &param1, &param2)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).resize)((int)param1, (int)param2);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "resize(const PfmFile self, int new_x_size, int new_y_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_resize_183_comment =
  "C++ Interface:\n"
  "resize(const PfmFile self, int new_x_size, int new_y_size)\n"
  "\n"
  "/**\n"
  " * Applies a simple filter to resample the pfm file in-place to the indicated\n"
  " * size.  Don't confuse this with applying a scale to all of the points via\n"
  " * xform().\n"
  " */";
#else
static const char *Dtool_PfmFile_resize_183_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::box_filter_from(float radius, PfmFile const &copy)
 */
static PyObject *Dtool_PfmFile_box_filter_from_184(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.box_filter_from")) {
    return nullptr;
  }
  // 1-void PfmFile::box_filter_from(float radius, PfmFile const &copy)
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"radius", "copy", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:box_filter_from", (char **)keyword_list, &param1, &param2)) {
    PfmFile const *param2_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PfmFile, 2, "PfmFile.box_filter_from", true, true);
    if (param2_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      ((*local_this).box_filter_from)((float)param1, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "box_filter_from(const PfmFile self, float radius, const PfmFile copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_box_filter_from_184_comment =
  "C++ Interface:\n"
  "box_filter_from(const PfmFile self, float radius, const PfmFile copy)\n"
  "\n"
  "/**\n"
  " * Makes a resized copy of the indicated image into this one using the\n"
  " * indicated filter.  The image to be copied is squashed and stretched to\n"
  " * match the dimensions of the current image, applying the appropriate filter\n"
  " * to perform the stretching.\n"
  " */";
#else
static const char *Dtool_PfmFile_box_filter_from_184_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::gaussian_filter_from(float radius, PfmFile const &copy)
 */
static PyObject *Dtool_PfmFile_gaussian_filter_from_185(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.gaussian_filter_from")) {
    return nullptr;
  }
  // 1-void PfmFile::gaussian_filter_from(float radius, PfmFile const &copy)
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"radius", "copy", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:gaussian_filter_from", (char **)keyword_list, &param1, &param2)) {
    PfmFile const *param2_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PfmFile, 2, "PfmFile.gaussian_filter_from", true, true);
    if (param2_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      ((*local_this).gaussian_filter_from)((float)param1, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "gaussian_filter_from(const PfmFile self, float radius, const PfmFile copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_gaussian_filter_from_185_comment =
  "C++ Interface:\n"
  "gaussian_filter_from(const PfmFile self, float radius, const PfmFile copy)\n"
  "\n"
  "/**\n"
  " * Makes a resized copy of the indicated image into this one using the\n"
  " * indicated filter.  The image to be copied is squashed and stretched to\n"
  " * match the dimensions of the current image, applying the appropriate filter\n"
  " * to perform the stretching.\n"
  " */";
#else
static const char *Dtool_PfmFile_gaussian_filter_from_185_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::quick_filter_from(PfmFile const &copy)
 */
static PyObject *Dtool_PfmFile_quick_filter_from_186(PyObject *self, PyObject *arg) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.quick_filter_from")) {
    return nullptr;
  }
  // 1-void PfmFile::quick_filter_from(PfmFile const &copy)
  PfmFile const *arg_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PfmFile, 1, "PfmFile.quick_filter_from", true, true);
  if (arg_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).quick_filter_from)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "quick_filter_from(const PfmFile self, const PfmFile copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_quick_filter_from_186_comment =
  "C++ Interface:\n"
  "quick_filter_from(const PfmFile self, const PfmFile copy)\n"
  "\n"
  "/**\n"
  " * Resizes from the given image, with a fixed radius of 0.5. This is a very\n"
  " * specialized and simple algorithm that doesn't handle dropping below the\n"
  " * Nyquist rate very well, but is quite a bit faster than the more general\n"
  " * box_filter(), above.\n"
  " */";
#else
static const char *Dtool_PfmFile_quick_filter_from_186_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::reverse_rows(void)
 */
static PyObject *Dtool_PfmFile_reverse_rows_187(PyObject *self, PyObject *) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.reverse_rows")) {
    return nullptr;
  }
  // 1-void PfmFile::reverse_rows(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*local_this).reverse_rows)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_reverse_rows_187_comment =
  "C++ Interface:\n"
  "reverse_rows(const PfmFile self)\n"
  "\n"
  "/**\n"
  " * Performs an in-place reversal of the row (y) data.\n"
  " */";
#else
static const char *Dtool_PfmFile_reverse_rows_187_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::flip(bool flip_x, bool flip_y, bool transpose)
 */
static PyObject *Dtool_PfmFile_flip_188(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.flip")) {
    return nullptr;
  }
  // 1-void PfmFile::flip(bool flip_x, bool flip_y, bool transpose)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"flip_x", "flip_y", "transpose", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:flip", (char **)keyword_list, &param1, &param2, &param3)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).flip)((PyObject_IsTrue(param1) != 0), (PyObject_IsTrue(param2) != 0), (PyObject_IsTrue(param3) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "flip(const PfmFile self, bool flip_x, bool flip_y, bool transpose)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_flip_188_comment =
  "C++ Interface:\n"
  "flip(const PfmFile self, bool flip_x, bool flip_y, bool transpose)\n"
  "\n"
  "/**\n"
  " * Reverses, transposes, and/or rotates the table in-place according to the\n"
  " * specified parameters.  If flip_x is true, the x axis is reversed; if flip_y\n"
  " * is true, the y axis is reversed.  Then, if transpose is true, the x and y\n"
  " * axes are exchanged.  These parameters can be used to select any combination\n"
  " * of 90-degree or 180-degree rotations and flips.\n"
  " */";
#else
static const char *Dtool_PfmFile_flip_188_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::xform(LMatrix4d const &transform)
 * void PfmFile::xform(LMatrix4f const &transform)
 */
static PyObject *Dtool_PfmFile_xform_189(PyObject *self, PyObject *arg) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.xform")) {
    return nullptr;
  }
  {
    // -2 inline void PfmFile::xform(LMatrix4d const &transform)
    LMatrix4d const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LMatrix4d);
    if (arg_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      ((*local_this).xform)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }

  {
    // -2 void PfmFile::xform(LMatrix4f const &transform)
    LMatrix4f const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LMatrix4f);
    if (arg_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      ((*local_this).xform)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void PfmFile::xform(LMatrix4d const &transform)
    LMatrix4d arg_local;
    LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
    if ((arg_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      ((*local_this).xform)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }

  {
    // -2 void PfmFile::xform(LMatrix4f const &transform)
    LMatrix4f arg_local;
    LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
    if ((arg_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      ((*local_this).xform)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform(const PfmFile self, const LMatrix4d transform)\n"
      "xform(const PfmFile self, const LMatrix4f transform)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_xform_189_comment =
  "C++ Interface:\n"
  "xform(const PfmFile self, const LMatrix4d transform)\n"
  "xform(const PfmFile self, const LMatrix4f transform)\n"
  "\n"
  "/**\n"
  " * Applies the indicated transform matrix to all points in-place.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Applies the indicated transform matrix to all points in-place.\n"
  " */";
#else
static const char *Dtool_PfmFile_xform_189_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::forward_distort(PfmFile const &dist, PN_float32 scale_factor = 1.0)
 */
static PyObject *Dtool_PfmFile_forward_distort_190(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.forward_distort")) {
    return nullptr;
  }
  // 1-void PfmFile::forward_distort(PfmFile const &dist, PN_float32 scale_factor = 1.0)
  PyObject *param1;
  float param2 = 1.0;
  static const char *keyword_list[] = {"dist", "scale_factor", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|f:forward_distort", (char **)keyword_list, &param1, &param2)) {
    PfmFile const *param1_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PfmFile, 1, "PfmFile.forward_distort", true, true);
    if (param1_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      ((*local_this).forward_distort)(*param1_this, (PN_float32)param2);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "forward_distort(const PfmFile self, const PfmFile dist, float scale_factor)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_forward_distort_190_comment =
  "C++ Interface:\n"
  "forward_distort(const PfmFile self, const PfmFile dist, float scale_factor)\n"
  "\n"
  "/**\n"
  " * Applies the distortion indicated in the supplied dist map to the current\n"
  " * map.  The dist map is understood to be a mapping of points in the range\n"
  " * 0..1 in the first two dimensions.\n"
  " *\n"
  " * The operation can be expressed symbolically as:\n"
  " *\n"
  " * this(u, v) = this(dist(u, v))\n"
  " *\n"
  " * If scale_factor is not 1, it should be a value > 1, and it specifies the\n"
  " * factor to upscale the working table while processing, to reduce artifacts\n"
  " * from integer truncation.\n"
  " *\n"
  " * By convention, the y axis is inverted in the distortion map relative to the\n"
  " * coordinates here.  A y value of 0 in the distortion map corresponds with a\n"
  " * v value of 1 in this file.\n"
  " */";
#else
static const char *Dtool_PfmFile_forward_distort_190_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::reverse_distort(PfmFile const &dist, PN_float32 scale_factor = 1.0)
 */
static PyObject *Dtool_PfmFile_reverse_distort_191(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.reverse_distort")) {
    return nullptr;
  }
  // 1-void PfmFile::reverse_distort(PfmFile const &dist, PN_float32 scale_factor = 1.0)
  PyObject *param1;
  float param2 = 1.0;
  static const char *keyword_list[] = {"dist", "scale_factor", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|f:reverse_distort", (char **)keyword_list, &param1, &param2)) {
    PfmFile const *param1_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PfmFile, 1, "PfmFile.reverse_distort", true, true);
    if (param1_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      ((*local_this).reverse_distort)(*param1_this, (PN_float32)param2);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reverse_distort(const PfmFile self, const PfmFile dist, float scale_factor)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_reverse_distort_191_comment =
  "C++ Interface:\n"
  "reverse_distort(const PfmFile self, const PfmFile dist, float scale_factor)\n"
  "\n"
  "/**\n"
  " * Applies the distortion indicated in the supplied dist map to the current\n"
  " * map.  The dist map is understood to be a mapping of points in the range\n"
  " * 0..1 in the first two dimensions.\n"
  " *\n"
  " * The operation can be expressed symbolically as:\n"
  " *\n"
  " * this(u, v) = dist(this(u, v))\n"
  " *\n"
  " * If scale_factor is not 1, it should be a value > 1, and it specifies the\n"
  " * factor to upscale the working table while processing, to reduce artifacts\n"
  " * from integer truncation.\n"
  " *\n"
  " * By convention, the y axis in inverted in the distortion map relative to the\n"
  " * coordinates here.  A y value of 0 in the distortion map corresponds with a\n"
  " * v value of 1 in this file.\n"
  " */";
#else
static const char *Dtool_PfmFile_reverse_distort_191_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::apply_1d_lut(int channel, PfmFile const &lut, PN_float32 x_scale = 1.0)
 */
static PyObject *Dtool_PfmFile_apply_1d_lut_192(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.apply_1d_lut")) {
    return nullptr;
  }
  // 1-void PfmFile::apply_1d_lut(int channel, PfmFile const &lut, PN_float32 x_scale = 1.0)
  int param1;
  PyObject *param2;
  float param3 = 1.0;
  static const char *keyword_list[] = {"channel", "lut", "x_scale", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO|f:apply_1d_lut", (char **)keyword_list, &param1, &param2, &param3)) {
    PfmFile const *param2_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PfmFile, 2, "PfmFile.apply_1d_lut", true, true);
    if (param2_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      ((*local_this).apply_1d_lut)((int)param1, *param2_this, (PN_float32)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_1d_lut(const PfmFile self, int channel, const PfmFile lut, float x_scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_apply_1d_lut_192_comment =
  "C++ Interface:\n"
  "apply_1d_lut(const PfmFile self, int channel, const PfmFile lut, float x_scale)\n"
  "\n"
  "/**\n"
  " * Assumes that lut is an X by 1, 1-component PfmFile whose X axis maps points\n"
  " * to target points.  For each point in this pfm file, computes: p(u,\n"
  " * v)[channel] = lut(p(u, v)[channel] * x_scale, 0)[0]\n"
  " */";
#else
static const char *Dtool_PfmFile_apply_1d_lut_192_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::merge(PfmFile const &other)
 */
static PyObject *Dtool_PfmFile_merge_193(PyObject *self, PyObject *arg) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.merge")) {
    return nullptr;
  }
  // 1-void PfmFile::merge(PfmFile const &other)
  PfmFile const *arg_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PfmFile, 1, "PfmFile.merge", true, true);
  if (arg_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).merge)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "merge(const PfmFile self, const PfmFile other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_merge_193_comment =
  "C++ Interface:\n"
  "merge(const PfmFile self, const PfmFile other)\n"
  "\n"
  "/**\n"
  " * Wherever there is missing data in this PfmFile (that is, wherever\n"
  " * has_point() returns false), copy data from the other PfmFile, which must be\n"
  " * exactly the same dimensions as this one.\n"
  " */";
#else
static const char *Dtool_PfmFile_merge_193_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::apply_mask(PfmFile const &other)
 */
static PyObject *Dtool_PfmFile_apply_mask_194(PyObject *self, PyObject *arg) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.apply_mask")) {
    return nullptr;
  }
  // 1-void PfmFile::apply_mask(PfmFile const &other)
  PfmFile const *arg_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PfmFile, 1, "PfmFile.apply_mask", true, true);
  if (arg_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).apply_mask)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_mask(const PfmFile self, const PfmFile other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_apply_mask_194_comment =
  "C++ Interface:\n"
  "apply_mask(const PfmFile self, const PfmFile other)\n"
  "\n"
  "/**\n"
  " * Wherever there is missing data in the other PfmFile, set this the\n"
  " * corresponding point in this PfmFile to missing as well, so that this\n"
  " * PfmFile has only points where both files have points.\n"
  " *\n"
  " * The point is set to \"missing\" by setting it the no_data_value.\n"
  " */";
#else
static const char *Dtool_PfmFile_apply_mask_194_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::copy_channel(int to_channel, PfmFile const &other, int from_channel)
 */
static PyObject *Dtool_PfmFile_copy_channel_195(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.copy_channel")) {
    return nullptr;
  }
  // 1-void PfmFile::copy_channel(int to_channel, PfmFile const &other, int from_channel)
  int param1;
  PyObject *param2;
  int param3;
  static const char *keyword_list[] = {"to_channel", "other", "from_channel", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iOi:copy_channel", (char **)keyword_list, &param1, &param2, &param3)) {
    PfmFile const *param2_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PfmFile, 2, "PfmFile.copy_channel", true, true);
    if (param2_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      ((*local_this).copy_channel)((int)param1, *param2_this, (int)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_channel(const PfmFile self, int to_channel, const PfmFile other, int from_channel)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_copy_channel_195_comment =
  "C++ Interface:\n"
  "copy_channel(const PfmFile self, int to_channel, const PfmFile other, int from_channel)\n"
  "\n"
  "/**\n"
  " * Copies just the specified channel values from the indicated PfmFile (which\n"
  " * could be same as this PfmFile) into the specified channel of this one.\n"
  " */";
#else
static const char *Dtool_PfmFile_copy_channel_195_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::copy_channel_masked(int to_channel, PfmFile const &other, int from_channel)
 */
static PyObject *Dtool_PfmFile_copy_channel_masked_196(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.copy_channel_masked")) {
    return nullptr;
  }
  // 1-void PfmFile::copy_channel_masked(int to_channel, PfmFile const &other, int from_channel)
  int param1;
  PyObject *param2;
  int param3;
  static const char *keyword_list[] = {"to_channel", "other", "from_channel", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iOi:copy_channel_masked", (char **)keyword_list, &param1, &param2, &param3)) {
    PfmFile const *param2_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PfmFile, 2, "PfmFile.copy_channel_masked", true, true);
    if (param2_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      ((*local_this).copy_channel_masked)((int)param1, *param2_this, (int)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_channel_masked(const PfmFile self, int to_channel, const PfmFile other, int from_channel)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_copy_channel_masked_196_comment =
  "C++ Interface:\n"
  "copy_channel_masked(const PfmFile self, int to_channel, const PfmFile other, int from_channel)\n"
  "\n"
  "/**\n"
  " * Copies just the specified channel values from the indicated PfmFile, but\n"
  " * only where the other file has a data point.\n"
  " */";
#else
static const char *Dtool_PfmFile_copy_channel_masked_196_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::apply_crop(int x_begin, int x_end, int y_begin, int y_end)
 */
static PyObject *Dtool_PfmFile_apply_crop_197(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.apply_crop")) {
    return nullptr;
  }
  // 1-void PfmFile::apply_crop(int x_begin, int x_end, int y_begin, int y_end)
  int param1;
  int param2;
  int param3;
  int param4;
  static const char *keyword_list[] = {"x_begin", "x_end", "y_begin", "y_end", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiii:apply_crop", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).apply_crop)((int)param1, (int)param2, (int)param3, (int)param4);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_crop(const PfmFile self, int x_begin, int x_end, int y_begin, int y_end)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_apply_crop_197_comment =
  "C++ Interface:\n"
  "apply_crop(const PfmFile self, int x_begin, int x_end, int y_begin, int y_end)\n"
  "\n"
  "/**\n"
  " * Reduces the PFM file to the cells in the rectangle bounded by (x_begin,\n"
  " * x_end, y_begin, y_end), where the _end cells are not included.\n"
  " */";
#else
static const char *Dtool_PfmFile_apply_crop_197_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::clear_to_texcoords(int x_size, int y_size)
 */
static PyObject *Dtool_PfmFile_clear_to_texcoords_198(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.clear_to_texcoords")) {
    return nullptr;
  }
  // 1-void PfmFile::clear_to_texcoords(int x_size, int y_size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"x_size", "y_size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:clear_to_texcoords", (char **)keyword_list, &param1, &param2)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).clear_to_texcoords)((int)param1, (int)param2);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_to_texcoords(const PfmFile self, int x_size, int y_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_clear_to_texcoords_198_comment =
  "C++ Interface:\n"
  "clear_to_texcoords(const PfmFile self, int x_size, int y_size)\n"
  "\n"
  "/**\n"
  " * Replaces this PfmFile with a new PfmFile of size x_size x y_size x 3,\n"
  " * containing the x y 0 values in the range 0 .. 1 according to the x y index.\n"
  " */";
#else
static const char *Dtool_PfmFile_clear_to_texcoords_198_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int PfmFile::pull_spot(LPoint4f const &delta, float xc, float yc, float xr, float yr, float exponent)
 */
static PyObject *Dtool_PfmFile_pull_spot_199(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.pull_spot")) {
    return nullptr;
  }
  // 1-int PfmFile::pull_spot(LPoint4f const &delta, float xc, float yc, float xr, float yr, float exponent)
  PyObject *param1;
  float param2;
  float param3;
  float param4;
  float param5;
  float param6;
  static const char *keyword_list[] = {"delta", "xc", "yc", "xr", "yr", "exponent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Offfff:pull_spot", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
    LPoint4f param1_local;
    LPoint4f const *param1_this = Dtool_Coerce_LPoint4f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PfmFile.pull_spot", "LPoint4f");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    int return_value = ((*local_this).pull_spot)(*param1_this, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pull_spot(const PfmFile self, const LPoint4f delta, float xc, float yc, float xr, float yr, float exponent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_pull_spot_199_comment =
  "C++ Interface:\n"
  "pull_spot(const PfmFile self, const LPoint4f delta, float xc, float yc, float xr, float yr, float exponent)\n"
  "\n"
  "/**\n"
  " * Applies delta * t to the point values within radius (xr, yr) distance of\n"
  " * (xc, yc).  The t value is scaled from 1.0 at the center to 0.0 at radius\n"
  " * (xr, yr), and this scale follows the specified exponent.  Returns the\n"
  " * number of points affected.\n"
  " */";
#else
static const char *Dtool_PfmFile_pull_spot_199_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PfmFile::calc_tight_bounds(LPoint3f &min_point, LPoint3f &max_point) const
 */
static PyObject *Dtool_PfmFile_calc_tight_bounds_200(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PfmFile)) {
    return nullptr;
  }
  // 1-bool PfmFile::calc_tight_bounds(LPoint3f &min_point, LPoint3f &max_point) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"min_point", "max_point", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:calc_tight_bounds", (char **)keyword_list, &param1, &param2)) {
    LPoint3f param1_local;
    LPoint3f *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PfmFile.calc_tight_bounds", "LPoint3f");
    }
    LPoint3f param2_local;
    LPoint3f *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PfmFile.calc_tight_bounds", "LPoint3f");
    }
    bool return_value = ((*(const PfmFile*)local_this).calc_tight_bounds)(*param1_this, *param2_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_tight_bounds(PfmFile self, LPoint3f min_point, LPoint3f max_point)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_calc_tight_bounds_200_comment =
  "C++ Interface:\n"
  "calc_tight_bounds(PfmFile self, LPoint3f min_point, LPoint3f max_point)\n"
  "\n"
  "/**\n"
  " * Calculates the minimum and maximum vertices of all points within the table.\n"
  " * Assumes the table contains 3-D points.\n"
  " *\n"
  " * The return value is true if any points in the table, or false if none are.\n"
  " */";
#else
static const char *Dtool_PfmFile_calc_tight_bounds_200_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< BoundingHexahedron > PfmFile::compute_planar_bounds(LPoint2d const &center, PN_float32 point_dist, PN_float32 sample_radius, bool points_only) const
 * PointerTo< BoundingHexahedron > PfmFile::compute_planar_bounds(LPoint2f const &center, PN_float32 point_dist, PN_float32 sample_radius, bool points_only) const
 */
static PyObject *Dtool_PfmFile_compute_planar_bounds_201(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PfmFile)) {
    return nullptr;
  }
  {
    // -2 inline PointerTo< BoundingHexahedron > PfmFile::compute_planar_bounds(LPoint2d const &center, PN_float32 point_dist, PN_float32 sample_radius, bool points_only) const
    PyObject *param1;
    float param2;
    float param3;
    PyObject *param4;
    static const char *keyword_list[] = {"center", "point_dist", "sample_radius", "points_only", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OffO:compute_planar_bounds", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
      LPoint2d const *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LPoint2d);
      if (param1_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        PointerTo< BoundingHexahedron > return_value = ((*(const PfmFile*)local_this).compute_planar_bounds)(*param1_this, (PN_float32)param2, (PN_float32)param3, (PyObject_IsTrue(param4) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        BoundingHexahedron *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        if (return_ptr == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_BoundingHexahedron, true, false, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    PyErr_Clear();
  }

  {
    // -2 PointerTo< BoundingHexahedron > PfmFile::compute_planar_bounds(LPoint2f const &center, PN_float32 point_dist, PN_float32 sample_radius, bool points_only) const
    PyObject *param1;
    float param2;
    float param3;
    PyObject *param4;
    static const char *keyword_list[] = {"center", "point_dist", "sample_radius", "points_only", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OffO:compute_planar_bounds", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
      LPoint2f const *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LPoint2f);
      if (param1_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        PointerTo< BoundingHexahedron > return_value = ((*(const PfmFile*)local_this).compute_planar_bounds)(*param1_this, (PN_float32)param2, (PN_float32)param3, (PyObject_IsTrue(param4) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        BoundingHexahedron *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        if (return_ptr == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_BoundingHexahedron, true, false, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline PointerTo< BoundingHexahedron > PfmFile::compute_planar_bounds(LPoint2d const &center, PN_float32 point_dist, PN_float32 sample_radius, bool points_only) const
    PyObject *param1;
    float param2;
    float param3;
    PyObject *param4;
    static const char *keyword_list[] = {"center", "point_dist", "sample_radius", "points_only", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OffO:compute_planar_bounds", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
      LPoint2d param1_local;
      LPoint2d const *param1_this = Dtool_Coerce_LPoint2d(param1, param1_local);
      if ((param1_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        PointerTo< BoundingHexahedron > return_value = ((*(const PfmFile*)local_this).compute_planar_bounds)(*param1_this, (PN_float32)param2, (PN_float32)param3, (PyObject_IsTrue(param4) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        BoundingHexahedron *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        if (return_ptr == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_BoundingHexahedron, true, false, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    PyErr_Clear();
  }

  {
    // -2 PointerTo< BoundingHexahedron > PfmFile::compute_planar_bounds(LPoint2f const &center, PN_float32 point_dist, PN_float32 sample_radius, bool points_only) const
    PyObject *param1;
    float param2;
    float param3;
    PyObject *param4;
    static const char *keyword_list[] = {"center", "point_dist", "sample_radius", "points_only", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OffO:compute_planar_bounds", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
      LPoint2f param1_local;
      LPoint2f const *param1_this = Dtool_Coerce_LPoint2f(param1, param1_local);
      if ((param1_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        PointerTo< BoundingHexahedron > return_value = ((*(const PfmFile*)local_this).compute_planar_bounds)(*param1_this, (PN_float32)param2, (PN_float32)param3, (PyObject_IsTrue(param4) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        BoundingHexahedron *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        if (return_ptr == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_BoundingHexahedron, true, false, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compute_planar_bounds(PfmFile self, const LPoint2d center, float point_dist, float sample_radius, bool points_only)\n"
      "compute_planar_bounds(PfmFile self, const LPoint2f center, float point_dist, float sample_radius, bool points_only)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_compute_planar_bounds_201_comment =
  "C++ Interface:\n"
  "compute_planar_bounds(PfmFile self, const LPoint2d center, float point_dist, float sample_radius, bool points_only)\n"
  "compute_planar_bounds(PfmFile self, const LPoint2f center, float point_dist, float sample_radius, bool points_only)\n"
  "\n"
  "/**\n"
  " * Computes the minmax bounding volume of the points in 3-D space, assuming\n"
  " * the points represent a mostly-planar surface.\n"
  " *\n"
  " * This algorithm works by sampling the (square) sample_radius pixels at the\n"
  " * four point_dist corners around the center (cx - pd, cx + pd) and so on, to\n"
  " * approximate the plane of the surface.  Then all of the points are projected\n"
  " * into that plane and the bounding volume of the entire mesh within that\n"
  " * plane is determined.  If points_only is true, the bounding volume of only\n"
  " * those four points is determined.\n"
  " *\n"
  " * center, point_dist and sample_radius are in UV space, i.e.  in the range\n"
  " * 0..1.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Computes the minmax bounding volume of the points in 3-D space, assuming\n"
  " * the points represent a mostly-planar surface.\n"
  " *\n"
  " * This algorithm works by sampling the (square) sample_radius pixels at the\n"
  " * four point_dist corners around the center (cx - pd, cx + pd) and so on, to\n"
  " * approximate the plane of the surface.  Then all of the points are projected\n"
  " * into that plane and the bounding volume of the entire mesh within that\n"
  " * plane is determined.  If points_only is true, the bounding volume of only\n"
  " * those four points is determined.\n"
  " *\n"
  " * center, point_dist and sample_radius are in UV space, i.e.  in the range\n"
  " * 0..1.\n"
  " */";
#else
static const char *Dtool_PfmFile_compute_planar_bounds_201_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::compute_sample_point(LPoint3f &result, PN_float32 x, PN_float32 y, PN_float32 sample_radius) const
 */
static PyObject *Dtool_PfmFile_compute_sample_point_202(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PfmFile)) {
    return nullptr;
  }
  // 1-void PfmFile::compute_sample_point(LPoint3f &result, PN_float32 x, PN_float32 y, PN_float32 sample_radius) const
  PyObject *param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"result", "x", "y", "sample_radius", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Offf:compute_sample_point", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    LPoint3f param1_local;
    LPoint3f *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PfmFile.compute_sample_point", "LPoint3f");
    }
    ((*(const PfmFile*)local_this).compute_sample_point)(*param1_this, (PN_float32)param2, (PN_float32)param3, (PN_float32)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compute_sample_point(PfmFile self, LPoint3f result, float x, float y, float sample_radius)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_compute_sample_point_202_comment =
  "C++ Interface:\n"
  "compute_sample_point(PfmFile self, LPoint3f result, float x, float y, float sample_radius)\n"
  "\n"
  "/**\n"
  " * Computes the average of all the point within sample_radius (manhattan\n"
  " * distance) and the indicated point.\n"
  " *\n"
  " * The point coordinates are given in UV space, in the range 0..1.\n"
  " */";
#else
static const char *Dtool_PfmFile_compute_sample_point_202_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::copy_sub_image(PfmFile const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1)
 */
static PyObject *Dtool_PfmFile_copy_sub_image_203(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.copy_sub_image")) {
    return nullptr;
  }
  // 1-void PfmFile::copy_sub_image(PfmFile const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1)
  PyObject *param1;
  int param2;
  int param3;
  int param4 = 0;
  int param5 = 0;
  int param6 = -1;
  int param7 = -1;
  static const char *keyword_list[] = {"copy", "xto", "yto", "xfrom", "yfrom", "x_size", "y_size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii|iiii:copy_sub_image", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
    PfmFile const *param1_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PfmFile, 1, "PfmFile.copy_sub_image", true, true);
    if (param1_this != nullptr) {
      ((*local_this).copy_sub_image)(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_sub_image(const PfmFile self, const PfmFile copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_copy_sub_image_203_comment =
  "C++ Interface:\n"
  "copy_sub_image(const PfmFile self, const PfmFile copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size)\n"
  "\n"
  "/**\n"
  " * Copies a rectangular area of another image into a rectangular area of this\n"
  " * image.  Both images must already have been initialized.  The upper-left\n"
  " * corner of the region in both images is specified, and the size of the area;\n"
  " * if the size is omitted, it defaults to the entire other image, or the\n"
  " * largest piece that will fit.\n"
  " */";
#else
static const char *Dtool_PfmFile_copy_sub_image_203_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::add_sub_image(PfmFile const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
 */
static PyObject *Dtool_PfmFile_add_sub_image_204(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.add_sub_image")) {
    return nullptr;
  }
  // 1-void PfmFile::add_sub_image(PfmFile const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
  PyObject *param1;
  int param2;
  int param3;
  int param4 = 0;
  int param5 = 0;
  int param6 = -1;
  int param7 = -1;
  float param8 = 1.0;
  static const char *keyword_list[] = {"copy", "xto", "yto", "xfrom", "yfrom", "x_size", "y_size", "pixel_scale", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii|iiiif:add_sub_image", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8)) {
    PfmFile const *param1_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PfmFile, 1, "PfmFile.add_sub_image", true, true);
    if (param1_this != nullptr) {
      ((*local_this).add_sub_image)(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7, (float)param8);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_sub_image(const PfmFile self, const PfmFile copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_add_sub_image_204_comment =
  "C++ Interface:\n"
  "add_sub_image(const PfmFile self, const PfmFile copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n"
  "\n"
  "/**\n"
  " * Behaves like copy_sub_image(), except the copy pixels are added to the\n"
  " * pixels of the destination, after scaling by the specified pixel_scale.\n"
  " */";
#else
static const char *Dtool_PfmFile_add_sub_image_204_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::mult_sub_image(PfmFile const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
 */
static PyObject *Dtool_PfmFile_mult_sub_image_205(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.mult_sub_image")) {
    return nullptr;
  }
  // 1-void PfmFile::mult_sub_image(PfmFile const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
  PyObject *param1;
  int param2;
  int param3;
  int param4 = 0;
  int param5 = 0;
  int param6 = -1;
  int param7 = -1;
  float param8 = 1.0;
  static const char *keyword_list[] = {"copy", "xto", "yto", "xfrom", "yfrom", "x_size", "y_size", "pixel_scale", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii|iiiif:mult_sub_image", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8)) {
    PfmFile const *param1_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PfmFile, 1, "PfmFile.mult_sub_image", true, true);
    if (param1_this != nullptr) {
      ((*local_this).mult_sub_image)(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7, (float)param8);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "mult_sub_image(const PfmFile self, const PfmFile copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_mult_sub_image_205_comment =
  "C++ Interface:\n"
  "mult_sub_image(const PfmFile self, const PfmFile copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n"
  "\n"
  "/**\n"
  " * Behaves like copy_sub_image(), except the copy pixels are multiplied to the\n"
  " * pixels of the destination, after scaling by the specified pixel_scale.\n"
  " */";
#else
static const char *Dtool_PfmFile_mult_sub_image_205_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::divide_sub_image(PfmFile const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
 */
static PyObject *Dtool_PfmFile_divide_sub_image_206(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.divide_sub_image")) {
    return nullptr;
  }
  // 1-void PfmFile::divide_sub_image(PfmFile const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
  PyObject *param1;
  int param2;
  int param3;
  int param4 = 0;
  int param5 = 0;
  int param6 = -1;
  int param7 = -1;
  float param8 = 1.0;
  static const char *keyword_list[] = {"copy", "xto", "yto", "xfrom", "yfrom", "x_size", "y_size", "pixel_scale", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii|iiiif:divide_sub_image", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8)) {
    PfmFile const *param1_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PfmFile, 1, "PfmFile.divide_sub_image", true, true);
    if (param1_this != nullptr) {
      ((*local_this).divide_sub_image)(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7, (float)param8);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "divide_sub_image(const PfmFile self, const PfmFile copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_divide_sub_image_206_comment =
  "C++ Interface:\n"
  "divide_sub_image(const PfmFile self, const PfmFile copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n"
  "\n"
  "/**\n"
  " * Behaves like copy_sub_image(), except the copy pixels are divided into the\n"
  " * pixels of the destination, after scaling by the specified pixel_scale.\n"
  " * dest(x, y) = dest(x, y) / (copy(x, y) * pixel_scale).\n"
  " */";
#else
static const char *Dtool_PfmFile_divide_sub_image_206_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::indirect_1d_lookup(PfmFile const &index_image, int channel, PfmFile const &pixel_values)
 */
static PyObject *Dtool_PfmFile_indirect_1d_lookup_208(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.indirect_1d_lookup")) {
    return nullptr;
  }
  // 1-void PfmFile::indirect_1d_lookup(PfmFile const &index_image, int channel, PfmFile const &pixel_values)
  PyObject *param1;
  int param2;
  PyObject *param3;
  static const char *keyword_list[] = {"index_image", "channel", "pixel_values", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OiO:indirect_1d_lookup", (char **)keyword_list, &param1, &param2, &param3)) {
    PfmFile const *param1_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PfmFile, 1, "PfmFile.indirect_1d_lookup", true, true);
    PfmFile const *param3_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_PfmFile, 3, "PfmFile.indirect_1d_lookup", true, true);
    if (param1_this != nullptr && param3_this != nullptr) {
      ((*local_this).indirect_1d_lookup)(*param1_this, (int)param2, *param3_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "indirect_1d_lookup(const PfmFile self, const PfmFile index_image, int channel, const PfmFile pixel_values)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_indirect_1d_lookup_208_comment =
  "C++ Interface:\n"
  "indirect_1d_lookup(const PfmFile self, const PfmFile index_image, int channel, const PfmFile pixel_values)\n"
  "\n"
  "/**\n"
  " * index_image is a WxH 1-channel image, while pixel_values is an Nx1\n"
  " * image with any number of channels.  Typically pixel_values will be\n"
  " * a 256x1 image.\n"
  " *\n"
  " * Fills the PfmFile with a new image the same width and height as\n"
  " * index_image, with the same number of channels as pixel_values.\n"
  " *\n"
  " * Each pixel of the new image is computed with the formula:\n"
  " *\n"
  " * new_image(x, y) = pixel_values(index_image(x, y)[channel], 0)\n"
  " *\n"
  " * At present, no interpolation is performed; the nearest value in\n"
  " * pixel_values is discovered.  This may change in the future.\n"
  " */";
#else
static const char *Dtool_PfmFile_indirect_1d_lookup_208_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::gamma_correct(float from_gamma, float to_gamma)
 */
static PyObject *Dtool_PfmFile_gamma_correct_209(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.gamma_correct")) {
    return nullptr;
  }
  // 1-inline void PfmFile::gamma_correct(float from_gamma, float to_gamma)
  float param1;
  float param2;
  static const char *keyword_list[] = {"from_gamma", "to_gamma", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:gamma_correct", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).gamma_correct)((float)param1, (float)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "gamma_correct(const PfmFile self, float from_gamma, float to_gamma)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_gamma_correct_209_comment =
  "C++ Interface:\n"
  "gamma_correct(const PfmFile self, float from_gamma, float to_gamma)\n"
  "\n"
  "/**\n"
  " * Assuming the image was constructed with a gamma curve of from_gamma in the\n"
  " * RGB channels, converts it to an image with a gamma curve of to_gamma in the\n"
  " * RGB channels.  Does not affect the alpha channel.\n"
  " */";
#else
static const char *Dtool_PfmFile_gamma_correct_209_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::gamma_correct_alpha(float from_gamma, float to_gamma)
 */
static PyObject *Dtool_PfmFile_gamma_correct_alpha_210(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.gamma_correct_alpha")) {
    return nullptr;
  }
  // 1-inline void PfmFile::gamma_correct_alpha(float from_gamma, float to_gamma)
  float param1;
  float param2;
  static const char *keyword_list[] = {"from_gamma", "to_gamma", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:gamma_correct_alpha", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).gamma_correct_alpha)((float)param1, (float)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "gamma_correct_alpha(const PfmFile self, float from_gamma, float to_gamma)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_gamma_correct_alpha_210_comment =
  "C++ Interface:\n"
  "gamma_correct_alpha(const PfmFile self, float from_gamma, float to_gamma)\n"
  "\n"
  "/**\n"
  " * Assuming the image was constructed with a gamma curve of from_gamma in the\n"
  " * alpha channel, converts it to an image with a gamma curve of to_gamma in\n"
  " * the alpha channel.  Does not affect the RGB channels.\n"
  " */";
#else
static const char *Dtool_PfmFile_gamma_correct_alpha_210_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PfmFile::apply_exponent(float gray_exponent)
 * inline void PfmFile::apply_exponent(float gray_exponent, float alpha_exponent)
 * inline void PfmFile::apply_exponent(float c0_exponent, float c1_exponent, float c2_exponent)
 * void PfmFile::apply_exponent(float c0_exponent, float c1_exponent, float c2_exponent, float c3_exponent)
 */
static PyObject *Dtool_PfmFile_apply_exponent_211(PyObject *self, PyObject *args, PyObject *kwds) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.apply_exponent")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "gray_exponent")) {
        // 1-inline void PfmFile::apply_exponent(float gray_exponent)
        if (PyNumber_Check(arg)) {
          ((*local_this).apply_exponent)((float)PyFloat_AsDouble(arg));
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-inline void PfmFile::apply_exponent(float gray_exponent, float alpha_exponent)
      float param1;
      float param2;
      static const char *keyword_list[] = {"gray_exponent", "alpha_exponent", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:apply_exponent", (char **)keyword_list, &param1, &param2)) {
        ((*local_this).apply_exponent)((float)param1, (float)param2);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void PfmFile::apply_exponent(float c0_exponent, float c1_exponent, float c2_exponent)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"c0_exponent", "c1_exponent", "c2_exponent", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:apply_exponent", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).apply_exponent)((float)param1, (float)param2, (float)param3);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-void PfmFile::apply_exponent(float c0_exponent, float c1_exponent, float c2_exponent, float c3_exponent)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"c0_exponent", "c1_exponent", "c2_exponent", "c3_exponent", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:apply_exponent", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).apply_exponent)((float)param1, (float)param2, (float)param3, (float)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "apply_exponent() takes 2, 3, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_exponent(const PfmFile self, float gray_exponent)\n"
      "apply_exponent(const PfmFile self, float gray_exponent, float alpha_exponent)\n"
      "apply_exponent(const PfmFile self, float c0_exponent, float c1_exponent, float c2_exponent)\n"
      "apply_exponent(const PfmFile self, float c0_exponent, float c1_exponent, float c2_exponent, float c3_exponent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_apply_exponent_211_comment =
  "C++ Interface:\n"
  "apply_exponent(const PfmFile self, float gray_exponent)\n"
  "apply_exponent(const PfmFile self, float gray_exponent, float alpha_exponent)\n"
  "apply_exponent(const PfmFile self, float c0_exponent, float c1_exponent, float c2_exponent)\n"
  "apply_exponent(const PfmFile self, float c0_exponent, float c1_exponent, float c2_exponent, float c3_exponent)\n"
  "\n"
  "/**\n"
  " * Adjusts each channel of the image by raising the corresponding component\n"
  " * value to the indicated exponent, such that L' = L ^ exponent.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adjusts each channel of the image by raising the corresponding component\n"
  " * value to the indicated exponent, such that L' = L ^ exponent.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adjusts each channel of the image by raising the corresponding component\n"
  " * value to the indicated exponent, such that L' = L ^ exponent.  For a\n"
  " * grayscale image, the blue_exponent value is used for the grayscale value,\n"
  " * and red_exponent and green_exponent are unused.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adjusts each channel of the image by raising the corresponding component\n"
  " * value to the indicated exponent, such that L' = L ^ exponent.\n"
  " */";
#else
static const char *Dtool_PfmFile_apply_exponent_211_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PfmFile::output(std::ostream &out) const
 */
static PyObject *Dtool_PfmFile_output_212(PyObject *self, PyObject *arg) {
  PfmFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PfmFile)) {
    return nullptr;
  }
  // 1-void PfmFile::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PfmFile.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PfmFile*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PfmFile self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_output_212_comment =
  "C++ Interface:\n"
  "output(PfmFile self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PfmFile_output_212_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PfmFile::get_points(void) const
 */
static PyObject *Dtool_PfmFile_get_points_213(PyObject *self, PyObject *) {
  PfmFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PfmFile)) {
    return nullptr;
  }
  // 1-PyObject *PfmFile::get_points(void) const
  PyObject *return_value = invoke_extension((const PfmFile*)local_this).get_points();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PfmFile_get_points_213_comment =
  "C++ Interface:\n"
  "get_points(PfmFile self)\n";
#else
static const char *Dtool_PfmFile_get_points_213_comment = nullptr;
#endif

static PyObject *Dtool_PfmFile_valid_Getter(PyObject *self, void *) {
  const PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool PfmFile::is_valid(void) const
  bool return_value = ((*(const PfmFile*)local_this).is_valid)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PfmFile_scale_Getter(PyObject *self, void *) {
  const PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_float32 PfmFile::get_scale(void) const
  PN_float32 return_value = ((*(const PfmFile*)local_this).get_scale)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_PfmFile_scale_Setter(PyObject *self, PyObject *arg, void *) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PfmFile, (void **)&local_this, "PfmFile.scale")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete scale attribute");
    return -1;
  }
  // 1-inline void PfmFile::set_scale(PN_float32 scale)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_scale)((PN_float32)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_scale(const PfmFile self, float scale)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * PfmFile::PfmFile(void)
 * PfmFile::PfmFile(PfmFile const &copy)
 */
static int Dtool_Init_PfmFile(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-PfmFile::PfmFile(void)
      PfmFile *return_value = new PfmFile();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PfmFile, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-PfmFile::PfmFile(PfmFile const &copy)
        PfmFile const *arg_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PfmFile, 0, "PfmFile.PfmFile", true, true);
        if (arg_this != nullptr) {
          PfmFile *return_value = new PfmFile(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PfmFile, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PfmFile() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PfmFile()\n"
      "PfmFile(const PfmFile copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PfmFile(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PfmFile) {
    printf("PfmFile ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PfmFile *local_this = (PfmFile *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PfmFile) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PNMImageHeader) {
    return (PNMImageHeader *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PfmFile(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PfmFile) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PNMImageHeader) {
    PNMImageHeader* other_this = (PNMImageHeader*)from_this;
    return (PfmFile*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PNMBrush
 */
/**
 * Python function wrapper for:
 * static PointerTo< PNMBrush > PNMBrush::make_transparent(void)
 */
static PyObject *Dtool_PNMBrush_make_transparent_219(PyObject *, PyObject *) {
  // 1-static PointerTo< PNMBrush > PNMBrush::make_transparent(void)
  PointerTo< PNMBrush > return_value = (PNMBrush::make_transparent)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  PNMBrush *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_PNMBrush, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PNMBrush_make_transparent_219_comment =
  "C++ Interface:\n"
  "make_transparent()\n"
  "\n"
  "/**\n"
  " * Returns a new brush that does not paint anything.  Can be used as either a\n"
  " * pen or a fill brush to make borderless or unfilled shapes, respectively.\n"
  " */";
#else
static const char *Dtool_PNMBrush_make_transparent_219_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< PNMBrush > PNMBrush::make_pixel(LColorf const &color, PNMBrush::BrushEffect effect = ::PNMBrush::BE_blend)
 */
static PyObject *Dtool_PNMBrush_make_pixel_220(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static PointerTo< PNMBrush > PNMBrush::make_pixel(LColorf const &color, PNMBrush::BrushEffect effect = ::PNMBrush::BE_blend)
  PyObject *param0;
  int param1 = PNMBrush::BE_blend;
  static const char *keyword_list[] = {"color", "effect", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:make_pixel", (char **)keyword_list, &param0, &param1)) {
    LVecBase4f param0_local;
    LColorf const *param0_this = Dtool_Coerce_LVecBase4f(param0, param0_local);
    if (!(param0_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "PNMBrush.make_pixel", "LVecBase4f");
    }
    PointerTo< PNMBrush > return_value = (PNMBrush::make_pixel)(*param0_this, (PNMBrush::BrushEffect)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    PNMBrush *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_PNMBrush, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_pixel(const LVecBase4f color, int effect)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMBrush_make_pixel_220_comment =
  "C++ Interface:\n"
  "make_pixel(const LVecBase4f color, int effect)\n"
  "\n"
  "/**\n"
  " * Returns a new brush that paints a single pixel of the indicated color on a\n"
  " * border, or paints a solid color in an interior.\n"
  " */";
#else
static const char *Dtool_PNMBrush_make_pixel_220_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< PNMBrush > PNMBrush::make_spot(LColorf const &color, float radius, bool fuzzy, PNMBrush::BrushEffect effect = ::PNMBrush::BE_blend)
 */
static PyObject *Dtool_PNMBrush_make_spot_221(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static PointerTo< PNMBrush > PNMBrush::make_spot(LColorf const &color, float radius, bool fuzzy, PNMBrush::BrushEffect effect = ::PNMBrush::BE_blend)
  PyObject *param0;
  float param1;
  PyObject *param2;
  int param3 = PNMBrush::BE_blend;
  static const char *keyword_list[] = {"color", "radius", "fuzzy", "effect", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OfO|i:make_spot", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
    LVecBase4f param0_local;
    LColorf const *param0_this = Dtool_Coerce_LVecBase4f(param0, param0_local);
    if (!(param0_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "PNMBrush.make_spot", "LVecBase4f");
    }
    PointerTo< PNMBrush > return_value = (PNMBrush::make_spot)(*param0_this, (float)param1, (PyObject_IsTrue(param2) != 0), (PNMBrush::BrushEffect)param3);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    PNMBrush *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_PNMBrush, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_spot(const LVecBase4f color, float radius, bool fuzzy, int effect)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMBrush_make_spot_221_comment =
  "C++ Interface:\n"
  "make_spot(const LVecBase4f color, float radius, bool fuzzy, int effect)\n"
  "\n"
  "/**\n"
  " * Returns a new brush that paints a spot of the indicated color and radius.\n"
  " * If fuzzy is true, the spot is fuzzy; otherwise, it is hard-edged.\n"
  " */";
#else
static const char *Dtool_PNMBrush_make_spot_221_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< PNMBrush > PNMBrush::make_image(PNMImage const &image, float xc, float yc, PNMBrush::BrushEffect effect = ::PNMBrush::BE_blend)
 */
static PyObject *Dtool_PNMBrush_make_image_222(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static PointerTo< PNMBrush > PNMBrush::make_image(PNMImage const &image, float xc, float yc, PNMBrush::BrushEffect effect = ::PNMBrush::BE_blend)
  PyObject *param0;
  float param1;
  float param2;
  int param3 = PNMBrush::BE_blend;
  static const char *keyword_list[] = {"image", "xc", "yc", "effect", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Off|i:make_image", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
    PNMImage const *param0_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PNMImage, 0, "PNMBrush.make_image", true, true);
    if (param0_this != nullptr) {
      PointerTo< PNMBrush > return_value = (PNMBrush::make_image)(*param0_this, (float)param1, (float)param2, (PNMBrush::BrushEffect)param3);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      PNMBrush *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_PNMBrush, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_image(const PNMImage image, float xc, float yc, int effect)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMBrush_make_image_222_comment =
  "C++ Interface:\n"
  "make_image(const PNMImage image, float xc, float yc, int effect)\n"
  "\n"
  "/**\n"
  " * Returns a new brush that paints with the indicated image.  xc and yc\n"
  " * indicate the pixel in the center of the brush.\n"
  " *\n"
  " * The brush makes a copy of the image; it is safe to deallocate or modify the\n"
  " * image after making this call.\n"
  " */";
#else
static const char *Dtool_PNMBrush_make_image_222_comment = nullptr;
#endif

static int Dtool_Init_PNMBrush(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PNMBrush(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PNMBrush) {
    printf("PNMBrush ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PNMBrush *local_this = (PNMBrush *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PNMBrush) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PNMBrush(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PNMBrush) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PNMBrush*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PNMImage
 */
/**
 * Python function wrapper for:
 * inline void PNMImage::operator =(PNMImage const &copy)
 */
static PyObject *Dtool_PNMImage_operator_225(PyObject *self, PyObject *arg) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.assign")) {
    return nullptr;
  }
  // 1-inline void PNMImage::operator =(PNMImage const &copy)
  PNMImage const *arg_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImage, 1, "PNMImage.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    PNMImage *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImage, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const PNMImage self, const PNMImage copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_operator_225_comment =
  "C++ Interface:\n"
  "assign(const PNMImage self, const PNMImage copy)\n";
#else
static const char *Dtool_PNMImage_operator_225_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline xelval PNMImage::clamp_val(int input_value) const
 */
static PyObject *Dtool_PNMImage_clamp_val_227(PyObject *self, PyObject *arg) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  // 1-inline xelval PNMImage::clamp_val(int input_value) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    xelval return_value = ((*(const PNMImage*)local_this).clamp_val)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clamp_val(PNMImage self, int input_value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_clamp_val_227_comment =
  "C++ Interface:\n"
  "clamp_val(PNMImage self, int input_value)\n"
  "\n"
  "/**\n"
  " * A handy function to clamp values to [0..get_maxval()].\n"
  " */";
#else
static const char *Dtool_PNMImage_clamp_val_227_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline xel PNMImage::to_val(LRGBColorf const &input_value) const
 * inline xelval PNMImage::to_val(float input_value) const
 */
static PyObject *Dtool_PNMImage_to_val_228(PyObject *self, PyObject *arg) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  {
    // -2 inline xel PNMImage::to_val(LRGBColorf const &input_value) const
    LRGBColorf const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase3f);
    if (arg_this != nullptr) {
      xel *return_value = new xel(((*(const PNMImage*)local_this).to_val)(*arg_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_pixel, true, false);
    }
  }

  {
    // -2 inline xelval PNMImage::to_val(float input_value) const
    if (PyNumber_Check(arg)) {
      xelval return_value = ((*(const PNMImage*)local_this).to_val)((float)PyFloat_AsDouble(arg));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 inline xel PNMImage::to_val(LRGBColorf const &input_value) const
    LVecBase3f arg_local;
    LRGBColorf const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
    if ((arg_this != nullptr)) {
      xel *return_value = new xel(((*(const PNMImage*)local_this).to_val)(*arg_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_pixel, true, false);
    }
  }

  // No coercion possible: inline xelval PNMImage::to_val(float input_value) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "to_val(PNMImage self, const LVecBase3f input_value)\n"
      "to_val(PNMImage self, float input_value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_to_val_228_comment =
  "C++ Interface:\n"
  "to_val(PNMImage self, const LVecBase3f input_value)\n"
  "to_val(PNMImage self, float input_value)\n"
  "\n"
  "/**\n"
  " * A handy function to scale non-alpha values from [0..1] to\n"
  " * [0..get_maxval()].  Do not use this for alpha values, see to_alpha_val.\n"
  " */\n"
  "\n"
  "/**\n"
  " * A handy function to scale non-alpha values from [0..1] to\n"
  " * [0..get_maxval()].  Do not use this for alpha values, see to_alpha_val.\n"
  " */";
#else
static const char *Dtool_PNMImage_to_val_228_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline xelval PNMImage::to_alpha_val(float input_value) const
 */
static PyObject *Dtool_PNMImage_to_alpha_val_229(PyObject *self, PyObject *arg) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  // 1-inline xelval PNMImage::to_alpha_val(float input_value) const
  if (PyNumber_Check(arg)) {
    xelval return_value = ((*(const PNMImage*)local_this).to_alpha_val)((float)PyFloat_AsDouble(arg));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "to_alpha_val(PNMImage self, float input_value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_to_alpha_val_229_comment =
  "C++ Interface:\n"
  "to_alpha_val(PNMImage self, float input_value)\n"
  "\n"
  "/**\n"
  " * A handy function to scale alpha values from [0..1] to [0..get_maxval()].\n"
  " */";
#else
static const char *Dtool_PNMImage_to_alpha_val_229_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LRGBColorf PNMImage::from_val(xel const &input_value) const
 * inline float PNMImage::from_val(xelval input_value) const
 */
static PyObject *Dtool_PNMImage_from_val_230(PyObject *self, PyObject *arg) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  {
    // -2 inline LRGBColorf PNMImage::from_val(xel const &input_value) const
    xel const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_pixel);
    if (arg_this != nullptr) {
      LRGBColorf *return_value = new LRGBColorf(((*(const PNMImage*)local_this).from_val)(*arg_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
    }
  }

  {
    // -2 inline float PNMImage::from_val(xelval input_value) const
    if (PyLongOrInt_Check(arg)) {
      long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
      if (param1 < 0 || param1 > USHRT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for unsigned short integer",
                            param1);
      }
#endif
      float return_value = ((*(const PNMImage*)local_this).from_val)((xelval)param1);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 inline LRGBColorf PNMImage::from_val(xel const &input_value) const
    pixel arg_local;
    xel const *arg_this = Dtool_Coerce_pixel(arg, arg_local);
    if ((arg_this != nullptr)) {
      LRGBColorf *return_value = new LRGBColorf(((*(const PNMImage*)local_this).from_val)(*arg_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
    }
  }

  // No coercion possible: inline float PNMImage::from_val(xelval input_value) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "from_val(PNMImage self, const pixel input_value)\n"
      "from_val(PNMImage self, int input_value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_from_val_230_comment =
  "C++ Interface:\n"
  "from_val(PNMImage self, const pixel input_value)\n"
  "from_val(PNMImage self, int input_value)\n"
  "\n"
  "/**\n"
  " * A handy function to scale non-alpha values from [0..get_maxval()] to\n"
  " * [0..1].  Do not use this for alpha values, see from_alpha_val.\n"
  " */\n"
  "\n"
  "/**\n"
  " * A handy function to scale non-alpha values from [0..get_maxval()] to\n"
  " * [0..1].  Do not use this for alpha values, see from_alpha_val.\n"
  " */";
#else
static const char *Dtool_PNMImage_from_val_230_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float PNMImage::from_alpha_val(xelval input_value) const
 */
static PyObject *Dtool_PNMImage_from_alpha_val_231(PyObject *self, PyObject *arg) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  // 1-inline float PNMImage::from_alpha_val(xelval input_value) const
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    float return_value = ((*(const PNMImage*)local_this).from_alpha_val)((xelval)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "from_alpha_val(PNMImage self, int input_value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_from_alpha_val_231_comment =
  "C++ Interface:\n"
  "from_alpha_val(PNMImage self, int input_value)\n"
  "\n"
  "/**\n"
  " * A handy function to scale alpha values from [0..get_maxval()] to [0..1].\n"
  " */";
#else
static const char *Dtool_PNMImage_from_alpha_val_231_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::clear(void)
 * void PNMImage::clear(int x_size, int y_size, int num_channels = 3, xelval maxval = 255, PNMFileType *type = nullptr, ColorSpace color_space = ::CS_linear)
 */
static PyObject *Dtool_PNMImage_clear_232(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.clear")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-void PNMImage::clear(void)
      ((*local_this).clear)();
      return Dtool_Return_None();
    }
    break;
  case 2:
  case 3:
  case 4:
  case 5:
  case 6:
    {
      // 1-void PNMImage::clear(int x_size, int y_size, int num_channels = 3, xelval maxval = 255, PNMFileType *type = nullptr, ColorSpace color_space = ::CS_linear)
      int param1;
      int param2;
      int param3 = 3;
      long param4 = 255;
      PyObject *param5 = nullptr;
      int param6 = ::CS_linear;
      static const char *keyword_list[] = {"x_size", "y_size", "num_channels", "maxval", "type", "color_space", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii|ilOi:clear", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
#ifndef NDEBUG
        if (param4 < 0 || param4 > USHRT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for unsigned short integer",
                              param4);
        }
#endif
        PNMFileType *param5_this = nullptr;
        if (param5 != nullptr && param5 != Py_None) {
          param5_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param5, Dtool_Ptr_PNMFileType, 5, "PNMImage.clear", false, true);
        }
        if ((param5 == nullptr || param5 == Py_None || param5_this != nullptr)) {
          ((*local_this).clear)((int)param1, (int)param2, (int)param3, (xelval)param4, param5_this, (ColorSpace)param6);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "clear() takes 1, 3, 4, 5, 6 or 7 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear(const PNMImage self)\n"
      "clear(const PNMImage self, int x_size, int y_size, int num_channels, int maxval, PNMFileType type, int color_space)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_clear_232_comment =
  "C++ Interface:\n"
  "clear(const PNMImage self)\n"
  "clear(const PNMImage self, int x_size, int y_size, int num_channels, int maxval, PNMFileType type, int color_space)\n"
  "\n"
  "/**\n"
  " * Frees all memory allocated for the image, and clears all its parameters\n"
  " * (size, color, type, etc).\n"
  " */\n"
  "\n"
  "/**\n"
  " * This flavor of clear() reinitializes the image to an empty (black) image\n"
  " * with the given dimensions.\n"
  " */";
#else
static const char *Dtool_PNMImage_clear_232_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::copy_from(PNMImage const &copy)
 */
static PyObject *Dtool_PNMImage_copy_from_233(PyObject *self, PyObject *arg) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.copy_from")) {
    return nullptr;
  }
  // 1-void PNMImage::copy_from(PNMImage const &copy)
  PNMImage const *arg_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImage, 1, "PNMImage.copy_from", true, true);
  if (arg_this != nullptr) {
    ((*local_this).copy_from)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_from(const PNMImage self, const PNMImage copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_copy_from_233_comment =
  "C++ Interface:\n"
  "copy_from(const PNMImage self, const PNMImage copy)\n"
  "\n"
  "/**\n"
  " * Makes this image become a copy of the other image.\n"
  " */";
#else
static const char *Dtool_PNMImage_copy_from_233_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::copy_channel(PNMImage const &copy, int src_channel, int dest_channel)
 * void PNMImage::copy_channel(PNMImage const &copy, int xto, int yto, int cto, int xfrom = 0, int yfrom = 0, int cfrom = 0, int x_size = -1, int y_size = -1)
 */
static PyObject *Dtool_PNMImage_copy_channel_234(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.copy_channel")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 3:
    {
      // 1-void PNMImage::copy_channel(PNMImage const &copy, int src_channel, int dest_channel)
      PyObject *param1;
      int param2;
      int param3;
      static const char *keyword_list[] = {"copy", "src_channel", "dest_channel", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii:copy_channel", (char **)keyword_list, &param1, &param2, &param3)) {
        PNMImage const *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PNMImage.copy_channel", true, true);
        if (param1_this != nullptr) {
          ((*local_this).copy_channel)(*param1_this, (int)param2, (int)param3);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 4:
  case 5:
  case 6:
  case 7:
  case 8:
  case 9:
    {
      // 1-void PNMImage::copy_channel(PNMImage const &copy, int xto, int yto, int cto, int xfrom = 0, int yfrom = 0, int cfrom = 0, int x_size = -1, int y_size = -1)
      PyObject *param1;
      int param2;
      int param3;
      int param4;
      int param5 = 0;
      int param6 = 0;
      int param7 = 0;
      int param8 = -1;
      int param9 = -1;
      static const char *keyword_list[] = {"copy", "xto", "yto", "cto", "xfrom", "yfrom", "cfrom", "x_size", "y_size", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oiii|iiiii:copy_channel", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9)) {
        PNMImage const *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PNMImage.copy_channel", true, true);
        if (param1_this != nullptr) {
          ((*local_this).copy_channel)(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7, (int)param8, (int)param9);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "copy_channel() takes 4, 5, 6, 7, 8, 9 or 10 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_channel(const PNMImage self, const PNMImage copy, int src_channel, int dest_channel)\n"
      "copy_channel(const PNMImage self, const PNMImage copy, int xto, int yto, int cto, int xfrom, int yfrom, int cfrom, int x_size, int y_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_copy_channel_234_comment =
  "C++ Interface:\n"
  "copy_channel(const PNMImage self, const PNMImage copy, int src_channel, int dest_channel)\n"
  "copy_channel(const PNMImage self, const PNMImage copy, int xto, int yto, int cto, int xfrom, int yfrom, int cfrom, int x_size, int y_size)\n"
  "\n"
  "/**\n"
  " * Copies a channel from one image into another.  Images must be the same size\n"
  " */\n"
  "\n"
  "/**\n"
  " * Copies just a single channel from the source image into a single channel of\n"
  " * this image, leaving the remaining channels alone.\n"
  " */";
#else
static const char *Dtool_PNMImage_copy_channel_234_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::copy_channel_bits(PNMImage const &copy, int src_channel, int dest_channel, xelval src_mask, int right_shift)
 */
static PyObject *Dtool_PNMImage_copy_channel_bits_235(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.copy_channel_bits")) {
    return nullptr;
  }
  // 1-void PNMImage::copy_channel_bits(PNMImage const &copy, int src_channel, int dest_channel, xelval src_mask, int right_shift)
  PyObject *param1;
  int param2;
  int param3;
  long param4;
  int param5;
  static const char *keyword_list[] = {"copy", "src_channel", "dest_channel", "src_mask", "right_shift", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oiili:copy_channel_bits", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
    PNMImage const *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PNMImage.copy_channel_bits", true, true);
#ifndef NDEBUG
    if (param4 < 0 || param4 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param4);
    }
#endif
    if (param1_this != nullptr) {
      ((*local_this).copy_channel_bits)(*param1_this, (int)param2, (int)param3, (xelval)param4, (int)param5);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_channel_bits(const PNMImage self, const PNMImage copy, int src_channel, int dest_channel, int src_mask, int right_shift)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_copy_channel_bits_235_comment =
  "C++ Interface:\n"
  "copy_channel_bits(const PNMImage self, const PNMImage copy, int src_channel, int dest_channel, int src_mask, int right_shift)\n"
  "\n"
  "/**\n"
  " * Copies some subset of the bits of the specified channel from one image into\n"
  " * some subset of the bits of the specified channel in another image.  Images\n"
  " * must be the same size.\n"
  " *\n"
  " * If right_shift is negative, it means a left shift.\n"
  " */";
#else
static const char *Dtool_PNMImage_copy_channel_bits_235_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::copy_header_from(PNMImageHeader const &header)
 */
static PyObject *Dtool_PNMImage_copy_header_from_236(PyObject *self, PyObject *arg) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.copy_header_from")) {
    return nullptr;
  }
  // 1-void PNMImage::copy_header_from(PNMImageHeader const &header)
  PNMImageHeader const *arg_this = (PNMImageHeader *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImageHeader, 1, "PNMImage.copy_header_from", true, true);
  if (arg_this != nullptr) {
    ((*local_this).copy_header_from)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_header_from(const PNMImage self, const PNMImageHeader header)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_copy_header_from_236_comment =
  "C++ Interface:\n"
  "copy_header_from(const PNMImage self, const PNMImageHeader header)\n"
  "\n"
  "/**\n"
  " * Copies just the header information into this image.  This will blow away\n"
  " * any image data stored in the image.  The new image data will be allocated,\n"
  " * but left unitialized.\n"
  " */";
#else
static const char *Dtool_PNMImage_copy_header_from_236_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::take_from(PNMImage &orig)
 */
static PyObject *Dtool_PNMImage_take_from_237(PyObject *self, PyObject *arg) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.take_from")) {
    return nullptr;
  }
  // 1-void PNMImage::take_from(PNMImage &orig)
  PNMImage *arg_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImage, 1, "PNMImage.take_from", false, true);
  if (arg_this != nullptr) {
    ((*local_this).take_from)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "take_from(const PNMImage self, PNMImage orig)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_take_from_237_comment =
  "C++ Interface:\n"
  "take_from(const PNMImage self, PNMImage orig)\n"
  "\n"
  "/**\n"
  " * Move the contents of the other image into this one, and empty the other\n"
  " * image.\n"
  " */";
#else
static const char *Dtool_PNMImage_take_from_237_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::fill(float gray = 0.0)
 * inline void PNMImage::fill(float red, float green, float blue)
 */
static PyObject *Dtool_PNMImage_fill_238(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.fill")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void PNMImage::fill(float gray)
      ((*local_this).fill)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "gray")) {
        // 1-inline void PNMImage::fill(float gray)
        if (PyNumber_Check(arg)) {
          ((*local_this).fill)((float)PyFloat_AsDouble(arg));
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 3:
    {
      // 1-inline void PNMImage::fill(float red, float green, float blue)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"red", "green", "blue", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:fill", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).fill)((float)param1, (float)param2, (float)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "fill() takes 1, 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill(const PNMImage self)\n"
      "fill(const PNMImage self, float gray)\n"
      "fill(const PNMImage self, float red, float green, float blue)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_fill_238_comment =
  "C++ Interface:\n"
  "fill(const PNMImage self)\n"
  "fill(const PNMImage self, float gray)\n"
  "fill(const PNMImage self, float red, float green, float blue)\n"
  "\n"
  "/**\n"
  " * Sets the entire image (except the alpha channel) to the given color.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the entire image (except the alpha channel) to the given grayscale\n"
  " * level.\n"
  " */";
#else
static const char *Dtool_PNMImage_fill_238_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::fill_val(xelval gray = 0)
 * void PNMImage::fill_val(xelval red, xelval green, xelval blue)
 */
static PyObject *Dtool_PNMImage_fill_val_239(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.fill_val")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void PNMImage::fill_val(xelval gray)
      ((*local_this).fill_val)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "gray")) {
        // 1-inline void PNMImage::fill_val(xelval gray)
        if (PyLongOrInt_Check(arg)) {
          long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
          if (param1 < 0 || param1 > USHRT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for unsigned short integer",
                                param1);
          }
#endif
          ((*local_this).fill_val)((xelval)param1);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 3:
    {
      // 1-void PNMImage::fill_val(xelval red, xelval green, xelval blue)
      long param1;
      long param2;
      long param3;
      static const char *keyword_list[] = {"red", "green", "blue", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "lll:fill_val", (char **)keyword_list, &param1, &param2, &param3)) {
#ifndef NDEBUG
        if (param1 < 0 || param1 > USHRT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for unsigned short integer",
                              param1);
        }
#endif
#ifndef NDEBUG
        if (param2 < 0 || param2 > USHRT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for unsigned short integer",
                              param2);
        }
#endif
#ifndef NDEBUG
        if (param3 < 0 || param3 > USHRT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for unsigned short integer",
                              param3);
        }
#endif
        ((*local_this).fill_val)((xelval)param1, (xelval)param2, (xelval)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "fill_val() takes 1, 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill_val(const PNMImage self)\n"
      "fill_val(const PNMImage self, int gray)\n"
      "fill_val(const PNMImage self, int red, int green, int blue)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_fill_val_239_comment =
  "C++ Interface:\n"
  "fill_val(const PNMImage self)\n"
  "fill_val(const PNMImage self, int gray)\n"
  "fill_val(const PNMImage self, int red, int green, int blue)\n"
  "\n"
  "/**\n"
  " * Sets the entire image (except the alpha channel) to the given grayscale\n"
  " * level.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the entire image (except the alpha channel) to the given color.\n"
  " */";
#else
static const char *Dtool_PNMImage_fill_val_239_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::alpha_fill(float alpha = 0.0)
 */
static PyObject *Dtool_PNMImage_alpha_fill_240(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.alpha_fill")) {
    return nullptr;
  }
  // 1-inline void PNMImage::alpha_fill(float alpha = 0.0)
  float param1 = 0.0;
  static const char *keyword_list[] = {"alpha", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|f:alpha_fill", (char **)keyword_list, &param1)) {
    ((*local_this).alpha_fill)((float)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "alpha_fill(const PNMImage self, float alpha)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_alpha_fill_240_comment =
  "C++ Interface:\n"
  "alpha_fill(const PNMImage self, float alpha)\n"
  "\n"
  "/**\n"
  " * Sets the entire alpha channel to the given level.\n"
  " */";
#else
static const char *Dtool_PNMImage_alpha_fill_240_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::alpha_fill_val(xelval alpha = 0)
 */
static PyObject *Dtool_PNMImage_alpha_fill_val_241(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.alpha_fill_val")) {
    return nullptr;
  }
  // 1-void PNMImage::alpha_fill_val(xelval alpha = 0)
  long param1 = 0;
  static const char *keyword_list[] = {"alpha", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|l:alpha_fill_val", (char **)keyword_list, &param1)) {
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    ((*local_this).alpha_fill_val)((xelval)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "alpha_fill_val(const PNMImage self, int alpha)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_alpha_fill_val_241_comment =
  "C++ Interface:\n"
  "alpha_fill_val(const PNMImage self, int alpha)\n"
  "\n"
  "/**\n"
  " * Sets the entire alpha channel to the given level.\n"
  " */";
#else
static const char *Dtool_PNMImage_alpha_fill_val_241_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::set_read_size(int x_size, int y_size)
 */
static PyObject *Dtool_PNMImage_set_read_size_242(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_read_size")) {
    return nullptr;
  }
  // 1-inline void PNMImage::set_read_size(int x_size, int y_size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"x_size", "y_size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_read_size", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_read_size)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_read_size(const PNMImage self, int x_size, int y_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_read_size_242_comment =
  "C++ Interface:\n"
  "set_read_size(const PNMImage self, int x_size, int y_size)\n"
  "\n"
  "/**\n"
  " * Specifies the size to we'd like to scale the image upon reading it.  This\n"
  " * will affect the next call to read().  This is usually used to reduce the\n"
  " * image size, e.g.  for a thumbnail.\n"
  " *\n"
  " * If the file type reader supports it (e.g.  JPEG), then this will scale the\n"
  " * image during the read operation, consequently reducing memory and CPU\n"
  " * utilization.  If the file type reader does not support it, this will load\n"
  " * the image normally, and them perform a linear scale after it has been\n"
  " * loaded.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_read_size_242_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::clear_read_size(void)
 */
static PyObject *Dtool_PNMImage_clear_read_size_243(PyObject *self, PyObject *) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.clear_read_size")) {
    return nullptr;
  }
  // 1-inline void PNMImage::clear_read_size(void)
  ((*local_this).clear_read_size)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_clear_read_size_243_comment =
  "C++ Interface:\n"
  "clear_read_size(const PNMImage self)\n"
  "\n"
  "/**\n"
  " * Undoes the effect of a previous call to set_read_size().\n"
  " */";
#else
static const char *Dtool_PNMImage_clear_read_size_243_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PNMImage::has_read_size(void) const
 */
static PyObject *Dtool_PNMImage_has_read_size_244(PyObject *self, PyObject *) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  // 1-inline bool PNMImage::has_read_size(void) const
  bool return_value = ((*(const PNMImage*)local_this).has_read_size)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_has_read_size_244_comment =
  "C++ Interface:\n"
  "has_read_size(PNMImage self)\n"
  "\n"
  "/**\n"
  " * Returns true if set_read_size() has been called.\n"
  " */";
#else
static const char *Dtool_PNMImage_has_read_size_244_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PNMImage::get_read_x_size(void) const
 */
static PyObject *Dtool_PNMImage_get_read_x_size_245(PyObject *self, PyObject *) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  // 1-inline int PNMImage::get_read_x_size(void) const
  int return_value = ((*(const PNMImage*)local_this).get_read_x_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_read_x_size_245_comment =
  "C++ Interface:\n"
  "get_read_x_size(PNMImage self)\n"
  "\n"
  "/**\n"
  " * Returns the requested x_size of the image if set_read_size() has been\n"
  " * called, or the image x_size otherwise (if it is known).\n"
  " */";
#else
static const char *Dtool_PNMImage_get_read_x_size_245_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PNMImage::get_read_y_size(void) const
 */
static PyObject *Dtool_PNMImage_get_read_y_size_246(PyObject *self, PyObject *) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  // 1-inline int PNMImage::get_read_y_size(void) const
  int return_value = ((*(const PNMImage*)local_this).get_read_y_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_read_y_size_246_comment =
  "C++ Interface:\n"
  "get_read_y_size(PNMImage self)\n"
  "\n"
  "/**\n"
  " * Returns the requested y_size of the image if set_read_size() has been\n"
  " * called, or the image y_size otherwise (if it is known).\n"
  " */";
#else
static const char *Dtool_PNMImage_get_read_y_size_246_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ColorSpace PNMImage::get_color_space(void) const
 */
static PyObject *Dtool_PNMImage_get_color_space_247(PyObject *self, PyObject *) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  // 1-inline ColorSpace PNMImage::get_color_space(void) const
  ColorSpace return_value = ((*(const PNMImage*)local_this).get_color_space)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_color_space_247_comment =
  "C++ Interface:\n"
  "get_color_space(PNMImage self)\n"
  "\n"
  "/**\n"
  " * Returns the color space in which the image is encoded.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_color_space_247_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PNMImage::read(Filename const &filename, PNMFileType *type = nullptr, bool report_unknown_type = true)
 * Rejected Remap [bool PNMImage::read(PNMReader *reader)]
 * bool PNMImage::read(std::istream &data, std::string const &filename = string(), PNMFileType *type = nullptr, bool report_unknown_type = true)
 */
static PyObject *Dtool_PNMImage_read_248(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.read")) {
    return nullptr;
  }
  {
    // -2 bool PNMImage::read(std::istream &data, std::string const &filename = string(), PNMFileType *type = nullptr, bool report_unknown_type = true)
    PyObject *param1;
    const char *param2_str = "";
    Py_ssize_t param2_len = 0;
    PyObject *param3 = nullptr;
    PyObject *param4 = Py_True;
    static const char *keyword_list[] = {"data", "filename", "type", "report_unknown_type", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#OO:read", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3, &param4)) {
      std::istream *param1_this = (std::istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_istream, 1, "PNMImage.read", false, false);
      PNMFileType *param3_this = nullptr;
      if (param3 != nullptr && param3 != Py_None) {
        param3_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_PNMFileType, 3, "PNMImage.read", false, false);
      }
      if (param1_this != nullptr && (param3 == nullptr || param3 == Py_None || param3_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = ((*local_this).read)(*param1_this, std::string(param2_str, param2_len), param3_this, (PyObject_IsTrue(param4) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: bool PNMImage::read(std::istream &data, std::string const &filename = string(), PNMFileType *type = nullptr, bool report_unknown_type = true)
  {
    // -2 bool PNMImage::read(Filename const &filename, PNMFileType *type = nullptr, bool report_unknown_type = true)
    PyObject *param1;
    PyObject *param2 = nullptr;
    PyObject *param3 = Py_True;
    static const char *keyword_list[] = {"filename", "type", "report_unknown_type", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|OO:read", (char **)keyword_list, &param1, &param2, &param3)) {
      Filename param1_local;
      Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
      PNMFileType *param2_this = nullptr;
      if (param2 != nullptr && param2 != Py_None) {
        param2_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PNMFileType, 2, "PNMImage.read", false, false);
      }
      if ((param1_this != nullptr) && (param2 == nullptr || param2 == Py_None || param2_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = ((*local_this).read)(*param1_this, param2_this, (PyObject_IsTrue(param3) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read(const PNMImage self, istream data, str filename, PNMFileType type, bool report_unknown_type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_read_248_comment =
  "C++ Interface:\n"
  "read(const PNMImage self, istream data, str filename, PNMFileType type, bool report_unknown_type)\n"
  "\n"
  "/**\n"
  " * Reads the indicated image filename.  If type is non-NULL, it is a\n"
  " * suggestion for the type of file it is.  Returns true if successful, false\n"
  " * on error.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Reads the image data from the indicated stream.\n"
  " *\n"
  " * The filename is advisory only, and may be used to suggest a type if it has\n"
  " * a known extension.\n"
  " *\n"
  " * If type is non-NULL, it is a suggestion for the type of file it is (and a\n"
  " * non-NULL type will override any magic number test or filename extension\n"
  " * lookup).\n"
  " *\n"
  " * Returns true if successful, false on error.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This flavor of read() uses an already-existing PNMReader to read the image\n"
  " * file.  You can get a reader via the PNMImageHeader::make_reader() methods.\n"
  " * This is a good way to examine the header of a file (for instance, to\n"
  " * determine its size) before actually reading the entire image.\n"
  " *\n"
  " * The PNMReader is always deleted upon completion, whether successful or not.\n"
  " */";
#else
static const char *Dtool_PNMImage_read_248_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PNMImage::write(Filename const &filename, PNMFileType *type = nullptr) const
 * Rejected Remap [bool PNMImage::write(PNMWriter *writer) const]
 * bool PNMImage::write(std::ostream &data, std::string const &filename = string(), PNMFileType *type = nullptr) const
 */
static PyObject *Dtool_PNMImage_write_249(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  {
    // -2 bool PNMImage::write(std::ostream &data, std::string const &filename = string(), PNMFileType *type = nullptr) const
    PyObject *param1;
    const char *param2_str = "";
    Py_ssize_t param2_len = 0;
    PyObject *param3 = nullptr;
    static const char *keyword_list[] = {"data", "filename", "type", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#O:write", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3)) {
      std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "PNMImage.write", false, false);
      PNMFileType *param3_this = nullptr;
      if (param3 != nullptr && param3 != Py_None) {
        param3_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_PNMFileType, 3, "PNMImage.write", false, false);
      }
      if (param1_this != nullptr && (param3 == nullptr || param3 == Py_None || param3_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = ((*(const PNMImage*)local_this).write)(*param1_this, std::string(param2_str, param2_len), param3_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: bool PNMImage::write(std::ostream &data, std::string const &filename = string(), PNMFileType *type = nullptr) const
  {
    // -2 bool PNMImage::write(Filename const &filename, PNMFileType *type = nullptr) const
    PyObject *param1;
    PyObject *param2 = nullptr;
    static const char *keyword_list[] = {"filename", "type", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:write", (char **)keyword_list, &param1, &param2)) {
      Filename param1_local;
      Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
      PNMFileType *param2_this = nullptr;
      if (param2 != nullptr && param2 != Py_None) {
        param2_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PNMFileType, 2, "PNMImage.write", false, false);
      }
      if ((param1_this != nullptr) && (param2 == nullptr || param2 == Py_None || param2_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = ((*(const PNMImage*)local_this).write)(*param1_this, param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(PNMImage self, ostream data, str filename, PNMFileType type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_write_249_comment =
  "C++ Interface:\n"
  "write(PNMImage self, ostream data, str filename, PNMFileType type)\n"
  "\n"
  "/**\n"
  " * Writes the image to the indicated filename.  If type is non-NULL, it is a\n"
  " * suggestion for the type of image file to write.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Writes the image to the indicated ostream.\n"
  " *\n"
  " * The filename is advisory only, and may be used suggest a type if it has a\n"
  " * known extension.\n"
  " *\n"
  " * If type is non-NULL, it is a suggestion for the type of image file to\n"
  " * write.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This flavor of write() uses an already-existing PNMWriter to write the\n"
  " * image file.  You can get a writer via the PNMImageHeader::make_writer()\n"
  " * methods.\n"
  " *\n"
  " * The PNMWriter is always deleted upon completion, whether successful or not.\n"
  " */";
#else
static const char *Dtool_PNMImage_write_249_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PNMImage::is_valid(void) const
 */
static PyObject *Dtool_PNMImage_is_valid_250(PyObject *self, PyObject *) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  // 1-inline bool PNMImage::is_valid(void) const
  bool return_value = ((*(const PNMImage*)local_this).is_valid)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_is_valid_250_comment =
  "C++ Interface:\n"
  "is_valid(PNMImage self)\n"
  "\n"
  "/**\n"
  " * Returns true if the image has been read in or correctly initialized with a\n"
  " * height and width.  If this returns false, virtually all member functions\n"
  " * except clear() and read() are invalid function calls.\n"
  " */";
#else
static const char *Dtool_PNMImage_is_valid_250_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::set_num_channels(int num_channels)
 */
static PyObject *Dtool_PNMImage_set_num_channels_251(PyObject *self, PyObject *arg) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_num_channels")) {
    return nullptr;
  }
  // 1-inline void PNMImage::set_num_channels(int num_channels)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_num_channels)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_channels(const PNMImage self, int num_channels)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_num_channels_251_comment =
  "C++ Interface:\n"
  "set_num_channels(const PNMImage self, int num_channels)\n"
  "\n"
  "/**\n"
  " * Changes the number of channels associated with the image.  The new number\n"
  " * of channels must be an integer in the range 1 through 4, inclusive.  This\n"
  " * will allocate and/or deallocate memory as necessary to accommodate; see\n"
  " * set_color_type().\n"
  " */";
#else
static const char *Dtool_PNMImage_set_num_channels_251_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::set_color_type(PNMImageHeader::ColorType color_type)
 */
static PyObject *Dtool_PNMImage_set_color_type_252(PyObject *self, PyObject *arg) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_color_type")) {
    return nullptr;
  }
  // 1-void PNMImage::set_color_type(PNMImageHeader::ColorType color_type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_color_type)((PNMImageHeader::ColorType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color_type(const PNMImage self, int color_type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_color_type_252_comment =
  "C++ Interface:\n"
  "set_color_type(const PNMImage self, int color_type)\n"
  "\n"
  "/**\n"
  " * Translates the image to or from grayscale, color, or four-color mode.\n"
  " * Grayscale images are converted to full-color images with R, G, B set to the\n"
  " * original gray level; color images are converted to grayscale according to\n"
  " * the value of Bright().  The alpha channel, if added, is initialized to\n"
  " * zero.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_color_type_252_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::set_color_space(ColorSpace color_space)
 */
static PyObject *Dtool_PNMImage_set_color_space_253(PyObject *self, PyObject *arg) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_color_space")) {
    return nullptr;
  }
  // 1-void PNMImage::set_color_space(ColorSpace color_space)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_color_space)((ColorSpace)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color_space(const PNMImage self, int color_space)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_color_space_253_comment =
  "C++ Interface:\n"
  "set_color_space(const PNMImage self, int color_space)\n"
  "\n"
  "/**\n"
  " * Converts the colors in the image to the indicated color space.  This may be\n"
  " * a lossy operation, in particular when going from sRGB to linear.  The alpha\n"
  " * channel remains untouched.\n"
  " *\n"
  " * Note that, because functions like get_xel() and set_xel() work on\n"
  " * linearized floating-point values, this conversion won't affect those values\n"
  " * (aside from some minor discrepancies due to storage precision).  It does\n"
  " * affect the values used by get_xel_val() and set_xel_val(), though, since\n"
  " * those operate on encoded colors.\n"
  " *\n"
  " * Some color spaces, particularly scRGB, may enforce the use of a particular\n"
  " * maxval setting.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_color_space_253_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::add_alpha(void)
 */
static PyObject *Dtool_PNMImage_add_alpha_254(PyObject *self, PyObject *) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.add_alpha")) {
    return nullptr;
  }
  // 1-inline void PNMImage::add_alpha(void)
  ((*local_this).add_alpha)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_add_alpha_254_comment =
  "C++ Interface:\n"
  "add_alpha(const PNMImage self)\n"
  "\n"
  "/**\n"
  " * Adds an alpha channel to the image, if it does not already have one.  The\n"
  " * alpha channel is initialized to zeros.\n"
  " */";
#else
static const char *Dtool_PNMImage_add_alpha_254_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::remove_alpha(void)
 */
static PyObject *Dtool_PNMImage_remove_alpha_255(PyObject *self, PyObject *) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.remove_alpha")) {
    return nullptr;
  }
  // 1-inline void PNMImage::remove_alpha(void)
  ((*local_this).remove_alpha)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_remove_alpha_255_comment =
  "C++ Interface:\n"
  "remove_alpha(const PNMImage self)\n"
  "\n"
  "/**\n"
  " * Removes the image's alpha channel, if it exists.\n"
  " */";
#else
static const char *Dtool_PNMImage_remove_alpha_255_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::make_grayscale(void)
 * void PNMImage::make_grayscale(float rc, float gc, float bc)
 */
static PyObject *Dtool_PNMImage_make_grayscale_256(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.make_grayscale")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void PNMImage::make_grayscale(void)
      ((*local_this).make_grayscale)();
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-void PNMImage::make_grayscale(float rc, float gc, float bc)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"rc", "gc", "bc", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:make_grayscale", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).make_grayscale)((float)param1, (float)param2, (float)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make_grayscale() takes 1 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_grayscale(const PNMImage self)\n"
      "make_grayscale(const PNMImage self, float rc, float gc, float bc)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_make_grayscale_256_comment =
  "C++ Interface:\n"
  "make_grayscale(const PNMImage self)\n"
  "make_grayscale(const PNMImage self, float rc, float gc, float bc)\n"
  "\n"
  "/**\n"
  " * Converts the image from RGB to grayscale.  Any alpha channel, if present,\n"
  " * is left undisturbed.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Converts the image from RGB to grayscale.  Any alpha channel, if present,\n"
  " * is left undisturbed.  The optional rc, gc, bc values represent the relative\n"
  " * weights to apply to each channel to convert it to grayscale.\n"
  " */";
#else
static const char *Dtool_PNMImage_make_grayscale_256_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::make_rgb(void)
 */
static PyObject *Dtool_PNMImage_make_rgb_257(PyObject *self, PyObject *) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.make_rgb")) {
    return nullptr;
  }
  // 1-inline void PNMImage::make_rgb(void)
  ((*local_this).make_rgb)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_make_rgb_257_comment =
  "C++ Interface:\n"
  "make_rgb(const PNMImage self)\n"
  "\n"
  "/**\n"
  " * Converts the image from grayscale to RGB.  Any alpha channel, if present,\n"
  " * is left undisturbed.\n"
  " */";
#else
static const char *Dtool_PNMImage_make_rgb_257_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::premultiply_alpha(void)
 */
static PyObject *Dtool_PNMImage_premultiply_alpha_258(PyObject *self, PyObject *) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.premultiply_alpha")) {
    return nullptr;
  }
  // 1-void PNMImage::premultiply_alpha(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*local_this).premultiply_alpha)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_premultiply_alpha_258_comment =
  "C++ Interface:\n"
  "premultiply_alpha(const PNMImage self)\n"
  "\n"
  "/**\n"
  " * Converts an image in-place to its \"premultiplied\" form, where, for every\n"
  " * pixel in the image, the red, green, and blue components are multiplied by\n"
  " * that pixel's alpha value.\n"
  " *\n"
  " * This does not modify any alpha values.\n"
  " */";
#else
static const char *Dtool_PNMImage_premultiply_alpha_258_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::unpremultiply_alpha(void)
 */
static PyObject *Dtool_PNMImage_unpremultiply_alpha_259(PyObject *self, PyObject *) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.unpremultiply_alpha")) {
    return nullptr;
  }
  // 1-void PNMImage::unpremultiply_alpha(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*local_this).unpremultiply_alpha)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_unpremultiply_alpha_259_comment =
  "C++ Interface:\n"
  "unpremultiply_alpha(const PNMImage self)\n"
  "\n"
  "/**\n"
  " * Converts an image in-place to its \"straight alpha\" form (presumably from a\n"
  " * \"premultiplied\" form), where, for every pixel in the image, the red, green,\n"
  " * and blue components are divided by that pixel's alpha value.\n"
  " *\n"
  " * This does not modify any alpha values.\n"
  " */";
#else
static const char *Dtool_PNMImage_unpremultiply_alpha_259_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::reverse_rows(void)
 */
static PyObject *Dtool_PNMImage_reverse_rows_260(PyObject *self, PyObject *) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.reverse_rows")) {
    return nullptr;
  }
  // 1-void PNMImage::reverse_rows(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*local_this).reverse_rows)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_reverse_rows_260_comment =
  "C++ Interface:\n"
  "reverse_rows(const PNMImage self)\n"
  "\n"
  "/**\n"
  " * Performs an in-place reversal of the row (y) data.\n"
  " */";
#else
static const char *Dtool_PNMImage_reverse_rows_260_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::flip(bool flip_x, bool flip_y, bool transpose)
 */
static PyObject *Dtool_PNMImage_flip_261(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.flip")) {
    return nullptr;
  }
  // 1-void PNMImage::flip(bool flip_x, bool flip_y, bool transpose)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"flip_x", "flip_y", "transpose", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:flip", (char **)keyword_list, &param1, &param2, &param3)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).flip)((PyObject_IsTrue(param1) != 0), (PyObject_IsTrue(param2) != 0), (PyObject_IsTrue(param3) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "flip(const PNMImage self, bool flip_x, bool flip_y, bool transpose)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_flip_261_comment =
  "C++ Interface:\n"
  "flip(const PNMImage self, bool flip_x, bool flip_y, bool transpose)\n"
  "\n"
  "/**\n"
  " * Reverses, transposes, and/or rotates the image in-place according to the\n"
  " * specified parameters.  If flip_x is true, the x axis is reversed; if flip_y\n"
  " * is true, the y axis is reversed.  Then, if transpose is true, the x and y\n"
  " * axes are exchanged.  These parameters can be used to select any combination\n"
  " * of 90-degree or 180-degree rotations and flips.\n"
  " */";
#else
static const char *Dtool_PNMImage_flip_261_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::set_maxval(xelval maxval)
 */
static PyObject *Dtool_PNMImage_set_maxval_262(PyObject *self, PyObject *arg) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_maxval")) {
    return nullptr;
  }
  // 1-void PNMImage::set_maxval(xelval maxval)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).set_maxval)((xelval)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_maxval(const PNMImage self, int maxval)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_maxval_262_comment =
  "C++ Interface:\n"
  "set_maxval(const PNMImage self, int maxval)\n"
  "\n"
  "/**\n"
  " * Rescales the image to the indicated maxval.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_maxval_262_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline xel &PNMImage::get_xel_val(int x, int y)
 * inline xel PNMImage::get_xel_val(int x, int y) const
 */
static PyObject *Dtool_PNMImage_get_xel_val_263(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 inline xel &PNMImage::get_xel_val(int x, int y)
    int param1;
    int param2;
    static const char *keyword_list[] = {"x", "y", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_xel_val", (char **)keyword_list, &param1, &param2)) {
      xel *return_value = &(((*local_this).get_xel_val)((int)param1, (int)param2));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_pixel, false, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline xel PNMImage::get_xel_val(int x, int y) const
    int param1;
    int param2;
    static const char *keyword_list[] = {"x", "y", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_xel_val", (char **)keyword_list, &param1, &param2)) {
      xel *return_value = new xel(((*(const PNMImage*)local_this).get_xel_val)((int)param1, (int)param2));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_pixel, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: inline xel &PNMImage::get_xel_val(int x, int y)
  // No coercion possible: inline xel PNMImage::get_xel_val(int x, int y) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_xel_val(const PNMImage self, int x, int y)\n"
      "get_xel_val(PNMImage self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_xel_val_263_comment =
  "C++ Interface:\n"
  "get_xel_val(const PNMImage self, int x, int y)\n"
  "get_xel_val(PNMImage self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the RGB color at the indicated pixel.  Each component is in the\n"
  " * range 0..maxval.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the RGB color at the indicated pixel.  Each component is in the\n"
  " * range 0..maxval.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_xel_val_263_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::set_xel_val(int x, int y, xel const &value)
 * inline void PNMImage::set_xel_val(int x, int y, xelval gray)
 * inline void PNMImage::set_xel_val(int x, int y, xelval r, xelval g, xelval b)
 */
static PyObject *Dtool_PNMImage_set_xel_val_264(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_xel_val")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 3:
    {
      {
        // -2 inline void PNMImage::set_xel_val(int x, int y, xel const &value)
        int param1;
        int param2;
        PyObject *param3;
        static const char *keyword_list[] = {"x", "y", "value", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_xel_val", (char **)keyword_list, &param1, &param2, &param3)) {
          xel const *param3_this = nullptr;
          DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_pixel);
          if (param3_this != nullptr) {
            ((*local_this).set_xel_val)((int)param1, (int)param2, *param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void PNMImage::set_xel_val(int x, int y, xelval gray)
        int param1;
        int param2;
        long param3;
        static const char *keyword_list[] = {"x", "y", "gray", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "iil:set_xel_val", (char **)keyword_list, &param1, &param2, &param3)) {
#ifndef NDEBUG
          if (param3 < 0 || param3 > USHRT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for unsigned short integer",
                                param3);
          }
#endif
          ((*local_this).set_xel_val)((int)param1, (int)param2, (xelval)param3);
          return Dtool_Return_None();
        }
        PyErr_Clear();
      }

      {
        // -2 inline void PNMImage::set_xel_val(int x, int y, xel const &value)
        int param1;
        int param2;
        PyObject *param3;
        static const char *keyword_list[] = {"x", "y", "value", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_xel_val", (char **)keyword_list, &param1, &param2, &param3)) {
          pixel param3_local;
          xel const *param3_this = Dtool_Coerce_pixel(param3, param3_local);
          if ((param3_this != nullptr)) {
            ((*local_this).set_xel_val)((int)param1, (int)param2, *param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline void PNMImage::set_xel_val(int x, int y, xelval gray)
    }
    break;
  case 5:
    {
      // 1-inline void PNMImage::set_xel_val(int x, int y, xelval r, xelval g, xelval b)
      int param1;
      int param2;
      long param3;
      long param4;
      long param5;
      static const char *keyword_list[] = {"x", "y", "r", "g", "b", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iilll:set_xel_val", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
#ifndef NDEBUG
        if (param3 < 0 || param3 > USHRT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for unsigned short integer",
                              param3);
        }
#endif
#ifndef NDEBUG
        if (param4 < 0 || param4 > USHRT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for unsigned short integer",
                              param4);
        }
#endif
#ifndef NDEBUG
        if (param5 < 0 || param5 > USHRT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for unsigned short integer",
                              param5);
        }
#endif
        ((*local_this).set_xel_val)((int)param1, (int)param2, (xelval)param3, (xelval)param4, (xelval)param5);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_xel_val() takes 4 or 6 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_xel_val(const PNMImage self, int x, int y, const pixel value)\n"
      "set_xel_val(const PNMImage self, int x, int y, int gray)\n"
      "set_xel_val(const PNMImage self, int x, int y, int r, int g, int b)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_xel_val_264_comment =
  "C++ Interface:\n"
  "set_xel_val(const PNMImage self, int x, int y, const pixel value)\n"
  "set_xel_val(const PNMImage self, int x, int y, int gray)\n"
  "set_xel_val(const PNMImage self, int x, int y, int r, int g, int b)\n"
  "\n"
  "/**\n"
  " * Changes the RGB color at the indicated pixel.  Each component is in the\n"
  " * range 0..maxval, encoded in the configured color space.  See set_xel if you\n"
  " * instead have a linearized and normalized floating-point value.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Changes the RGB color at the indicated pixel.  Each component is in the\n"
  " * range 0..maxval, encoded in the configured color space.  See set_xel if you\n"
  " * instead have a linearized and normalized floating-point value.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Changes all three color components at the indicated pixel to the same\n"
  " * value.  The value is in the range component is in the range 0..maxval,\n"
  " * encoded in the configured color space.  See set_xel if you instead have a\n"
  " * linearized and normalized floating-point value.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_xel_val_264_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline xelval PNMImage::get_red_val(int x, int y) const
 */
static PyObject *Dtool_PNMImage_get_red_val_265(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  // 1-inline xelval PNMImage::get_red_val(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_red_val", (char **)keyword_list, &param1, &param2)) {
    xelval return_value = ((*(const PNMImage*)local_this).get_red_val)((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_red_val(PNMImage self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_red_val_265_comment =
  "C++ Interface:\n"
  "get_red_val(PNMImage self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the red component color at the indicated pixel.  The value returned\n"
  " * is in the range 0..maxval and encoded in the configured color space.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_red_val_265_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline xelval PNMImage::get_green_val(int x, int y) const
 */
static PyObject *Dtool_PNMImage_get_green_val_266(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  // 1-inline xelval PNMImage::get_green_val(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_green_val", (char **)keyword_list, &param1, &param2)) {
    xelval return_value = ((*(const PNMImage*)local_this).get_green_val)((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_green_val(PNMImage self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_green_val_266_comment =
  "C++ Interface:\n"
  "get_green_val(PNMImage self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the green component color at the indicated pixel.  The value\n"
  " * returned is in the range 0..maxval and encoded in the configured color\n"
  " * space.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_green_val_266_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline xelval PNMImage::get_blue_val(int x, int y) const
 */
static PyObject *Dtool_PNMImage_get_blue_val_267(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  // 1-inline xelval PNMImage::get_blue_val(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_blue_val", (char **)keyword_list, &param1, &param2)) {
    xelval return_value = ((*(const PNMImage*)local_this).get_blue_val)((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_blue_val(PNMImage self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_blue_val_267_comment =
  "C++ Interface:\n"
  "get_blue_val(PNMImage self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the blue component color at the indicated pixel.  The value\n"
  " * returned is in the range 0..maxval and encoded in the configured color\n"
  " * space.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_blue_val_267_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline xelval PNMImage::get_gray_val(int x, int y) const
 */
static PyObject *Dtool_PNMImage_get_gray_val_268(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  // 1-inline xelval PNMImage::get_gray_val(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_gray_val", (char **)keyword_list, &param1, &param2)) {
    xelval return_value = ((*(const PNMImage*)local_this).get_gray_val)((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_gray_val(PNMImage self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_gray_val_268_comment =
  "C++ Interface:\n"
  "get_gray_val(PNMImage self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the gray component color at the indicated pixel.  This only has a\n"
  " * meaningful value for grayscale images; for other image types, this returns\n"
  " * the value of the blue channel only.  However, also see the get_bright()\n"
  " * function.  The value returned is in the range 0..maxval and encoded in the\n"
  " * configured color space.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_gray_val_268_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline xelval PNMImage::get_alpha_val(int x, int y) const
 */
static PyObject *Dtool_PNMImage_get_alpha_val_269(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  // 1-inline xelval PNMImage::get_alpha_val(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_alpha_val", (char **)keyword_list, &param1, &param2)) {
    xelval return_value = ((*(const PNMImage*)local_this).get_alpha_val)((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_alpha_val(PNMImage self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_alpha_val_269_comment =
  "C++ Interface:\n"
  "get_alpha_val(PNMImage self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the alpha component color at the indicated pixel.  It is an error\n"
  " * to call this unless has_alpha() is true.  The value returned is in the\n"
  " * range 0..maxval and always linear.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_alpha_val_269_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::set_red_val(int x, int y, xelval r)
 */
static PyObject *Dtool_PNMImage_set_red_val_270(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_red_val")) {
    return nullptr;
  }
  // 1-inline void PNMImage::set_red_val(int x, int y, xelval r)
  int param1;
  int param2;
  long param3;
  static const char *keyword_list[] = {"x", "y", "r", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iil:set_red_val", (char **)keyword_list, &param1, &param2, &param3)) {
#ifndef NDEBUG
    if (param3 < 0 || param3 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param3);
    }
#endif
    ((*local_this).set_red_val)((int)param1, (int)param2, (xelval)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_red_val(const PNMImage self, int x, int y, int r)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_red_val_270_comment =
  "C++ Interface:\n"
  "set_red_val(const PNMImage self, int x, int y, int r)\n"
  "\n"
  "/**\n"
  " * Sets the red component color only at the indicated pixel.  The value given\n"
  " * should be in the range 0..maxval, encoded in the configured color space.\n"
  " * See set_red if you instead have a linearized and normalized floating-point\n"
  " * value.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_red_val_270_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::set_green_val(int x, int y, xelval g)
 */
static PyObject *Dtool_PNMImage_set_green_val_271(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_green_val")) {
    return nullptr;
  }
  // 1-inline void PNMImage::set_green_val(int x, int y, xelval g)
  int param1;
  int param2;
  long param3;
  static const char *keyword_list[] = {"x", "y", "g", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iil:set_green_val", (char **)keyword_list, &param1, &param2, &param3)) {
#ifndef NDEBUG
    if (param3 < 0 || param3 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param3);
    }
#endif
    ((*local_this).set_green_val)((int)param1, (int)param2, (xelval)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_green_val(const PNMImage self, int x, int y, int g)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_green_val_271_comment =
  "C++ Interface:\n"
  "set_green_val(const PNMImage self, int x, int y, int g)\n"
  "\n"
  "/**\n"
  " * Sets the green component color only at the indicated pixel.  The value\n"
  " * given should be in the range 0..maxval, encoded in the configured color\n"
  " * space.  See set_green if you instead have a linearized and normalized\n"
  " * floating-point value.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_green_val_271_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::set_blue_val(int x, int y, xelval b)
 */
static PyObject *Dtool_PNMImage_set_blue_val_272(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_blue_val")) {
    return nullptr;
  }
  // 1-inline void PNMImage::set_blue_val(int x, int y, xelval b)
  int param1;
  int param2;
  long param3;
  static const char *keyword_list[] = {"x", "y", "b", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iil:set_blue_val", (char **)keyword_list, &param1, &param2, &param3)) {
#ifndef NDEBUG
    if (param3 < 0 || param3 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param3);
    }
#endif
    ((*local_this).set_blue_val)((int)param1, (int)param2, (xelval)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_blue_val(const PNMImage self, int x, int y, int b)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_blue_val_272_comment =
  "C++ Interface:\n"
  "set_blue_val(const PNMImage self, int x, int y, int b)\n"
  "\n"
  "/**\n"
  " * Sets the blue component color only at the indicated pixel.  The value given\n"
  " * should be in the range 0..maxval, encoded in the configured color space.\n"
  " * See set_blue if you instead have a linearized and normalized floating-point\n"
  " * value.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_blue_val_272_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::set_gray_val(int x, int y, xelval gray)
 */
static PyObject *Dtool_PNMImage_set_gray_val_273(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_gray_val")) {
    return nullptr;
  }
  // 1-inline void PNMImage::set_gray_val(int x, int y, xelval gray)
  int param1;
  int param2;
  long param3;
  static const char *keyword_list[] = {"x", "y", "gray", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iil:set_gray_val", (char **)keyword_list, &param1, &param2, &param3)) {
#ifndef NDEBUG
    if (param3 < 0 || param3 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param3);
    }
#endif
    ((*local_this).set_gray_val)((int)param1, (int)param2, (xelval)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_gray_val(const PNMImage self, int x, int y, int gray)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_gray_val_273_comment =
  "C++ Interface:\n"
  "set_gray_val(const PNMImage self, int x, int y, int gray)\n"
  "\n"
  "/**\n"
  " * Sets the gray component color at the indicated pixel.  This is only\n"
  " * meaningful for grayscale images; for other image types, this simply sets\n"
  " * the blue component color.  However, also see set_xel_val(), which can set\n"
  " * all the component colors to the same grayscale level, and hence works\n"
  " * correctly both for grayscale and color images.  The value given should be\n"
  " * in the range 0..maxval, encoded in the configured color space.  See\n"
  " * set_gray if you instead have a linearized normalized floating-point value.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_gray_val_273_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::set_alpha_val(int x, int y, xelval a)
 */
static PyObject *Dtool_PNMImage_set_alpha_val_274(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_alpha_val")) {
    return nullptr;
  }
  // 1-inline void PNMImage::set_alpha_val(int x, int y, xelval a)
  int param1;
  int param2;
  long param3;
  static const char *keyword_list[] = {"x", "y", "a", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iil:set_alpha_val", (char **)keyword_list, &param1, &param2, &param3)) {
#ifndef NDEBUG
    if (param3 < 0 || param3 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param3);
    }
#endif
    ((*local_this).set_alpha_val)((int)param1, (int)param2, (xelval)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_alpha_val(const PNMImage self, int x, int y, int a)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_alpha_val_274_comment =
  "C++ Interface:\n"
  "set_alpha_val(const PNMImage self, int x, int y, int a)\n"
  "\n"
  "/**\n"
  " * Sets the alpha component color only at the indicated pixel.  It is an error\n"
  " * to call this unless has_alpha() is true.  The value given should be in the\n"
  " * range 0..maxval.\n"
  " *\n"
  " * This value is always linearly encoded, even if the image is set to the sRGB\n"
  " * color space.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_alpha_val_274_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * xelval PNMImage::get_channel_val(int x, int y, int channel) const
 */
static PyObject *Dtool_PNMImage_get_channel_val_275(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  // 1-xelval PNMImage::get_channel_val(int x, int y, int channel) const
  int param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"x", "y", "channel", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:get_channel_val", (char **)keyword_list, &param1, &param2, &param3)) {
    xelval return_value = ((*(const PNMImage*)local_this).get_channel_val)((int)param1, (int)param2, (int)param3);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_channel_val(PNMImage self, int x, int y, int channel)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_channel_val_275_comment =
  "C++ Interface:\n"
  "get_channel_val(PNMImage self, int x, int y, int channel)\n"
  "\n"
  "/**\n"
  " * Returns the nth component color at the indicated pixel.  The channel index\n"
  " * should be in the range 0..(get_num_channels()-1).  The channels are ordered\n"
  " * B, G, R, A.  This is slightly less optimal than accessing the component\n"
  " * values directly by named methods.  The value returned is in the range\n"
  " * 0..maxval.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_channel_val_275_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::set_channel_val(int x, int y, int channel, xelval value)
 */
static PyObject *Dtool_PNMImage_set_channel_val_276(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_channel_val")) {
    return nullptr;
  }
  // 1-void PNMImage::set_channel_val(int x, int y, int channel, xelval value)
  int param1;
  int param2;
  int param3;
  long param4;
  static const char *keyword_list[] = {"x", "y", "channel", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiil:set_channel_val", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
#ifndef NDEBUG
    if (param4 < 0 || param4 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param4);
    }
#endif
    ((*local_this).set_channel_val)((int)param1, (int)param2, (int)param3, (xelval)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_channel_val(const PNMImage self, int x, int y, int channel, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_channel_val_276_comment =
  "C++ Interface:\n"
  "set_channel_val(const PNMImage self, int x, int y, int channel, int value)\n"
  "\n"
  "/**\n"
  " * Sets the nth component color at the indicated pixel.  The channel index\n"
  " * should be in the range 0..(get_num_channels()-1).  The channels are ordered\n"
  " * B, G, R, A.  This is slightly less optimal than setting the component\n"
  " * values directly by named methods.  The value given should be in the range\n"
  " * 0..maxval.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_channel_val_276_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * float PNMImage::get_channel(int x, int y, int channel) const
 */
static PyObject *Dtool_PNMImage_get_channel_277(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  // 1-float PNMImage::get_channel(int x, int y, int channel) const
  int param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"x", "y", "channel", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:get_channel", (char **)keyword_list, &param1, &param2, &param3)) {
    float return_value = ((*(const PNMImage*)local_this).get_channel)((int)param1, (int)param2, (int)param3);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_channel(PNMImage self, int x, int y, int channel)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_channel_277_comment =
  "C++ Interface:\n"
  "get_channel(PNMImage self, int x, int y, int channel)\n"
  "\n"
  "/**\n"
  " * Returns the nth component color at the indicated pixel.  The channel index\n"
  " * should be in the range 0..(get_num_channels()-1).  The channels are ordered\n"
  " * B, G, R, A.  This is slightly less optimal than accessing the component\n"
  " * values directly by named methods.  The value returned is a float in the\n"
  " * range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_channel_277_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::set_channel(int x, int y, int channel, float value)
 */
static PyObject *Dtool_PNMImage_set_channel_278(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_channel")) {
    return nullptr;
  }
  // 1-void PNMImage::set_channel(int x, int y, int channel, float value)
  int param1;
  int param2;
  int param3;
  float param4;
  static const char *keyword_list[] = {"x", "y", "channel", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiif:set_channel", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    ((*local_this).set_channel)((int)param1, (int)param2, (int)param3, (float)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_channel(const PNMImage self, int x, int y, int channel, float value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_channel_278_comment =
  "C++ Interface:\n"
  "set_channel(const PNMImage self, int x, int y, int channel, float value)\n"
  "\n"
  "/**\n"
  " * Sets the nth component color at the indicated pixel.  The channel index\n"
  " * should be in the range 0..(get_num_channels()-1).  The channels are ordered\n"
  " * B, G, R, A.  This is slightly less optimal than setting the component\n"
  " * values directly by named methods.  The value given should be a float in the\n"
  " * range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_channel_278_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PNMImageHeader::PixelSpec PNMImage::get_pixel(int x, int y) const
 */
static PyObject *Dtool_PNMImage_get_pixel_279(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  // 1-PNMImageHeader::PixelSpec PNMImage::get_pixel(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_pixel", (char **)keyword_list, &param1, &param2)) {
    PNMImageHeader::PixelSpec *return_value = new PNMImageHeader::PixelSpec(((*(const PNMImage*)local_this).get_pixel)((int)param1, (int)param2));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImageHeader_PixelSpec, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pixel(PNMImage self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_pixel_279_comment =
  "C++ Interface:\n"
  "get_pixel(PNMImage self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the (r, g, b, a) pixel value at the indicated pixel, using a\n"
  " * PixelSpec object.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_pixel_279_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::set_pixel(int x, int y, PNMImageHeader::PixelSpec const &pixel)
 */
static PyObject *Dtool_PNMImage_set_pixel_280(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_pixel")) {
    return nullptr;
  }
  // 1-void PNMImage::set_pixel(int x, int y, PNMImageHeader::PixelSpec const &pixel)
  int param1;
  int param2;
  PyObject *param3;
  static const char *keyword_list[] = {"x", "y", "pixel", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_pixel", (char **)keyword_list, &param1, &param2, &param3)) {
    PNMImageHeader::PixelSpec param3_local;
    PNMImageHeader::PixelSpec const *param3_this = Dtool_Coerce_PNMImageHeader_PixelSpec(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "PNMImage.set_pixel", "PixelSpec");
    }
    ((*local_this).set_pixel)((int)param1, (int)param2, *param3_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pixel(const PNMImage self, int x, int y, const PixelSpec pixel)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_pixel_280_comment =
  "C++ Interface:\n"
  "set_pixel(const PNMImage self, int x, int y, const PixelSpec pixel)\n"
  "\n"
  "/**\n"
  " * Sets the (r, g, b, a) pixel value at the indicated pixel, using a PixelSpec\n"
  " * object.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_pixel_280_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LRGBColorf PNMImage::get_xel(int x, int y) const
 */
static PyObject *Dtool_PNMImage_get_xel_281(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  // 1-inline LRGBColorf PNMImage::get_xel(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_xel", (char **)keyword_list, &param1, &param2)) {
    LRGBColorf *return_value = new LRGBColorf(((*(const PNMImage*)local_this).get_xel)((int)param1, (int)param2));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_xel(PNMImage self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_xel_281_comment =
  "C++ Interface:\n"
  "get_xel(PNMImage self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the RGB color at the indicated pixel.  Each component is a\n"
  " * linearized float in the range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_xel_281_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::set_xel(int x, int y, LRGBColorf const &value)
 * inline void PNMImage::set_xel(int x, int y, float gray)
 * inline void PNMImage::set_xel(int x, int y, float r, float g, float b)
 */
static PyObject *Dtool_PNMImage_set_xel_282(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_xel")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 3:
    {
      {
        // -2 inline void PNMImage::set_xel(int x, int y, LRGBColorf const &value)
        int param1;
        int param2;
        PyObject *param3;
        static const char *keyword_list[] = {"x", "y", "value", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_xel", (char **)keyword_list, &param1, &param2, &param3)) {
          LRGBColorf const *param3_this = nullptr;
          DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_LVecBase3f);
          if (param3_this != nullptr) {
            ((*local_this).set_xel)((int)param1, (int)param2, *param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void PNMImage::set_xel(int x, int y, float gray)
        int param1;
        int param2;
        float param3;
        static const char *keyword_list[] = {"x", "y", "gray", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "iif:set_xel", (char **)keyword_list, &param1, &param2, &param3)) {
          ((*local_this).set_xel)((int)param1, (int)param2, (float)param3);
          return Dtool_Return_None();
        }
        PyErr_Clear();
      }

      {
        // -2 inline void PNMImage::set_xel(int x, int y, LRGBColorf const &value)
        int param1;
        int param2;
        PyObject *param3;
        static const char *keyword_list[] = {"x", "y", "value", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_xel", (char **)keyword_list, &param1, &param2, &param3)) {
          LVecBase3f param3_local;
          LRGBColorf const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
          if ((param3_this != nullptr)) {
            ((*local_this).set_xel)((int)param1, (int)param2, *param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline void PNMImage::set_xel(int x, int y, float gray)
    }
    break;
  case 5:
    {
      // 1-inline void PNMImage::set_xel(int x, int y, float r, float g, float b)
      int param1;
      int param2;
      float param3;
      float param4;
      float param5;
      static const char *keyword_list[] = {"x", "y", "r", "g", "b", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iifff:set_xel", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
        ((*local_this).set_xel)((int)param1, (int)param2, (float)param3, (float)param4, (float)param5);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_xel() takes 4 or 6 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_xel(const PNMImage self, int x, int y, const LVecBase3f value)\n"
      "set_xel(const PNMImage self, int x, int y, float gray)\n"
      "set_xel(const PNMImage self, int x, int y, float r, float g, float b)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_xel_282_comment =
  "C++ Interface:\n"
  "set_xel(const PNMImage self, int x, int y, const LVecBase3f value)\n"
  "set_xel(const PNMImage self, int x, int y, float gray)\n"
  "set_xel(const PNMImage self, int x, int y, float r, float g, float b)\n"
  "\n"
  "/**\n"
  " * Changes the RGB color at the indicated pixel.  Each component is a\n"
  " * linearized float in the range 0..1.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Changes the RGB color at the indicated pixel.  Each component is a\n"
  " * linearized float in the range 0..1.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Changes all three color components at the indicated pixel to the same\n"
  " * value.  The value is a linearized float in the range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_xel_282_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColorf PNMImage::get_xel_a(int x, int y) const
 */
static PyObject *Dtool_PNMImage_get_xel_a_283(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  // 1-inline LColorf PNMImage::get_xel_a(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_xel_a", (char **)keyword_list, &param1, &param2)) {
    LColorf *return_value = new LColorf(((*(const PNMImage*)local_this).get_xel_a)((int)param1, (int)param2));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_xel_a(PNMImage self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_xel_a_283_comment =
  "C++ Interface:\n"
  "get_xel_a(PNMImage self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the RGBA color at the indicated pixel.  Each component is a\n"
  " * linearized float in the range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_xel_a_283_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::set_xel_a(int x, int y, LColorf const &value)
 * inline void PNMImage::set_xel_a(int x, int y, float r, float g, float b, float a)
 */
static PyObject *Dtool_PNMImage_set_xel_a_284(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_xel_a")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 3:
    {
      // 1-inline void PNMImage::set_xel_a(int x, int y, LColorf const &value)
      int param1;
      int param2;
      PyObject *param3;
      static const char *keyword_list[] = {"x", "y", "value", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_xel_a", (char **)keyword_list, &param1, &param2, &param3)) {
        LVecBase4f param3_local;
        LColorf const *param3_this = Dtool_Coerce_LVecBase4f(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "PNMImage.set_xel_a", "LVecBase4f");
        }
        ((*local_this).set_xel_a)((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 6:
    {
      // 1-inline void PNMImage::set_xel_a(int x, int y, float r, float g, float b, float a)
      int param1;
      int param2;
      float param3;
      float param4;
      float param5;
      float param6;
      static const char *keyword_list[] = {"x", "y", "r", "g", "b", "a", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiffff:set_xel_a", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        ((*local_this).set_xel_a)((int)param1, (int)param2, (float)param3, (float)param4, (float)param5, (float)param6);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_xel_a() takes 4 or 7 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_xel_a(const PNMImage self, int x, int y, const LVecBase4f value)\n"
      "set_xel_a(const PNMImage self, int x, int y, float r, float g, float b, float a)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_xel_a_284_comment =
  "C++ Interface:\n"
  "set_xel_a(const PNMImage self, int x, int y, const LVecBase4f value)\n"
  "set_xel_a(const PNMImage self, int x, int y, float r, float g, float b, float a)\n"
  "\n"
  "/**\n"
  " * Changes the RGBA color at the indicated pixel.  Each component is a\n"
  " * linearized float in the range 0..1.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Changes the RGBA color at the indicated pixel.  Each component is a\n"
  " * linearized float in the range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_xel_a_284_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float PNMImage::get_red(int x, int y) const
 */
static PyObject *Dtool_PNMImage_get_red_285(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  // 1-inline float PNMImage::get_red(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_red", (char **)keyword_list, &param1, &param2)) {
    float return_value = ((*(const PNMImage*)local_this).get_red)((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_red(PNMImage self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_red_285_comment =
  "C++ Interface:\n"
  "get_red(PNMImage self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the red component color at the indicated pixel.  The value returned\n"
  " * is a linearized float in the range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_red_285_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float PNMImage::get_green(int x, int y) const
 */
static PyObject *Dtool_PNMImage_get_green_286(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  // 1-inline float PNMImage::get_green(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_green", (char **)keyword_list, &param1, &param2)) {
    float return_value = ((*(const PNMImage*)local_this).get_green)((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_green(PNMImage self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_green_286_comment =
  "C++ Interface:\n"
  "get_green(PNMImage self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the green component color at the indicated pixel.  The value\n"
  " * returned is a linearized float in the range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_green_286_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float PNMImage::get_blue(int x, int y) const
 */
static PyObject *Dtool_PNMImage_get_blue_287(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  // 1-inline float PNMImage::get_blue(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_blue", (char **)keyword_list, &param1, &param2)) {
    float return_value = ((*(const PNMImage*)local_this).get_blue)((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_blue(PNMImage self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_blue_287_comment =
  "C++ Interface:\n"
  "get_blue(PNMImage self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the blue component color at the indicated pixel.  The value\n"
  " * returned is a linearized float in the range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_blue_287_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float PNMImage::get_gray(int x, int y) const
 */
static PyObject *Dtool_PNMImage_get_gray_288(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  // 1-inline float PNMImage::get_gray(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_gray", (char **)keyword_list, &param1, &param2)) {
    float return_value = ((*(const PNMImage*)local_this).get_gray)((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_gray(PNMImage self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_gray_288_comment =
  "C++ Interface:\n"
  "get_gray(PNMImage self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the gray component color at the indicated pixel.  This only has a\n"
  " * meaningful value for grayscale images; for other image types, this returns\n"
  " * the value of the blue channel only.  However, also see the get_bright()\n"
  " * function.  The value returned is a linearized float in the range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_gray_288_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float PNMImage::get_alpha(int x, int y) const
 */
static PyObject *Dtool_PNMImage_get_alpha_289(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  // 1-inline float PNMImage::get_alpha(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_alpha", (char **)keyword_list, &param1, &param2)) {
    float return_value = ((*(const PNMImage*)local_this).get_alpha)((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_alpha(PNMImage self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_alpha_289_comment =
  "C++ Interface:\n"
  "get_alpha(PNMImage self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns the alpha component color at the indicated pixel.  It is an error\n"
  " * to call this unless has_alpha() is true.  The value returned is a float in\n"
  " * the range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_alpha_289_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::set_red(int x, int y, float r)
 */
static PyObject *Dtool_PNMImage_set_red_290(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_red")) {
    return nullptr;
  }
  // 1-inline void PNMImage::set_red(int x, int y, float r)
  int param1;
  int param2;
  float param3;
  static const char *keyword_list[] = {"x", "y", "r", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iif:set_red", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).set_red)((int)param1, (int)param2, (float)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_red(const PNMImage self, int x, int y, float r)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_red_290_comment =
  "C++ Interface:\n"
  "set_red(const PNMImage self, int x, int y, float r)\n"
  "\n"
  "/**\n"
  " * Sets the red component color only at the indicated pixel.  The value given\n"
  " * should be a linearized float in the range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_red_290_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::set_green(int x, int y, float g)
 */
static PyObject *Dtool_PNMImage_set_green_291(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_green")) {
    return nullptr;
  }
  // 1-inline void PNMImage::set_green(int x, int y, float g)
  int param1;
  int param2;
  float param3;
  static const char *keyword_list[] = {"x", "y", "g", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iif:set_green", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).set_green)((int)param1, (int)param2, (float)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_green(const PNMImage self, int x, int y, float g)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_green_291_comment =
  "C++ Interface:\n"
  "set_green(const PNMImage self, int x, int y, float g)\n"
  "\n"
  "/**\n"
  " * Sets the green component color only at the indicated pixel.  The value\n"
  " * given should be a linearized float in the range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_green_291_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::set_blue(int x, int y, float b)
 */
static PyObject *Dtool_PNMImage_set_blue_292(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_blue")) {
    return nullptr;
  }
  // 1-inline void PNMImage::set_blue(int x, int y, float b)
  int param1;
  int param2;
  float param3;
  static const char *keyword_list[] = {"x", "y", "b", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iif:set_blue", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).set_blue)((int)param1, (int)param2, (float)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_blue(const PNMImage self, int x, int y, float b)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_blue_292_comment =
  "C++ Interface:\n"
  "set_blue(const PNMImage self, int x, int y, float b)\n"
  "\n"
  "/**\n"
  " * Sets the blue component color only at the indicated pixel.  The value given\n"
  " * should be a linearized float in the range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_blue_292_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::set_gray(int x, int y, float gray)
 */
static PyObject *Dtool_PNMImage_set_gray_293(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_gray")) {
    return nullptr;
  }
  // 1-inline void PNMImage::set_gray(int x, int y, float gray)
  int param1;
  int param2;
  float param3;
  static const char *keyword_list[] = {"x", "y", "gray", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iif:set_gray", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).set_gray)((int)param1, (int)param2, (float)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_gray(const PNMImage self, int x, int y, float gray)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_gray_293_comment =
  "C++ Interface:\n"
  "set_gray(const PNMImage self, int x, int y, float gray)\n"
  "\n"
  "/**\n"
  " * Sets the gray component color at the indicated pixel.  This is only\n"
  " * meaningful for grayscale images; for other image types, this simply sets\n"
  " * the blue component color.  However, also see set_xel(), which can set all\n"
  " * the component colors to the same grayscale level, and hence works correctly\n"
  " * both for grayscale and color images.  The value given should be a\n"
  " * linearized float in the range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_gray_293_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::set_alpha(int x, int y, float a)
 */
static PyObject *Dtool_PNMImage_set_alpha_294(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.set_alpha")) {
    return nullptr;
  }
  // 1-inline void PNMImage::set_alpha(int x, int y, float a)
  int param1;
  int param2;
  float param3;
  static const char *keyword_list[] = {"x", "y", "a", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iif:set_alpha", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).set_alpha)((int)param1, (int)param2, (float)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_alpha(const PNMImage self, int x, int y, float a)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_set_alpha_294_comment =
  "C++ Interface:\n"
  "set_alpha(const PNMImage self, int x, int y, float a)\n"
  "\n"
  "/**\n"
  " * Sets the alpha component color only at the indicated pixel.  It is an error\n"
  " * to call this unless has_alpha() is true.  The value given should be in the\n"
  " * range 0..1.\n"
  " */";
#else
static const char *Dtool_PNMImage_set_alpha_294_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float PNMImage::get_bright(int x, int y) const
 * inline float PNMImage::get_bright(int x, int y, float rc, float gc, float bc) const
 * inline float PNMImage::get_bright(int x, int y, float rc, float gc, float bc, float ac) const
 */
static PyObject *Dtool_PNMImage_get_bright_295(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline float PNMImage::get_bright(int x, int y) const
      int param1;
      int param2;
      static const char *keyword_list[] = {"x", "y", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_bright", (char **)keyword_list, &param1, &param2)) {
        float return_value = ((*(const PNMImage*)local_this).get_bright)((int)param1, (int)param2);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 5:
    {
      // 1-inline float PNMImage::get_bright(int x, int y, float rc, float gc, float bc) const
      int param1;
      int param2;
      float param3;
      float param4;
      float param5;
      static const char *keyword_list[] = {"x", "y", "rc", "gc", "bc", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iifff:get_bright", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
        float return_value = ((*(const PNMImage*)local_this).get_bright)((int)param1, (int)param2, (float)param3, (float)param4, (float)param5);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 6:
    {
      // 1-inline float PNMImage::get_bright(int x, int y, float rc, float gc, float bc, float ac) const
      int param1;
      int param2;
      float param3;
      float param4;
      float param5;
      float param6;
      static const char *keyword_list[] = {"x", "y", "rc", "gc", "bc", "ac", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiffff:get_bright", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        float return_value = ((*(const PNMImage*)local_this).get_bright)((int)param1, (int)param2, (float)param3, (float)param4, (float)param5, (float)param6);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_bright() takes 3, 6 or 7 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bright(PNMImage self, int x, int y)\n"
      "get_bright(PNMImage self, int x, int y, float rc, float gc, float bc)\n"
      "get_bright(PNMImage self, int x, int y, float rc, float gc, float bc, float ac)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_bright_295_comment =
  "C++ Interface:\n"
  "get_bright(PNMImage self, int x, int y)\n"
  "get_bright(PNMImage self, int x, int y, float rc, float gc, float bc)\n"
  "get_bright(PNMImage self, int x, int y, float rc, float gc, float bc, float ac)\n"
  "\n"
  "/**\n"
  " * Returns the linear brightness of the given xel, as a linearized float in\n"
  " * the range 0..1.  This flavor of get_bright() returns the correct grayscale\n"
  " * brightness level for both full-color and grayscale images.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This flavor of get_bright() works correctly only for color images.  It\n"
  " * returns a single brightness value for the RGB color at the indicated pixel,\n"
  " * based on the supplied weights for each component.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This flavor of get_bright() works correctly only for four-channel images.\n"
  " * It returns a single brightness value for the RGBA color at the indicated\n"
  " * pixel, based on the supplied weights for each component.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_bright_295_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::blend(int x, int y, LRGBColorf const &val, float alpha)
 * void PNMImage::blend(int x, int y, float r, float g, float b, float alpha)
 */
static PyObject *Dtool_PNMImage_blend_296(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.blend")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 4:
    {
      // 1-inline void PNMImage::blend(int x, int y, LRGBColorf const &val, float alpha)
      int param1;
      int param2;
      PyObject *param3;
      float param4;
      static const char *keyword_list[] = {"x", "y", "val", "alpha", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiOf:blend", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        LVecBase3f param3_local;
        LRGBColorf const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "PNMImage.blend", "LVecBase3f");
        }
        ((*local_this).blend)((int)param1, (int)param2, *param3_this, (float)param4);
        return Dtool_Return_None();
      }
    }
    break;
  case 6:
    {
      // 1-void PNMImage::blend(int x, int y, float r, float g, float b, float alpha)
      int param1;
      int param2;
      float param3;
      float param4;
      float param5;
      float param6;
      static const char *keyword_list[] = {"x", "y", "r", "g", "b", "alpha", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiffff:blend", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        ((*local_this).blend)((int)param1, (int)param2, (float)param3, (float)param4, (float)param5, (float)param6);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "blend() takes 5 or 7 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "blend(const PNMImage self, int x, int y, const LVecBase3f val, float alpha)\n"
      "blend(const PNMImage self, int x, int y, float r, float g, float b, float alpha)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_blend_296_comment =
  "C++ Interface:\n"
  "blend(const PNMImage self, int x, int y, const LVecBase3f val, float alpha)\n"
  "blend(const PNMImage self, int x, int y, float r, float g, float b, float alpha)\n"
  "\n"
  "/**\n"
  " * Smoothly blends the indicated pixel value in with whatever was already in\n"
  " * the image, based on the given alpha value.  An alpha of 1.0 is fully opaque\n"
  " * and completely replaces whatever was there previously; alpha of 0.0 is\n"
  " * fully transparent and does nothing.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Smoothly blends the indicated pixel value in with whatever was already in\n"
  " * the image, based on the given alpha value.  An alpha of 1.0 is fully opaque\n"
  " * and completely replaces whatever was there previously; alpha of 0.0 is\n"
  " * fully transparent and does nothing.\n"
  " */";
#else
static const char *Dtool_PNMImage_blend_296_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::copy_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1)
 */
static PyObject *Dtool_PNMImage_copy_sub_image_297(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.copy_sub_image")) {
    return nullptr;
  }
  // 1-void PNMImage::copy_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1)
  PyObject *param1;
  int param2;
  int param3;
  int param4 = 0;
  int param5 = 0;
  int param6 = -1;
  int param7 = -1;
  static const char *keyword_list[] = {"copy", "xto", "yto", "xfrom", "yfrom", "x_size", "y_size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii|iiii:copy_sub_image", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
    PNMImage const *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PNMImage.copy_sub_image", true, true);
    if (param1_this != nullptr) {
      ((*local_this).copy_sub_image)(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_sub_image(const PNMImage self, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_copy_sub_image_297_comment =
  "C++ Interface:\n"
  "copy_sub_image(const PNMImage self, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size)\n"
  "\n"
  "/**\n"
  " * Copies a rectangular area of another image into a rectangular area of this\n"
  " * image.  Both images must already have been initialized.  The upper-left\n"
  " * corner of the region in both images is specified, and the size of the area;\n"
  " * if the size is omitted, it defaults to the entire other image, or the\n"
  " * largest piece that will fit.\n"
  " */";
#else
static const char *Dtool_PNMImage_copy_sub_image_297_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::blend_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
 */
static PyObject *Dtool_PNMImage_blend_sub_image_298(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.blend_sub_image")) {
    return nullptr;
  }
  // 1-void PNMImage::blend_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
  PyObject *param1;
  int param2;
  int param3;
  int param4 = 0;
  int param5 = 0;
  int param6 = -1;
  int param7 = -1;
  float param8 = 1.0;
  static const char *keyword_list[] = {"copy", "xto", "yto", "xfrom", "yfrom", "x_size", "y_size", "pixel_scale", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii|iiiif:blend_sub_image", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8)) {
    PNMImage const *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PNMImage.blend_sub_image", true, true);
    if (param1_this != nullptr) {
      ((*local_this).blend_sub_image)(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7, (float)param8);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "blend_sub_image(const PNMImage self, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_blend_sub_image_298_comment =
  "C++ Interface:\n"
  "blend_sub_image(const PNMImage self, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n"
  "\n"
  "/**\n"
  " * Behaves like copy_sub_image(), except the alpha channel of the copy is used\n"
  " * to blend the copy into the destination image, instead of overwriting pixels\n"
  " * unconditionally.\n"
  " *\n"
  " * If pixel_scale is not 1.0, it specifies an amount to scale each *alpha*\n"
  " * value of the source image before applying it to the target image.\n"
  " *\n"
  " * If pixel_scale is 1.0 and the copy has no alpha channel, this degenerates\n"
  " * into copy_sub_image().\n"
  " */";
#else
static const char *Dtool_PNMImage_blend_sub_image_298_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::add_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
 */
static PyObject *Dtool_PNMImage_add_sub_image_299(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.add_sub_image")) {
    return nullptr;
  }
  // 1-void PNMImage::add_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
  PyObject *param1;
  int param2;
  int param3;
  int param4 = 0;
  int param5 = 0;
  int param6 = -1;
  int param7 = -1;
  float param8 = 1.0;
  static const char *keyword_list[] = {"copy", "xto", "yto", "xfrom", "yfrom", "x_size", "y_size", "pixel_scale", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii|iiiif:add_sub_image", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8)) {
    PNMImage const *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PNMImage.add_sub_image", true, true);
    if (param1_this != nullptr) {
      ((*local_this).add_sub_image)(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7, (float)param8);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_sub_image(const PNMImage self, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_add_sub_image_299_comment =
  "C++ Interface:\n"
  "add_sub_image(const PNMImage self, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n"
  "\n"
  "/**\n"
  " * Behaves like copy_sub_image(), except the copy pixels are added to the\n"
  " * pixels of the destination, after scaling by the specified pixel_scale.\n"
  " * Unlike blend_sub_image(), the alpha channel is not treated specially.\n"
  " */";
#else
static const char *Dtool_PNMImage_add_sub_image_299_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::mult_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
 */
static PyObject *Dtool_PNMImage_mult_sub_image_300(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.mult_sub_image")) {
    return nullptr;
  }
  // 1-void PNMImage::mult_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
  PyObject *param1;
  int param2;
  int param3;
  int param4 = 0;
  int param5 = 0;
  int param6 = -1;
  int param7 = -1;
  float param8 = 1.0;
  static const char *keyword_list[] = {"copy", "xto", "yto", "xfrom", "yfrom", "x_size", "y_size", "pixel_scale", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii|iiiif:mult_sub_image", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8)) {
    PNMImage const *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PNMImage.mult_sub_image", true, true);
    if (param1_this != nullptr) {
      ((*local_this).mult_sub_image)(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7, (float)param8);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "mult_sub_image(const PNMImage self, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_mult_sub_image_300_comment =
  "C++ Interface:\n"
  "mult_sub_image(const PNMImage self, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n"
  "\n"
  "/**\n"
  " * Behaves like copy_sub_image(), except the copy pixels are multiplied to the\n"
  " * pixels of the destination, after scaling by the specified pixel_scale.\n"
  " * Unlike blend_sub_image(), the alpha channel is not treated specially.\n"
  " */";
#else
static const char *Dtool_PNMImage_mult_sub_image_300_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::darken_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
 */
static PyObject *Dtool_PNMImage_darken_sub_image_301(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.darken_sub_image")) {
    return nullptr;
  }
  // 1-void PNMImage::darken_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
  PyObject *param1;
  int param2;
  int param3;
  int param4 = 0;
  int param5 = 0;
  int param6 = -1;
  int param7 = -1;
  float param8 = 1.0;
  static const char *keyword_list[] = {"copy", "xto", "yto", "xfrom", "yfrom", "x_size", "y_size", "pixel_scale", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii|iiiif:darken_sub_image", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8)) {
    PNMImage const *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PNMImage.darken_sub_image", true, true);
    if (param1_this != nullptr) {
      ((*local_this).darken_sub_image)(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7, (float)param8);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "darken_sub_image(const PNMImage self, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_darken_sub_image_301_comment =
  "C++ Interface:\n"
  "darken_sub_image(const PNMImage self, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n"
  "\n"
  "/**\n"
  " * Behaves like copy_sub_image(), but the resulting color will be the darker\n"
  " * of the source and destination colors at each pixel (and at each R, G, B, A\n"
  " * component value).\n"
  " *\n"
  " * If pixel_scale is not 1.0, it specifies an amount to scale each pixel value\n"
  " * of the source image before applying it to the target image.  The scale is\n"
  " * applied with the center at 1.0: scaling the pixel value smaller brings it\n"
  " * closer to 1.0.\n"
  " */";
#else
static const char *Dtool_PNMImage_darken_sub_image_301_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::lighten_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
 */
static PyObject *Dtool_PNMImage_lighten_sub_image_302(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.lighten_sub_image")) {
    return nullptr;
  }
  // 1-void PNMImage::lighten_sub_image(PNMImage const &copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0)
  PyObject *param1;
  int param2;
  int param3;
  int param4 = 0;
  int param5 = 0;
  int param6 = -1;
  int param7 = -1;
  float param8 = 1.0;
  static const char *keyword_list[] = {"copy", "xto", "yto", "xfrom", "yfrom", "x_size", "y_size", "pixel_scale", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii|iiiif:lighten_sub_image", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8)) {
    PNMImage const *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PNMImage.lighten_sub_image", true, true);
    if (param1_this != nullptr) {
      ((*local_this).lighten_sub_image)(*param1_this, (int)param2, (int)param3, (int)param4, (int)param5, (int)param6, (int)param7, (float)param8);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "lighten_sub_image(const PNMImage self, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_lighten_sub_image_302_comment =
  "C++ Interface:\n"
  "lighten_sub_image(const PNMImage self, const PNMImage copy, int xto, int yto, int xfrom, int yfrom, int x_size, int y_size, float pixel_scale)\n"
  "\n"
  "/**\n"
  " * Behaves like copy_sub_image(), but the resulting color will be the lighter\n"
  " * of the source and destination colors at each pixel (and at each R, G, B, A\n"
  " * component value).\n"
  " *\n"
  " * If pixel_scale is not 1.0, it specifies an amount to scale each pixel value\n"
  " * of the source image before applying it to the target image.\n"
  " */";
#else
static const char *Dtool_PNMImage_lighten_sub_image_302_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::threshold(PNMImage const &select_image, int channel, float threshold, PNMImage const &lt, PNMImage const &ge)
 */
static PyObject *Dtool_PNMImage_threshold_303(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.threshold")) {
    return nullptr;
  }
  // 1-void PNMImage::threshold(PNMImage const &select_image, int channel, float threshold, PNMImage const &lt, PNMImage const &ge)
  PyObject *param1;
  int param2;
  float param3;
  PyObject *param4;
  PyObject *param5;
  static const char *keyword_list[] = {"select_image", "channel", "threshold", "lt", "ge", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OifOO:threshold", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
    PNMImage const *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PNMImage.threshold", true, true);
    PNMImage const *param4_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param4, Dtool_Ptr_PNMImage, 4, "PNMImage.threshold", true, true);
    PNMImage const *param5_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param5, Dtool_Ptr_PNMImage, 5, "PNMImage.threshold", true, true);
    if (param1_this != nullptr && param4_this != nullptr && param5_this != nullptr) {
      ((*local_this).threshold)(*param1_this, (int)param2, (float)param3, *param4_this, *param5_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "threshold(const PNMImage self, const PNMImage select_image, int channel, float threshold, const PNMImage lt, const PNMImage ge)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_threshold_303_comment =
  "C++ Interface:\n"
  "threshold(const PNMImage self, const PNMImage select_image, int channel, float threshold, const PNMImage lt, const PNMImage ge)\n"
  "\n"
  "/**\n"
  " * Selectively copies each pixel from either one source or another source,\n"
  " * depending on the pixel value of the indicated channel of select_image.\n"
  " *\n"
  " * For each pixel (x, y):\n"
  " *\n"
  " * s = select_image.get_channel(x, y, channel). Set this image's (x, y) to:\n"
  " *\n"
  " * lt.get_xel(x, y) if s < threshold, or\n"
  " *\n"
  " * ge.get_xel(x, y) if s >= threshold\n"
  " *\n"
  " * Any of select_image, lt, or ge may be the same PNMImge object as this\n"
  " * image, or the same as each other; or they may all be different.  All images\n"
  " * must be the same size.  As a special case, lt and ge may both be 1x1 images\n"
  " * instead of the source image size.\n"
  " */";
#else
static const char *Dtool_PNMImage_threshold_303_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::fill_distance_inside(PNMImage const &mask, float threshold, int radius, bool shrink_from_border)
 */
static PyObject *Dtool_PNMImage_fill_distance_inside_304(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.fill_distance_inside")) {
    return nullptr;
  }
  // 1-void PNMImage::fill_distance_inside(PNMImage const &mask, float threshold, int radius, bool shrink_from_border)
  PyObject *param1;
  float param2;
  int param3;
  PyObject *param4;
  static const char *keyword_list[] = {"mask", "threshold", "radius", "shrink_from_border", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OfiO:fill_distance_inside", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    PNMImage const *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PNMImage.fill_distance_inside", true, true);
    if (param1_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      ((*local_this).fill_distance_inside)(*param1_this, (float)param2, (int)param3, (PyObject_IsTrue(param4) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill_distance_inside(const PNMImage self, const PNMImage mask, float threshold, int radius, bool shrink_from_border)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_fill_distance_inside_304_comment =
  "C++ Interface:\n"
  "fill_distance_inside(const PNMImage self, const PNMImage mask, float threshold, int radius, bool shrink_from_border)\n"
  "\n"
  "/**\n"
  " * Replaces this image with a grayscale image whose gray channel represents\n"
  " * the linear Manhattan distance from the nearest dark pixel in the given mask\n"
  " * image, up to the specified radius value (which also becomes the new\n"
  " * maxval).  radius may range from 0 to maxmaxval; smaller values will compute\n"
  " * faster.  A dark pixel is defined as one whose pixel value is < threshold.\n"
  " *\n"
  " * If shrink_from_border is true, then the mask image is considered to be\n"
  " * surrounded by a border of dark pixels; otherwise, the border isn't\n"
  " * considered.\n"
  " *\n"
  " * This can be used, in conjunction with threshold, to shrink a mask image\n"
  " * inwards by a certain number of pixels.\n"
  " *\n"
  " * The mask image may be the same image as this one, in which case it is\n"
  " * destructively modified by this process.\n"
  " */";
#else
static const char *Dtool_PNMImage_fill_distance_inside_304_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::fill_distance_outside(PNMImage const &mask, float threshold, int radius)
 */
static PyObject *Dtool_PNMImage_fill_distance_outside_305(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.fill_distance_outside")) {
    return nullptr;
  }
  // 1-void PNMImage::fill_distance_outside(PNMImage const &mask, float threshold, int radius)
  PyObject *param1;
  float param2;
  int param3;
  static const char *keyword_list[] = {"mask", "threshold", "radius", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Ofi:fill_distance_outside", (char **)keyword_list, &param1, &param2, &param3)) {
    PNMImage const *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PNMImage.fill_distance_outside", true, true);
    if (param1_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      ((*local_this).fill_distance_outside)(*param1_this, (float)param2, (int)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill_distance_outside(const PNMImage self, const PNMImage mask, float threshold, int radius)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_fill_distance_outside_305_comment =
  "C++ Interface:\n"
  "fill_distance_outside(const PNMImage self, const PNMImage mask, float threshold, int radius)\n"
  "\n"
  "/**\n"
  " * Replaces this image with a grayscale image whose gray channel represents\n"
  " * the linear Manhattan distance from the nearest white pixel in the given\n"
  " * mask image, up to the specified radius value (which also becomes the new\n"
  " * maxval).  radius may range from 0 to maxmaxval; smaller values will compute\n"
  " * faster.  A white pixel is defined as one whose pixel value is >= threshold.\n"
  " *\n"
  " * This can be used, in conjunction with threshold, to grow a mask image\n"
  " * outwards by a certain number of pixels.\n"
  " *\n"
  " * The mask image may be the same image as this one, in which case it is\n"
  " * destructively modified by this process.\n"
  " */";
#else
static const char *Dtool_PNMImage_fill_distance_outside_305_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::indirect_1d_lookup(PNMImage const &index_image, int channel, PNMImage const &pixel_values)
 */
static PyObject *Dtool_PNMImage_indirect_1d_lookup_306(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.indirect_1d_lookup")) {
    return nullptr;
  }
  // 1-void PNMImage::indirect_1d_lookup(PNMImage const &index_image, int channel, PNMImage const &pixel_values)
  PyObject *param1;
  int param2;
  PyObject *param3;
  static const char *keyword_list[] = {"index_image", "channel", "pixel_values", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OiO:indirect_1d_lookup", (char **)keyword_list, &param1, &param2, &param3)) {
    PNMImage const *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PNMImage.indirect_1d_lookup", true, true);
    PNMImage const *param3_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_PNMImage, 3, "PNMImage.indirect_1d_lookup", true, true);
    if (param1_this != nullptr && param3_this != nullptr) {
      ((*local_this).indirect_1d_lookup)(*param1_this, (int)param2, *param3_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "indirect_1d_lookup(const PNMImage self, const PNMImage index_image, int channel, const PNMImage pixel_values)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_indirect_1d_lookup_306_comment =
  "C++ Interface:\n"
  "indirect_1d_lookup(const PNMImage self, const PNMImage index_image, int channel, const PNMImage pixel_values)\n"
  "\n"
  "/**\n"
  " * index_image is a WxH grayscale image, while pixel_values is an Nx1 color\n"
  " * (or grayscale) image.  Typically pixel_values will be a 256x1 image.\n"
  " *\n"
  " * Fills the PNMImage with a new image the same width and height as\n"
  " * index_image, with the same number of channels as pixel_values.\n"
  " *\n"
  " * Each pixel of the new image is computed with the formula:\n"
  " *\n"
  " * new_image(x, y) = pixel_values(index_image(x, y)[channel], 0)\n"
  " *\n"
  " * At present, no interpolation is performed; the nearest value in\n"
  " * pixel_values is discovered.  This may change in the future.\n"
  " */";
#else
static const char *Dtool_PNMImage_indirect_1d_lookup_306_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::rescale(float min_val, float max_val)
 */
static PyObject *Dtool_PNMImage_rescale_307(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.rescale")) {
    return nullptr;
  }
  // 1-void PNMImage::rescale(float min_val, float max_val)
  float param1;
  float param2;
  static const char *keyword_list[] = {"min_val", "max_val", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:rescale", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).rescale)((float)param1, (float)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rescale(const PNMImage self, float min_val, float max_val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_rescale_307_comment =
  "C++ Interface:\n"
  "rescale(const PNMImage self, float min_val, float max_val)\n"
  "\n"
  "/**\n"
  " * Rescales the RGB channel values so that any values in the original image\n"
  " * between min_val and max_val are expanded to the range 0 .. 1.  Values below\n"
  " * min_val are set to 0, and values above max_val are set to 1. Does not\n"
  " * affect the alpha channel, if any.\n"
  " */";
#else
static const char *Dtool_PNMImage_rescale_307_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::render_spot(LColorf const &fg, LColorf const &bg, float min_radius, float max_radius)
 */
static PyObject *Dtool_PNMImage_render_spot_308(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.render_spot")) {
    return nullptr;
  }
  // 1-void PNMImage::render_spot(LColorf const &fg, LColorf const &bg, float min_radius, float max_radius)
  PyObject *param1;
  PyObject *param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"fg", "bg", "min_radius", "max_radius", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOff:render_spot", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    LVecBase4f param1_local;
    LColorf const *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PNMImage.render_spot", "LVecBase4f");
    }
    LVecBase4f param2_local;
    LColorf const *param2_this = Dtool_Coerce_LVecBase4f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PNMImage.render_spot", "LVecBase4f");
    }
    ((*local_this).render_spot)(*param1_this, *param2_this, (float)param3, (float)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "render_spot(const PNMImage self, const LVecBase4f fg, const LVecBase4f bg, float min_radius, float max_radius)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_render_spot_308_comment =
  "C++ Interface:\n"
  "render_spot(const PNMImage self, const LVecBase4f fg, const LVecBase4f bg, float min_radius, float max_radius)\n"
  "\n"
  "/**\n"
  " * Renders a solid-color circle, with a fuzzy edge, into the center of the\n"
  " * PNMImage.  If the PNMImage is non-square, this actually renders an ellipse.\n"
  " *\n"
  " * The min_radius and max_radius are in the scale 0..1, where 1.0 means the\n"
  " * full width of the image.  If min_radius == max_radius, the edge is sharp\n"
  " * (but still antialiased); otherwise, the pixels between min_radius and\n"
  " * max_radius are smoothly blended between fg and bg colors.\n"
  " */";
#else
static const char *Dtool_PNMImage_render_spot_308_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::expand_border(int left, int right, int bottom, int top, LColorf const &color)
 */
static PyObject *Dtool_PNMImage_expand_border_309(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.expand_border")) {
    return nullptr;
  }
  // 1-void PNMImage::expand_border(int left, int right, int bottom, int top, LColorf const &color)
  int param1;
  int param2;
  int param3;
  int param4;
  PyObject *param5;
  static const char *keyword_list[] = {"left", "right", "bottom", "top", "color", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiiiO:expand_border", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
    LVecBase4f param5_local;
    LColorf const *param5_this = Dtool_Coerce_LVecBase4f(param5, param5_local);
    if (!(param5_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param5, 5, "PNMImage.expand_border", "LVecBase4f");
    }
    ((*local_this).expand_border)((int)param1, (int)param2, (int)param3, (int)param4, *param5_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "expand_border(const PNMImage self, int left, int right, int bottom, int top, const LVecBase4f color)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_expand_border_309_comment =
  "C++ Interface:\n"
  "expand_border(const PNMImage self, int left, int right, int bottom, int top, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " * Expands the image by the indicated number of pixels on each edge.  The new\n"
  " * pixels are set to the indicated color.\n"
  " *\n"
  " * If any of the values is negative, this actually crops the image.\n"
  " */";
#else
static const char *Dtool_PNMImage_expand_border_309_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::box_filter(float radius = 1.0)
 */
static PyObject *Dtool_PNMImage_box_filter_310(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.box_filter")) {
    return nullptr;
  }
  // 1-inline void PNMImage::box_filter(float radius = 1.0)
  float param1 = 1.0;
  static const char *keyword_list[] = {"radius", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|f:box_filter", (char **)keyword_list, &param1)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).box_filter)((float)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "box_filter(const PNMImage self, float radius)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_box_filter_310_comment =
  "C++ Interface:\n"
  "box_filter(const PNMImage self, float radius)\n"
  "\n"
  "/**\n"
  " * This flavor of box_filter() will apply the filter over the entire image\n"
  " * without resizing or copying; the effect is that of a blur operation.\n"
  " */";
#else
static const char *Dtool_PNMImage_box_filter_310_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::gaussian_filter(float radius = 1.0)
 */
static PyObject *Dtool_PNMImage_gaussian_filter_311(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.gaussian_filter")) {
    return nullptr;
  }
  // 1-inline void PNMImage::gaussian_filter(float radius = 1.0)
  float param1 = 1.0;
  static const char *keyword_list[] = {"radius", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|f:gaussian_filter", (char **)keyword_list, &param1)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).gaussian_filter)((float)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "gaussian_filter(const PNMImage self, float radius)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_gaussian_filter_311_comment =
  "C++ Interface:\n"
  "gaussian_filter(const PNMImage self, float radius)\n"
  "\n"
  "/**\n"
  " * This flavor of gaussian_filter() will apply the filter over the entire\n"
  " * image without resizing or copying; the effect is that of a blur operation.\n"
  " */";
#else
static const char *Dtool_PNMImage_gaussian_filter_311_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::unfiltered_stretch_from(PNMImage const &copy)
 */
static PyObject *Dtool_PNMImage_unfiltered_stretch_from_312(PyObject *self, PyObject *arg) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.unfiltered_stretch_from")) {
    return nullptr;
  }
  // 1-void PNMImage::unfiltered_stretch_from(PNMImage const &copy)
  PNMImage const *arg_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImage, 1, "PNMImage.unfiltered_stretch_from", true, true);
  if (arg_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).unfiltered_stretch_from)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unfiltered_stretch_from(const PNMImage self, const PNMImage copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_unfiltered_stretch_from_312_comment =
  "C++ Interface:\n"
  "unfiltered_stretch_from(const PNMImage self, const PNMImage copy)\n"
  "\n"
  "/**\n"
  " * Resizes from the indicated image into this one by performing a nearest-\n"
  " * point sample.\n"
  " */";
#else
static const char *Dtool_PNMImage_unfiltered_stretch_from_312_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::box_filter_from(float radius, PNMImage const &copy)
 */
static PyObject *Dtool_PNMImage_box_filter_from_313(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.box_filter_from")) {
    return nullptr;
  }
  // 1-void PNMImage::box_filter_from(float radius, PNMImage const &copy)
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"radius", "copy", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:box_filter_from", (char **)keyword_list, &param1, &param2)) {
    PNMImage const *param2_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PNMImage, 2, "PNMImage.box_filter_from", true, true);
    if (param2_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      ((*local_this).box_filter_from)((float)param1, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "box_filter_from(const PNMImage self, float radius, const PNMImage copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_box_filter_from_313_comment =
  "C++ Interface:\n"
  "box_filter_from(const PNMImage self, float radius, const PNMImage copy)\n"
  "\n"
  "/**\n"
  " * Makes a resized copy of the indicated image into this one using the\n"
  " * indicated filter.  The image to be copied is squashed and stretched to\n"
  " * match the dimensions of the current image, applying the appropriate filter\n"
  " * to perform the stretching.\n"
  " */";
#else
static const char *Dtool_PNMImage_box_filter_from_313_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::gaussian_filter_from(float radius, PNMImage const &copy)
 */
static PyObject *Dtool_PNMImage_gaussian_filter_from_314(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.gaussian_filter_from")) {
    return nullptr;
  }
  // 1-void PNMImage::gaussian_filter_from(float radius, PNMImage const &copy)
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"radius", "copy", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:gaussian_filter_from", (char **)keyword_list, &param1, &param2)) {
    PNMImage const *param2_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PNMImage, 2, "PNMImage.gaussian_filter_from", true, true);
    if (param2_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      ((*local_this).gaussian_filter_from)((float)param1, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "gaussian_filter_from(const PNMImage self, float radius, const PNMImage copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_gaussian_filter_from_314_comment =
  "C++ Interface:\n"
  "gaussian_filter_from(const PNMImage self, float radius, const PNMImage copy)\n"
  "\n"
  "/**\n"
  " * Makes a resized copy of the indicated image into this one using the\n"
  " * indicated filter.  The image to be copied is squashed and stretched to\n"
  " * match the dimensions of the current image, applying the appropriate filter\n"
  " * to perform the stretching.\n"
  " */";
#else
static const char *Dtool_PNMImage_gaussian_filter_from_314_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::quick_filter_from(PNMImage const &copy, int xborder = 0, int yborder = 0)
 */
static PyObject *Dtool_PNMImage_quick_filter_from_315(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.quick_filter_from")) {
    return nullptr;
  }
  // 1-void PNMImage::quick_filter_from(PNMImage const &copy, int xborder = 0, int yborder = 0)
  PyObject *param1;
  int param2 = 0;
  int param3 = 0;
  static const char *keyword_list[] = {"copy", "xborder", "yborder", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|ii:quick_filter_from", (char **)keyword_list, &param1, &param2, &param3)) {
    PNMImage const *param1_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMImage, 1, "PNMImage.quick_filter_from", true, true);
    if (param1_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      ((*local_this).quick_filter_from)(*param1_this, (int)param2, (int)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "quick_filter_from(const PNMImage self, const PNMImage copy, int xborder, int yborder)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_quick_filter_from_315_comment =
  "C++ Interface:\n"
  "quick_filter_from(const PNMImage self, const PNMImage copy, int xborder, int yborder)\n"
  "\n"
  "/**\n"
  " * Resizes from the given image, with a fixed radius of 0.5. This is a very\n"
  " * specialized and simple algorithm that doesn't handle dropping below the\n"
  " * Nyquist rate very well, but is quite a bit faster than the more general\n"
  " * box_filter(), above.  If borders are specified, they will further restrict\n"
  " * the size of the resulting image.  There's no point in using\n"
  " * quick_box_filter() on a single image.\n"
  " */";
#else
static const char *Dtool_PNMImage_quick_filter_from_315_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::make_histogram(PNMImageHeader::Histogram &hist)
 */
static PyObject *Dtool_PNMImage_make_histogram_316(PyObject *self, PyObject *arg) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.make_histogram")) {
    return nullptr;
  }
  // 1-void PNMImage::make_histogram(PNMImageHeader::Histogram &hist)
  PNMImageHeader::Histogram *arg_this = (PNMImageHeader::Histogram *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImageHeader_Histogram, 1, "PNMImage.make_histogram", false, true);
  if (arg_this != nullptr) {
    ((*local_this).make_histogram)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_histogram(const PNMImage self, Histogram hist)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_make_histogram_316_comment =
  "C++ Interface:\n"
  "make_histogram(const PNMImage self, Histogram hist)\n"
  "\n"
  "/**\n"
  " * Computes a histogram of the colors used in the image.\n"
  " */";
#else
static const char *Dtool_PNMImage_make_histogram_316_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::quantize(std::size_t max_colors)
 */
static PyObject *Dtool_PNMImage_quantize_317(PyObject *self, PyObject *arg) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.quantize")) {
    return nullptr;
  }
  // 1-void PNMImage::quantize(std::size_t max_colors)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ((*local_this).quantize)(arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "quantize(const PNMImage self, int max_colors)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_quantize_317_comment =
  "C++ Interface:\n"
  "quantize(const PNMImage self, int max_colors)\n"
  "\n"
  "/**\n"
  " * Reduces the number of unique colors in the image to (at most) the given\n"
  " * count.  Fewer colors than requested may be left in the image after this\n"
  " * operation, but never more.\n"
  " *\n"
  " * At present, this is only supported on images without an alpha channel.\n"
  " *\n"
  " * @since 1.10.5\n"
  " */";
#else
static const char *Dtool_PNMImage_quantize_317_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::perlin_noise_fill(StackedPerlinNoise2 &perlin)
 * void PNMImage::perlin_noise_fill(float sx, float sy, int table_size = 256, unsigned long int seed = 0)
 */
static PyObject *Dtool_PNMImage_perlin_noise_fill_318(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.perlin_noise_fill")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "perlin")) {
        // 1-void PNMImage::perlin_noise_fill(StackedPerlinNoise2 &perlin)
        StackedPerlinNoise2 *arg_this = (StackedPerlinNoise2 *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_StackedPerlinNoise2, 1, "PNMImage.perlin_noise_fill", false, true);
        if (arg_this != nullptr) {
          ((*local_this).perlin_noise_fill)(*arg_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
  case 3:
  case 4:
    {
      // 1-void PNMImage::perlin_noise_fill(float sx, float sy, int table_size = 256, unsigned long int seed = 0)
      float param1;
      float param2;
      int param3 = 256;
      unsigned long param4 = 0;
      static const char *keyword_list[] = {"sx", "sy", "table_size", "seed", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff|ik:perlin_noise_fill", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        ((*local_this).perlin_noise_fill)((float)param1, (float)param2, (int)param3, (unsigned long int)param4);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "perlin_noise_fill() takes 2, 3, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "perlin_noise_fill(const PNMImage self, StackedPerlinNoise2 perlin)\n"
      "perlin_noise_fill(const PNMImage self, float sx, float sy, int table_size, int seed)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_perlin_noise_fill_318_comment =
  "C++ Interface:\n"
  "perlin_noise_fill(const PNMImage self, StackedPerlinNoise2 perlin)\n"
  "perlin_noise_fill(const PNMImage self, float sx, float sy, int table_size, int seed)\n"
  "\n"
  "/**\n"
  " * Fills the image with a grayscale perlin noise pattern based on the\n"
  " * indicated parameters.  Uses set_xel to set the grayscale values.  The sx\n"
  " * and sy parameters are in multiples of the size of this image.  See also the\n"
  " * PerlinNoise2 class in mathutil.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Variant of perlin_noise_fill that uses an existing StackedPerlinNoise2\n"
  " * object.\n"
  " */";
#else
static const char *Dtool_PNMImage_perlin_noise_fill_318_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::remix_channels(LMatrix4 const &conv)
 */
static PyObject *Dtool_PNMImage_remix_channels_319(PyObject *self, PyObject *arg) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.remix_channels")) {
    return nullptr;
  }
  // 1-void PNMImage::remix_channels(LMatrix4 const &conv)
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PNMImage.remix_channels", "LMatrix4f");
  }
  ((*local_this).remix_channels)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remix_channels(const PNMImage self, const LMatrix4f conv)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_remix_channels_319_comment =
  "C++ Interface:\n"
  "remix_channels(const PNMImage self, const LMatrix4f conv)\n"
  "\n"
  "/**\n"
  " * Transforms every pixel using the operation (Ro,Go,Bo) =\n"
  " * conv.xform_point(Ri,Gi,Bi); Input must be a color image.\n"
  " */";
#else
static const char *Dtool_PNMImage_remix_channels_319_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::gamma_correct(float from_gamma, float to_gamma)
 */
static PyObject *Dtool_PNMImage_gamma_correct_320(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.gamma_correct")) {
    return nullptr;
  }
  // 1-inline void PNMImage::gamma_correct(float from_gamma, float to_gamma)
  float param1;
  float param2;
  static const char *keyword_list[] = {"from_gamma", "to_gamma", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:gamma_correct", (char **)keyword_list, &param1, &param2)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).gamma_correct)((float)param1, (float)param2);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "gamma_correct(const PNMImage self, float from_gamma, float to_gamma)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_gamma_correct_320_comment =
  "C++ Interface:\n"
  "gamma_correct(const PNMImage self, float from_gamma, float to_gamma)\n"
  "\n"
  "/**\n"
  " * Assuming the image was constructed with a gamma curve of from_gamma in the\n"
  " * RGB channels, converts it to an image with a gamma curve of to_gamma in the\n"
  " * RGB channels.  Does not affect the alpha channel.\n"
  " */";
#else
static const char *Dtool_PNMImage_gamma_correct_320_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::gamma_correct_alpha(float from_gamma, float to_gamma)
 */
static PyObject *Dtool_PNMImage_gamma_correct_alpha_321(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.gamma_correct_alpha")) {
    return nullptr;
  }
  // 1-inline void PNMImage::gamma_correct_alpha(float from_gamma, float to_gamma)
  float param1;
  float param2;
  static const char *keyword_list[] = {"from_gamma", "to_gamma", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:gamma_correct_alpha", (char **)keyword_list, &param1, &param2)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).gamma_correct_alpha)((float)param1, (float)param2);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "gamma_correct_alpha(const PNMImage self, float from_gamma, float to_gamma)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_gamma_correct_alpha_321_comment =
  "C++ Interface:\n"
  "gamma_correct_alpha(const PNMImage self, float from_gamma, float to_gamma)\n"
  "\n"
  "/**\n"
  " * Assuming the image was constructed with a gamma curve of from_gamma in the\n"
  " * alpha channel, converts it to an image with a gamma curve of to_gamma in\n"
  " * the alpha channel.  Does not affect the RGB channels.\n"
  " */";
#else
static const char *Dtool_PNMImage_gamma_correct_alpha_321_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::apply_exponent(float gray_exponent)
 * inline void PNMImage::apply_exponent(float gray_exponent, float alpha_exponent)
 * inline void PNMImage::apply_exponent(float red_exponent, float green_exponent, float blue_exponent)
 * void PNMImage::apply_exponent(float red_exponent, float green_exponent, float blue_exponent, float alpha_exponent)
 */
static PyObject *Dtool_PNMImage_apply_exponent_322(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.apply_exponent")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "gray_exponent")) {
        // 1-inline void PNMImage::apply_exponent(float gray_exponent)
        if (PyNumber_Check(arg)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
          PyThreadState *_save;
          Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
          ((*local_this).apply_exponent)((float)PyFloat_AsDouble(arg));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
          Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-inline void PNMImage::apply_exponent(float gray_exponent, float alpha_exponent)
      float param1;
      float param2;
      static const char *keyword_list[] = {"gray_exponent", "alpha_exponent", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:apply_exponent", (char **)keyword_list, &param1, &param2)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        ((*local_this).apply_exponent)((float)param1, (float)param2);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void PNMImage::apply_exponent(float red_exponent, float green_exponent, float blue_exponent)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"red_exponent", "green_exponent", "blue_exponent", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:apply_exponent", (char **)keyword_list, &param1, &param2, &param3)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        ((*local_this).apply_exponent)((float)param1, (float)param2, (float)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-void PNMImage::apply_exponent(float red_exponent, float green_exponent, float blue_exponent, float alpha_exponent)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"red_exponent", "green_exponent", "blue_exponent", "alpha_exponent", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:apply_exponent", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        ((*local_this).apply_exponent)((float)param1, (float)param2, (float)param3, (float)param4);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "apply_exponent() takes 2, 3, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_exponent(const PNMImage self, float gray_exponent)\n"
      "apply_exponent(const PNMImage self, float gray_exponent, float alpha_exponent)\n"
      "apply_exponent(const PNMImage self, float red_exponent, float green_exponent, float blue_exponent)\n"
      "apply_exponent(const PNMImage self, float red_exponent, float green_exponent, float blue_exponent, float alpha_exponent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_apply_exponent_322_comment =
  "C++ Interface:\n"
  "apply_exponent(const PNMImage self, float gray_exponent)\n"
  "apply_exponent(const PNMImage self, float gray_exponent, float alpha_exponent)\n"
  "apply_exponent(const PNMImage self, float red_exponent, float green_exponent, float blue_exponent)\n"
  "apply_exponent(const PNMImage self, float red_exponent, float green_exponent, float blue_exponent, float alpha_exponent)\n"
  "\n"
  "/**\n"
  " * Adjusts each channel of the image by raising the corresponding component\n"
  " * value to the indicated exponent, such that L' = L ^ exponent.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adjusts each channel of the image by raising the corresponding component\n"
  " * value to the indicated exponent, such that L' = L ^ exponent.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adjusts each channel of the image by raising the corresponding component\n"
  " * value to the indicated exponent, such that L' = L ^ exponent.  For a\n"
  " * grayscale image, the blue_exponent value is used for the grayscale value,\n"
  " * and red_exponent and green_exponent are unused.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adjusts each channel of the image by raising the corresponding component\n"
  " * value to the indicated exponent, such that L' = L ^ exponent.  For a\n"
  " * grayscale image, the blue_exponent value is used for the grayscale value,\n"
  " * and red_exponent and green_exponent are unused.\n"
  " */";
#else
static const char *Dtool_PNMImage_apply_exponent_322_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LRGBColorf PNMImage::get_average_xel(void) const
 */
static PyObject *Dtool_PNMImage_get_average_xel_323(PyObject *self, PyObject *) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  // 1-LRGBColorf PNMImage::get_average_xel(void) const
  LRGBColorf *return_value = new LRGBColorf(((*(const PNMImage*)local_this).get_average_xel)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_average_xel_323_comment =
  "C++ Interface:\n"
  "get_average_xel(PNMImage self)\n"
  "\n"
  "/**\n"
  " * Returns the average color of all of the pixels in the image.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_average_xel_323_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LColorf PNMImage::get_average_xel_a(void) const
 */
static PyObject *Dtool_PNMImage_get_average_xel_a_324(PyObject *self, PyObject *) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  // 1-LColorf PNMImage::get_average_xel_a(void) const
  LColorf *return_value = new LColorf(((*(const PNMImage*)local_this).get_average_xel_a)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_average_xel_a_324_comment =
  "C++ Interface:\n"
  "get_average_xel_a(PNMImage self)\n"
  "\n"
  "/**\n"
  " * Returns the average color of all of the pixels in the image, including the\n"
  " * alpha channel.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_average_xel_a_324_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * float PNMImage::get_average_gray(void) const
 */
static PyObject *Dtool_PNMImage_get_average_gray_325(PyObject *self, PyObject *) {
  PNMImage *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage)) {
    return nullptr;
  }
  // 1-float PNMImage::get_average_gray(void) const
  float return_value = ((*(const PNMImage*)local_this).get_average_gray)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_get_average_gray_325_comment =
  "C++ Interface:\n"
  "get_average_gray(PNMImage self)\n"
  "\n"
  "/**\n"
  " * Returns the average grayscale component of all of the pixels in the image.\n"
  " */";
#else
static const char *Dtool_PNMImage_get_average_gray_325_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMImage::do_fill_distance(int xi, int yi, int d)
 */
static PyObject *Dtool_PNMImage_do_fill_distance_326(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage, (void **)&local_this, "PNMImage.do_fill_distance")) {
    return nullptr;
  }
  // 1-void PNMImage::do_fill_distance(int xi, int yi, int d)
  int param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"xi", "yi", "d", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:do_fill_distance", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).do_fill_distance)((int)param1, (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "do_fill_distance(const PNMImage self, int xi, int yi, int d)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_do_fill_distance_326_comment =
  "C++ Interface:\n"
  "do_fill_distance(const PNMImage self, int xi, int yi, int d)\n"
  "\n"
  "/**\n"
  " * Recursively fills in the minimum distance measured from a certain set of\n"
  " * points into the gray channel.\n"
  " */";
#else
static const char *Dtool_PNMImage_do_fill_distance_326_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PNMImage::PNMImage(void)
 * explicit PNMImage::PNMImage(Filename const &filename, PNMFileType *type = nullptr)
 * inline PNMImage::PNMImage(PNMImage const &copy)
 * inline explicit PNMImage::PNMImage(int x_size, int y_size, int num_channels = 3, xelval maxval = 255, PNMFileType *type = nullptr, ColorSpace color_space = ::CS_linear)
 */
static int Dtool_Init_PNMImage(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PNMImage::PNMImage(void)
      PNMImage *return_value = new PNMImage();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImage, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 explicit PNMImage::PNMImage(Filename const &filename, PNMFileType *type)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "filename")) {
          Filename const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_Filename);
          if (param0_this != nullptr) {
            PNMImage *return_value = new PNMImage(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImage, true, false);
          }
        }
      }

      {
        // -2 inline PNMImage::PNMImage(PNMImage const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PNMImage const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_PNMImage);
          if (param0_this != nullptr) {
            PNMImage *return_value = new PNMImage(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImage, true, false);
          }
        }
      }

      {
        // -2 explicit PNMImage::PNMImage(Filename const &filename, PNMFileType *type)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "filename")) {
          Filename param0_local;
          Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
          if ((param0_this != nullptr)) {
            PNMImage *return_value = new PNMImage(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImage, true, false);
          }
        }
      }

      // No coercion possible: inline PNMImage::PNMImage(PNMImage const &copy)
    }
    break;
  case 2:
  case 3:
  case 4:
  case 5:
  case 6:
    {
      {
        // -2 inline explicit PNMImage::PNMImage(int x_size, int y_size, int num_channels = 3, xelval maxval = 255, PNMFileType *type = nullptr, ColorSpace color_space = ::CS_linear)
        int param0;
        int param1;
        int param2 = 3;
        long param3 = 255;
        PyObject *param4 = nullptr;
        int param5 = ::CS_linear;
        static const char *keyword_list[] = {"x_size", "y_size", "num_channels", "maxval", "type", "color_space", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "ii|ilOi:PNMImage", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
#ifndef NDEBUG
          if (param3 < 0 || param3 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param3);
            return -1;
          }
#endif
          PNMFileType *param4_this = nullptr;
          if (param4 != nullptr && param4 != Py_None) {
            param4_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param4, Dtool_Ptr_PNMFileType, 4, "PNMImage.PNMImage", false, false);
          }
          if ((param4 == nullptr || param4 == Py_None || param4_this != nullptr)) {
            PNMImage *return_value = new PNMImage((int)param0, (int)param1, (int)param2, (xelval)param3, param4_this, (ColorSpace)param5);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImage, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline explicit PNMImage::PNMImage(int x_size, int y_size, int num_channels = 3, xelval maxval = 255, PNMFileType *type = nullptr, ColorSpace color_space = ::CS_linear)
      {
        // -2 explicit PNMImage::PNMImage(Filename const &filename, PNMFileType *type = nullptr)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"filename", "type", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:PNMImage", (char **)keyword_list, &param0, &param1)) {
          Filename param0_local;
          Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
          PNMFileType *param1_this = nullptr;
          if (param1 != Py_None) {
            param1_this = (PNMFileType *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PNMFileType, 1, "PNMImage.PNMImage", false, false);
          }
          if ((param0_this != nullptr) && (param1 == Py_None || param1_this != nullptr)) {
            PNMImage *return_value = new PNMImage(*param0_this, param1_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImage, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PNMImage() takes 0, 1, 2, 3, 4, 5 or 6 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PNMImage()\n"
      "PNMImage(const Filename filename)\n"
      "PNMImage(const PNMImage copy)\n"
      "PNMImage(int x_size, int y_size, int num_channels, int maxval, PNMFileType type, int color_space)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PNMImage(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PNMImage) {
    printf("PNMImage ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PNMImage *local_this = (PNMImage *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PNMImage) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PNMImageHeader) {
    return (PNMImageHeader *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PNMImage(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PNMImage) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PNMImageHeader) {
    PNMImageHeader* other_this = (PNMImageHeader*)from_this;
    return (PNMImage*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PNMImage::Row
 */
/**
 * Python function wrapper for:
 * inline xel &PNMImage::Row::get_xel_val(int x)
 */
static PyObject *Dtool_PNMImage_Row_get_xel_val_331(PyObject *self, PyObject *arg) {
  PNMImage::Row *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage_Row, (void **)&local_this, "PNMImage::Row.get_xel_val")) {
    return nullptr;
  }
  // 1-inline xel &PNMImage::Row::get_xel_val(int x)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    xel *return_value = &(((*local_this).get_xel_val)((int)arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_pixel, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_xel_val(const Row self, int x)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_Row_get_xel_val_331_comment =
  "C++ Interface:\n"
  "get_xel_val(const Row self, int x)\n"
  "\n"
  "/**\n"
  " * Fetch the pixel at the given column in the row.\n"
  " */";
#else
static const char *Dtool_PNMImage_Row_get_xel_val_331_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::Row::set_xel_val(int x, xel const &v)
 */
static PyObject *Dtool_PNMImage_Row_set_xel_val_332(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage::Row *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage_Row, (void **)&local_this, "PNMImage::Row.set_xel_val")) {
    return nullptr;
  }
  // 1-inline void PNMImage::Row::set_xel_val(int x, xel const &v)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"x", "v", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_xel_val", (char **)keyword_list, &param1, &param2)) {
    pixel param2_local;
    xel const *param2_this = Dtool_Coerce_pixel(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "Row.set_xel_val", "pixel");
    }
    ((*local_this).set_xel_val)((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_xel_val(const Row self, int x, const pixel v)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_Row_set_xel_val_332_comment =
  "C++ Interface:\n"
  "set_xel_val(const Row self, int x, const pixel v)\n"
  "\n"
  "/**\n"
  " * Set the pixel at the given column in the row.\n"
  " */";
#else
static const char *Dtool_PNMImage_Row_set_xel_val_332_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline xelval PNMImage::Row::get_alpha_val(int x) const
 */
static PyObject *Dtool_PNMImage_Row_get_alpha_val_333(PyObject *self, PyObject *arg) {
  PNMImage::Row *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage_Row)) {
    return nullptr;
  }
  // 1-inline xelval PNMImage::Row::get_alpha_val(int x) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    xelval return_value = ((*(const PNMImage::Row*)local_this).get_alpha_val)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_alpha_val(Row self, int x)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_Row_get_alpha_val_333_comment =
  "C++ Interface:\n"
  "get_alpha_val(Row self, int x)\n"
  "\n"
  "/**\n"
  " * Fetch the alpha value at the given column in the row.\n"
  " */";
#else
static const char *Dtool_PNMImage_Row_get_alpha_val_333_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMImage::Row::set_alpha_val(int x, xelval v)
 */
static PyObject *Dtool_PNMImage_Row_set_alpha_val_334(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMImage::Row *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMImage_Row, (void **)&local_this, "PNMImage::Row.set_alpha_val")) {
    return nullptr;
  }
  // 1-inline void PNMImage::Row::set_alpha_val(int x, xelval v)
  int param1;
  long param2;
  static const char *keyword_list[] = {"x", "v", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "il:set_alpha_val", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param2 < 0 || param2 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param2);
    }
#endif
    ((*local_this).set_alpha_val)((int)param1, (xelval)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_alpha_val(const Row self, int x, int v)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_Row_set_alpha_val_334_comment =
  "C++ Interface:\n"
  "set_alpha_val(const Row self, int x, int v)\n"
  "\n"
  "/**\n"
  " * Set the alpha value at the given column in the row.\n"
  " */";
#else
static const char *Dtool_PNMImage_Row_set_alpha_val_334_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PNMImage::Row::Row(PNMImage::Row const &) = default
 */
static int Dtool_Init_PNMImage_Row(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("Row() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline PNMImage::Row::Row(PNMImage::Row const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    PNMImage::Row const *param0_this = (PNMImage::Row *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PNMImage_Row, 0, "Row.Row", true, true);
    if (param0_this != nullptr) {
      PNMImage::Row *return_value = new PNMImage::Row(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImage_Row, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Row(const Row param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PNMImage_Row(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PNMImage_Row) {
    printf("PNMImage_Row ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PNMImage::Row *local_this = (PNMImage::Row *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PNMImage_Row) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PNMImage_Row(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PNMImage_Row) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PNMImage::CRow
 */
/**
 * Python function wrapper for:
 * inline xel PNMImage::CRow::get_xel_val(int x) const
 */
static PyObject *Dtool_PNMImage_CRow_get_xel_val_339(PyObject *self, PyObject *arg) {
  PNMImage::CRow *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage_CRow)) {
    return nullptr;
  }
  // 1-inline xel PNMImage::CRow::get_xel_val(int x) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    xel *return_value = new xel(((*(const PNMImage::CRow*)local_this).get_xel_val)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_pixel, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_xel_val(CRow self, int x)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_CRow_get_xel_val_339_comment =
  "C++ Interface:\n"
  "get_xel_val(CRow self, int x)\n"
  "\n"
  "/**\n"
  " * Fetch the pixel at the given column in the row.\n"
  " */";
#else
static const char *Dtool_PNMImage_CRow_get_xel_val_339_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline xelval PNMImage::CRow::get_alpha_val(int x) const
 */
static PyObject *Dtool_PNMImage_CRow_get_alpha_val_340(PyObject *self, PyObject *arg) {
  PNMImage::CRow *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMImage_CRow)) {
    return nullptr;
  }
  // 1-inline xelval PNMImage::CRow::get_alpha_val(int x) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    xelval return_value = ((*(const PNMImage::CRow*)local_this).get_alpha_val)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_alpha_val(CRow self, int x)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMImage_CRow_get_alpha_val_340_comment =
  "C++ Interface:\n"
  "get_alpha_val(CRow self, int x)\n"
  "\n"
  "/**\n"
  " * Fetch the alpha value at the given column in the row.\n"
  " */";
#else
static const char *Dtool_PNMImage_CRow_get_alpha_val_340_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PNMImage::CRow::CRow(PNMImage::CRow const &) = default
 */
static int Dtool_Init_PNMImage_CRow(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CRow() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline PNMImage::CRow::CRow(PNMImage::CRow const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    PNMImage::CRow const *param0_this = (PNMImage::CRow *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PNMImage_CRow, 0, "CRow.CRow", true, true);
    if (param0_this != nullptr) {
      PNMImage::CRow *return_value = new PNMImage::CRow(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMImage_CRow, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CRow(const CRow param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PNMImage_CRow(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PNMImage_CRow) {
    printf("PNMImage_CRow ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PNMImage::CRow *local_this = (PNMImage::CRow *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PNMImage_CRow) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PNMImage_CRow(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PNMImage_CRow) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PNMPainter
 */
/**
 * Python function wrapper for:
 * inline void PNMPainter::set_pen(PNMBrush *pen)
 */
static PyObject *Dtool_PNMPainter_set_pen_353(PyObject *self, PyObject *arg) {
  PNMPainter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMPainter, (void **)&local_this, "PNMPainter.set_pen")) {
    return nullptr;
  }
  // 1-inline void PNMPainter::set_pen(PNMBrush *pen)
  PNMBrush *arg_this = (PNMBrush *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMBrush, 1, "PNMPainter.set_pen", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_pen)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pen(const PNMPainter self, PNMBrush pen)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMPainter_set_pen_353_comment =
  "C++ Interface:\n"
  "set_pen(const PNMPainter self, PNMBrush pen)\n"
  "\n"
  "/**\n"
  " * Specifies a PNMBrush that will be used for drawing lines and edges.  If the\n"
  " * brush is a bitmap brush, its image will be smeared pixelwise along the\n"
  " * line.\n"
  " *\n"
  " * Unlike the PNMImage passed to the constructor, the PNMPainter will take\n"
  " * ownership of the pen.  It is not necessary to keep a separate pointer to\n"
  " * it.\n"
  " */";
#else
static const char *Dtool_PNMPainter_set_pen_353_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PNMBrush *PNMPainter::get_pen(void) const
 */
static PyObject *Dtool_PNMPainter_get_pen_354(PyObject *self, PyObject *) {
  PNMPainter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMPainter)) {
    return nullptr;
  }
  // 1-inline PNMBrush *PNMPainter::get_pen(void) const
  PNMBrush *return_value = ((*(const PNMPainter*)local_this).get_pen)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMBrush, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PNMPainter_get_pen_354_comment =
  "C++ Interface:\n"
  "get_pen(PNMPainter self)\n"
  "\n"
  "/**\n"
  " * Returns the current pen.  See set_pen().\n"
  " */";
#else
static const char *Dtool_PNMPainter_get_pen_354_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMPainter::set_fill(PNMBrush *fill)
 */
static PyObject *Dtool_PNMPainter_set_fill_355(PyObject *self, PyObject *arg) {
  PNMPainter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMPainter, (void **)&local_this, "PNMPainter.set_fill")) {
    return nullptr;
  }
  // 1-inline void PNMPainter::set_fill(PNMBrush *fill)
  PNMBrush *arg_this = (PNMBrush *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMBrush, 1, "PNMPainter.set_fill", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_fill)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fill(const PNMPainter self, PNMBrush fill)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMPainter_set_fill_355_comment =
  "C++ Interface:\n"
  "set_fill(const PNMPainter self, PNMBrush fill)\n"
  "\n"
  "/**\n"
  " * Specifies a PNMBrush that will be used for filling in the interiors of\n"
  " * objects.  If the brush is a bitmap brush, its image will be tiled\n"
  " * throughout the space.\n"
  " *\n"
  " * Unlike the PNMImage passed to the constructor, the PNMPainter will take\n"
  " * ownership of the fill brush.  It is not necessary to keep a separate\n"
  " * pointer to it.\n"
  " */";
#else
static const char *Dtool_PNMPainter_set_fill_355_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PNMBrush *PNMPainter::get_fill(void) const
 */
static PyObject *Dtool_PNMPainter_get_fill_356(PyObject *self, PyObject *) {
  PNMPainter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PNMPainter)) {
    return nullptr;
  }
  // 1-inline PNMBrush *PNMPainter::get_fill(void) const
  PNMBrush *return_value = ((*(const PNMPainter*)local_this).get_fill)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMBrush, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PNMPainter_get_fill_356_comment =
  "C++ Interface:\n"
  "get_fill(PNMPainter self)\n"
  "\n"
  "/**\n"
  " * Returns the current fill brush.  See set_fill().\n"
  " */";
#else
static const char *Dtool_PNMPainter_get_fill_356_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PNMPainter::draw_point(float x, float y)
 */
static PyObject *Dtool_PNMPainter_draw_point_360(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMPainter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMPainter, (void **)&local_this, "PNMPainter.draw_point")) {
    return nullptr;
  }
  // 1-inline void PNMPainter::draw_point(float x, float y)
  float param1;
  float param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:draw_point", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).draw_point)((float)param1, (float)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "draw_point(const PNMPainter self, float x, float y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMPainter_draw_point_360_comment =
  "C++ Interface:\n"
  "draw_point(const PNMPainter self, float x, float y)\n"
  "\n"
  "/**\n"
  " * Draws an antialiased point on the PNMImage, using the current pen.\n"
  " */";
#else
static const char *Dtool_PNMPainter_draw_point_360_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMPainter::draw_line(float xa, float ya, float xb, float yb)
 */
static PyObject *Dtool_PNMPainter_draw_line_361(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMPainter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMPainter, (void **)&local_this, "PNMPainter.draw_line")) {
    return nullptr;
  }
  // 1-void PNMPainter::draw_line(float xa, float ya, float xb, float yb)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"xa", "ya", "xb", "yb", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:draw_line", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    ((*local_this).draw_line)((float)param1, (float)param2, (float)param3, (float)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "draw_line(const PNMPainter self, float xa, float ya, float xb, float yb)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMPainter_draw_line_361_comment =
  "C++ Interface:\n"
  "draw_line(const PNMPainter self, float xa, float ya, float xb, float yb)\n"
  "\n"
  "/**\n"
  " * Draws an antialiased line on the PNMImage, using the current pen.\n"
  " */";
#else
static const char *Dtool_PNMPainter_draw_line_361_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PNMPainter::draw_rectangle(float xa, float ya, float xb, float yb)
 */
static PyObject *Dtool_PNMPainter_draw_rectangle_362(PyObject *self, PyObject *args, PyObject *kwds) {
  PNMPainter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMPainter, (void **)&local_this, "PNMPainter.draw_rectangle")) {
    return nullptr;
  }
  // 1-void PNMPainter::draw_rectangle(float xa, float ya, float xb, float yb)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"xa", "ya", "xb", "yb", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:draw_rectangle", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    ((*local_this).draw_rectangle)((float)param1, (float)param2, (float)param3, (float)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "draw_rectangle(const PNMPainter self, float xa, float ya, float xb, float yb)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PNMPainter_draw_rectangle_362_comment =
  "C++ Interface:\n"
  "draw_rectangle(const PNMPainter self, float xa, float ya, float xb, float yb)\n"
  "\n"
  "/**\n"
  " * Draws a filled rectangule on the PNMImage, using the current pen for the\n"
  " * outline, and the current fill brush for the interior.\n"
  " *\n"
  " * The two coordinates specify any two diagonally opposite corners.\n"
  " */";
#else
static const char *Dtool_PNMPainter_draw_rectangle_362_comment = nullptr;
#endif

static PyObject *Dtool_PNMPainter_pen_Getter(PyObject *self, void *) {
  const PNMPainter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMPainter, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PNMBrush *PNMPainter::get_pen(void) const
  PNMBrush *return_value = ((*(const PNMPainter*)local_this).get_pen)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMBrush, true, false);
}

static int Dtool_PNMPainter_pen_Setter(PyObject *self, PyObject *arg, void *) {
  PNMPainter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMPainter, (void **)&local_this, "PNMPainter.pen")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete pen attribute");
    return -1;
  }
  // 1-inline void PNMPainter::set_pen(PNMBrush *pen)
  PNMBrush *arg_this = (PNMBrush *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMBrush, 1, "PNMPainter.set_pen", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_pen)(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_pen(const PNMPainter self, PNMBrush pen)\n");
  }
  return -1;
}

static PyObject *Dtool_PNMPainter_fill_Getter(PyObject *self, void *) {
  const PNMPainter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMPainter, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PNMBrush *PNMPainter::get_fill(void) const
  PNMBrush *return_value = ((*(const PNMPainter*)local_this).get_fill)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMBrush, true, false);
}

static int Dtool_PNMPainter_fill_Setter(PyObject *self, PyObject *arg, void *) {
  PNMPainter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PNMPainter, (void **)&local_this, "PNMPainter.fill")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete fill attribute");
    return -1;
  }
  // 1-inline void PNMPainter::set_fill(PNMBrush *fill)
  PNMBrush *arg_this = (PNMBrush *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMBrush, 1, "PNMPainter.set_fill", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_fill)(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_fill(const PNMPainter self, PNMBrush fill)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * explicit PNMPainter::PNMPainter(PNMImage &image, int xo = 0, int yo = 0)
 * inline PNMPainter::PNMPainter(PNMPainter const &) = default
 */
static int Dtool_Init_PNMPainter(PyObject *self, PyObject *args, PyObject *kwds) {
  {
    // -2 explicit PNMPainter::PNMPainter(PNMImage &image, int xo = 0, int yo = 0)
    PyObject *param0;
    int param1 = 0;
    int param2 = 0;
    static const char *keyword_list[] = {"image", "xo", "yo", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|ii:PNMPainter", (char **)keyword_list, &param0, &param1, &param2)) {
      PNMImage *param0_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PNMImage, 0, "PNMPainter.PNMPainter", false, false);
      if (param0_this != nullptr) {
        PNMPainter *return_value = new PNMPainter(*param0_this, (int)param1, (int)param2);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMPainter, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline PNMPainter::PNMPainter(PNMPainter const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      PNMPainter const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_PNMPainter);
      if (param0_this != nullptr) {
        PNMPainter *return_value = new PNMPainter(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PNMPainter, true, false);
      }
    }
  }

  // No coercion possible: explicit PNMPainter::PNMPainter(PNMImage &image, int xo = 0, int yo = 0)
  // No coercion possible: inline PNMPainter::PNMPainter(PNMPainter const &) = default
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PNMPainter(PNMImage image, int xo, int yo)\n"
      "PNMPainter(const PNMPainter param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PNMPainter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PNMPainter) {
    printf("PNMPainter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PNMPainter *local_this = (PNMPainter *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PNMPainter) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PNMPainter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PNMPainter) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python method tables for pixel (pixel)
 */
static PyMethodDef Dtool_Methods_pixel[] = {
  {"output", &Dtool_pixel_output_14, METH_O, (const char *)Dtool_pixel_output_14_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// pixel slot nb_add -> operator +
//////////////////
static PyObject *Dtool_pixel_operator_4_nb_add(PyObject *self, PyObject *arg) {
  pixel *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_pixel, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-pixel pixel::operator +(pixel const &other) const
  pixel arg_local;
  pixel const *arg_this = Dtool_Coerce_pixel(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "pixel.__add__", "pixel");
  }
  pixel *return_value = new pixel(((*(const pixel*)local_this).operator +)(*arg_this));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_pixel, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// pixel slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_pixel_operator_7_nb_inplace_add(PyObject *self, PyObject *arg) {
  pixel *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_pixel, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-void pixel::operator +=(pixel const &other)
  pixel arg_local;
  pixel const *arg_this = Dtool_Coerce_pixel(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "pixel.__iadd__", "pixel");
    return nullptr;
  }
  ((*local_this).operator +=)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  Py_INCREF(self);
  return self;
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// pixel slot nb_inplace_multiply -> operator *=
//////////////////
static PyObject *Dtool_pixel_operator_9_nb_inplace_multiply(PyObject *self, PyObject *arg) {
  pixel *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_pixel, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-void pixel::operator *=(double const mult)
  if (PyNumber_Check(arg)) {
    ((*local_this).operator *=)(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// pixel slot nb_inplace_subtract -> operator -=
//////////////////
static PyObject *Dtool_pixel_operator_8_nb_inplace_subtract(PyObject *self, PyObject *arg) {
  pixel *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_pixel, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-void pixel::operator -=(pixel const &other)
  pixel arg_local;
  pixel const *arg_this = Dtool_Coerce_pixel(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "pixel.__isub__", "pixel");
    return nullptr;
  }
  ((*local_this).operator -=)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  Py_INCREF(self);
  return self;
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// pixel slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_pixel_operator_6_nb_multiply(PyObject *self, PyObject *arg) {
  pixel *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_pixel, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-pixel pixel::operator *(double const mult) const
  if (PyNumber_Check(arg)) {
    pixel *return_value = new pixel(((*(const pixel*)local_this).operator *)(PyFloat_AsDouble(arg)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_pixel, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// pixel slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_pixel_operator_5_nb_subtract(PyObject *self, PyObject *arg) {
  pixel *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_pixel, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-pixel pixel::operator -(pixel const &other) const
  pixel arg_local;
  pixel const *arg_this = Dtool_Coerce_pixel(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "pixel.__sub__", "pixel");
  }
  pixel *return_value = new pixel(((*(const pixel*)local_this).operator -)(*arg_this));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_pixel, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// pixel slot sq_ass_item -> operator []
//////////////////
static int Dtool_pixel_operator_3_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  pixel *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_pixel, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "pixel index out of range");
    return -1;
  }
  if (arg != nullptr) { // __setitem__
    if (!DtoolInstance_IS_CONST(self)) {
      // 1-gray &pixel::operator [](int i)
      if (PyLongOrInt_Check(arg)) {
        long param2 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
        if (param2 < 0 || param2 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param2);
          return -1;
        }
#endif
        ((*local_this).operator [])(index) = (gray)param2;
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return 0;
      }
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call pixel.__getitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__getitem__(const pixel self, index, int assign_val)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// pixel slot sq_item -> operator []
//////////////////
static PyObject *Dtool_pixel_operator_3_sq_item(PyObject *self, Py_ssize_t index) {
  pixel *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_pixel, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "pixel index out of range");
    return nullptr;
  }
  // 1-gray pixel::operator [](int i) const
  gray return_value = ((*(const pixel*)local_this).operator [])(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(pixel self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// pixel slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_pixel_size_13_sq_length(PyObject *self) {
  pixel *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_pixel, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

//////////////////
//  A __repr__ function
//     pixel
//////////////////
static PyObject *Dtool_Repr_pixel(PyObject *self) {
  pixel *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_pixel, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     pixel
//////////////////
static PyObject *Dtool_RichCompare_pixel(PyObject *self, PyObject *arg, int op) {
  pixel *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_pixel, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      if (!DtoolInstance_IS_CONST(self)) {
        // 1-bool pixel::operator ==(pixel const &other)
        pixel arg_local;
        pixel const *arg_this = Dtool_Coerce_pixel(arg, arg_local);
        if ((arg_this != nullptr)) {
          bool return_value = ((*local_this).operator ==)(*arg_this);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (UNLIKELY(notify->has_assert_failed())) {
            return Dtool_Raise_AssertionError();
          }
#endif
          return Dtool_WrapValue(return_value);
        }
      }
      break;
    }
  case Py_NE:
    {
      if (!DtoolInstance_IS_CONST(self)) {
        // 1-bool pixel::operator !=(pixel const &other)
        pixel arg_local;
        pixel const *arg_this = Dtool_Coerce_pixel(arg, arg_local);
        if ((arg_this != nullptr)) {
          bool return_value = ((*local_this).operator !=)(*arg_this);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (UNLIKELY(notify->has_assert_failed())) {
            return Dtool_Raise_AssertionError();
          }
#endif
          return Dtool_WrapValue(return_value);
        }
      }
      break;
    }
  case Py_LT:
    {
      // 1-bool pixel::operator <(pixel const &other) const
      pixel arg_local;
      pixel const *arg_this = Dtool_Coerce_pixel(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const pixel*)local_this).operator <)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_pixel[] = {
  {(char *)"b", &Dtool_pixel_b_Getter, &Dtool_pixel_b_Setter, nullptr, nullptr},
  {(char *)"g", &Dtool_pixel_g_Getter, &Dtool_pixel_g_Setter, nullptr, nullptr},
  {(char *)"r", &Dtool_pixel_r_Getter, &Dtool_pixel_r_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_pixel = {
  &Dtool_pixel_operator_4_nb_add,
  &Dtool_pixel_operator_5_nb_subtract,
  &Dtool_pixel_operator_6_nb_multiply,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  &Dtool_pixel_operator_7_nb_inplace_add,
  &Dtool_pixel_operator_8_nb_inplace_subtract,
  &Dtool_pixel_operator_9_nb_inplace_multiply,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_pixel = {
  &Dtool_pixel_size_13_sq_length,
  nullptr,
  nullptr,
  &Dtool_pixel_operator_3_sq_item,
  nullptr, // sq_slice
  &Dtool_pixel_operator_3_sq_ass_item,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

struct Dtool_PyTypedObject Dtool_pixel = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.pixel",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_pixel,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &DtoolInstance_ComparePointers,
#endif
    &Dtool_Repr_pixel,
    &Dtool_NumberMethods_pixel,
    &Dtool_SequenceMethods_pixel,
    nullptr, // tp_as_mapping
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Repr_pixel,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_pixel,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_pixel,
    nullptr, // tp_members
    Dtool_Properties_pixel,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_pixel,
    PyType_GenericAlloc,
    Dtool_new_pixel,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_pixel,
  Dtool_UpcastInterface_pixel,
  Dtool_DowncastInterface_pixel,
  nullptr,
  (CoerceFunction)Dtool_Coerce_pixel,
};

static void Dtool_PyModuleClassInit_pixel(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_pixel._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_pixel._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_pixel) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(pixel)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_pixel);
  }
}

/**
 * Python method tables for PNMFileType (PNMFileType)
 */
static PyMethodDef Dtool_Methods_PNMFileType[] = {
  {"get_name", &Dtool_PNMFileType_get_name_34, METH_NOARGS, (const char *)Dtool_PNMFileType_get_name_34_comment},
  {"getName", &Dtool_PNMFileType_get_name_34, METH_NOARGS, (const char *)Dtool_PNMFileType_get_name_34_comment},
  {"get_num_extensions", &Dtool_PNMFileType_get_num_extensions_35, METH_NOARGS, (const char *)Dtool_PNMFileType_get_num_extensions_35_comment},
  {"getNumExtensions", &Dtool_PNMFileType_get_num_extensions_35, METH_NOARGS, (const char *)Dtool_PNMFileType_get_num_extensions_35_comment},
  {"get_extension", &Dtool_PNMFileType_get_extension_36, METH_O, (const char *)Dtool_PNMFileType_get_extension_36_comment},
  {"getExtension", &Dtool_PNMFileType_get_extension_36, METH_O, (const char *)Dtool_PNMFileType_get_extension_36_comment},
  {"get_suggested_extension", &Dtool_PNMFileType_get_suggested_extension_38, METH_NOARGS, (const char *)Dtool_PNMFileType_get_suggested_extension_38_comment},
  {"getSuggestedExtension", &Dtool_PNMFileType_get_suggested_extension_38, METH_NOARGS, (const char *)Dtool_PNMFileType_get_suggested_extension_38_comment},
  {"get_class_type", &Dtool_PNMFileType_get_class_type_44, METH_NOARGS | METH_STATIC, (const char *)Dtool_PNMFileType_get_class_type_44_comment},
  {"getClassType", &Dtool_PNMFileType_get_class_type_44, METH_NOARGS | METH_STATIC, (const char *)Dtool_PNMFileType_get_class_type_44_comment},
  {"get_extensions", (PyCFunction) &MakeSeq_PNMFileType_get_extensions, METH_NOARGS, nullptr},
  { "getExtensions", (PyCFunction) &MakeSeq_PNMFileType_get_extensions, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_PNMFileType[] = {
  {(char *)"name", &Dtool_PNMFileType_name_Getter, nullptr, nullptr, nullptr},
  {(char *)"extensions", &Dtool_PNMFileType_extensions_Getter, nullptr, nullptr, nullptr},
  {(char *)"suggested_extension", &Dtool_PNMFileType_suggested_extension_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_PNMFileType = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PNMFileType = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PNMFileType = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PNMFileType = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PNMFileType = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PNMFileType = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PNMFileType",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PNMFileType,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PNMFileType,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PNMFileType,
    &Dtool_SequenceMethods_PNMFileType,
    &Dtool_MappingMethods_PNMFileType,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PNMFileType,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base class of a family of classes that represent particular\n"
    " * image file types that PNMImage supports.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PNMFileType,
    nullptr, // tp_members
    Dtool_Properties_PNMFileType,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PNMFileType,
    PyType_GenericAlloc,
    Dtool_new_PNMFileType,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PNMFileType,
  Dtool_UpcastInterface_PNMFileType,
  Dtool_DowncastInterface_PNMFileType,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PNMFileType(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritable != nullptr);
    assert(Dtool_Ptr_TypedWritable->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedWritable->_Dtool_ModuleClassInit(nullptr);
    Dtool_PNMFileType._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedWritable);
    Dtool_PNMFileType._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PNMFileType._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PNMFileType) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PNMFileType)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PNMFileType);
  }
}

/**
 * Python method tables for PNMFileTypeRegistry (PNMFileTypeRegistry)
 */
static PyMethodDef Dtool_Methods_PNMFileTypeRegistry[] = {
  {"get_num_types", &Dtool_PNMFileTypeRegistry_get_num_types_47, METH_NOARGS, (const char *)Dtool_PNMFileTypeRegistry_get_num_types_47_comment},
  {"getNumTypes", &Dtool_PNMFileTypeRegistry_get_num_types_47, METH_NOARGS, (const char *)Dtool_PNMFileTypeRegistry_get_num_types_47_comment},
  {"get_type", &Dtool_PNMFileTypeRegistry_get_type_48, METH_O, (const char *)Dtool_PNMFileTypeRegistry_get_type_48_comment},
  {"getType", &Dtool_PNMFileTypeRegistry_get_type_48, METH_O, (const char *)Dtool_PNMFileTypeRegistry_get_type_48_comment},
  {"get_type_from_extension", &Dtool_PNMFileTypeRegistry_get_type_from_extension_52, METH_O, (const char *)Dtool_PNMFileTypeRegistry_get_type_from_extension_52_comment},
  {"getTypeFromExtension", &Dtool_PNMFileTypeRegistry_get_type_from_extension_52, METH_O, (const char *)Dtool_PNMFileTypeRegistry_get_type_from_extension_52_comment},
  {"get_type_from_magic_number", &Dtool_PNMFileTypeRegistry_get_type_from_magic_number_53, METH_O, (const char *)Dtool_PNMFileTypeRegistry_get_type_from_magic_number_53_comment},
  {"getTypeFromMagicNumber", &Dtool_PNMFileTypeRegistry_get_type_from_magic_number_53, METH_O, (const char *)Dtool_PNMFileTypeRegistry_get_type_from_magic_number_53_comment},
  {"get_type_by_handle", &Dtool_PNMFileTypeRegistry_get_type_by_handle_54, METH_O, (const char *)Dtool_PNMFileTypeRegistry_get_type_by_handle_54_comment},
  {"getTypeByHandle", &Dtool_PNMFileTypeRegistry_get_type_by_handle_54, METH_O, (const char *)Dtool_PNMFileTypeRegistry_get_type_by_handle_54_comment},
  {"write", (PyCFunction) &Dtool_PNMFileTypeRegistry_write_55, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMFileTypeRegistry_write_55_comment},
  {"get_global_ptr", &Dtool_PNMFileTypeRegistry_get_global_ptr_56, METH_NOARGS | METH_STATIC, (const char *)Dtool_PNMFileTypeRegistry_get_global_ptr_56_comment},
  {"getGlobalPtr", &Dtool_PNMFileTypeRegistry_get_global_ptr_56, METH_NOARGS | METH_STATIC, (const char *)Dtool_PNMFileTypeRegistry_get_global_ptr_56_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_types", (PyCFunction) &MakeSeq_PNMFileTypeRegistry_get_types, METH_NOARGS, nullptr},
  { "getTypes", (PyCFunction) &MakeSeq_PNMFileTypeRegistry_get_types, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     PNMFileTypeRegistry
//////////////////
static PyObject *Dtool_Str_PNMFileTypeRegistry(PyObject *self) {
  PNMFileTypeRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMFileTypeRegistry, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_PNMFileTypeRegistry[] = {
  {(char *)"types", &Dtool_PNMFileTypeRegistry_types_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_PNMFileTypeRegistry = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_PNMFileTypeRegistry = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PNMFileTypeRegistry",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PNMFileTypeRegistry,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PNMFileTypeRegistry,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_PNMFileTypeRegistry,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class maintains the set of all known PNMFileTypes in the universe.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PNMFileTypeRegistry,
    nullptr, // tp_members
    Dtool_Properties_PNMFileTypeRegistry,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PNMFileTypeRegistry,
    PyType_GenericAlloc,
    Dtool_new_PNMFileTypeRegistry,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PNMFileTypeRegistry,
  Dtool_UpcastInterface_PNMFileTypeRegistry,
  Dtool_DowncastInterface_PNMFileTypeRegistry,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PNMFileTypeRegistry(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PNMFileTypeRegistry._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PNMFileTypeRegistry._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PNMFileTypeRegistry) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PNMFileTypeRegistry)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PNMFileTypeRegistry);
  }
}

/**
 * Python method tables for PNMImageHeader_PixelSpec (PixelSpec)
 */
static PyMethodDef Dtool_Methods_PNMImageHeader_PixelSpec[] = {
  {"compare_to", &Dtool_PNMImageHeader_PixelSpec_compare_to_97, METH_O, (const char *)Dtool_PNMImageHeader_PixelSpec_compare_to_97_comment},
  {"compareTo", &Dtool_PNMImageHeader_PixelSpec_compare_to_97, METH_O, (const char *)Dtool_PNMImageHeader_PixelSpec_compare_to_97_comment},
  {"get_red", &Dtool_PNMImageHeader_PixelSpec_get_red_98, METH_NOARGS, (const char *)Dtool_PNMImageHeader_PixelSpec_get_red_98_comment},
  {"getRed", &Dtool_PNMImageHeader_PixelSpec_get_red_98, METH_NOARGS, (const char *)Dtool_PNMImageHeader_PixelSpec_get_red_98_comment},
  {"get_green", &Dtool_PNMImageHeader_PixelSpec_get_green_99, METH_NOARGS, (const char *)Dtool_PNMImageHeader_PixelSpec_get_green_99_comment},
  {"getGreen", &Dtool_PNMImageHeader_PixelSpec_get_green_99, METH_NOARGS, (const char *)Dtool_PNMImageHeader_PixelSpec_get_green_99_comment},
  {"get_blue", &Dtool_PNMImageHeader_PixelSpec_get_blue_100, METH_NOARGS, (const char *)Dtool_PNMImageHeader_PixelSpec_get_blue_100_comment},
  {"getBlue", &Dtool_PNMImageHeader_PixelSpec_get_blue_100, METH_NOARGS, (const char *)Dtool_PNMImageHeader_PixelSpec_get_blue_100_comment},
  {"get_alpha", &Dtool_PNMImageHeader_PixelSpec_get_alpha_101, METH_NOARGS, (const char *)Dtool_PNMImageHeader_PixelSpec_get_alpha_101_comment},
  {"getAlpha", &Dtool_PNMImageHeader_PixelSpec_get_alpha_101, METH_NOARGS, (const char *)Dtool_PNMImageHeader_PixelSpec_get_alpha_101_comment},
  {"set_red", &Dtool_PNMImageHeader_PixelSpec_set_red_102, METH_O, (const char *)Dtool_PNMImageHeader_PixelSpec_set_red_102_comment},
  {"setRed", &Dtool_PNMImageHeader_PixelSpec_set_red_102, METH_O, (const char *)Dtool_PNMImageHeader_PixelSpec_set_red_102_comment},
  {"set_green", &Dtool_PNMImageHeader_PixelSpec_set_green_103, METH_O, (const char *)Dtool_PNMImageHeader_PixelSpec_set_green_103_comment},
  {"setGreen", &Dtool_PNMImageHeader_PixelSpec_set_green_103, METH_O, (const char *)Dtool_PNMImageHeader_PixelSpec_set_green_103_comment},
  {"set_blue", &Dtool_PNMImageHeader_PixelSpec_set_blue_104, METH_O, (const char *)Dtool_PNMImageHeader_PixelSpec_set_blue_104_comment},
  {"setBlue", &Dtool_PNMImageHeader_PixelSpec_set_blue_104, METH_O, (const char *)Dtool_PNMImageHeader_PixelSpec_set_blue_104_comment},
  {"set_alpha", &Dtool_PNMImageHeader_PixelSpec_set_alpha_105, METH_O, (const char *)Dtool_PNMImageHeader_PixelSpec_set_alpha_105_comment},
  {"setAlpha", &Dtool_PNMImageHeader_PixelSpec_set_alpha_105, METH_O, (const char *)Dtool_PNMImageHeader_PixelSpec_set_alpha_105_comment},
  {"output", &Dtool_PNMImageHeader_PixelSpec_output_108, METH_O, (const char *)Dtool_PNMImageHeader_PixelSpec_output_108_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImageHeader_PixelSpec slot sq_item -> operator []
//////////////////
static PyObject *Dtool_PNMImageHeader_PixelSpec_operator_106_sq_item(PyObject *self, Py_ssize_t index) {
  PNMImageHeader::PixelSpec *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader_PixelSpec, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PNMImageHeader_PixelSpec index out of range");
    return nullptr;
  }
  // 1-inline xelval PNMImageHeader::PixelSpec::operator [](int n) const
  xelval return_value = ((*(const PNMImageHeader::PixelSpec*)local_this).operator [])(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PixelSpec self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImageHeader_PixelSpec slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PNMImageHeader_PixelSpec_size_107_sq_length(PyObject *self) {
  PNMImageHeader::PixelSpec *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader_PixelSpec, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImageHeader_PixelSpec slot tp_compare -> compare_to
//////////////////
static int Dtool_PNMImageHeader_PixelSpec_compare_to_97_tp_compare(PyObject *self, PyObject *arg) {
  PNMImageHeader::PixelSpec *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader_PixelSpec, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int PNMImageHeader::PixelSpec::compare_to(PNMImageHeader::PixelSpec const &other) const
  PNMImageHeader::PixelSpec arg_local;
  PNMImageHeader::PixelSpec const *arg_this = Dtool_Coerce_PNMImageHeader_PixelSpec(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "PixelSpec.compare_to", "PixelSpec");
    return -1;
  }
  int return_value = ((*(const PNMImageHeader::PixelSpec*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(PixelSpec self, const PixelSpec other)\n");
  }
  return -1;
}

//////////////////
//  A __repr__ function
//     PNMImageHeader_PixelSpec
//////////////////
static PyObject *Dtool_Repr_PNMImageHeader_PixelSpec(PyObject *self) {
  PNMImageHeader::PixelSpec *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader_PixelSpec, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     PNMImageHeader_PixelSpec
//////////////////
static PyObject *Dtool_RichCompare_PNMImageHeader_PixelSpec(PyObject *self, PyObject *arg, int op) {
  PNMImageHeader::PixelSpec *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader_PixelSpec, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_LT:
    {
      // 1-inline bool PNMImageHeader::PixelSpec::operator <(PNMImageHeader::PixelSpec const &other) const
      PNMImageHeader::PixelSpec arg_local;
      PNMImageHeader::PixelSpec const *arg_this = Dtool_Coerce_PNMImageHeader_PixelSpec(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const PNMImageHeader::PixelSpec*)local_this).operator <)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_EQ:
    {
      // 1-inline bool PNMImageHeader::PixelSpec::operator ==(PNMImageHeader::PixelSpec const &other) const
      PNMImageHeader::PixelSpec arg_local;
      PNMImageHeader::PixelSpec const *arg_this = Dtool_Coerce_PNMImageHeader_PixelSpec(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const PNMImageHeader::PixelSpec*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool PNMImageHeader::PixelSpec::operator !=(PNMImageHeader::PixelSpec const &other) const
      PNMImageHeader::PixelSpec arg_local;
      PNMImageHeader::PixelSpec const *arg_this = Dtool_Coerce_PNMImageHeader_PixelSpec(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const PNMImageHeader::PixelSpec*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_PNMImageHeader_PixelSpec_compare_to_97_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_PNMImageHeader_PixelSpec = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PNMImageHeader_PixelSpec = {
  &Dtool_PNMImageHeader_PixelSpec_size_107_sq_length,
  nullptr,
  nullptr,
  &Dtool_PNMImageHeader_PixelSpec_operator_106_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

struct Dtool_PyTypedObject Dtool_PNMImageHeader_PixelSpec = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PixelSpec",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PNMImageHeader_PixelSpec,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_PNMImageHeader_PixelSpec_compare_to_97_tp_compare,
#endif
    &Dtool_Repr_PNMImageHeader_PixelSpec,
    &Dtool_NumberMethods_PNMImageHeader_PixelSpec,
    &Dtool_SequenceMethods_PNMImageHeader_PixelSpec,
    nullptr, // tp_as_mapping
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Repr_PNMImageHeader_PixelSpec,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "// Contains a single pixel specification used in compute_histogram() and\n"
    "// make_histogram().  Note that pixels are stored by integer value, not by\n"
    "// floating-point scaled value.",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_PNMImageHeader_PixelSpec,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PNMImageHeader_PixelSpec,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PNMImageHeader_PixelSpec,
    PyType_GenericAlloc,
    Dtool_new_PNMImageHeader_PixelSpec,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PNMImageHeader_PixelSpec,
  Dtool_UpcastInterface_PNMImageHeader_PixelSpec,
  Dtool_DowncastInterface_PNMImageHeader_PixelSpec,
  nullptr,
  (CoerceFunction)Dtool_Coerce_PNMImageHeader_PixelSpec,
};

static void Dtool_PyModuleClassInit_PNMImageHeader_PixelSpec(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PNMImageHeader_PixelSpec._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PNMImageHeader_PixelSpec._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PNMImageHeader_PixelSpec) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PNMImageHeader_PixelSpec)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PNMImageHeader_PixelSpec);
  }
}

/**
 * Python method tables for PNMImageHeader_PixelSpecCount (PixelSpecCount)
 */
static PyMethodDef Dtool_Methods_PNMImageHeader_PixelSpecCount[] = {
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PNMImageHeader_PixelSpecCount = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_PNMImageHeader_PixelSpecCount = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PixelSpecCount",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PNMImageHeader_PixelSpecCount,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PNMImageHeader_PixelSpecCount,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "// Associates a pixel specification with an appearance count, for use in\n"
    "// Histogram, below.",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PNMImageHeader_PixelSpecCount,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PNMImageHeader_PixelSpecCount,
    PyType_GenericAlloc,
    Dtool_new_PNMImageHeader_PixelSpecCount,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PNMImageHeader_PixelSpecCount,
  Dtool_UpcastInterface_PNMImageHeader_PixelSpecCount,
  Dtool_DowncastInterface_PNMImageHeader_PixelSpecCount,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PNMImageHeader_PixelSpecCount(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PNMImageHeader_PixelSpecCount._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PNMImageHeader_PixelSpecCount._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PNMImageHeader_PixelSpecCount) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PNMImageHeader_PixelSpecCount)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PNMImageHeader_PixelSpecCount);
  }
}

/**
 * Python method tables for PNMImageHeader_Histogram (Histogram)
 */
static PyMethodDef Dtool_Methods_PNMImageHeader_Histogram[] = {
  {"get_num_pixels", &Dtool_PNMImageHeader_Histogram_get_num_pixels_121, METH_NOARGS, (const char *)Dtool_PNMImageHeader_Histogram_get_num_pixels_121_comment},
  {"getNumPixels", &Dtool_PNMImageHeader_Histogram_get_num_pixels_121, METH_NOARGS, (const char *)Dtool_PNMImageHeader_Histogram_get_num_pixels_121_comment},
  {"get_pixel", &Dtool_PNMImageHeader_Histogram_get_pixel_122, METH_O, (const char *)Dtool_PNMImageHeader_Histogram_get_pixel_122_comment},
  {"getPixel", &Dtool_PNMImageHeader_Histogram_get_pixel_122, METH_O, (const char *)Dtool_PNMImageHeader_Histogram_get_pixel_122_comment},
  {"get_count", &Dtool_PNMImageHeader_Histogram_get_count_123, METH_O, (const char *)Dtool_PNMImageHeader_Histogram_get_count_123_comment},
  {"getCount", &Dtool_PNMImageHeader_Histogram_get_count_123, METH_O, (const char *)Dtool_PNMImageHeader_Histogram_get_count_123_comment},
  {"write", &Dtool_PNMImageHeader_Histogram_write_125, METH_O, (const char *)Dtool_PNMImageHeader_Histogram_write_125_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_pixels", (PyCFunction) &MakeSeq_PNMImageHeader_Histogram_get_pixels, METH_NOARGS, nullptr},
  { "getPixels", (PyCFunction) &MakeSeq_PNMImageHeader_Histogram_get_pixels, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     PNMImageHeader_Histogram
//////////////////
static PyObject *Dtool_Str_PNMImageHeader_Histogram(PyObject *self) {
  PNMImageHeader::Histogram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader_Histogram, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PNMImageHeader_Histogram = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_PNMImageHeader_Histogram = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Histogram",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PNMImageHeader_Histogram,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PNMImageHeader_Histogram,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_PNMImageHeader_Histogram,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "// Used to return a pixel histogram in PNMImage::get_histogram().",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PNMImageHeader_Histogram,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PNMImageHeader_Histogram,
    PyType_GenericAlloc,
    Dtool_new_PNMImageHeader_Histogram,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PNMImageHeader_Histogram,
  Dtool_UpcastInterface_PNMImageHeader_Histogram,
  Dtool_DowncastInterface_PNMImageHeader_Histogram,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PNMImageHeader_Histogram(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PNMImageHeader_Histogram._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PNMImageHeader_Histogram._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PNMImageHeader_Histogram) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PNMImageHeader_Histogram)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PNMImageHeader_Histogram);
  }
}

/**
 * Python method tables for PNMImageHeader (PNMImageHeader)
 */
static PyMethodDef Dtool_Methods_PNMImageHeader[] = {
  {"assign", &Dtool_PNMImageHeader_operator_60, METH_O, (const char *)Dtool_PNMImageHeader_operator_60_comment},
  {"get_color_type", &Dtool_PNMImageHeader_get_color_type_63, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_color_type_63_comment},
  {"getColorType", &Dtool_PNMImageHeader_get_color_type_63, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_color_type_63_comment},
  {"get_num_channels", &Dtool_PNMImageHeader_get_num_channels_64, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_num_channels_64_comment},
  {"getNumChannels", &Dtool_PNMImageHeader_get_num_channels_64, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_num_channels_64_comment},
  {"is_grayscale", &Dtool_PNMImageHeader_is_grayscale_67, METH_VARARGS, (const char *)Dtool_PNMImageHeader_is_grayscale_67_comment},
  {"isGrayscale", &Dtool_PNMImageHeader_is_grayscale_67, METH_VARARGS, (const char *)Dtool_PNMImageHeader_is_grayscale_67_comment},
  {"has_alpha", &Dtool_PNMImageHeader_has_alpha_68, METH_VARARGS, (const char *)Dtool_PNMImageHeader_has_alpha_68_comment},
  {"hasAlpha", &Dtool_PNMImageHeader_has_alpha_68, METH_VARARGS, (const char *)Dtool_PNMImageHeader_has_alpha_68_comment},
  {"get_maxval", &Dtool_PNMImageHeader_get_maxval_69, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_maxval_69_comment},
  {"getMaxval", &Dtool_PNMImageHeader_get_maxval_69, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_maxval_69_comment},
  {"get_color_space", &Dtool_PNMImageHeader_get_color_space_70, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_color_space_70_comment},
  {"getColorSpace", &Dtool_PNMImageHeader_get_color_space_70, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_color_space_70_comment},
  {"get_x_size", &Dtool_PNMImageHeader_get_x_size_75, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_x_size_75_comment},
  {"getXSize", &Dtool_PNMImageHeader_get_x_size_75, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_x_size_75_comment},
  {"get_y_size", &Dtool_PNMImageHeader_get_y_size_76, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_y_size_76_comment},
  {"getYSize", &Dtool_PNMImageHeader_get_y_size_76, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_y_size_76_comment},
  {"get_size", &Dtool_PNMImageHeader_get_size_77, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_size_77_comment},
  {"getSize", &Dtool_PNMImageHeader_get_size_77, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_size_77_comment},
  {"get_comment", &Dtool_PNMImageHeader_get_comment_80, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_comment_80_comment},
  {"getComment", &Dtool_PNMImageHeader_get_comment_80, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_comment_80_comment},
  {"set_comment", &Dtool_PNMImageHeader_set_comment_81, METH_O, (const char *)Dtool_PNMImageHeader_set_comment_81_comment},
  {"setComment", &Dtool_PNMImageHeader_set_comment_81, METH_O, (const char *)Dtool_PNMImageHeader_set_comment_81_comment},
  {"has_type", &Dtool_PNMImageHeader_has_type_83, METH_NOARGS, (const char *)Dtool_PNMImageHeader_has_type_83_comment},
  {"hasType", &Dtool_PNMImageHeader_has_type_83, METH_NOARGS, (const char *)Dtool_PNMImageHeader_has_type_83_comment},
  {"get_type", &Dtool_PNMImageHeader_get_type_84, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_type_84_comment},
  {"getType", &Dtool_PNMImageHeader_get_type_84, METH_NOARGS, (const char *)Dtool_PNMImageHeader_get_type_84_comment},
  {"set_type", &Dtool_PNMImageHeader_set_type_85, METH_O, (const char *)Dtool_PNMImageHeader_set_type_85_comment},
  {"setType", &Dtool_PNMImageHeader_set_type_85, METH_O, (const char *)Dtool_PNMImageHeader_set_type_85_comment},
  {"read_header", (PyCFunction) &Dtool_PNMImageHeader_read_header_87, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImageHeader_read_header_87_comment},
  {"readHeader", (PyCFunction) &Dtool_PNMImageHeader_read_header_87, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImageHeader_read_header_87_comment},
  {"output", &Dtool_PNMImageHeader_output_91, METH_O, (const char *)Dtool_PNMImageHeader_output_91_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     PNMImageHeader
//////////////////
static PyObject *Dtool_Repr_PNMImageHeader(PyObject *self) {
  PNMImageHeader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImageHeader, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_PNMImageHeader[] = {
  {(char *)"num_channels", &Dtool_PNMImageHeader_num_channels_Getter, nullptr, nullptr, nullptr},
  {(char *)"maxval", &Dtool_PNMImageHeader_maxval_Getter, nullptr, nullptr, nullptr},
  {(char *)"color_space", &Dtool_PNMImageHeader_color_space_Getter, nullptr, nullptr, nullptr},
  {(char *)"size", &Dtool_PNMImageHeader_size_Getter, nullptr, nullptr, nullptr},
  {(char *)"comment", &Dtool_PNMImageHeader_comment_Getter, &Dtool_PNMImageHeader_comment_Setter, nullptr, nullptr},
  {(char *)"type", &Dtool_PNMImageHeader_type_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_PNMImageHeader = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_PNMImageHeader = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PNMImageHeader",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PNMImageHeader,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_PNMImageHeader,
    &Dtool_NumberMethods_PNMImageHeader,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_PNMImageHeader,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base class of PNMImage, PNMReader, and PNMWriter.  It\n"
    " * encapsulates all the information associated with an image that describes\n"
    " * its size, number of channels, etc; that is, all the information about the\n"
    " * image except the image data itself.  It's the sort of information you\n"
    " * typically read from the image file's header.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PNMImageHeader,
    nullptr, // tp_members
    Dtool_Properties_PNMImageHeader,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PNMImageHeader,
    PyType_GenericAlloc,
    Dtool_new_PNMImageHeader,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PNMImageHeader,
  Dtool_UpcastInterface_PNMImageHeader,
  Dtool_DowncastInterface_PNMImageHeader,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PNMImageHeader(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PNMImageHeader._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(18);
    Dtool_PNMImageHeader._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum PNMImageHeader::ColorType;
    PyDict_SetItemString(dict, "CT_invalid", Dtool_WrapValue(PNMImageHeader::CT_invalid));
    PyDict_SetItemString(dict, "CTInvalid", Dtool_WrapValue(PNMImageHeader::CT_invalid));
    PyDict_SetItemString(dict, "CT_grayscale", Dtool_WrapValue(PNMImageHeader::CT_grayscale));
    PyDict_SetItemString(dict, "CTGrayscale", Dtool_WrapValue(PNMImageHeader::CT_grayscale));
    PyDict_SetItemString(dict, "CT_two_channel", Dtool_WrapValue(PNMImageHeader::CT_two_channel));
    PyDict_SetItemString(dict, "CTTwoChannel", Dtool_WrapValue(PNMImageHeader::CT_two_channel));
    PyDict_SetItemString(dict, "CT_color", Dtool_WrapValue(PNMImageHeader::CT_color));
    PyDict_SetItemString(dict, "CTColor", Dtool_WrapValue(PNMImageHeader::CT_color));
    PyDict_SetItemString(dict, "CT_four_channel", Dtool_WrapValue(PNMImageHeader::CT_four_channel));
    PyDict_SetItemString(dict, "CTFourChannel", Dtool_WrapValue(PNMImageHeader::CT_four_channel));
    // Nested Object   PNMImageHeader_PixelSpec;
    Dtool_PyModuleClassInit_PNMImageHeader_PixelSpec(nullptr);
    PyDict_SetItemString(dict, "PixelSpec", (PyObject *)&Dtool_PNMImageHeader_PixelSpec);
    // Nested Object   PNMImageHeader_PixelSpecCount;
    Dtool_PyModuleClassInit_PNMImageHeader_PixelSpecCount(nullptr);
    PyDict_SetItemString(dict, "PixelSpecCount", (PyObject *)&Dtool_PNMImageHeader_PixelSpecCount);
    // Nested Object   PNMImageHeader_Histogram;
    Dtool_PyModuleClassInit_PNMImageHeader_Histogram(nullptr);
    PyDict_SetItemString(dict, "Histogram", (PyObject *)&Dtool_PNMImageHeader_Histogram);
    if (PyType_Ready((PyTypeObject *)&Dtool_PNMImageHeader) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PNMImageHeader)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PNMImageHeader);
  }
}

/**
 * Python method tables for PfmFile (PfmFile)
 */
static PyMethodDef Dtool_Methods_PfmFile[] = {
  {"assign", &Dtool_PfmFile_operator_129, METH_O, (const char *)Dtool_PfmFile_operator_129_comment},
  {"clear", (PyCFunction) &Dtool_PfmFile_clear_130, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_clear_130_comment},
  {"read", (PyCFunction) &Dtool_PfmFile_read_131, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_read_131_comment},
  {"write", (PyCFunction) &Dtool_PfmFile_write_132, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_write_132_comment},
  {"load", &Dtool_PfmFile_load_133, METH_O, (const char *)Dtool_PfmFile_load_133_comment},
  {"store", &Dtool_PfmFile_store_134, METH_O, (const char *)Dtool_PfmFile_store_134_comment},
  {"store_mask", (PyCFunction) &Dtool_PfmFile_store_mask_135, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_store_mask_135_comment},
  {"storeMask", (PyCFunction) &Dtool_PfmFile_store_mask_135, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_store_mask_135_comment},
  {"is_valid", &Dtool_PfmFile_is_valid_136, METH_NOARGS, (const char *)Dtool_PfmFile_is_valid_136_comment},
  {"isValid", &Dtool_PfmFile_is_valid_136, METH_NOARGS, (const char *)Dtool_PfmFile_is_valid_136_comment},
  {"get_scale", &Dtool_PfmFile_get_scale_139, METH_NOARGS, (const char *)Dtool_PfmFile_get_scale_139_comment},
  {"getScale", &Dtool_PfmFile_get_scale_139, METH_NOARGS, (const char *)Dtool_PfmFile_get_scale_139_comment},
  {"set_scale", &Dtool_PfmFile_set_scale_140, METH_O, (const char *)Dtool_PfmFile_set_scale_140_comment},
  {"setScale", &Dtool_PfmFile_set_scale_140, METH_O, (const char *)Dtool_PfmFile_set_scale_140_comment},
  {"has_point", (PyCFunction) &Dtool_PfmFile_has_point_144, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_has_point_144_comment},
  {"hasPoint", (PyCFunction) &Dtool_PfmFile_has_point_144, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_has_point_144_comment},
  {"get_channel", (PyCFunction) &Dtool_PfmFile_get_channel_145, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_get_channel_145_comment},
  {"getChannel", (PyCFunction) &Dtool_PfmFile_get_channel_145, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_get_channel_145_comment},
  {"set_channel", (PyCFunction) &Dtool_PfmFile_set_channel_146, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_set_channel_146_comment},
  {"setChannel", (PyCFunction) &Dtool_PfmFile_set_channel_146, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_set_channel_146_comment},
  {"get_point1", (PyCFunction) &Dtool_PfmFile_get_point1_147, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_get_point1_147_comment},
  {"getPoint1", (PyCFunction) &Dtool_PfmFile_get_point1_147, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_get_point1_147_comment},
  {"set_point1", (PyCFunction) &Dtool_PfmFile_set_point1_148, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_set_point1_148_comment},
  {"setPoint1", (PyCFunction) &Dtool_PfmFile_set_point1_148, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_set_point1_148_comment},
  {"get_point2", (PyCFunction) &Dtool_PfmFile_get_point2_149, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_get_point2_149_comment},
  {"getPoint2", (PyCFunction) &Dtool_PfmFile_get_point2_149, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_get_point2_149_comment},
  {"set_point2", (PyCFunction) &Dtool_PfmFile_set_point2_150, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_set_point2_150_comment},
  {"setPoint2", (PyCFunction) &Dtool_PfmFile_set_point2_150, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_set_point2_150_comment},
  {"modify_point2", (PyCFunction) &Dtool_PfmFile_modify_point2_151, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_modify_point2_151_comment},
  {"modifyPoint2", (PyCFunction) &Dtool_PfmFile_modify_point2_151, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_modify_point2_151_comment},
  {"get_point", (PyCFunction) &Dtool_PfmFile_get_point_152, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_get_point_152_comment},
  {"getPoint", (PyCFunction) &Dtool_PfmFile_get_point_152, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_get_point_152_comment},
  {"set_point", (PyCFunction) &Dtool_PfmFile_set_point_153, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_set_point_153_comment},
  {"setPoint", (PyCFunction) &Dtool_PfmFile_set_point_153, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_set_point_153_comment},
  {"modify_point", (PyCFunction) &Dtool_PfmFile_modify_point_154, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_modify_point_154_comment},
  {"modifyPoint", (PyCFunction) &Dtool_PfmFile_modify_point_154, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_modify_point_154_comment},
  {"get_point3", (PyCFunction) &Dtool_PfmFile_get_point3_155, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_get_point3_155_comment},
  {"getPoint3", (PyCFunction) &Dtool_PfmFile_get_point3_155, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_get_point3_155_comment},
  {"set_point3", (PyCFunction) &Dtool_PfmFile_set_point3_156, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_set_point3_156_comment},
  {"setPoint3", (PyCFunction) &Dtool_PfmFile_set_point3_156, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_set_point3_156_comment},
  {"modify_point3", (PyCFunction) &Dtool_PfmFile_modify_point3_157, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_modify_point3_157_comment},
  {"modifyPoint3", (PyCFunction) &Dtool_PfmFile_modify_point3_157, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_modify_point3_157_comment},
  {"get_point4", (PyCFunction) &Dtool_PfmFile_get_point4_158, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_get_point4_158_comment},
  {"getPoint4", (PyCFunction) &Dtool_PfmFile_get_point4_158, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_get_point4_158_comment},
  {"set_point4", (PyCFunction) &Dtool_PfmFile_set_point4_159, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_set_point4_159_comment},
  {"setPoint4", (PyCFunction) &Dtool_PfmFile_set_point4_159, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_set_point4_159_comment},
  {"modify_point4", (PyCFunction) &Dtool_PfmFile_modify_point4_160, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_modify_point4_160_comment},
  {"modifyPoint4", (PyCFunction) &Dtool_PfmFile_modify_point4_160, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_modify_point4_160_comment},
  {"fill", &Dtool_PfmFile_fill_161, METH_O, (const char *)Dtool_PfmFile_fill_161_comment},
  {"fill_nan", &Dtool_PfmFile_fill_nan_162, METH_NOARGS, (const char *)Dtool_PfmFile_fill_nan_162_comment},
  {"fillNan", &Dtool_PfmFile_fill_nan_162, METH_NOARGS, (const char *)Dtool_PfmFile_fill_nan_162_comment},
  {"fill_no_data_value", &Dtool_PfmFile_fill_no_data_value_163, METH_NOARGS, (const char *)Dtool_PfmFile_fill_no_data_value_163_comment},
  {"fillNoDataValue", &Dtool_PfmFile_fill_no_data_value_163, METH_NOARGS, (const char *)Dtool_PfmFile_fill_no_data_value_163_comment},
  {"fill_channel", (PyCFunction) &Dtool_PfmFile_fill_channel_164, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_fill_channel_164_comment},
  {"fillChannel", (PyCFunction) &Dtool_PfmFile_fill_channel_164, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_fill_channel_164_comment},
  {"fill_channel_nan", &Dtool_PfmFile_fill_channel_nan_165, METH_O, (const char *)Dtool_PfmFile_fill_channel_nan_165_comment},
  {"fillChannelNan", &Dtool_PfmFile_fill_channel_nan_165, METH_O, (const char *)Dtool_PfmFile_fill_channel_nan_165_comment},
  {"fill_channel_masked", (PyCFunction) &Dtool_PfmFile_fill_channel_masked_166, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_fill_channel_masked_166_comment},
  {"fillChannelMasked", (PyCFunction) &Dtool_PfmFile_fill_channel_masked_166, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_fill_channel_masked_166_comment},
  {"fill_channel_masked_nan", &Dtool_PfmFile_fill_channel_masked_nan_167, METH_O, (const char *)Dtool_PfmFile_fill_channel_masked_nan_167_comment},
  {"fillChannelMaskedNan", &Dtool_PfmFile_fill_channel_masked_nan_167, METH_O, (const char *)Dtool_PfmFile_fill_channel_masked_nan_167_comment},
  {"calc_average_point", (PyCFunction) &Dtool_PfmFile_calc_average_point_168, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_calc_average_point_168_comment},
  {"calcAveragePoint", (PyCFunction) &Dtool_PfmFile_calc_average_point_168, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_calc_average_point_168_comment},
  {"calc_bilinear_point", (PyCFunction) &Dtool_PfmFile_calc_bilinear_point_169, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_calc_bilinear_point_169_comment},
  {"calcBilinearPoint", (PyCFunction) &Dtool_PfmFile_calc_bilinear_point_169, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_calc_bilinear_point_169_comment},
  {"calc_min_max", (PyCFunction) &Dtool_PfmFile_calc_min_max_170, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_calc_min_max_170_comment},
  {"calcMinMax", (PyCFunction) &Dtool_PfmFile_calc_min_max_170, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_calc_min_max_170_comment},
  {"calc_autocrop", &Dtool_PfmFile_calc_autocrop_171, METH_O, (const char *)Dtool_PfmFile_calc_autocrop_171_comment},
  {"calcAutocrop", &Dtool_PfmFile_calc_autocrop_171, METH_O, (const char *)Dtool_PfmFile_calc_autocrop_171_comment},
  {"is_row_empty", (PyCFunction) &Dtool_PfmFile_is_row_empty_172, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_is_row_empty_172_comment},
  {"isRowEmpty", (PyCFunction) &Dtool_PfmFile_is_row_empty_172, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_is_row_empty_172_comment},
  {"is_column_empty", (PyCFunction) &Dtool_PfmFile_is_column_empty_173, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_is_column_empty_173_comment},
  {"isColumnEmpty", (PyCFunction) &Dtool_PfmFile_is_column_empty_173, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_is_column_empty_173_comment},
  {"set_zero_special", &Dtool_PfmFile_set_zero_special_174, METH_O, (const char *)Dtool_PfmFile_set_zero_special_174_comment},
  {"setZeroSpecial", &Dtool_PfmFile_set_zero_special_174, METH_O, (const char *)Dtool_PfmFile_set_zero_special_174_comment},
  {"set_no_data_chan4", &Dtool_PfmFile_set_no_data_chan4_175, METH_O, (const char *)Dtool_PfmFile_set_no_data_chan4_175_comment},
  {"setNoDataChan4", &Dtool_PfmFile_set_no_data_chan4_175, METH_O, (const char *)Dtool_PfmFile_set_no_data_chan4_175_comment},
  {"set_no_data_nan", &Dtool_PfmFile_set_no_data_nan_176, METH_O, (const char *)Dtool_PfmFile_set_no_data_nan_176_comment},
  {"setNoDataNan", &Dtool_PfmFile_set_no_data_nan_176, METH_O, (const char *)Dtool_PfmFile_set_no_data_nan_176_comment},
  {"set_no_data_value", &Dtool_PfmFile_set_no_data_value_177, METH_O, (const char *)Dtool_PfmFile_set_no_data_value_177_comment},
  {"setNoDataValue", &Dtool_PfmFile_set_no_data_value_177, METH_O, (const char *)Dtool_PfmFile_set_no_data_value_177_comment},
  {"set_no_data_threshold", &Dtool_PfmFile_set_no_data_threshold_178, METH_O, (const char *)Dtool_PfmFile_set_no_data_threshold_178_comment},
  {"setNoDataThreshold", &Dtool_PfmFile_set_no_data_threshold_178, METH_O, (const char *)Dtool_PfmFile_set_no_data_threshold_178_comment},
  {"clear_no_data_value", &Dtool_PfmFile_clear_no_data_value_179, METH_NOARGS, (const char *)Dtool_PfmFile_clear_no_data_value_179_comment},
  {"clearNoDataValue", &Dtool_PfmFile_clear_no_data_value_179, METH_NOARGS, (const char *)Dtool_PfmFile_clear_no_data_value_179_comment},
  {"has_no_data_value", &Dtool_PfmFile_has_no_data_value_180, METH_NOARGS, (const char *)Dtool_PfmFile_has_no_data_value_180_comment},
  {"hasNoDataValue", &Dtool_PfmFile_has_no_data_value_180, METH_NOARGS, (const char *)Dtool_PfmFile_has_no_data_value_180_comment},
  {"has_no_data_threshold", &Dtool_PfmFile_has_no_data_threshold_181, METH_NOARGS, (const char *)Dtool_PfmFile_has_no_data_threshold_181_comment},
  {"hasNoDataThreshold", &Dtool_PfmFile_has_no_data_threshold_181, METH_NOARGS, (const char *)Dtool_PfmFile_has_no_data_threshold_181_comment},
  {"get_no_data_value", &Dtool_PfmFile_get_no_data_value_182, METH_NOARGS, (const char *)Dtool_PfmFile_get_no_data_value_182_comment},
  {"getNoDataValue", &Dtool_PfmFile_get_no_data_value_182, METH_NOARGS, (const char *)Dtool_PfmFile_get_no_data_value_182_comment},
  {"resize", (PyCFunction) &Dtool_PfmFile_resize_183, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_resize_183_comment},
  {"box_filter_from", (PyCFunction) &Dtool_PfmFile_box_filter_from_184, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_box_filter_from_184_comment},
  {"boxFilterFrom", (PyCFunction) &Dtool_PfmFile_box_filter_from_184, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_box_filter_from_184_comment},
  {"gaussian_filter_from", (PyCFunction) &Dtool_PfmFile_gaussian_filter_from_185, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_gaussian_filter_from_185_comment},
  {"gaussianFilterFrom", (PyCFunction) &Dtool_PfmFile_gaussian_filter_from_185, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_gaussian_filter_from_185_comment},
  {"quick_filter_from", &Dtool_PfmFile_quick_filter_from_186, METH_O, (const char *)Dtool_PfmFile_quick_filter_from_186_comment},
  {"quickFilterFrom", &Dtool_PfmFile_quick_filter_from_186, METH_O, (const char *)Dtool_PfmFile_quick_filter_from_186_comment},
  {"reverse_rows", &Dtool_PfmFile_reverse_rows_187, METH_NOARGS, (const char *)Dtool_PfmFile_reverse_rows_187_comment},
  {"reverseRows", &Dtool_PfmFile_reverse_rows_187, METH_NOARGS, (const char *)Dtool_PfmFile_reverse_rows_187_comment},
  {"flip", (PyCFunction) &Dtool_PfmFile_flip_188, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_flip_188_comment},
  {"xform", &Dtool_PfmFile_xform_189, METH_O, (const char *)Dtool_PfmFile_xform_189_comment},
  {"forward_distort", (PyCFunction) &Dtool_PfmFile_forward_distort_190, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_forward_distort_190_comment},
  {"forwardDistort", (PyCFunction) &Dtool_PfmFile_forward_distort_190, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_forward_distort_190_comment},
  {"reverse_distort", (PyCFunction) &Dtool_PfmFile_reverse_distort_191, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_reverse_distort_191_comment},
  {"reverseDistort", (PyCFunction) &Dtool_PfmFile_reverse_distort_191, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_reverse_distort_191_comment},
  {"apply_1d_lut", (PyCFunction) &Dtool_PfmFile_apply_1d_lut_192, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_apply_1d_lut_192_comment},
  {"apply1dLut", (PyCFunction) &Dtool_PfmFile_apply_1d_lut_192, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_apply_1d_lut_192_comment},
  {"merge", &Dtool_PfmFile_merge_193, METH_O, (const char *)Dtool_PfmFile_merge_193_comment},
  {"apply_mask", &Dtool_PfmFile_apply_mask_194, METH_O, (const char *)Dtool_PfmFile_apply_mask_194_comment},
  {"applyMask", &Dtool_PfmFile_apply_mask_194, METH_O, (const char *)Dtool_PfmFile_apply_mask_194_comment},
  {"copy_channel", (PyCFunction) &Dtool_PfmFile_copy_channel_195, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_copy_channel_195_comment},
  {"copyChannel", (PyCFunction) &Dtool_PfmFile_copy_channel_195, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_copy_channel_195_comment},
  {"copy_channel_masked", (PyCFunction) &Dtool_PfmFile_copy_channel_masked_196, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_copy_channel_masked_196_comment},
  {"copyChannelMasked", (PyCFunction) &Dtool_PfmFile_copy_channel_masked_196, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_copy_channel_masked_196_comment},
  {"apply_crop", (PyCFunction) &Dtool_PfmFile_apply_crop_197, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_apply_crop_197_comment},
  {"applyCrop", (PyCFunction) &Dtool_PfmFile_apply_crop_197, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_apply_crop_197_comment},
  {"clear_to_texcoords", (PyCFunction) &Dtool_PfmFile_clear_to_texcoords_198, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_clear_to_texcoords_198_comment},
  {"clearToTexcoords", (PyCFunction) &Dtool_PfmFile_clear_to_texcoords_198, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_clear_to_texcoords_198_comment},
  {"pull_spot", (PyCFunction) &Dtool_PfmFile_pull_spot_199, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_pull_spot_199_comment},
  {"pullSpot", (PyCFunction) &Dtool_PfmFile_pull_spot_199, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_pull_spot_199_comment},
  {"calc_tight_bounds", (PyCFunction) &Dtool_PfmFile_calc_tight_bounds_200, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_calc_tight_bounds_200_comment},
  {"calcTightBounds", (PyCFunction) &Dtool_PfmFile_calc_tight_bounds_200, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_calc_tight_bounds_200_comment},
  {"compute_planar_bounds", (PyCFunction) &Dtool_PfmFile_compute_planar_bounds_201, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_compute_planar_bounds_201_comment},
  {"computePlanarBounds", (PyCFunction) &Dtool_PfmFile_compute_planar_bounds_201, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_compute_planar_bounds_201_comment},
  {"compute_sample_point", (PyCFunction) &Dtool_PfmFile_compute_sample_point_202, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_compute_sample_point_202_comment},
  {"computeSamplePoint", (PyCFunction) &Dtool_PfmFile_compute_sample_point_202, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_compute_sample_point_202_comment},
  {"copy_sub_image", (PyCFunction) &Dtool_PfmFile_copy_sub_image_203, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_copy_sub_image_203_comment},
  {"copySubImage", (PyCFunction) &Dtool_PfmFile_copy_sub_image_203, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_copy_sub_image_203_comment},
  {"add_sub_image", (PyCFunction) &Dtool_PfmFile_add_sub_image_204, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_add_sub_image_204_comment},
  {"addSubImage", (PyCFunction) &Dtool_PfmFile_add_sub_image_204, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_add_sub_image_204_comment},
  {"mult_sub_image", (PyCFunction) &Dtool_PfmFile_mult_sub_image_205, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_mult_sub_image_205_comment},
  {"multSubImage", (PyCFunction) &Dtool_PfmFile_mult_sub_image_205, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_mult_sub_image_205_comment},
  {"divide_sub_image", (PyCFunction) &Dtool_PfmFile_divide_sub_image_206, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_divide_sub_image_206_comment},
  {"divideSubImage", (PyCFunction) &Dtool_PfmFile_divide_sub_image_206, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_divide_sub_image_206_comment},
  {"indirect_1d_lookup", (PyCFunction) &Dtool_PfmFile_indirect_1d_lookup_208, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_indirect_1d_lookup_208_comment},
  {"indirect1dLookup", (PyCFunction) &Dtool_PfmFile_indirect_1d_lookup_208, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_indirect_1d_lookup_208_comment},
  {"gamma_correct", (PyCFunction) &Dtool_PfmFile_gamma_correct_209, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_gamma_correct_209_comment},
  {"gammaCorrect", (PyCFunction) &Dtool_PfmFile_gamma_correct_209, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_gamma_correct_209_comment},
  {"gamma_correct_alpha", (PyCFunction) &Dtool_PfmFile_gamma_correct_alpha_210, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_gamma_correct_alpha_210_comment},
  {"gammaCorrectAlpha", (PyCFunction) &Dtool_PfmFile_gamma_correct_alpha_210, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_gamma_correct_alpha_210_comment},
  {"apply_exponent", (PyCFunction) &Dtool_PfmFile_apply_exponent_211, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_apply_exponent_211_comment},
  {"applyExponent", (PyCFunction) &Dtool_PfmFile_apply_exponent_211, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PfmFile_apply_exponent_211_comment},
  {"output", &Dtool_PfmFile_output_212, METH_O, (const char *)Dtool_PfmFile_output_212_comment},
  {"get_points", &Dtool_PfmFile_get_points_213, METH_NOARGS, (const char *)Dtool_PfmFile_get_points_213_comment},
  {"getPoints", &Dtool_PfmFile_get_points_213, METH_NOARGS, (const char *)Dtool_PfmFile_get_points_213_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PfmFile slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PfmFile_getbuffer_214_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const PfmFile *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PfmFile slot nb_inplace_multiply -> operator *=
//////////////////
static PyObject *Dtool_PfmFile_operator_207_nb_inplace_multiply(PyObject *self, PyObject *arg) {
  PfmFile *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_PfmFile, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-void PfmFile::operator *=(float multiplier)
  if (PyNumber_Check(arg)) {
    ((*local_this).operator *=)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
//  A __repr__ function
//     PfmFile
//////////////////
static PyObject *Dtool_Repr_PfmFile(PyObject *self) {
  PfmFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PfmFile, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_PfmFile[] = {
  {(char *)"valid", &Dtool_PfmFile_valid_Getter, nullptr, nullptr, nullptr},
  {(char *)"scale", &Dtool_PfmFile_scale_Getter, &Dtool_PfmFile_scale_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_PfmFile = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  &Dtool_PfmFile_operator_207_nb_inplace_multiply,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PfmFile = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PfmFile = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PfmFile = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PfmFile_getbuffer_214_bf_getbuffer,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PfmFile = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PfmFile = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PfmFile",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PfmFile,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PfmFile,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_PfmFile,
    &Dtool_NumberMethods_PfmFile,
    &Dtool_SequenceMethods_PfmFile,
    &Dtool_MappingMethods_PfmFile,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_PfmFile,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PfmFile,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Defines a pfm file, a 2-d table of floating-point numbers, either\n"
    " * 3-component or 1-component, or with a special extension, 2- or 4-component.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PfmFile,
    nullptr, // tp_members
    Dtool_Properties_PfmFile,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PfmFile,
    PyType_GenericAlloc,
    Dtool_new_PfmFile,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PfmFile,
  Dtool_UpcastInterface_PfmFile,
  Dtool_DowncastInterface_PfmFile,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PfmFile(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PNMImageHeader(nullptr);
    Dtool_PfmFile._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PNMImageHeader);
    Dtool_PfmFile._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PfmFile._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PfmFile) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PfmFile)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PfmFile);
  }
}

/**
 * Python method tables for PNMBrush (PNMBrush)
 */
static PyMethodDef Dtool_Methods_PNMBrush[] = {
  {"make_transparent", &Dtool_PNMBrush_make_transparent_219, METH_NOARGS | METH_STATIC, (const char *)Dtool_PNMBrush_make_transparent_219_comment},
  {"makeTransparent", &Dtool_PNMBrush_make_transparent_219, METH_NOARGS | METH_STATIC, (const char *)Dtool_PNMBrush_make_transparent_219_comment},
  {"make_pixel", (PyCFunction) &Dtool_PNMBrush_make_pixel_220, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PNMBrush_make_pixel_220_comment},
  {"makePixel", (PyCFunction) &Dtool_PNMBrush_make_pixel_220, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PNMBrush_make_pixel_220_comment},
  {"make_spot", (PyCFunction) &Dtool_PNMBrush_make_spot_221, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PNMBrush_make_spot_221_comment},
  {"makeSpot", (PyCFunction) &Dtool_PNMBrush_make_spot_221, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PNMBrush_make_spot_221_comment},
  {"make_image", (PyCFunction) &Dtool_PNMBrush_make_image_222, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PNMBrush_make_image_222_comment},
  {"makeImage", (PyCFunction) &Dtool_PNMBrush_make_image_222, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PNMBrush_make_image_222_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PNMBrush = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PNMBrush = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PNMBrush = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PNMBrush = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PNMBrush = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PNMBrush = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PNMBrush",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PNMBrush,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PNMBrush,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PNMBrush,
    &Dtool_SequenceMethods_PNMBrush,
    &Dtool_MappingMethods_PNMBrush,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PNMBrush,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is used to control the shape and color of the drawing operations\n"
    " * performed by a PNMPainter object.\n"
    " *\n"
    " * Normally, you don't create a PNMBrush directly; instead, use one of the\n"
    " * static PNMBrush::make_*() methods provided here.\n"
    " *\n"
    " * A PNMBrush is used to draw the border of a polygon or rectangle, as well as\n"
    " * for filling its interior.  When it is used to draw a border, the brush is\n"
    " * \"smeared\" over the border; when it is used to fill the interior, it is\n"
    " * tiled through the interior.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PNMBrush,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PNMBrush,
    PyType_GenericAlloc,
    Dtool_new_PNMBrush,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PNMBrush,
  Dtool_UpcastInterface_PNMBrush,
  Dtool_DowncastInterface_PNMBrush,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PNMBrush(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_PNMBrush._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    Dtool_PNMBrush._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(9);
    Dtool_PNMBrush._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum PNMBrush::BrushEffect;
    PyDict_SetItemString(dict, "BE_set", Dtool_WrapValue(PNMBrush::BE_set));
    PyDict_SetItemString(dict, "BESet", Dtool_WrapValue(PNMBrush::BE_set));
    PyDict_SetItemString(dict, "BE_blend", Dtool_WrapValue(PNMBrush::BE_blend));
    PyDict_SetItemString(dict, "BEBlend", Dtool_WrapValue(PNMBrush::BE_blend));
    PyDict_SetItemString(dict, "BE_darken", Dtool_WrapValue(PNMBrush::BE_darken));
    PyDict_SetItemString(dict, "BEDarken", Dtool_WrapValue(PNMBrush::BE_darken));
    PyDict_SetItemString(dict, "BE_lighten", Dtool_WrapValue(PNMBrush::BE_lighten));
    PyDict_SetItemString(dict, "BELighten", Dtool_WrapValue(PNMBrush::BE_lighten));
    if (PyType_Ready((PyTypeObject *)&Dtool_PNMBrush) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PNMBrush)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PNMBrush);
  }
}

/**
 * Python method tables for PNMImage_Row (Row)
 */
static PyMethodDef Dtool_Methods_PNMImage_Row[] = {
  {"get_xel_val", &Dtool_PNMImage_Row_get_xel_val_331, METH_O, (const char *)Dtool_PNMImage_Row_get_xel_val_331_comment},
  {"getXelVal", &Dtool_PNMImage_Row_get_xel_val_331, METH_O, (const char *)Dtool_PNMImage_Row_get_xel_val_331_comment},
  {"set_xel_val", (PyCFunction) &Dtool_PNMImage_Row_set_xel_val_332, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_Row_set_xel_val_332_comment},
  {"setXelVal", (PyCFunction) &Dtool_PNMImage_Row_set_xel_val_332, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_Row_set_xel_val_332_comment},
  {"get_alpha_val", &Dtool_PNMImage_Row_get_alpha_val_333, METH_O, (const char *)Dtool_PNMImage_Row_get_alpha_val_333_comment},
  {"getAlphaVal", &Dtool_PNMImage_Row_get_alpha_val_333, METH_O, (const char *)Dtool_PNMImage_Row_get_alpha_val_333_comment},
  {"set_alpha_val", (PyCFunction) &Dtool_PNMImage_Row_set_alpha_val_334, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_Row_set_alpha_val_334_comment},
  {"setAlphaVal", (PyCFunction) &Dtool_PNMImage_Row_set_alpha_val_334, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_Row_set_alpha_val_334_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImage_Row slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PNMImage_Row_setitem_330_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PNMImage::Row *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage_Row, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PNMImage_Row index out of range");
    return -1;
  }
  if (arg != nullptr) { // __setitem__
    if (!DtoolInstance_IS_CONST(self)) {
      // 1-inline void PNMImage::Row::__setitem__(int x, LColorf const &v)
      LVecBase4f arg_local;
      LColorf const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
      if (!(arg_this != nullptr)) {
        Dtool_Raise_ArgTypeError(arg, 2, "Row.__setitem__", "LVecBase4f");
        return -1;
      }
      ((*local_this).__setitem__)(index, *arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call Row.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const Row self, index, const LVecBase4f v)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImage_Row slot sq_item -> operator []
//////////////////
static PyObject *Dtool_PNMImage_Row_operator_329_sq_item(PyObject *self, Py_ssize_t index) {
  PNMImage::Row *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage_Row, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PNMImage_Row index out of range");
    return nullptr;
  }
  // 1-inline LColorf PNMImage::Row::operator [](int x) const
  LColorf *return_value = new LColorf(((*(const PNMImage::Row*)local_this).operator [])(index));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(Row self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImage_Row slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PNMImage_Row_size_328_sq_length(PyObject *self) {
  PNMImage::Row *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage_Row, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PNMImage_Row = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PNMImage_Row = {
  &Dtool_PNMImage_Row_size_328_sq_length,
  nullptr,
  nullptr,
  &Dtool_PNMImage_Row_operator_329_sq_item,
  nullptr, // sq_slice
  &Dtool_PNMImage_Row_setitem_330_sq_ass_item,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

struct Dtool_PyTypedObject Dtool_PNMImage_Row = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Row",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PNMImage_Row,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PNMImage_Row,
    &Dtool_SequenceMethods_PNMImage_Row,
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "// Provides an accessor for reading or writing the contents of one row of\n"
    "// the image in-place.",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PNMImage_Row,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PNMImage_Row,
    PyType_GenericAlloc,
    Dtool_new_PNMImage_Row,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PNMImage_Row,
  Dtool_UpcastInterface_PNMImage_Row,
  Dtool_DowncastInterface_PNMImage_Row,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PNMImage_Row(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PNMImage_Row._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PNMImage_Row._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PNMImage_Row) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PNMImage_Row)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PNMImage_Row);
  }
}

/**
 * Python method tables for PNMImage_CRow (CRow)
 */
static PyMethodDef Dtool_Methods_PNMImage_CRow[] = {
  {"get_xel_val", &Dtool_PNMImage_CRow_get_xel_val_339, METH_O, (const char *)Dtool_PNMImage_CRow_get_xel_val_339_comment},
  {"getXelVal", &Dtool_PNMImage_CRow_get_xel_val_339, METH_O, (const char *)Dtool_PNMImage_CRow_get_xel_val_339_comment},
  {"get_alpha_val", &Dtool_PNMImage_CRow_get_alpha_val_340, METH_O, (const char *)Dtool_PNMImage_CRow_get_alpha_val_340_comment},
  {"getAlphaVal", &Dtool_PNMImage_CRow_get_alpha_val_340, METH_O, (const char *)Dtool_PNMImage_CRow_get_alpha_val_340_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImage_CRow slot sq_item -> operator []
//////////////////
static PyObject *Dtool_PNMImage_CRow_operator_338_sq_item(PyObject *self, Py_ssize_t index) {
  PNMImage::CRow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage_CRow, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PNMImage_CRow index out of range");
    return nullptr;
  }
  // 1-inline LColorf PNMImage::CRow::operator [](int x) const
  LColorf *return_value = new LColorf(((*(const PNMImage::CRow*)local_this).operator [])(index));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(CRow self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImage_CRow slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PNMImage_CRow_size_337_sq_length(PyObject *self) {
  PNMImage::CRow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage_CRow, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PNMImage_CRow = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PNMImage_CRow = {
  &Dtool_PNMImage_CRow_size_337_sq_length,
  nullptr,
  nullptr,
  &Dtool_PNMImage_CRow_operator_338_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

struct Dtool_PyTypedObject Dtool_PNMImage_CRow = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CRow",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PNMImage_CRow,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PNMImage_CRow,
    &Dtool_SequenceMethods_PNMImage_CRow,
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "// Provides an accessor for reading the contents of one row of the image in-\n"
    "// place.",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PNMImage_CRow,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PNMImage_CRow,
    PyType_GenericAlloc,
    Dtool_new_PNMImage_CRow,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PNMImage_CRow,
  Dtool_UpcastInterface_PNMImage_CRow,
  Dtool_DowncastInterface_PNMImage_CRow,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PNMImage_CRow(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PNMImage_CRow._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PNMImage_CRow._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PNMImage_CRow) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PNMImage_CRow)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PNMImage_CRow);
  }
}

/**
 * Python method tables for PNMImage (PNMImage)
 */
static PyMethodDef Dtool_Methods_PNMImage[] = {
  {"assign", &Dtool_PNMImage_operator_225, METH_O, (const char *)Dtool_PNMImage_operator_225_comment},
  {"clamp_val", &Dtool_PNMImage_clamp_val_227, METH_O, (const char *)Dtool_PNMImage_clamp_val_227_comment},
  {"clampVal", &Dtool_PNMImage_clamp_val_227, METH_O, (const char *)Dtool_PNMImage_clamp_val_227_comment},
  {"to_val", &Dtool_PNMImage_to_val_228, METH_O, (const char *)Dtool_PNMImage_to_val_228_comment},
  {"toVal", &Dtool_PNMImage_to_val_228, METH_O, (const char *)Dtool_PNMImage_to_val_228_comment},
  {"to_alpha_val", &Dtool_PNMImage_to_alpha_val_229, METH_O, (const char *)Dtool_PNMImage_to_alpha_val_229_comment},
  {"toAlphaVal", &Dtool_PNMImage_to_alpha_val_229, METH_O, (const char *)Dtool_PNMImage_to_alpha_val_229_comment},
  {"from_val", &Dtool_PNMImage_from_val_230, METH_O, (const char *)Dtool_PNMImage_from_val_230_comment},
  {"fromVal", &Dtool_PNMImage_from_val_230, METH_O, (const char *)Dtool_PNMImage_from_val_230_comment},
  {"from_alpha_val", &Dtool_PNMImage_from_alpha_val_231, METH_O, (const char *)Dtool_PNMImage_from_alpha_val_231_comment},
  {"fromAlphaVal", &Dtool_PNMImage_from_alpha_val_231, METH_O, (const char *)Dtool_PNMImage_from_alpha_val_231_comment},
  {"clear", (PyCFunction) &Dtool_PNMImage_clear_232, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_clear_232_comment},
  {"copy_from", &Dtool_PNMImage_copy_from_233, METH_O, (const char *)Dtool_PNMImage_copy_from_233_comment},
  {"copyFrom", &Dtool_PNMImage_copy_from_233, METH_O, (const char *)Dtool_PNMImage_copy_from_233_comment},
  {"copy_channel", (PyCFunction) &Dtool_PNMImage_copy_channel_234, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_copy_channel_234_comment},
  {"copyChannel", (PyCFunction) &Dtool_PNMImage_copy_channel_234, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_copy_channel_234_comment},
  {"copy_channel_bits", (PyCFunction) &Dtool_PNMImage_copy_channel_bits_235, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_copy_channel_bits_235_comment},
  {"copyChannelBits", (PyCFunction) &Dtool_PNMImage_copy_channel_bits_235, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_copy_channel_bits_235_comment},
  {"copy_header_from", &Dtool_PNMImage_copy_header_from_236, METH_O, (const char *)Dtool_PNMImage_copy_header_from_236_comment},
  {"copyHeaderFrom", &Dtool_PNMImage_copy_header_from_236, METH_O, (const char *)Dtool_PNMImage_copy_header_from_236_comment},
  {"take_from", &Dtool_PNMImage_take_from_237, METH_O, (const char *)Dtool_PNMImage_take_from_237_comment},
  {"takeFrom", &Dtool_PNMImage_take_from_237, METH_O, (const char *)Dtool_PNMImage_take_from_237_comment},
  {"fill", (PyCFunction) &Dtool_PNMImage_fill_238, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_fill_238_comment},
  {"fill_val", (PyCFunction) &Dtool_PNMImage_fill_val_239, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_fill_val_239_comment},
  {"fillVal", (PyCFunction) &Dtool_PNMImage_fill_val_239, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_fill_val_239_comment},
  {"alpha_fill", (PyCFunction) &Dtool_PNMImage_alpha_fill_240, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_alpha_fill_240_comment},
  {"alphaFill", (PyCFunction) &Dtool_PNMImage_alpha_fill_240, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_alpha_fill_240_comment},
  {"alpha_fill_val", (PyCFunction) &Dtool_PNMImage_alpha_fill_val_241, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_alpha_fill_val_241_comment},
  {"alphaFillVal", (PyCFunction) &Dtool_PNMImage_alpha_fill_val_241, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_alpha_fill_val_241_comment},
  {"set_read_size", (PyCFunction) &Dtool_PNMImage_set_read_size_242, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_read_size_242_comment},
  {"setReadSize", (PyCFunction) &Dtool_PNMImage_set_read_size_242, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_read_size_242_comment},
  {"clear_read_size", &Dtool_PNMImage_clear_read_size_243, METH_NOARGS, (const char *)Dtool_PNMImage_clear_read_size_243_comment},
  {"clearReadSize", &Dtool_PNMImage_clear_read_size_243, METH_NOARGS, (const char *)Dtool_PNMImage_clear_read_size_243_comment},
  {"has_read_size", &Dtool_PNMImage_has_read_size_244, METH_NOARGS, (const char *)Dtool_PNMImage_has_read_size_244_comment},
  {"hasReadSize", &Dtool_PNMImage_has_read_size_244, METH_NOARGS, (const char *)Dtool_PNMImage_has_read_size_244_comment},
  {"get_read_x_size", &Dtool_PNMImage_get_read_x_size_245, METH_NOARGS, (const char *)Dtool_PNMImage_get_read_x_size_245_comment},
  {"getReadXSize", &Dtool_PNMImage_get_read_x_size_245, METH_NOARGS, (const char *)Dtool_PNMImage_get_read_x_size_245_comment},
  {"get_read_y_size", &Dtool_PNMImage_get_read_y_size_246, METH_NOARGS, (const char *)Dtool_PNMImage_get_read_y_size_246_comment},
  {"getReadYSize", &Dtool_PNMImage_get_read_y_size_246, METH_NOARGS, (const char *)Dtool_PNMImage_get_read_y_size_246_comment},
  {"get_color_space", &Dtool_PNMImage_get_color_space_247, METH_NOARGS, (const char *)Dtool_PNMImage_get_color_space_247_comment},
  {"getColorSpace", &Dtool_PNMImage_get_color_space_247, METH_NOARGS, (const char *)Dtool_PNMImage_get_color_space_247_comment},
  {"read", (PyCFunction) &Dtool_PNMImage_read_248, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_read_248_comment},
  {"write", (PyCFunction) &Dtool_PNMImage_write_249, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_write_249_comment},
  {"is_valid", &Dtool_PNMImage_is_valid_250, METH_NOARGS, (const char *)Dtool_PNMImage_is_valid_250_comment},
  {"isValid", &Dtool_PNMImage_is_valid_250, METH_NOARGS, (const char *)Dtool_PNMImage_is_valid_250_comment},
  {"set_num_channels", &Dtool_PNMImage_set_num_channels_251, METH_O, (const char *)Dtool_PNMImage_set_num_channels_251_comment},
  {"setNumChannels", &Dtool_PNMImage_set_num_channels_251, METH_O, (const char *)Dtool_PNMImage_set_num_channels_251_comment},
  {"set_color_type", &Dtool_PNMImage_set_color_type_252, METH_O, (const char *)Dtool_PNMImage_set_color_type_252_comment},
  {"setColorType", &Dtool_PNMImage_set_color_type_252, METH_O, (const char *)Dtool_PNMImage_set_color_type_252_comment},
  {"set_color_space", &Dtool_PNMImage_set_color_space_253, METH_O, (const char *)Dtool_PNMImage_set_color_space_253_comment},
  {"setColorSpace", &Dtool_PNMImage_set_color_space_253, METH_O, (const char *)Dtool_PNMImage_set_color_space_253_comment},
  {"add_alpha", &Dtool_PNMImage_add_alpha_254, METH_NOARGS, (const char *)Dtool_PNMImage_add_alpha_254_comment},
  {"addAlpha", &Dtool_PNMImage_add_alpha_254, METH_NOARGS, (const char *)Dtool_PNMImage_add_alpha_254_comment},
  {"remove_alpha", &Dtool_PNMImage_remove_alpha_255, METH_NOARGS, (const char *)Dtool_PNMImage_remove_alpha_255_comment},
  {"removeAlpha", &Dtool_PNMImage_remove_alpha_255, METH_NOARGS, (const char *)Dtool_PNMImage_remove_alpha_255_comment},
  {"make_grayscale", (PyCFunction) &Dtool_PNMImage_make_grayscale_256, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_make_grayscale_256_comment},
  {"makeGrayscale", (PyCFunction) &Dtool_PNMImage_make_grayscale_256, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_make_grayscale_256_comment},
  {"make_rgb", &Dtool_PNMImage_make_rgb_257, METH_NOARGS, (const char *)Dtool_PNMImage_make_rgb_257_comment},
  {"makeRgb", &Dtool_PNMImage_make_rgb_257, METH_NOARGS, (const char *)Dtool_PNMImage_make_rgb_257_comment},
  {"premultiply_alpha", &Dtool_PNMImage_premultiply_alpha_258, METH_NOARGS, (const char *)Dtool_PNMImage_premultiply_alpha_258_comment},
  {"premultiplyAlpha", &Dtool_PNMImage_premultiply_alpha_258, METH_NOARGS, (const char *)Dtool_PNMImage_premultiply_alpha_258_comment},
  {"unpremultiply_alpha", &Dtool_PNMImage_unpremultiply_alpha_259, METH_NOARGS, (const char *)Dtool_PNMImage_unpremultiply_alpha_259_comment},
  {"unpremultiplyAlpha", &Dtool_PNMImage_unpremultiply_alpha_259, METH_NOARGS, (const char *)Dtool_PNMImage_unpremultiply_alpha_259_comment},
  {"reverse_rows", &Dtool_PNMImage_reverse_rows_260, METH_NOARGS, (const char *)Dtool_PNMImage_reverse_rows_260_comment},
  {"reverseRows", &Dtool_PNMImage_reverse_rows_260, METH_NOARGS, (const char *)Dtool_PNMImage_reverse_rows_260_comment},
  {"flip", (PyCFunction) &Dtool_PNMImage_flip_261, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_flip_261_comment},
  {"set_maxval", &Dtool_PNMImage_set_maxval_262, METH_O, (const char *)Dtool_PNMImage_set_maxval_262_comment},
  {"setMaxval", &Dtool_PNMImage_set_maxval_262, METH_O, (const char *)Dtool_PNMImage_set_maxval_262_comment},
  {"get_xel_val", (PyCFunction) &Dtool_PNMImage_get_xel_val_263, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_xel_val_263_comment},
  {"getXelVal", (PyCFunction) &Dtool_PNMImage_get_xel_val_263, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_xel_val_263_comment},
  {"set_xel_val", (PyCFunction) &Dtool_PNMImage_set_xel_val_264, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_xel_val_264_comment},
  {"setXelVal", (PyCFunction) &Dtool_PNMImage_set_xel_val_264, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_xel_val_264_comment},
  {"get_red_val", (PyCFunction) &Dtool_PNMImage_get_red_val_265, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_red_val_265_comment},
  {"getRedVal", (PyCFunction) &Dtool_PNMImage_get_red_val_265, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_red_val_265_comment},
  {"get_green_val", (PyCFunction) &Dtool_PNMImage_get_green_val_266, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_green_val_266_comment},
  {"getGreenVal", (PyCFunction) &Dtool_PNMImage_get_green_val_266, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_green_val_266_comment},
  {"get_blue_val", (PyCFunction) &Dtool_PNMImage_get_blue_val_267, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_blue_val_267_comment},
  {"getBlueVal", (PyCFunction) &Dtool_PNMImage_get_blue_val_267, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_blue_val_267_comment},
  {"get_gray_val", (PyCFunction) &Dtool_PNMImage_get_gray_val_268, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_gray_val_268_comment},
  {"getGrayVal", (PyCFunction) &Dtool_PNMImage_get_gray_val_268, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_gray_val_268_comment},
  {"get_alpha_val", (PyCFunction) &Dtool_PNMImage_get_alpha_val_269, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_alpha_val_269_comment},
  {"getAlphaVal", (PyCFunction) &Dtool_PNMImage_get_alpha_val_269, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_alpha_val_269_comment},
  {"set_red_val", (PyCFunction) &Dtool_PNMImage_set_red_val_270, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_red_val_270_comment},
  {"setRedVal", (PyCFunction) &Dtool_PNMImage_set_red_val_270, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_red_val_270_comment},
  {"set_green_val", (PyCFunction) &Dtool_PNMImage_set_green_val_271, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_green_val_271_comment},
  {"setGreenVal", (PyCFunction) &Dtool_PNMImage_set_green_val_271, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_green_val_271_comment},
  {"set_blue_val", (PyCFunction) &Dtool_PNMImage_set_blue_val_272, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_blue_val_272_comment},
  {"setBlueVal", (PyCFunction) &Dtool_PNMImage_set_blue_val_272, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_blue_val_272_comment},
  {"set_gray_val", (PyCFunction) &Dtool_PNMImage_set_gray_val_273, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_gray_val_273_comment},
  {"setGrayVal", (PyCFunction) &Dtool_PNMImage_set_gray_val_273, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_gray_val_273_comment},
  {"set_alpha_val", (PyCFunction) &Dtool_PNMImage_set_alpha_val_274, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_alpha_val_274_comment},
  {"setAlphaVal", (PyCFunction) &Dtool_PNMImage_set_alpha_val_274, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_alpha_val_274_comment},
  {"get_channel_val", (PyCFunction) &Dtool_PNMImage_get_channel_val_275, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_channel_val_275_comment},
  {"getChannelVal", (PyCFunction) &Dtool_PNMImage_get_channel_val_275, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_channel_val_275_comment},
  {"set_channel_val", (PyCFunction) &Dtool_PNMImage_set_channel_val_276, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_channel_val_276_comment},
  {"setChannelVal", (PyCFunction) &Dtool_PNMImage_set_channel_val_276, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_channel_val_276_comment},
  {"get_channel", (PyCFunction) &Dtool_PNMImage_get_channel_277, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_channel_277_comment},
  {"getChannel", (PyCFunction) &Dtool_PNMImage_get_channel_277, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_channel_277_comment},
  {"set_channel", (PyCFunction) &Dtool_PNMImage_set_channel_278, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_channel_278_comment},
  {"setChannel", (PyCFunction) &Dtool_PNMImage_set_channel_278, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_channel_278_comment},
  {"get_pixel", (PyCFunction) &Dtool_PNMImage_get_pixel_279, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_pixel_279_comment},
  {"getPixel", (PyCFunction) &Dtool_PNMImage_get_pixel_279, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_pixel_279_comment},
  {"set_pixel", (PyCFunction) &Dtool_PNMImage_set_pixel_280, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_pixel_280_comment},
  {"setPixel", (PyCFunction) &Dtool_PNMImage_set_pixel_280, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_pixel_280_comment},
  {"get_xel", (PyCFunction) &Dtool_PNMImage_get_xel_281, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_xel_281_comment},
  {"getXel", (PyCFunction) &Dtool_PNMImage_get_xel_281, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_xel_281_comment},
  {"set_xel", (PyCFunction) &Dtool_PNMImage_set_xel_282, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_xel_282_comment},
  {"setXel", (PyCFunction) &Dtool_PNMImage_set_xel_282, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_xel_282_comment},
  {"get_xel_a", (PyCFunction) &Dtool_PNMImage_get_xel_a_283, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_xel_a_283_comment},
  {"getXelA", (PyCFunction) &Dtool_PNMImage_get_xel_a_283, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_xel_a_283_comment},
  {"set_xel_a", (PyCFunction) &Dtool_PNMImage_set_xel_a_284, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_xel_a_284_comment},
  {"setXelA", (PyCFunction) &Dtool_PNMImage_set_xel_a_284, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_xel_a_284_comment},
  {"get_red", (PyCFunction) &Dtool_PNMImage_get_red_285, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_red_285_comment},
  {"getRed", (PyCFunction) &Dtool_PNMImage_get_red_285, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_red_285_comment},
  {"get_green", (PyCFunction) &Dtool_PNMImage_get_green_286, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_green_286_comment},
  {"getGreen", (PyCFunction) &Dtool_PNMImage_get_green_286, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_green_286_comment},
  {"get_blue", (PyCFunction) &Dtool_PNMImage_get_blue_287, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_blue_287_comment},
  {"getBlue", (PyCFunction) &Dtool_PNMImage_get_blue_287, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_blue_287_comment},
  {"get_gray", (PyCFunction) &Dtool_PNMImage_get_gray_288, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_gray_288_comment},
  {"getGray", (PyCFunction) &Dtool_PNMImage_get_gray_288, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_gray_288_comment},
  {"get_alpha", (PyCFunction) &Dtool_PNMImage_get_alpha_289, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_alpha_289_comment},
  {"getAlpha", (PyCFunction) &Dtool_PNMImage_get_alpha_289, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_alpha_289_comment},
  {"set_red", (PyCFunction) &Dtool_PNMImage_set_red_290, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_red_290_comment},
  {"setRed", (PyCFunction) &Dtool_PNMImage_set_red_290, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_red_290_comment},
  {"set_green", (PyCFunction) &Dtool_PNMImage_set_green_291, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_green_291_comment},
  {"setGreen", (PyCFunction) &Dtool_PNMImage_set_green_291, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_green_291_comment},
  {"set_blue", (PyCFunction) &Dtool_PNMImage_set_blue_292, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_blue_292_comment},
  {"setBlue", (PyCFunction) &Dtool_PNMImage_set_blue_292, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_blue_292_comment},
  {"set_gray", (PyCFunction) &Dtool_PNMImage_set_gray_293, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_gray_293_comment},
  {"setGray", (PyCFunction) &Dtool_PNMImage_set_gray_293, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_gray_293_comment},
  {"set_alpha", (PyCFunction) &Dtool_PNMImage_set_alpha_294, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_alpha_294_comment},
  {"setAlpha", (PyCFunction) &Dtool_PNMImage_set_alpha_294, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_set_alpha_294_comment},
  {"get_bright", (PyCFunction) &Dtool_PNMImage_get_bright_295, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_bright_295_comment},
  {"getBright", (PyCFunction) &Dtool_PNMImage_get_bright_295, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_get_bright_295_comment},
  {"blend", (PyCFunction) &Dtool_PNMImage_blend_296, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_blend_296_comment},
  {"copy_sub_image", (PyCFunction) &Dtool_PNMImage_copy_sub_image_297, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_copy_sub_image_297_comment},
  {"copySubImage", (PyCFunction) &Dtool_PNMImage_copy_sub_image_297, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_copy_sub_image_297_comment},
  {"blend_sub_image", (PyCFunction) &Dtool_PNMImage_blend_sub_image_298, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_blend_sub_image_298_comment},
  {"blendSubImage", (PyCFunction) &Dtool_PNMImage_blend_sub_image_298, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_blend_sub_image_298_comment},
  {"add_sub_image", (PyCFunction) &Dtool_PNMImage_add_sub_image_299, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_add_sub_image_299_comment},
  {"addSubImage", (PyCFunction) &Dtool_PNMImage_add_sub_image_299, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_add_sub_image_299_comment},
  {"mult_sub_image", (PyCFunction) &Dtool_PNMImage_mult_sub_image_300, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_mult_sub_image_300_comment},
  {"multSubImage", (PyCFunction) &Dtool_PNMImage_mult_sub_image_300, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_mult_sub_image_300_comment},
  {"darken_sub_image", (PyCFunction) &Dtool_PNMImage_darken_sub_image_301, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_darken_sub_image_301_comment},
  {"darkenSubImage", (PyCFunction) &Dtool_PNMImage_darken_sub_image_301, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_darken_sub_image_301_comment},
  {"lighten_sub_image", (PyCFunction) &Dtool_PNMImage_lighten_sub_image_302, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_lighten_sub_image_302_comment},
  {"lightenSubImage", (PyCFunction) &Dtool_PNMImage_lighten_sub_image_302, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_lighten_sub_image_302_comment},
  {"threshold", (PyCFunction) &Dtool_PNMImage_threshold_303, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_threshold_303_comment},
  {"fill_distance_inside", (PyCFunction) &Dtool_PNMImage_fill_distance_inside_304, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_fill_distance_inside_304_comment},
  {"fillDistanceInside", (PyCFunction) &Dtool_PNMImage_fill_distance_inside_304, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_fill_distance_inside_304_comment},
  {"fill_distance_outside", (PyCFunction) &Dtool_PNMImage_fill_distance_outside_305, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_fill_distance_outside_305_comment},
  {"fillDistanceOutside", (PyCFunction) &Dtool_PNMImage_fill_distance_outside_305, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_fill_distance_outside_305_comment},
  {"indirect_1d_lookup", (PyCFunction) &Dtool_PNMImage_indirect_1d_lookup_306, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_indirect_1d_lookup_306_comment},
  {"indirect1dLookup", (PyCFunction) &Dtool_PNMImage_indirect_1d_lookup_306, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_indirect_1d_lookup_306_comment},
  {"rescale", (PyCFunction) &Dtool_PNMImage_rescale_307, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_rescale_307_comment},
  {"render_spot", (PyCFunction) &Dtool_PNMImage_render_spot_308, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_render_spot_308_comment},
  {"renderSpot", (PyCFunction) &Dtool_PNMImage_render_spot_308, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_render_spot_308_comment},
  {"expand_border", (PyCFunction) &Dtool_PNMImage_expand_border_309, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_expand_border_309_comment},
  {"expandBorder", (PyCFunction) &Dtool_PNMImage_expand_border_309, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_expand_border_309_comment},
  {"box_filter", (PyCFunction) &Dtool_PNMImage_box_filter_310, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_box_filter_310_comment},
  {"boxFilter", (PyCFunction) &Dtool_PNMImage_box_filter_310, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_box_filter_310_comment},
  {"gaussian_filter", (PyCFunction) &Dtool_PNMImage_gaussian_filter_311, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_gaussian_filter_311_comment},
  {"gaussianFilter", (PyCFunction) &Dtool_PNMImage_gaussian_filter_311, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_gaussian_filter_311_comment},
  {"unfiltered_stretch_from", &Dtool_PNMImage_unfiltered_stretch_from_312, METH_O, (const char *)Dtool_PNMImage_unfiltered_stretch_from_312_comment},
  {"unfilteredStretchFrom", &Dtool_PNMImage_unfiltered_stretch_from_312, METH_O, (const char *)Dtool_PNMImage_unfiltered_stretch_from_312_comment},
  {"box_filter_from", (PyCFunction) &Dtool_PNMImage_box_filter_from_313, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_box_filter_from_313_comment},
  {"boxFilterFrom", (PyCFunction) &Dtool_PNMImage_box_filter_from_313, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_box_filter_from_313_comment},
  {"gaussian_filter_from", (PyCFunction) &Dtool_PNMImage_gaussian_filter_from_314, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_gaussian_filter_from_314_comment},
  {"gaussianFilterFrom", (PyCFunction) &Dtool_PNMImage_gaussian_filter_from_314, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_gaussian_filter_from_314_comment},
  {"quick_filter_from", (PyCFunction) &Dtool_PNMImage_quick_filter_from_315, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_quick_filter_from_315_comment},
  {"quickFilterFrom", (PyCFunction) &Dtool_PNMImage_quick_filter_from_315, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_quick_filter_from_315_comment},
  {"make_histogram", &Dtool_PNMImage_make_histogram_316, METH_O, (const char *)Dtool_PNMImage_make_histogram_316_comment},
  {"makeHistogram", &Dtool_PNMImage_make_histogram_316, METH_O, (const char *)Dtool_PNMImage_make_histogram_316_comment},
  {"quantize", &Dtool_PNMImage_quantize_317, METH_O, (const char *)Dtool_PNMImage_quantize_317_comment},
  {"perlin_noise_fill", (PyCFunction) &Dtool_PNMImage_perlin_noise_fill_318, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_perlin_noise_fill_318_comment},
  {"perlinNoiseFill", (PyCFunction) &Dtool_PNMImage_perlin_noise_fill_318, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_perlin_noise_fill_318_comment},
  {"remix_channels", &Dtool_PNMImage_remix_channels_319, METH_O, (const char *)Dtool_PNMImage_remix_channels_319_comment},
  {"remixChannels", &Dtool_PNMImage_remix_channels_319, METH_O, (const char *)Dtool_PNMImage_remix_channels_319_comment},
  {"gamma_correct", (PyCFunction) &Dtool_PNMImage_gamma_correct_320, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_gamma_correct_320_comment},
  {"gammaCorrect", (PyCFunction) &Dtool_PNMImage_gamma_correct_320, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_gamma_correct_320_comment},
  {"gamma_correct_alpha", (PyCFunction) &Dtool_PNMImage_gamma_correct_alpha_321, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_gamma_correct_alpha_321_comment},
  {"gammaCorrectAlpha", (PyCFunction) &Dtool_PNMImage_gamma_correct_alpha_321, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_gamma_correct_alpha_321_comment},
  {"apply_exponent", (PyCFunction) &Dtool_PNMImage_apply_exponent_322, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_apply_exponent_322_comment},
  {"applyExponent", (PyCFunction) &Dtool_PNMImage_apply_exponent_322, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_apply_exponent_322_comment},
  {"get_average_xel", &Dtool_PNMImage_get_average_xel_323, METH_NOARGS, (const char *)Dtool_PNMImage_get_average_xel_323_comment},
  {"getAverageXel", &Dtool_PNMImage_get_average_xel_323, METH_NOARGS, (const char *)Dtool_PNMImage_get_average_xel_323_comment},
  {"get_average_xel_a", &Dtool_PNMImage_get_average_xel_a_324, METH_NOARGS, (const char *)Dtool_PNMImage_get_average_xel_a_324_comment},
  {"getAverageXelA", &Dtool_PNMImage_get_average_xel_a_324, METH_NOARGS, (const char *)Dtool_PNMImage_get_average_xel_a_324_comment},
  {"get_average_gray", &Dtool_PNMImage_get_average_gray_325, METH_NOARGS, (const char *)Dtool_PNMImage_get_average_gray_325_comment},
  {"getAverageGray", &Dtool_PNMImage_get_average_gray_325, METH_NOARGS, (const char *)Dtool_PNMImage_get_average_gray_325_comment},
  {"do_fill_distance", (PyCFunction) &Dtool_PNMImage_do_fill_distance_326, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_do_fill_distance_326_comment},
  {"doFillDistance", (PyCFunction) &Dtool_PNMImage_do_fill_distance_326, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMImage_do_fill_distance_326_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImage slot mp_subscript -> operator []
//////////////////
static PyObject *Dtool_PNMImage_operator_342_mp_subscript(PyObject *self, PyObject *arg) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 inline PNMImage::Row PNMImage::operator [](int y)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      PNMImage::Row *return_value = new PNMImage::Row(((*local_this).operator [])((int)arg_val));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImage_Row, true, false);
    }
  }

  {
    // -2 inline PNMImage::CRow PNMImage::operator [](int y) const
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      PNMImage::CRow *return_value = new PNMImage::CRow(((*(const PNMImage*)local_this).operator [])((int)arg_val));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImage_CRow, true, false);
    }
  }

  // No coercion possible: inline PNMImage::Row PNMImage::operator [](int y)
  // No coercion possible: inline PNMImage::CRow PNMImage::operator [](int y) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(const PNMImage self, int y)\n"
      "__getitem__(PNMImage self, int y)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImage slot nb_add -> operator +
//////////////////
static PyObject *Dtool_PNMImage_operator_344_nb_add(PyObject *self, PyObject *arg) {
  PNMImage *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_PNMImage, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline PNMImage PNMImage::operator +(PNMImage const &other) const
    PNMImage const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PNMImage);
    if (arg_this != nullptr) {
      PNMImage *return_value = new PNMImage(((*(const PNMImage*)local_this).operator +)(*arg_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImage, true, false);
    }
  }

  // No coercion possible: inline PNMImage PNMImage::operator +(PNMImage const &other) const
  {
    // -2 inline PNMImage PNMImage::operator +(LColorf const &other) const
    LVecBase4f arg_local;
    LColorf const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
    if ((arg_this != nullptr)) {
      PNMImage *return_value = new PNMImage(((*(const PNMImage*)local_this).operator +)(*arg_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImage, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImage slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_PNMImage_operator_347_nb_inplace_add(PyObject *self, PyObject *arg) {
  PNMImage *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_PNMImage, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 void PNMImage::operator +=(PNMImage const &other)
    PNMImage const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PNMImage);
    if (arg_this != nullptr) {
      ((*local_this).operator +=)(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  }

  // No coercion possible: void PNMImage::operator +=(PNMImage const &other)
  {
    // -2 void PNMImage::operator +=(LColorf const &other)
    LVecBase4f arg_local;
    LColorf const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).operator +=)(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImage slot nb_inplace_multiply -> operator *=
//////////////////
static PyObject *Dtool_PNMImage_operator_349_nb_inplace_multiply(PyObject *self, PyObject *arg) {
  PNMImage *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_PNMImage, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 void PNMImage::operator *=(PNMImage const &other)
    PNMImage const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PNMImage);
    if (arg_this != nullptr) {
      ((*local_this).operator *=)(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  }

  {
    // -2 void PNMImage::operator *=(LColorf const &other)
    LColorf const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase4f);
    if (arg_this != nullptr) {
      ((*local_this).operator *=)(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  }

  {
    // -2 void PNMImage::operator *=(float multiplier)
    if (PyNumber_Check(arg)) {
      ((*local_this).operator *=)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  }

  // No coercion possible: void PNMImage::operator *=(PNMImage const &other)
  {
    // -2 void PNMImage::operator *=(LColorf const &other)
    LVecBase4f arg_local;
    LColorf const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).operator *=)(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  }

  // No coercion possible: void PNMImage::operator *=(float multiplier)
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImage slot nb_inplace_subtract -> operator -=
//////////////////
static PyObject *Dtool_PNMImage_operator_348_nb_inplace_subtract(PyObject *self, PyObject *arg) {
  PNMImage *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_PNMImage, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 void PNMImage::operator -=(PNMImage const &other)
    PNMImage const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PNMImage);
    if (arg_this != nullptr) {
      ((*local_this).operator -=)(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  }

  // No coercion possible: void PNMImage::operator -=(PNMImage const &other)
  {
    // -2 void PNMImage::operator -=(LColorf const &other)
    LVecBase4f arg_local;
    LColorf const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).operator -=)(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImage slot nb_invert -> operator ~
//////////////////
static PyObject *Dtool_PNMImage_operator_343_nb_invert(PyObject *self) {
  PNMImage *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PNMImage, (void **)&local_this)) {
    return nullptr;
  }

  // 1-PNMImage PNMImage::operator ~(void) const
  PNMImage *return_value = new PNMImage(((*(const PNMImage*)local_this).operator ~)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImage, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__invert__(PNMImage self)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImage slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_PNMImage_operator_346_nb_multiply(PyObject *self, PyObject *arg) {
  PNMImage *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_PNMImage, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline PNMImage PNMImage::operator *(PNMImage const &other) const
    PNMImage const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PNMImage);
    if (arg_this != nullptr) {
      PNMImage *return_value = new PNMImage(((*(const PNMImage*)local_this).operator *)(*arg_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImage, true, false);
    }
  }

  {
    // -2 inline PNMImage PNMImage::operator *(LColorf const &other) const
    LColorf const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase4f);
    if (arg_this != nullptr) {
      PNMImage *return_value = new PNMImage(((*(const PNMImage*)local_this).operator *)(*arg_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImage, true, false);
    }
  }

  {
    // -2 inline PNMImage PNMImage::operator *(float multiplier) const
    if (PyNumber_Check(arg)) {
      PNMImage *return_value = new PNMImage(((*(const PNMImage*)local_this).operator *)((float)PyFloat_AsDouble(arg)));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImage, true, false);
    }
  }

  // No coercion possible: inline PNMImage PNMImage::operator *(PNMImage const &other) const
  {
    // -2 inline PNMImage PNMImage::operator *(LColorf const &other) const
    LVecBase4f arg_local;
    LColorf const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
    if ((arg_this != nullptr)) {
      PNMImage *return_value = new PNMImage(((*(const PNMImage*)local_this).operator *)(*arg_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImage, true, false);
    }
  }

  // No coercion possible: inline PNMImage PNMImage::operator *(float multiplier) const
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PNMImage slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_PNMImage_operator_345_nb_subtract(PyObject *self, PyObject *arg) {
  PNMImage *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_PNMImage, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline PNMImage PNMImage::operator -(PNMImage const &other) const
    PNMImage const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PNMImage);
    if (arg_this != nullptr) {
      PNMImage *return_value = new PNMImage(((*(const PNMImage*)local_this).operator -)(*arg_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImage, true, false);
    }
  }

  // No coercion possible: inline PNMImage PNMImage::operator -(PNMImage const &other) const
  {
    // -2 inline PNMImage PNMImage::operator -(LColorf const &other) const
    LVecBase4f arg_local;
    LColorf const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
    if ((arg_this != nullptr)) {
      PNMImage *return_value = new PNMImage(((*(const PNMImage*)local_this).operator -)(*arg_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PNMImage, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_PNMImage = {
  &Dtool_PNMImage_operator_344_nb_add,
  &Dtool_PNMImage_operator_345_nb_subtract,
  &Dtool_PNMImage_operator_346_nb_multiply,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  &Dtool_PNMImage_operator_343_nb_invert,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  &Dtool_PNMImage_operator_347_nb_inplace_add,
  &Dtool_PNMImage_operator_348_nb_inplace_subtract,
  &Dtool_PNMImage_operator_349_nb_inplace_multiply,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PNMImage = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PNMImage = {
  nullptr,
  &Dtool_PNMImage_operator_342_mp_subscript,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PNMImage = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PNMImage = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PNMImage = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PNMImage",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PNMImage,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PNMImage,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PNMImage,
    &Dtool_SequenceMethods_PNMImage,
    &Dtool_MappingMethods_PNMImage,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PNMImage,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The name of this class derives from the fact that we originally implemented\n"
    " * it as a layer on top of the \"pnm library\", based on netpbm, which was built\n"
    " * to implement pbm, pgm, and pbm files, and is the underlying support of a\n"
    " * number of public-domain image file converters.  Nowadays we are no longer\n"
    " * derived directly from the pnm library, mainly to allow support of C++\n"
    " * iostreams instead of the C stdio FILE interface.\n"
    " *\n"
    " * Conceptually, a PNMImage is a two-dimensional array of xels, which are the\n"
    " * PNM-defined generic pixel type.  Each xel may have a red, green, and blue\n"
    " * component, or (if the image is grayscale) a gray component.  The image may\n"
    " * be read in, the individual xels manipulated, and written out again, or a\n"
    " * black image may be constructed from scratch.\n"
    " *\n"
    " * A PNMImage has a color space and a maxval, the combination of which defines\n"
    " * how a floating-point linear color value is encoded as an integer value in\n"
    " * memory.  The functions ending in _val operate on encoded colors, whereas\n"
    " * the regular ones work with linear floating-point values.  All operations\n"
    " * are color space correct unless otherwise specified.\n"
    " *\n"
    " * The image is of size XSize() by YSize() xels, numbered from top to bottom,\n"
    " * left to right, beginning at zero.\n"
    " *\n"
    " * Files can be specified by filename, or by an iostream pointer.  The\n"
    " * filename \"-\" refers to stdin or stdout.\n"
    " *\n"
    " * This class is not inherently thread-safe; use it from a single thread or\n"
    " * protect access using a mutex.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PNMImage,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PNMImage,
    PyType_GenericAlloc,
    Dtool_new_PNMImage,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PNMImage,
  Dtool_UpcastInterface_PNMImage,
  Dtool_DowncastInterface_PNMImage,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PNMImage(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PNMImageHeader(nullptr);
    Dtool_PNMImage._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PNMImageHeader);
    Dtool_PNMImage._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PNMImage._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // Nested Object   PNMImage_Row;
    Dtool_PyModuleClassInit_PNMImage_Row(nullptr);
    PyDict_SetItemString(dict, "Row", (PyObject *)&Dtool_PNMImage_Row);
    // Nested Object   PNMImage_CRow;
    Dtool_PyModuleClassInit_PNMImage_CRow(nullptr);
    PyDict_SetItemString(dict, "CRow", (PyObject *)&Dtool_PNMImage_CRow);
    if (PyType_Ready((PyTypeObject *)&Dtool_PNMImage) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PNMImage)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PNMImage);
  }
}

/**
 * Python method tables for PNMPainter (PNMPainter)
 */
static PyMethodDef Dtool_Methods_PNMPainter[] = {
  {"set_pen", &Dtool_PNMPainter_set_pen_353, METH_O, (const char *)Dtool_PNMPainter_set_pen_353_comment},
  {"setPen", &Dtool_PNMPainter_set_pen_353, METH_O, (const char *)Dtool_PNMPainter_set_pen_353_comment},
  {"get_pen", &Dtool_PNMPainter_get_pen_354, METH_NOARGS, (const char *)Dtool_PNMPainter_get_pen_354_comment},
  {"getPen", &Dtool_PNMPainter_get_pen_354, METH_NOARGS, (const char *)Dtool_PNMPainter_get_pen_354_comment},
  {"set_fill", &Dtool_PNMPainter_set_fill_355, METH_O, (const char *)Dtool_PNMPainter_set_fill_355_comment},
  {"setFill", &Dtool_PNMPainter_set_fill_355, METH_O, (const char *)Dtool_PNMPainter_set_fill_355_comment},
  {"get_fill", &Dtool_PNMPainter_get_fill_356, METH_NOARGS, (const char *)Dtool_PNMPainter_get_fill_356_comment},
  {"getFill", &Dtool_PNMPainter_get_fill_356, METH_NOARGS, (const char *)Dtool_PNMPainter_get_fill_356_comment},
  {"draw_point", (PyCFunction) &Dtool_PNMPainter_draw_point_360, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMPainter_draw_point_360_comment},
  {"drawPoint", (PyCFunction) &Dtool_PNMPainter_draw_point_360, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMPainter_draw_point_360_comment},
  {"draw_line", (PyCFunction) &Dtool_PNMPainter_draw_line_361, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMPainter_draw_line_361_comment},
  {"drawLine", (PyCFunction) &Dtool_PNMPainter_draw_line_361, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMPainter_draw_line_361_comment},
  {"draw_rectangle", (PyCFunction) &Dtool_PNMPainter_draw_rectangle_362, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMPainter_draw_rectangle_362_comment},
  {"drawRectangle", (PyCFunction) &Dtool_PNMPainter_draw_rectangle_362, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PNMPainter_draw_rectangle_362_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_PNMPainter[] = {
  {(char *)"pen", &Dtool_PNMPainter_pen_Getter, &Dtool_PNMPainter_pen_Setter, nullptr, nullptr},
  {(char *)"fill", &Dtool_PNMPainter_fill_Getter, &Dtool_PNMPainter_fill_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_PNMPainter = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_PNMPainter = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PNMPainter",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PNMPainter,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PNMPainter,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class provides a number of convenient methods for painting drawings\n"
    " * directly into a PNMImage.\n"
    " *\n"
    " * It stores a pointer to the PNMImage you pass it, but it does not take\n"
    " * ownership of the object; you are responsible for ensuring that the PNMImage\n"
    " * does not destruct during the lifetime of the PNMPainter object.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PNMPainter,
    nullptr, // tp_members
    Dtool_Properties_PNMPainter,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PNMPainter,
    PyType_GenericAlloc,
    Dtool_new_PNMPainter,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PNMPainter,
  Dtool_UpcastInterface_PNMPainter,
  Dtool_DowncastInterface_PNMPainter,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PNMPainter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PNMPainter._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PNMPainter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PNMPainter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PNMPainter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PNMPainter);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3pnmimage_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    PNMFileType::init_type();
    TypeHandle handle = PNMFileType::get_class_type();
    Dtool_PNMFileType._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_PNMFileType);
  }
}

void Dtool_libp3pnmimage_BuildInstants(PyObject *module) {
  (void) module;
  // pixel
  Dtool_PyModuleClassInit_pixel(module);
  PyModule_AddObject(module, "pixel", (PyObject *)&Dtool_pixel);
  Py_INCREF(Dtool_Ptr_pixel);
  PyModule_AddObject(module, "Pixel", (PyObject *)&Dtool_pixel);
  // typedef pixel xel
  Dtool_PyModuleClassInit_pixel(module);
  Py_INCREF((PyObject *)&Dtool_pixel);
  PyModule_AddObject(module, "xel", (PyObject *)&Dtool_pixel);
  Py_INCREF(Dtool_Ptr_pixel);
  PyModule_AddObject(module, "Xel", (PyObject *)&Dtool_pixel);
  // PNMFileType
  Dtool_PyModuleClassInit_PNMFileType(module);
  PyModule_AddObject(module, "PNMFileType", (PyObject *)&Dtool_PNMFileType);
  // PNMFileTypeRegistry
  Dtool_PyModuleClassInit_PNMFileTypeRegistry(module);
  PyModule_AddObject(module, "PNMFileTypeRegistry", (PyObject *)&Dtool_PNMFileTypeRegistry);
  // PNMImageHeader
  Dtool_PyModuleClassInit_PNMImageHeader(module);
  PyModule_AddObject(module, "PNMImageHeader", (PyObject *)&Dtool_PNMImageHeader);
  // PfmFile
  Dtool_PyModuleClassInit_PfmFile(module);
  PyModule_AddObject(module, "PfmFile", (PyObject *)&Dtool_PfmFile);
  // PNMBrush
  Dtool_PyModuleClassInit_PNMBrush(module);
  PyModule_AddObject(module, "PNMBrush", (PyObject *)&Dtool_PNMBrush);
  // PNMImage
  Dtool_PyModuleClassInit_PNMImage(module);
  PyModule_AddObject(module, "PNMImage", (PyObject *)&Dtool_PNMImage);
  // PNMPainter
  Dtool_PyModuleClassInit_PNMPainter(module);
  PyModule_AddObject(module, "PNMPainter", (PyObject *)&Dtool_PNMPainter);
}

static PyMethodDef python_simple_funcs[] = {
  {"decode_sRGB_float", &Dtool_decode_sRGB_float_28, METH_O, (const char *)Dtool_decode_sRGB_float_28_comment},
  {"decodeSRGBFloat", &Dtool_decode_sRGB_float_28, METH_O, (const char *)Dtool_decode_sRGB_float_28_comment},
  {"decode_sRGB_uchar", &Dtool_decode_sRGB_uchar_29, METH_O, (const char *)Dtool_decode_sRGB_uchar_29_comment},
  {"decodeSRGBUchar", &Dtool_decode_sRGB_uchar_29, METH_O, (const char *)Dtool_decode_sRGB_uchar_29_comment},
  {"encode_sRGB_float", &Dtool_encode_sRGB_float_30, METH_O, (const char *)Dtool_encode_sRGB_float_30_comment},
  {"encodeSRGBFloat", &Dtool_encode_sRGB_float_30, METH_O, (const char *)Dtool_encode_sRGB_float_30_comment},
  {"encode_sRGB_uchar", &Dtool_encode_sRGB_uchar_31, METH_O, (const char *)Dtool_encode_sRGB_uchar_31_comment},
  {"encodeSRGBUchar", &Dtool_encode_sRGB_uchar_31, METH_O, (const char *)Dtool_encode_sRGB_uchar_31_comment},
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3pnmimage_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3pnmimage_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583613087,  /* file_identifier */
  "libp3pnmimage",  /* library_name */
  "BCNh",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3pnmimage.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  858  /* next_index */
};

Configure(_in_configure_libp3pnmimage);
ConfigureFn(_in_configure_libp3pnmimage) {
  interrogate_request_module(&_in_module_def);
}

