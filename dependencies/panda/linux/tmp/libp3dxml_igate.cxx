/*
 * This file was generated by:
 * built/bin/interrogate -srcdir panda/src/dxml -Ipanda/src/dxml -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3dxml_igate.cxx -od built/pandac/input/libp3dxml.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/dxml -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -DTIXML_USE_STL= -module panda3d.core -library libp3dxml config_dxml.h p3dxml_composite1.cxx tinyxml.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "config_dxml.h"
#include "dconfig.h"
#include "notifyCategoryProxy.h"
#include "pandabase.h"
#include "tinyxml.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class TiXmlBase
 */
typedef TiXmlBase TiXmlBase_localtype;
Define_Module_Class(panda3d.core, TiXmlBase, TiXmlBase_localtype, TiXmlBase);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TiXmlBase = &Dtool_TiXmlBase;
static void Dtool_PyModuleClassInit_TiXmlBase(PyObject *module);

/**
 * Forward declarations for top-level class TiXmlDeclaration
 */
typedef TiXmlDeclaration TiXmlDeclaration_localtype;
Define_Module_Class(panda3d.core, TiXmlDeclaration, TiXmlDeclaration_localtype, TiXmlDeclaration);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TiXmlDeclaration = &Dtool_TiXmlDeclaration;
static void Dtool_PyModuleClassInit_TiXmlDeclaration(PyObject *module);
TiXmlDeclaration *Dtool_Coerce_TiXmlDeclaration(PyObject *args, TiXmlDeclaration &coerced);

/**
 * Forward declarations for top-level class TiXmlNode
 */
typedef TiXmlNode TiXmlNode_localtype;
Define_Module_Class(panda3d.core, TiXmlNode, TiXmlNode_localtype, TiXmlNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TiXmlNode = &Dtool_TiXmlNode;
static void Dtool_PyModuleClassInit_TiXmlNode(PyObject *module);

/**
 * Forward declarations for top-level class TiXmlDocument
 */
typedef TiXmlDocument TiXmlDocument_localtype;
Define_Module_Class(panda3d.core, TiXmlDocument, TiXmlDocument_localtype, TiXmlDocument);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TiXmlDocument = &Dtool_TiXmlDocument;
static void Dtool_PyModuleClassInit_TiXmlDocument(PyObject *module);
TiXmlDocument *Dtool_Coerce_TiXmlDocument(PyObject *args, TiXmlDocument &coerced);

/**
 * Forward declarations for top-level class TiXmlElement
 */
typedef TiXmlElement TiXmlElement_localtype;
Define_Module_Class(panda3d.core, TiXmlElement, TiXmlElement_localtype, TiXmlElement);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TiXmlElement = &Dtool_TiXmlElement;
static void Dtool_PyModuleClassInit_TiXmlElement(PyObject *module);

/**
 * Forward declarations for top-level class TiXmlCursor
 */
typedef TiXmlCursor TiXmlCursor_localtype;
Define_Module_Class(panda3d.core, TiXmlCursor, TiXmlCursor_localtype, TiXmlCursor);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TiXmlCursor = &Dtool_TiXmlCursor;
static void Dtool_PyModuleClassInit_TiXmlCursor(PyObject *module);

/**
 * Forward declarations for top-level class TiXmlVisitor
 */
typedef TiXmlVisitor TiXmlVisitor_localtype;
Define_Module_Class(panda3d.core, TiXmlVisitor, TiXmlVisitor_localtype, TiXmlVisitor);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TiXmlVisitor = &Dtool_TiXmlVisitor;
static void Dtool_PyModuleClassInit_TiXmlVisitor(PyObject *module);

/**
 * Forward declarations for top-level class TiXmlAttribute
 */
typedef TiXmlAttribute TiXmlAttribute_localtype;
Define_Module_Class(panda3d.core, TiXmlAttribute, TiXmlAttribute_localtype, TiXmlAttribute);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TiXmlAttribute = &Dtool_TiXmlAttribute;
static void Dtool_PyModuleClassInit_TiXmlAttribute(PyObject *module);

/**
 * Forward declarations for top-level class TiXmlAttributeSet
 */
typedef TiXmlAttributeSet TiXmlAttributeSet_localtype;
Define_Module_Class(panda3d.core, TiXmlAttributeSet, TiXmlAttributeSet_localtype, TiXmlAttributeSet);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TiXmlAttributeSet = &Dtool_TiXmlAttributeSet;
static void Dtool_PyModuleClassInit_TiXmlAttributeSet(PyObject *module);

/**
 * Forward declarations for top-level class TiXmlComment
 */
typedef TiXmlComment TiXmlComment_localtype;
Define_Module_Class(panda3d.core, TiXmlComment, TiXmlComment_localtype, TiXmlComment);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TiXmlComment = &Dtool_TiXmlComment;
static void Dtool_PyModuleClassInit_TiXmlComment(PyObject *module);
TiXmlComment *Dtool_Coerce_TiXmlComment(PyObject *args, TiXmlComment &coerced);

/**
 * Forward declarations for top-level class TiXmlText
 */
typedef TiXmlText TiXmlText_localtype;
Define_Module_Class(panda3d.core, TiXmlText, TiXmlText_localtype, TiXmlText);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TiXmlText = &Dtool_TiXmlText;
static void Dtool_PyModuleClassInit_TiXmlText(PyObject *module);

/**
 * Forward declarations for top-level class TiXmlUnknown
 */
typedef TiXmlUnknown TiXmlUnknown_localtype;
Define_Module_Class(panda3d.core, TiXmlUnknown, TiXmlUnknown_localtype, TiXmlUnknown);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TiXmlUnknown = &Dtool_TiXmlUnknown;
static void Dtool_PyModuleClassInit_TiXmlUnknown(PyObject *module);

/**
 * Forward declarations for top-level class TiXmlHandle
 */
typedef TiXmlHandle TiXmlHandle_localtype;
Define_Module_Class(panda3d.core, TiXmlHandle, TiXmlHandle_localtype, TiXmlHandle);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TiXmlHandle = &Dtool_TiXmlHandle;
static void Dtool_PyModuleClassInit_TiXmlHandle(PyObject *module);

/**
 * Forward declarations for top-level class TiXmlPrinter
 */
typedef TiXmlPrinter TiXmlPrinter_localtype;
Define_Module_Class(panda3d.core, TiXmlPrinter, TiXmlPrinter_localtype, TiXmlPrinter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TiXmlPrinter = &Dtool_TiXmlPrinter;
static void Dtool_PyModuleClassInit_TiXmlPrinter(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"TiXmlBase", &Dtool_TiXmlBase},
  {"TiXmlDeclaration", &Dtool_TiXmlDeclaration},
  {"TiXmlNode", &Dtool_TiXmlNode},
  {"TiXmlDocument", &Dtool_TiXmlDocument},
  {"TiXmlElement", &Dtool_TiXmlElement},
  {"TiXmlCursor", &Dtool_TiXmlCursor},
  {"TiXmlVisitor", &Dtool_TiXmlVisitor},
  {"TiXmlAttribute", &Dtool_TiXmlAttribute},
  {"TiXmlAttributeSet", &Dtool_TiXmlAttributeSet},
  {"TiXmlComment", &Dtool_TiXmlComment},
  {"TiXmlText", &Dtool_TiXmlText},
  {"TiXmlUnknown", &Dtool_TiXmlUnknown},
  {"TiXmlHandle", &Dtool_TiXmlHandle},
  {"TiXmlPrinter", &Dtool_TiXmlPrinter},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"std::ostream", nullptr},
#define Dtool_Ptr_std_ostream (imports[0].type)
  {"std::istream", nullptr},
#define Dtool_Ptr_std_istream (imports[1].type)
  {"Filename", nullptr},
#define Dtool_Ptr_Filename (imports[2].type)
  {nullptr, nullptr},
};
#endif

// std::ostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
#endif
// std::istream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_istream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_istream = &Dtool_std_istream;
#endif
// Filename
#ifndef LINK_ALL_STATIC
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != nullptr, nullptr);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != nullptr, nullptr);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python function wrapper for:
 * TiXmlDocument *read_xml_stream(std::istream &in)
 */
static PyObject *Dtool_read_xml_stream_82(PyObject *, PyObject *arg) {
  // 1-TiXmlDocument *read_xml_stream(std::istream &in)
  std::istream *arg_this = (std::istream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_istream, 0, "read_xml_stream", false, true);
  if (arg_this != nullptr) {
    TiXmlDocument *return_value = (::read_xml_stream)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlDocument, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_xml_stream(istream in)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_read_xml_stream_82_comment =
  "C++ Interface:\n"
  "read_xml_stream(istream in)\n"
  "\n"
  "/**\n"
  " * Reads an XML document from the indicated stream.\n"
  " * @returns the document, or NULL on error.\n"
  " */";
#else
static const char *Dtool_read_xml_stream_82_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void write_xml_stream(std::ostream &out, TiXmlDocument *doc)
 */
static PyObject *Dtool_write_xml_stream_83(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-void write_xml_stream(std::ostream &out, TiXmlDocument *doc)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"out", "doc", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:write_xml_stream", (char **)keyword_list, &param0, &param1)) {
    std::ostream *param0_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_std_ostream, 0, "write_xml_stream", false, true);
    TiXmlDocument param1_local;
    TiXmlDocument *param1_this = Dtool_Coerce_TiXmlDocument(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "write_xml_stream", "TiXmlDocument");
    }
    if (param0_this != nullptr) {
      (::write_xml_stream)(*param0_this, param1_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_xml_stream(ostream out, TiXmlDocument doc)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_write_xml_stream_83_comment =
  "C++ Interface:\n"
  "write_xml_stream(ostream out, TiXmlDocument doc)\n";
#else
static const char *Dtool_write_xml_stream_83_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void print_xml(TiXmlNode *xnode)
 */
static PyObject *Dtool_print_xml_84(PyObject *, PyObject *arg) {
  // 1-void print_xml(TiXmlNode *xnode)
  TiXmlNode *arg_this = (TiXmlNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TiXmlNode, 0, "print_xml", false, true);
  if (arg_this != nullptr) {
    (::print_xml)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "print_xml(TiXmlNode xnode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_print_xml_84_comment =
  "C++ Interface:\n"
  "print_xml(TiXmlNode xnode)\n";
#else
static const char *Dtool_print_xml_84_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void print_xml_to_file(Filename const &filename, TiXmlNode *xnode)
 */
static PyObject *Dtool_print_xml_to_file_85(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-void print_xml_to_file(Filename const &filename, TiXmlNode *xnode)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"filename", "xnode", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:print_xml_to_file", (char **)keyword_list, &param0, &param1)) {
    Filename param0_local;
    Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
    if (!(param0_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "print_xml_to_file", "Filename");
    }
    TiXmlNode *param1_this = (TiXmlNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TiXmlNode, 1, "print_xml_to_file", false, true);
    if (param1_this != nullptr) {
      (::print_xml_to_file)(*param0_this, param1_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "print_xml_to_file(const Filename filename, TiXmlNode xnode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_print_xml_to_file_85_comment =
  "C++ Interface:\n"
  "print_xml_to_file(const Filename filename, TiXmlNode xnode)\n";
#else
static const char *Dtool_print_xml_to_file_85_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int get_TIXML_MAJOR_VERSION(void)
 */
static PyObject *Dtool_get_TIXML_MAJOR_VERSION_87(PyObject *, PyObject *) {
  // 1-int get_TIXML_MAJOR_VERSION(void)
  int return_value = TIXML_MAJOR_VERSION;
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_get_TIXML_MAJOR_VERSION_87_comment =
  "C++ Interface:\n"
  "get_TIXML_MAJOR_VERSION()\n"
  "\n"
  "getter for int const TIXML_MAJOR_VERSION;";
#else
static const char *Dtool_get_TIXML_MAJOR_VERSION_87_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int get_TIXML_MINOR_VERSION(void)
 */
static PyObject *Dtool_get_TIXML_MINOR_VERSION_89(PyObject *, PyObject *) {
  // 1-int get_TIXML_MINOR_VERSION(void)
  int return_value = TIXML_MINOR_VERSION;
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_get_TIXML_MINOR_VERSION_89_comment =
  "C++ Interface:\n"
  "get_TIXML_MINOR_VERSION()\n"
  "\n"
  "getter for int const TIXML_MINOR_VERSION;";
#else
static const char *Dtool_get_TIXML_MINOR_VERSION_89_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int get_TIXML_PATCH_VERSION(void)
 */
static PyObject *Dtool_get_TIXML_PATCH_VERSION_91(PyObject *, PyObject *) {
  // 1-int get_TIXML_PATCH_VERSION(void)
  int return_value = TIXML_PATCH_VERSION;
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_get_TIXML_PATCH_VERSION_91_comment =
  "C++ Interface:\n"
  "get_TIXML_PATCH_VERSION()\n"
  "\n"
  "getter for int const TIXML_PATCH_VERSION;";
#else
static const char *Dtool_get_TIXML_PATCH_VERSION_91_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlEncoding get_TIXML_DEFAULT_ENCODING(void)
 */
static PyObject *Dtool_get_TIXML_DEFAULT_ENCODING_104(PyObject *, PyObject *) {
  // 1-TiXmlEncoding get_TIXML_DEFAULT_ENCODING(void)
  TiXmlEncoding return_value = TIXML_DEFAULT_ENCODING;
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_get_TIXML_DEFAULT_ENCODING_104_comment =
  "C++ Interface:\n"
  "get_TIXML_DEFAULT_ENCODING()\n"
  "\n"
  "getter for TiXmlEncoding const TIXML_DEFAULT_ENCODING;";
#else
static const char *Dtool_get_TIXML_DEFAULT_ENCODING_104_comment = nullptr;
#endif

/**
 * Python wrappers for functions of class TiXmlBase
 */
/**
 * Python function wrapper for:
 * static void TiXmlBase::SetCondenseWhiteSpace(bool condense)
 */
static PyObject *Dtool_TiXmlBase_SetCondenseWhiteSpace_4(PyObject *, PyObject *arg) {
  // 1-static void TiXmlBase::SetCondenseWhiteSpace(bool condense)
  (TiXmlBase::SetCondenseWhiteSpace)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetCondenseWhiteSpace(bool condense)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlBase_SetCondenseWhiteSpace_4_comment =
  "C++ Interface:\n"
  "SetCondenseWhiteSpace(bool condense)\n"
  "\n"
  "/** The world does not agree on whether white space should be kept or\n"
  "        not. In order to make everyone happy, these global, static functions\n"
  "        are provided to set whether or not TinyXml will condense all white space\n"
  "        into a single space or not. The default is to condense. Note changing this\n"
  "        value is not thread safe.\n"
  "    */";
#else
static const char *Dtool_TiXmlBase_SetCondenseWhiteSpace_4_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static bool TiXmlBase::IsWhiteSpaceCondensed(void)
 */
static PyObject *Dtool_TiXmlBase_IsWhiteSpaceCondensed_5(PyObject *, PyObject *) {
  // 1-static bool TiXmlBase::IsWhiteSpaceCondensed(void)
  bool return_value = (TiXmlBase::IsWhiteSpaceCondensed)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlBase_IsWhiteSpaceCondensed_5_comment =
  "C++ Interface:\n"
  "IsWhiteSpaceCondensed()\n"
  "\n"
  "/// Return the current white space setting.";
#else
static const char *Dtool_TiXmlBase_IsWhiteSpaceCondensed_5_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int TiXmlBase::Row(void) const
 */
static PyObject *Dtool_TiXmlBase_Row_6(PyObject *self, PyObject *) {
  TiXmlBase *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlBase)) {
    return nullptr;
  }
  // 1-int TiXmlBase::Row(void) const
  int return_value = ((*(const TiXmlBase*)local_this).Row)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlBase_Row_6_comment =
  "C++ Interface:\n"
  "Row(TiXmlBase self)\n"
  "\n"
  "/** Return the position, in the original source file, of this node or attribute.\n"
  "        The row and column are 1-based. (That is the first row and first column is\n"
  "        1,1). If the returns values are 0 or less, then the parser does not have\n"
  "        a row and column value.\n"
  "\n"
  "        Generally, the row and column value will be set when the TiXmlDocument::Load(),\n"
  "        TiXmlDocument::LoadFile(), or any TiXmlNode::Parse() is called. It will NOT be set\n"
  "        when the DOM was created from operator>>.\n"
  "\n"
  "        The values reflect the initial load. Once the DOM is modified programmatically\n"
  "        (by adding or changing nodes and attributes) the new values will NOT update to\n"
  "        reflect changes in the document.\n"
  "\n"
  "        There is a minor performance cost to computing the row and column. Computation\n"
  "        can be disabled if TiXmlDocument::SetTabSize() is called with 0 as the value.\n"
  "\n"
  "        @sa TiXmlDocument::SetTabSize()\n"
  "    */";
#else
static const char *Dtool_TiXmlBase_Row_6_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int TiXmlBase::Column(void) const
 */
static PyObject *Dtool_TiXmlBase_Column_7(PyObject *self, PyObject *) {
  TiXmlBase *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlBase)) {
    return nullptr;
  }
  // 1-int TiXmlBase::Column(void) const
  int return_value = ((*(const TiXmlBase*)local_this).Column)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlBase_Column_7_comment =
  "C++ Interface:\n"
  "Column(TiXmlBase self)\n"
  "\n"
  "///< See Row()";
#else
static const char *Dtool_TiXmlBase_Column_7_comment = nullptr;
#endif

static int Dtool_Init_TiXmlBase(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_TiXmlBase(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TiXmlBase) {
    printf("TiXmlBase ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TiXmlBase *local_this = (TiXmlBase *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TiXmlBase) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TiXmlBase(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TiXmlBase) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TiXmlDeclaration
 */
/**
 * Python function wrapper for:
 * void TiXmlDeclaration::operator =(TiXmlDeclaration const &copy)
 */
static PyObject *Dtool_TiXmlDeclaration_operator_46(PyObject *self, PyObject *arg) {
  TiXmlDeclaration *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlDeclaration, (void **)&local_this, "TiXmlDeclaration.assign")) {
    return nullptr;
  }
  // 1-void TiXmlDeclaration::operator =(TiXmlDeclaration const &copy)
  TiXmlDeclaration arg_local;
  TiXmlDeclaration const *arg_this = Dtool_Coerce_TiXmlDeclaration(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "TiXmlDeclaration.assign", "TiXmlDeclaration");
  }
  ((*local_this).operator =)(*arg_this);
  TiXmlDeclaration *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlDeclaration, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const TiXmlDeclaration self, const TiXmlDeclaration copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlDeclaration_operator_46_comment =
  "C++ Interface:\n"
  "assign(const TiXmlDeclaration self, const TiXmlDeclaration copy)\n";
#else
static const char *Dtool_TiXmlDeclaration_operator_46_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * char const *TiXmlDeclaration::Version(void) const
 */
static PyObject *Dtool_TiXmlDeclaration_Version_47(PyObject *self, PyObject *) {
  TiXmlDeclaration *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlDeclaration)) {
    return nullptr;
  }
  // 1-char const *TiXmlDeclaration::Version(void) const
  char const *return_value = ((*(const TiXmlDeclaration*)local_this).Version)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlDeclaration_Version_47_comment =
  "C++ Interface:\n"
  "Version(TiXmlDeclaration self)\n"
  "\n"
  "/// Version. Will return an empty string if none was found.";
#else
static const char *Dtool_TiXmlDeclaration_Version_47_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * char const *TiXmlDeclaration::Encoding(void) const
 */
static PyObject *Dtool_TiXmlDeclaration_Encoding_48(PyObject *self, PyObject *) {
  TiXmlDeclaration *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlDeclaration)) {
    return nullptr;
  }
  // 1-char const *TiXmlDeclaration::Encoding(void) const
  char const *return_value = ((*(const TiXmlDeclaration*)local_this).Encoding)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlDeclaration_Encoding_48_comment =
  "C++ Interface:\n"
  "Encoding(TiXmlDeclaration self)\n"
  "\n"
  "/// Encoding. Will return an empty string if none was found.";
#else
static const char *Dtool_TiXmlDeclaration_Encoding_48_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * char const *TiXmlDeclaration::Standalone(void) const
 */
static PyObject *Dtool_TiXmlDeclaration_Standalone_49(PyObject *self, PyObject *) {
  TiXmlDeclaration *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlDeclaration)) {
    return nullptr;
  }
  // 1-char const *TiXmlDeclaration::Standalone(void) const
  char const *return_value = ((*(const TiXmlDeclaration*)local_this).Standalone)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlDeclaration_Standalone_49_comment =
  "C++ Interface:\n"
  "Standalone(TiXmlDeclaration self)\n"
  "\n"
  "/// Is this a standalone document?";
#else
static const char *Dtool_TiXmlDeclaration_Standalone_49_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlDeclaration::TiXmlDeclaration(void)
 * TiXmlDeclaration::TiXmlDeclaration(TiXmlDeclaration const &copy)
 * TiXmlDeclaration::TiXmlDeclaration(char const *_version, char const *_encoding, char const *_standalone)
 * TiXmlDeclaration::TiXmlDeclaration(std::string const &_version, std::string const &_encoding, std::string const &_standalone)
 */
static int Dtool_Init_TiXmlDeclaration(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-TiXmlDeclaration::TiXmlDeclaration(void)
      TiXmlDeclaration *return_value = new TiXmlDeclaration();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlDeclaration, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-TiXmlDeclaration::TiXmlDeclaration(TiXmlDeclaration const &copy)
        TiXmlDeclaration arg_local;
        TiXmlDeclaration const *arg_this = Dtool_Coerce_TiXmlDeclaration(arg, arg_local);
        if (!(arg_this != nullptr)) {
          Dtool_Raise_ArgTypeError(arg, 0, "TiXmlDeclaration.TiXmlDeclaration", "TiXmlDeclaration");
          return -1;
        }
        TiXmlDeclaration *return_value = new TiXmlDeclaration(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlDeclaration, true, false);
      }
    }
    break;
  case 3:
    {
      {
        // -2 TiXmlDeclaration::TiXmlDeclaration(std::string const &_version, std::string const &_encoding, std::string const &_standalone)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        const char *param2_str = nullptr;
        Py_ssize_t param2_len;
        static const char *keyword_list[] = {"_version", "_encoding", "_standalone", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#s#:TiXmlDeclaration", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len)) {
          TiXmlDeclaration *return_value = new TiXmlDeclaration(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlDeclaration, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 TiXmlDeclaration::TiXmlDeclaration(char const *_version, char const *_encoding, char const *_standalone)
        char const *param0;
        char const *param1;
        char const *param2;
        static const char *keyword_list[] = {"_version", "_encoding", "_standalone", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "zzz:TiXmlDeclaration", (char **)keyword_list, &param0, &param1, &param2)) {
          TiXmlDeclaration *return_value = new TiXmlDeclaration((char const *)param0, (char const *)param1, (char const *)param2);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlDeclaration, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: TiXmlDeclaration::TiXmlDeclaration(std::string const &_version, std::string const &_encoding, std::string const &_standalone)
      // No coercion possible: TiXmlDeclaration::TiXmlDeclaration(char const *_version, char const *_encoding, char const *_standalone)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "TiXmlDeclaration() takes 0, 1 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TiXmlDeclaration()\n"
      "TiXmlDeclaration(const TiXmlDeclaration copy)\n"
      "TiXmlDeclaration(str _version, str _encoding, str _standalone)\n"
      "TiXmlDeclaration(str _version, str _encoding, str _standalone)\n");
  }
  return -1;
}

TiXmlDeclaration *Dtool_Coerce_TiXmlDeclaration(PyObject *args, TiXmlDeclaration &coerced) {
  TiXmlDeclaration *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_TiXmlDeclaration)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const TiXmlDeclaration *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      {
        // -2 TiXmlDeclaration::TiXmlDeclaration(std::string const &_version, std::string const &_encoding, std::string const &_standalone)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        const char *param2_str = nullptr;
        Py_ssize_t param2_len;
        if (PyArg_ParseTuple(args, "s#s#s#:TiXmlDeclaration", &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len)) {
          coerced = TiXmlDeclaration(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len));
          if (_PyErr_OCCURRED()) {
            return nullptr;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
      }

      {
        // -2 TiXmlDeclaration::TiXmlDeclaration(char const *_version, char const *_encoding, char const *_standalone)
        char const *param0;
        char const *param1;
        char const *param2;
        if (PyArg_ParseTuple(args, "zzz:TiXmlDeclaration", &param0, &param1, &param2)) {
          coerced = TiXmlDeclaration((char const *)param0, (char const *)param1, (char const *)param2);
          if (_PyErr_OCCURRED()) {
            return nullptr;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
      }

    }
  }

  return nullptr;
}

static void *Dtool_UpcastInterface_TiXmlDeclaration(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TiXmlDeclaration) {
    printf("TiXmlDeclaration ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TiXmlDeclaration *local_this = (TiXmlDeclaration *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TiXmlDeclaration) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TiXmlBase) {
    return (TiXmlBase *)(TiXmlNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TiXmlNode) {
    return (TiXmlNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TiXmlDeclaration(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TiXmlDeclaration) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TiXmlBase) {
    TiXmlBase* other_this = (TiXmlBase*)from_this;
    return (TiXmlDeclaration*)other_this;
  }
  if (from_type == Dtool_Ptr_TiXmlNode) {
    TiXmlNode* other_this = (TiXmlNode*)from_this;
    return (TiXmlDeclaration*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TiXmlNode
 */
/**
 * Python function wrapper for:
 * char const *TiXmlNode::Value(void) const
 */
static PyObject *Dtool_TiXmlNode_Value_16(PyObject *self, PyObject *) {
  TiXmlNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlNode)) {
    return nullptr;
  }
  // 1-char const *TiXmlNode::Value(void) const
  char const *return_value = ((*(const TiXmlNode*)local_this).Value)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlNode_Value_16_comment =
  "C++ Interface:\n"
  "Value(TiXmlNode self)\n"
  "\n"
  "/** The meaning of 'value' changes for the specific type of\n"
  "        TiXmlNode.\n"
  "        @verbatim\n"
  "        Document:   filename of the xml file\n"
  "        Element:    name of the element\n"
  "        Comment:    the comment text\n"
  "        Unknown:    the tag contents\n"
  "        Text:       the text string\n"
  "        @endverbatim\n"
  "\n"
  "        The subclasses will wrap this function.\n"
  "    */";
#else
static const char *Dtool_TiXmlNode_Value_16_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string const &TiXmlNode::ValueStr(void) const
 */
static PyObject *Dtool_TiXmlNode_ValueStr_17(PyObject *self, PyObject *) {
  TiXmlNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlNode)) {
    return nullptr;
  }
  // 1-std::string const &TiXmlNode::ValueStr(void) const
  std::string const &return_value = ((*(const TiXmlNode*)local_this).ValueStr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlNode_ValueStr_17_comment =
  "C++ Interface:\n"
  "ValueStr(TiXmlNode self)\n"
  "\n"
  "/** Return Value() as a std::string. If you only use STL,\n"
  "        this is more efficient than calling Value().\n"
  "        Only available in STL mode.\n"
  "    */";
#else
static const char *Dtool_TiXmlNode_ValueStr_17_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string const &TiXmlNode::ValueTStr(void) const
 */
static PyObject *Dtool_TiXmlNode_ValueTStr_18(PyObject *self, PyObject *) {
  TiXmlNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlNode)) {
    return nullptr;
  }
  // 1-std::string const &TiXmlNode::ValueTStr(void) const
  std::string const &return_value = ((*(const TiXmlNode*)local_this).ValueTStr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlNode_ValueTStr_18_comment =
  "C++ Interface:\n"
  "ValueTStr(TiXmlNode self)\n";
#else
static const char *Dtool_TiXmlNode_ValueTStr_18_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TiXmlNode::SetValue(char const *_value)
 * void TiXmlNode::SetValue(std::string const &_value)
 */
static PyObject *Dtool_TiXmlNode_SetValue_19(PyObject *self, PyObject *arg) {
  TiXmlNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlNode, (void **)&local_this, "TiXmlNode.SetValue")) {
    return nullptr;
  }
  {
    // -2 void TiXmlNode::SetValue(std::string const &_value)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      ((*local_this).SetValue)(std::string(param1_str, param1_len));
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  {
    // -2 void TiXmlNode::SetValue(char const *_value)
    char const *param1;
    if (PyArg_Parse(arg, "z:SetValue", &param1)) {
      ((*local_this).SetValue)((char const *)param1);
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  // No coercion possible: void TiXmlNode::SetValue(std::string const &_value)
  // No coercion possible: void TiXmlNode::SetValue(char const *_value)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetValue(const TiXmlNode self, str _value)\n"
      "SetValue(const TiXmlNode self, str _value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlNode_SetValue_19_comment =
  "C++ Interface:\n"
  "SetValue(const TiXmlNode self, str _value)\n"
  "SetValue(const TiXmlNode self, str _value)\n"
  "\n"
  "/** Changes the value of the node. Defined as:\n"
  "        @verbatim\n"
  "        Document:   filename of the xml file\n"
  "        Element:    name of the element\n"
  "        Comment:    the comment text\n"
  "        Unknown:    the tag contents\n"
  "        Text:       the text string\n"
  "        @endverbatim\n"
  "    */\n"
  "\n"
  "/// STL std::string form.";
#else
static const char *Dtool_TiXmlNode_SetValue_19_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TiXmlNode::Clear(void)
 */
static PyObject *Dtool_TiXmlNode_Clear_20(PyObject *self, PyObject *) {
  TiXmlNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlNode, (void **)&local_this, "TiXmlNode.Clear")) {
    return nullptr;
  }
  // 1-void TiXmlNode::Clear(void)
  ((*local_this).Clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TiXmlNode_Clear_20_comment =
  "C++ Interface:\n"
  "Clear(const TiXmlNode self)\n"
  "\n"
  "/// Delete all the children of this node. Does not affect 'this'.";
#else
static const char *Dtool_TiXmlNode_Clear_20_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlNode *TiXmlNode::Parent(void)
 * TiXmlNode const *TiXmlNode::Parent(void) const
 */
static PyObject *Dtool_TiXmlNode_Parent_21(PyObject *self, PyObject *) {
  TiXmlNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlNode)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 TiXmlNode *TiXmlNode::Parent(void)
    TiXmlNode *return_value = ((*local_this).Parent)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, false);
  }

  {
    // -2 TiXmlNode const *TiXmlNode::Parent(void) const
    TiXmlNode const *return_value = ((*(const TiXmlNode*)local_this).Parent)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, true);
  }

  // No coercion possible: TiXmlNode *TiXmlNode::Parent(void)
  // No coercion possible: TiXmlNode const *TiXmlNode::Parent(void) const
}

#ifndef NDEBUG
static const char *Dtool_TiXmlNode_Parent_21_comment =
  "C++ Interface:\n"
  "Parent(const TiXmlNode self)\n"
  "Parent(TiXmlNode self)\n"
  "\n"
  "/// One step up the DOM.";
#else
static const char *Dtool_TiXmlNode_Parent_21_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlNode *TiXmlNode::FirstChild(void)
 * TiXmlNode const *TiXmlNode::FirstChild(void) const
 * TiXmlNode *TiXmlNode::FirstChild(char const *_value)
 * TiXmlNode const *TiXmlNode::FirstChild(char const *value) const
 * TiXmlNode *TiXmlNode::FirstChild(std::string const &_value)
 * TiXmlNode const *TiXmlNode::FirstChild(std::string const &_value) const
 */
static PyObject *Dtool_TiXmlNode_FirstChild_22(PyObject *self, PyObject *args) {
  TiXmlNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlNode)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      if (!DtoolInstance_IS_CONST(self)) {
        // -2 TiXmlNode *TiXmlNode::FirstChild(void)
        TiXmlNode *return_value = ((*local_this).FirstChild)();
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, false);
      }

      {
        // -2 TiXmlNode const *TiXmlNode::FirstChild(void) const
        TiXmlNode const *return_value = ((*(const TiXmlNode*)local_this).FirstChild)();
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, true);
      }

      // No coercion possible: TiXmlNode *TiXmlNode::FirstChild(void)
      // No coercion possible: TiXmlNode const *TiXmlNode::FirstChild(void) const
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      if (!DtoolInstance_IS_CONST(self)) {
        // -2 TiXmlNode *TiXmlNode::FirstChild(std::string const &_value)
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
        param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
          param1_str = nullptr;
        }
#endif
        if (param1_str != nullptr) {
          TiXmlNode *return_value = ((*local_this).FirstChild)(std::string(param1_str, param1_len));
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, false);
        }
        PyErr_Clear();
      }

      if (!DtoolInstance_IS_CONST(self)) {
        // -2 TiXmlNode *TiXmlNode::FirstChild(char const *_value)
        char const *param1;
        if (PyArg_Parse(arg, "z:FirstChild", &param1)) {
          TiXmlNode *return_value = ((*local_this).FirstChild)((char const *)param1);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, false);
        }
        PyErr_Clear();
      }

      {
        // -2 TiXmlNode const *TiXmlNode::FirstChild(std::string const &_value) const
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
        param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
          param1_str = nullptr;
        }
#endif
        if (param1_str != nullptr) {
          TiXmlNode const *return_value = ((*(const TiXmlNode*)local_this).FirstChild)(std::string(param1_str, param1_len));
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, true);
        }
        PyErr_Clear();
      }

      {
        // -2 TiXmlNode const *TiXmlNode::FirstChild(char const *value) const
        char const *param1;
        if (PyArg_Parse(arg, "z:FirstChild", &param1)) {
          TiXmlNode const *return_value = ((*(const TiXmlNode*)local_this).FirstChild)((char const *)param1);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, true);
        }
        PyErr_Clear();
      }

      // No coercion possible: TiXmlNode *TiXmlNode::FirstChild(std::string const &_value)
      // No coercion possible: TiXmlNode *TiXmlNode::FirstChild(char const *_value)
      // No coercion possible: TiXmlNode const *TiXmlNode::FirstChild(std::string const &_value) const
      // No coercion possible: TiXmlNode const *TiXmlNode::FirstChild(char const *value) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "FirstChild() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "FirstChild(const TiXmlNode self)\n"
      "FirstChild(TiXmlNode self)\n"
      "FirstChild(const TiXmlNode self, str _value)\n"
      "FirstChild(const TiXmlNode self, str _value)\n"
      "FirstChild(TiXmlNode self, str _value)\n"
      "FirstChild(TiXmlNode self, str value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlNode_FirstChild_22_comment =
  "C++ Interface:\n"
  "FirstChild(const TiXmlNode self)\n"
  "FirstChild(TiXmlNode self)\n"
  "FirstChild(const TiXmlNode self, str _value)\n"
  "FirstChild(const TiXmlNode self, str _value)\n"
  "FirstChild(TiXmlNode self, str _value)\n"
  "FirstChild(TiXmlNode self, str value)\n"
  "\n"
  "///< The first child of this node. Will be null if there are no children.\n"
  "\n"
  "///< The first child of this node. Will be null if there are no children.\n"
  "\n"
  "///< The first child of this node with the matching 'value'. Will be null if none found.\n"
  "/// The first child of this node with the matching 'value'. Will be null if none found.\n"
  "\n"
  "///< STL std::string form.\n"
  "\n"
  "///< STL std::string form.";
#else
static const char *Dtool_TiXmlNode_FirstChild_22_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlNode *TiXmlNode::LastChild(void)
 * TiXmlNode const *TiXmlNode::LastChild(void) const
 * TiXmlNode *TiXmlNode::LastChild(char const *_value)
 * TiXmlNode const *TiXmlNode::LastChild(char const *value) const
 * TiXmlNode *TiXmlNode::LastChild(std::string const &_value)
 * TiXmlNode const *TiXmlNode::LastChild(std::string const &_value) const
 */
static PyObject *Dtool_TiXmlNode_LastChild_23(PyObject *self, PyObject *args) {
  TiXmlNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlNode)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      if (!DtoolInstance_IS_CONST(self)) {
        // -2 TiXmlNode *TiXmlNode::LastChild(void)
        TiXmlNode *return_value = ((*local_this).LastChild)();
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, false);
      }

      {
        // -2 TiXmlNode const *TiXmlNode::LastChild(void) const
        TiXmlNode const *return_value = ((*(const TiXmlNode*)local_this).LastChild)();
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, true);
      }

      // No coercion possible: TiXmlNode *TiXmlNode::LastChild(void)
      // No coercion possible: TiXmlNode const *TiXmlNode::LastChild(void) const
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      if (!DtoolInstance_IS_CONST(self)) {
        // -2 TiXmlNode *TiXmlNode::LastChild(std::string const &_value)
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
        param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
          param1_str = nullptr;
        }
#endif
        if (param1_str != nullptr) {
          TiXmlNode *return_value = ((*local_this).LastChild)(std::string(param1_str, param1_len));
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, false);
        }
        PyErr_Clear();
      }

      if (!DtoolInstance_IS_CONST(self)) {
        // -2 TiXmlNode *TiXmlNode::LastChild(char const *_value)
        char const *param1;
        if (PyArg_Parse(arg, "z:LastChild", &param1)) {
          TiXmlNode *return_value = ((*local_this).LastChild)((char const *)param1);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, false);
        }
        PyErr_Clear();
      }

      {
        // -2 TiXmlNode const *TiXmlNode::LastChild(std::string const &_value) const
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
        param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
          param1_str = nullptr;
        }
#endif
        if (param1_str != nullptr) {
          TiXmlNode const *return_value = ((*(const TiXmlNode*)local_this).LastChild)(std::string(param1_str, param1_len));
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, true);
        }
        PyErr_Clear();
      }

      {
        // -2 TiXmlNode const *TiXmlNode::LastChild(char const *value) const
        char const *param1;
        if (PyArg_Parse(arg, "z:LastChild", &param1)) {
          TiXmlNode const *return_value = ((*(const TiXmlNode*)local_this).LastChild)((char const *)param1);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, true);
        }
        PyErr_Clear();
      }

      // No coercion possible: TiXmlNode *TiXmlNode::LastChild(std::string const &_value)
      // No coercion possible: TiXmlNode *TiXmlNode::LastChild(char const *_value)
      // No coercion possible: TiXmlNode const *TiXmlNode::LastChild(std::string const &_value) const
      // No coercion possible: TiXmlNode const *TiXmlNode::LastChild(char const *value) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "LastChild() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "LastChild(const TiXmlNode self)\n"
      "LastChild(TiXmlNode self)\n"
      "LastChild(const TiXmlNode self, str _value)\n"
      "LastChild(const TiXmlNode self, str _value)\n"
      "LastChild(TiXmlNode self, str _value)\n"
      "LastChild(TiXmlNode self, str value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlNode_LastChild_23_comment =
  "C++ Interface:\n"
  "LastChild(const TiXmlNode self)\n"
  "LastChild(TiXmlNode self)\n"
  "LastChild(const TiXmlNode self, str _value)\n"
  "LastChild(const TiXmlNode self, str _value)\n"
  "LastChild(TiXmlNode self, str _value)\n"
  "LastChild(TiXmlNode self, str value)\n"
  "\n"
  "/// The last child of this node. Will be null if there are no children.\n"
  "\n"
  "/// The last child of this node. Will be null if there are no children.\n"
  "\n"
  "/// The last child of this node matching 'value'. Will be null if there are no children.\n"
  "\n"
  "/// The last child of this node matching 'value'. Will be null if there are no children.\n"
  "\n"
  "///< STL std::string form.\n"
  "\n"
  "///< STL std::string form.";
#else
static const char *Dtool_TiXmlNode_LastChild_23_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlNode *TiXmlNode::IterateChildren(TiXmlNode const *previous)
 * TiXmlNode const *TiXmlNode::IterateChildren(TiXmlNode const *previous) const
 * TiXmlNode *TiXmlNode::IterateChildren(char const *_value, TiXmlNode const *previous)
 * TiXmlNode const *TiXmlNode::IterateChildren(char const *value, TiXmlNode const *previous) const
 * TiXmlNode *TiXmlNode::IterateChildren(std::string const &_value, TiXmlNode const *previous)
 * TiXmlNode const *TiXmlNode::IterateChildren(std::string const &_value, TiXmlNode const *previous) const
 */
static PyObject *Dtool_TiXmlNode_IterateChildren_24(PyObject *self, PyObject *args, PyObject *kwds) {
  TiXmlNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlNode)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "previous")) {
        if (!DtoolInstance_IS_CONST(self)) {
          // -2 TiXmlNode *TiXmlNode::IterateChildren(TiXmlNode const *previous)
          TiXmlNode const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TiXmlNode);
          if (arg_this != nullptr) {
            TiXmlNode *return_value = ((*local_this).IterateChildren)(arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, false);
          }
        }

        {
          // -2 TiXmlNode const *TiXmlNode::IterateChildren(TiXmlNode const *previous) const
          TiXmlNode const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TiXmlNode);
          if (arg_this != nullptr) {
            TiXmlNode const *return_value = ((*(const TiXmlNode*)local_this).IterateChildren)(arg_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, true);
          }
        }

        // No coercion possible: TiXmlNode *TiXmlNode::IterateChildren(TiXmlNode const *previous)
        // No coercion possible: TiXmlNode const *TiXmlNode::IterateChildren(TiXmlNode const *previous) const
      }
    }
    break;
  case 2:
    {
      if (!DtoolInstance_IS_CONST(self)) {
        // -2 TiXmlNode *TiXmlNode::IterateChildren(std::string const &_value, TiXmlNode const *previous)
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        PyObject *param2;
        static const char *keyword_list[] = {"_value", "previous", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:IterateChildren", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
          TiXmlNode const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_TiXmlNode);
          if (param2_this != nullptr) {
            TiXmlNode *return_value = ((*local_this).IterateChildren)(std::string(param1_str, param1_len), param2_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, false);
          }
        }
        PyErr_Clear();
      }

      if (!DtoolInstance_IS_CONST(self)) {
        // -2 TiXmlNode *TiXmlNode::IterateChildren(char const *_value, TiXmlNode const *previous)
        char const *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"_value", "previous", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "zO:IterateChildren", (char **)keyword_list, &param1, &param2)) {
          TiXmlNode const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_TiXmlNode);
          if (param2_this != nullptr) {
            TiXmlNode *return_value = ((*local_this).IterateChildren)((char const *)param1, param2_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 TiXmlNode const *TiXmlNode::IterateChildren(std::string const &_value, TiXmlNode const *previous) const
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        PyObject *param2;
        static const char *keyword_list[] = {"_value", "previous", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:IterateChildren", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
          TiXmlNode const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_TiXmlNode);
          if (param2_this != nullptr) {
            TiXmlNode const *return_value = ((*(const TiXmlNode*)local_this).IterateChildren)(std::string(param1_str, param1_len), param2_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, true);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 TiXmlNode const *TiXmlNode::IterateChildren(char const *value, TiXmlNode const *previous) const
        char const *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"value", "previous", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "zO:IterateChildren", (char **)keyword_list, &param1, &param2)) {
          TiXmlNode const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_TiXmlNode);
          if (param2_this != nullptr) {
            TiXmlNode const *return_value = ((*(const TiXmlNode*)local_this).IterateChildren)((char const *)param1, param2_this);
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, true);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: TiXmlNode *TiXmlNode::IterateChildren(std::string const &_value, TiXmlNode const *previous)
      // No coercion possible: TiXmlNode *TiXmlNode::IterateChildren(char const *_value, TiXmlNode const *previous)
      // No coercion possible: TiXmlNode const *TiXmlNode::IterateChildren(std::string const &_value, TiXmlNode const *previous) const
      // No coercion possible: TiXmlNode const *TiXmlNode::IterateChildren(char const *value, TiXmlNode const *previous) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "IterateChildren() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "IterateChildren(const TiXmlNode self, const TiXmlNode previous)\n"
      "IterateChildren(TiXmlNode self, const TiXmlNode previous)\n"
      "IterateChildren(const TiXmlNode self, str _value, const TiXmlNode previous)\n"
      "IterateChildren(const TiXmlNode self, str _value, const TiXmlNode previous)\n"
      "IterateChildren(TiXmlNode self, str _value, const TiXmlNode previous)\n"
      "IterateChildren(TiXmlNode self, str value, const TiXmlNode previous)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlNode_IterateChildren_24_comment =
  "C++ Interface:\n"
  "IterateChildren(const TiXmlNode self, const TiXmlNode previous)\n"
  "IterateChildren(TiXmlNode self, const TiXmlNode previous)\n"
  "IterateChildren(const TiXmlNode self, str _value, const TiXmlNode previous)\n"
  "IterateChildren(const TiXmlNode self, str _value, const TiXmlNode previous)\n"
  "IterateChildren(TiXmlNode self, str _value, const TiXmlNode previous)\n"
  "IterateChildren(TiXmlNode self, str value, const TiXmlNode previous)\n"
  "\n"
  "/** An alternate way to walk the children of a node.\n"
  "        One way to iterate over nodes is:\n"
  "        @verbatim\n"
  "            for( child = parent->FirstChild(); child; child = child->NextSibling() )\n"
  "        @endverbatim\n"
  "\n"
  "        IterateChildren does the same thing with the syntax:\n"
  "        @verbatim\n"
  "            child = 0;\n"
  "            while( child = parent->IterateChildren( child ) )\n"
  "        @endverbatim\n"
  "\n"
  "        IterateChildren takes the previous child as input and finds\n"
  "        the next one. If the previous child is null, it returns the\n"
  "        first. IterateChildren will return null when done.\n"
  "    */\n"
  "\n"
  "/// This flavor of IterateChildren searches for children with a particular 'value'\n"
  "\n"
  "///< STL std::string form.\n"
  "\n"
  "///< STL std::string form.";
#else
static const char *Dtool_TiXmlNode_IterateChildren_24_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlNode *TiXmlNode::InsertEndChild(TiXmlNode const &addThis)
 */
static PyObject *Dtool_TiXmlNode_InsertEndChild_25(PyObject *self, PyObject *arg) {
  TiXmlNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlNode, (void **)&local_this, "TiXmlNode.InsertEndChild")) {
    return nullptr;
  }
  // 1-TiXmlNode *TiXmlNode::InsertEndChild(TiXmlNode const &addThis)
  TiXmlNode const *arg_this = (TiXmlNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TiXmlNode, 1, "TiXmlNode.InsertEndChild", true, true);
  if (arg_this != nullptr) {
    TiXmlNode *return_value = ((*local_this).InsertEndChild)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "InsertEndChild(const TiXmlNode self, const TiXmlNode addThis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlNode_InsertEndChild_25_comment =
  "C++ Interface:\n"
  "InsertEndChild(const TiXmlNode self, const TiXmlNode addThis)\n"
  "\n"
  "/** Add a new node related to this. Adds a child past the LastChild.\n"
  "        Returns a pointer to the new object or NULL if an error occured.\n"
  "    */";
#else
static const char *Dtool_TiXmlNode_InsertEndChild_25_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlNode *TiXmlNode::InsertBeforeChild(TiXmlNode *beforeThis, TiXmlNode const &addThis)
 */
static PyObject *Dtool_TiXmlNode_InsertBeforeChild_26(PyObject *self, PyObject *args, PyObject *kwds) {
  TiXmlNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlNode, (void **)&local_this, "TiXmlNode.InsertBeforeChild")) {
    return nullptr;
  }
  // 1-TiXmlNode *TiXmlNode::InsertBeforeChild(TiXmlNode *beforeThis, TiXmlNode const &addThis)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"beforeThis", "addThis", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:InsertBeforeChild", (char **)keyword_list, &param1, &param2)) {
    TiXmlNode *param1_this = (TiXmlNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TiXmlNode, 1, "TiXmlNode.InsertBeforeChild", false, true);
    TiXmlNode const *param2_this = (TiXmlNode *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TiXmlNode, 2, "TiXmlNode.InsertBeforeChild", true, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      TiXmlNode *return_value = ((*local_this).InsertBeforeChild)(param1_this, *param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "InsertBeforeChild(const TiXmlNode self, TiXmlNode beforeThis, const TiXmlNode addThis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlNode_InsertBeforeChild_26_comment =
  "C++ Interface:\n"
  "InsertBeforeChild(const TiXmlNode self, TiXmlNode beforeThis, const TiXmlNode addThis)\n"
  "\n"
  "/** Add a new node related to this. Adds a child before the specified child.\n"
  "        Returns a pointer to the new object or NULL if an error occured.\n"
  "    */";
#else
static const char *Dtool_TiXmlNode_InsertBeforeChild_26_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlNode *TiXmlNode::InsertAfterChild(TiXmlNode *afterThis, TiXmlNode const &addThis)
 */
static PyObject *Dtool_TiXmlNode_InsertAfterChild_27(PyObject *self, PyObject *args, PyObject *kwds) {
  TiXmlNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlNode, (void **)&local_this, "TiXmlNode.InsertAfterChild")) {
    return nullptr;
  }
  // 1-TiXmlNode *TiXmlNode::InsertAfterChild(TiXmlNode *afterThis, TiXmlNode const &addThis)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"afterThis", "addThis", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:InsertAfterChild", (char **)keyword_list, &param1, &param2)) {
    TiXmlNode *param1_this = (TiXmlNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TiXmlNode, 1, "TiXmlNode.InsertAfterChild", false, true);
    TiXmlNode const *param2_this = (TiXmlNode *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TiXmlNode, 2, "TiXmlNode.InsertAfterChild", true, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      TiXmlNode *return_value = ((*local_this).InsertAfterChild)(param1_this, *param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "InsertAfterChild(const TiXmlNode self, TiXmlNode afterThis, const TiXmlNode addThis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlNode_InsertAfterChild_27_comment =
  "C++ Interface:\n"
  "InsertAfterChild(const TiXmlNode self, TiXmlNode afterThis, const TiXmlNode addThis)\n"
  "\n"
  "/** Add a new node related to this. Adds a child after the specified child.\n"
  "        Returns a pointer to the new object or NULL if an error occured.\n"
  "    */";
#else
static const char *Dtool_TiXmlNode_InsertAfterChild_27_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlNode *TiXmlNode::ReplaceChild(TiXmlNode *replaceThis, TiXmlNode const &withThis)
 */
static PyObject *Dtool_TiXmlNode_ReplaceChild_28(PyObject *self, PyObject *args, PyObject *kwds) {
  TiXmlNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlNode, (void **)&local_this, "TiXmlNode.ReplaceChild")) {
    return nullptr;
  }
  // 1-TiXmlNode *TiXmlNode::ReplaceChild(TiXmlNode *replaceThis, TiXmlNode const &withThis)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"replaceThis", "withThis", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:ReplaceChild", (char **)keyword_list, &param1, &param2)) {
    TiXmlNode *param1_this = (TiXmlNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TiXmlNode, 1, "TiXmlNode.ReplaceChild", false, true);
    TiXmlNode const *param2_this = (TiXmlNode *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TiXmlNode, 2, "TiXmlNode.ReplaceChild", true, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      TiXmlNode *return_value = ((*local_this).ReplaceChild)(param1_this, *param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ReplaceChild(const TiXmlNode self, TiXmlNode replaceThis, const TiXmlNode withThis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlNode_ReplaceChild_28_comment =
  "C++ Interface:\n"
  "ReplaceChild(const TiXmlNode self, TiXmlNode replaceThis, const TiXmlNode withThis)\n"
  "\n"
  "/** Replace a child of this node.\n"
  "        Returns a pointer to the new object or NULL if an error occured.\n"
  "    */";
#else
static const char *Dtool_TiXmlNode_ReplaceChild_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool TiXmlNode::RemoveChild(TiXmlNode *removeThis)
 */
static PyObject *Dtool_TiXmlNode_RemoveChild_29(PyObject *self, PyObject *arg) {
  TiXmlNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlNode, (void **)&local_this, "TiXmlNode.RemoveChild")) {
    return nullptr;
  }
  // 1-bool TiXmlNode::RemoveChild(TiXmlNode *removeThis)
  TiXmlNode *arg_this = (TiXmlNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TiXmlNode, 1, "TiXmlNode.RemoveChild", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).RemoveChild)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "RemoveChild(const TiXmlNode self, TiXmlNode removeThis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlNode_RemoveChild_29_comment =
  "C++ Interface:\n"
  "RemoveChild(const TiXmlNode self, TiXmlNode removeThis)\n"
  "\n"
  "/// Delete a child of this node.";
#else
static const char *Dtool_TiXmlNode_RemoveChild_29_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlNode *TiXmlNode::PreviousSibling(void)
 * TiXmlNode const *TiXmlNode::PreviousSibling(void) const
 * TiXmlNode *TiXmlNode::PreviousSibling(char const *_prev)
 * TiXmlNode const *TiXmlNode::PreviousSibling(char const *) const
 * TiXmlNode *TiXmlNode::PreviousSibling(std::string const &_value)
 * TiXmlNode const *TiXmlNode::PreviousSibling(std::string const &_value) const
 */
static PyObject *Dtool_TiXmlNode_PreviousSibling_30(PyObject *self, PyObject *args) {
  TiXmlNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlNode)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      if (!DtoolInstance_IS_CONST(self)) {
        // -2 TiXmlNode *TiXmlNode::PreviousSibling(void)
        TiXmlNode *return_value = ((*local_this).PreviousSibling)();
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, false);
      }

      {
        // -2 TiXmlNode const *TiXmlNode::PreviousSibling(void) const
        TiXmlNode const *return_value = ((*(const TiXmlNode*)local_this).PreviousSibling)();
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, true);
      }

      // No coercion possible: TiXmlNode *TiXmlNode::PreviousSibling(void)
      // No coercion possible: TiXmlNode const *TiXmlNode::PreviousSibling(void) const
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      if (!DtoolInstance_IS_CONST(self)) {
        // -2 TiXmlNode *TiXmlNode::PreviousSibling(std::string const &_value)
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
        param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
          param1_str = nullptr;
        }
#endif
        if (param1_str != nullptr) {
          TiXmlNode *return_value = ((*local_this).PreviousSibling)(std::string(param1_str, param1_len));
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, false);
        }
        PyErr_Clear();
      }

      if (!DtoolInstance_IS_CONST(self)) {
        // -2 TiXmlNode *TiXmlNode::PreviousSibling(char const *_prev)
        char const *param1;
        if (PyArg_Parse(arg, "z:PreviousSibling", &param1)) {
          TiXmlNode *return_value = ((*local_this).PreviousSibling)((char const *)param1);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, false);
        }
        PyErr_Clear();
      }

      {
        // -2 TiXmlNode const *TiXmlNode::PreviousSibling(std::string const &_value) const
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
        param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
          param1_str = nullptr;
        }
#endif
        if (param1_str != nullptr) {
          TiXmlNode const *return_value = ((*(const TiXmlNode*)local_this).PreviousSibling)(std::string(param1_str, param1_len));
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, true);
        }
        PyErr_Clear();
      }

      {
        // -2 TiXmlNode const *TiXmlNode::PreviousSibling(char const *) const
        char const *param1;
        if (PyArg_Parse(arg, "z:PreviousSibling", &param1)) {
          TiXmlNode const *return_value = ((*(const TiXmlNode*)local_this).PreviousSibling)((char const *)param1);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, true);
        }
        PyErr_Clear();
      }

      // No coercion possible: TiXmlNode *TiXmlNode::PreviousSibling(std::string const &_value)
      // No coercion possible: TiXmlNode *TiXmlNode::PreviousSibling(char const *_prev)
      // No coercion possible: TiXmlNode const *TiXmlNode::PreviousSibling(std::string const &_value) const
      // No coercion possible: TiXmlNode const *TiXmlNode::PreviousSibling(char const *) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "PreviousSibling() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "PreviousSibling(const TiXmlNode self)\n"
      "PreviousSibling(TiXmlNode self)\n"
      "PreviousSibling(const TiXmlNode self, str _value)\n"
      "PreviousSibling(const TiXmlNode self, str _prev)\n"
      "PreviousSibling(TiXmlNode self, str _value)\n"
      "PreviousSibling(TiXmlNode self, str param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlNode_PreviousSibling_30_comment =
  "C++ Interface:\n"
  "PreviousSibling(const TiXmlNode self)\n"
  "PreviousSibling(TiXmlNode self)\n"
  "PreviousSibling(const TiXmlNode self, str _value)\n"
  "PreviousSibling(const TiXmlNode self, str _prev)\n"
  "PreviousSibling(TiXmlNode self, str _value)\n"
  "PreviousSibling(TiXmlNode self, str param0)\n"
  "\n"
  "/// Navigate to a sibling node.\n"
  "\n"
  "/// Navigate to a sibling node.\n"
  "\n"
  "///< STL std::string form.\n"
  "\n"
  "///< STL std::string form.";
#else
static const char *Dtool_TiXmlNode_PreviousSibling_30_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlNode *TiXmlNode::NextSibling(void)
 * TiXmlNode const *TiXmlNode::NextSibling(void) const
 * TiXmlNode *TiXmlNode::NextSibling(char const *_next)
 * TiXmlNode const *TiXmlNode::NextSibling(char const *) const
 * TiXmlNode *TiXmlNode::NextSibling(std::string const &_value)
 * TiXmlNode const *TiXmlNode::NextSibling(std::string const &_value) const
 */
static PyObject *Dtool_TiXmlNode_NextSibling_31(PyObject *self, PyObject *args) {
  TiXmlNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlNode)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      if (!DtoolInstance_IS_CONST(self)) {
        // -2 TiXmlNode *TiXmlNode::NextSibling(void)
        TiXmlNode *return_value = ((*local_this).NextSibling)();
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, false);
      }

      {
        // -2 TiXmlNode const *TiXmlNode::NextSibling(void) const
        TiXmlNode const *return_value = ((*(const TiXmlNode*)local_this).NextSibling)();
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, true);
      }

      // No coercion possible: TiXmlNode *TiXmlNode::NextSibling(void)
      // No coercion possible: TiXmlNode const *TiXmlNode::NextSibling(void) const
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      if (!DtoolInstance_IS_CONST(self)) {
        // -2 TiXmlNode *TiXmlNode::NextSibling(std::string const &_value)
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
        param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
          param1_str = nullptr;
        }
#endif
        if (param1_str != nullptr) {
          TiXmlNode *return_value = ((*local_this).NextSibling)(std::string(param1_str, param1_len));
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, false);
        }
        PyErr_Clear();
      }

      if (!DtoolInstance_IS_CONST(self)) {
        // -2 TiXmlNode *TiXmlNode::NextSibling(char const *_next)
        char const *param1;
        if (PyArg_Parse(arg, "z:NextSibling", &param1)) {
          TiXmlNode *return_value = ((*local_this).NextSibling)((char const *)param1);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, false);
        }
        PyErr_Clear();
      }

      {
        // -2 TiXmlNode const *TiXmlNode::NextSibling(std::string const &_value) const
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
        param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
          param1_str = nullptr;
        }
#endif
        if (param1_str != nullptr) {
          TiXmlNode const *return_value = ((*(const TiXmlNode*)local_this).NextSibling)(std::string(param1_str, param1_len));
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, true);
        }
        PyErr_Clear();
      }

      {
        // -2 TiXmlNode const *TiXmlNode::NextSibling(char const *) const
        char const *param1;
        if (PyArg_Parse(arg, "z:NextSibling", &param1)) {
          TiXmlNode const *return_value = ((*(const TiXmlNode*)local_this).NextSibling)((char const *)param1);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, true);
        }
        PyErr_Clear();
      }

      // No coercion possible: TiXmlNode *TiXmlNode::NextSibling(std::string const &_value)
      // No coercion possible: TiXmlNode *TiXmlNode::NextSibling(char const *_next)
      // No coercion possible: TiXmlNode const *TiXmlNode::NextSibling(std::string const &_value) const
      // No coercion possible: TiXmlNode const *TiXmlNode::NextSibling(char const *) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "NextSibling() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "NextSibling(const TiXmlNode self)\n"
      "NextSibling(TiXmlNode self)\n"
      "NextSibling(const TiXmlNode self, str _value)\n"
      "NextSibling(const TiXmlNode self, str _next)\n"
      "NextSibling(TiXmlNode self, str _value)\n"
      "NextSibling(TiXmlNode self, str param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlNode_NextSibling_31_comment =
  "C++ Interface:\n"
  "NextSibling(const TiXmlNode self)\n"
  "NextSibling(TiXmlNode self)\n"
  "NextSibling(const TiXmlNode self, str _value)\n"
  "NextSibling(const TiXmlNode self, str _next)\n"
  "NextSibling(TiXmlNode self, str _value)\n"
  "NextSibling(TiXmlNode self, str param0)\n"
  "\n"
  "///< STL std::string form.\n"
  "\n"
  "///< STL std::string form.\n"
  "\n"
  "/// Navigate to a sibling node.\n"
  "\n"
  "/// Navigate to a sibling node with the given 'value'.";
#else
static const char *Dtool_TiXmlNode_NextSibling_31_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlElement *TiXmlNode::NextSiblingElement(void)
 * TiXmlElement const *TiXmlNode::NextSiblingElement(void) const
 * TiXmlElement *TiXmlNode::NextSiblingElement(char const *_next)
 * TiXmlElement const *TiXmlNode::NextSiblingElement(char const *) const
 * TiXmlElement *TiXmlNode::NextSiblingElement(std::string const &_value)
 * TiXmlElement const *TiXmlNode::NextSiblingElement(std::string const &_value) const
 */
static PyObject *Dtool_TiXmlNode_NextSiblingElement_32(PyObject *self, PyObject *args) {
  TiXmlNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlNode)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      if (!DtoolInstance_IS_CONST(self)) {
        // -2 TiXmlElement *TiXmlNode::NextSiblingElement(void)
        TiXmlElement *return_value = ((*local_this).NextSiblingElement)();
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlElement, false, false);
      }

      {
        // -2 TiXmlElement const *TiXmlNode::NextSiblingElement(void) const
        TiXmlElement const *return_value = ((*(const TiXmlNode*)local_this).NextSiblingElement)();
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlElement, false, true);
      }

      // No coercion possible: TiXmlElement *TiXmlNode::NextSiblingElement(void)
      // No coercion possible: TiXmlElement const *TiXmlNode::NextSiblingElement(void) const
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      if (!DtoolInstance_IS_CONST(self)) {
        // -2 TiXmlElement *TiXmlNode::NextSiblingElement(std::string const &_value)
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
        param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
          param1_str = nullptr;
        }
#endif
        if (param1_str != nullptr) {
          TiXmlElement *return_value = ((*local_this).NextSiblingElement)(std::string(param1_str, param1_len));
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlElement, false, false);
        }
        PyErr_Clear();
      }

      if (!DtoolInstance_IS_CONST(self)) {
        // -2 TiXmlElement *TiXmlNode::NextSiblingElement(char const *_next)
        char const *param1;
        if (PyArg_Parse(arg, "z:NextSiblingElement", &param1)) {
          TiXmlElement *return_value = ((*local_this).NextSiblingElement)((char const *)param1);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlElement, false, false);
        }
        PyErr_Clear();
      }

      {
        // -2 TiXmlElement const *TiXmlNode::NextSiblingElement(std::string const &_value) const
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
        param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
          param1_str = nullptr;
        }
#endif
        if (param1_str != nullptr) {
          TiXmlElement const *return_value = ((*(const TiXmlNode*)local_this).NextSiblingElement)(std::string(param1_str, param1_len));
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlElement, false, true);
        }
        PyErr_Clear();
      }

      {
        // -2 TiXmlElement const *TiXmlNode::NextSiblingElement(char const *) const
        char const *param1;
        if (PyArg_Parse(arg, "z:NextSiblingElement", &param1)) {
          TiXmlElement const *return_value = ((*(const TiXmlNode*)local_this).NextSiblingElement)((char const *)param1);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlElement, false, true);
        }
        PyErr_Clear();
      }

      // No coercion possible: TiXmlElement *TiXmlNode::NextSiblingElement(std::string const &_value)
      // No coercion possible: TiXmlElement *TiXmlNode::NextSiblingElement(char const *_next)
      // No coercion possible: TiXmlElement const *TiXmlNode::NextSiblingElement(std::string const &_value) const
      // No coercion possible: TiXmlElement const *TiXmlNode::NextSiblingElement(char const *) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "NextSiblingElement() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "NextSiblingElement(const TiXmlNode self)\n"
      "NextSiblingElement(TiXmlNode self)\n"
      "NextSiblingElement(const TiXmlNode self, str _value)\n"
      "NextSiblingElement(const TiXmlNode self, str _next)\n"
      "NextSiblingElement(TiXmlNode self, str _value)\n"
      "NextSiblingElement(TiXmlNode self, str param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlNode_NextSiblingElement_32_comment =
  "C++ Interface:\n"
  "NextSiblingElement(const TiXmlNode self)\n"
  "NextSiblingElement(TiXmlNode self)\n"
  "NextSiblingElement(const TiXmlNode self, str _value)\n"
  "NextSiblingElement(const TiXmlNode self, str _next)\n"
  "NextSiblingElement(TiXmlNode self, str _value)\n"
  "NextSiblingElement(TiXmlNode self, str param0)\n"
  "\n"
  "/** Convenience function to get through elements.\n"
  "        Calls NextSibling and ToElement. Will skip all non-Element\n"
  "        nodes. Returns 0 if there is not another element.\n"
  "    */\n"
  "\n"
  "/** Convenience function to get through elements.\n"
  "        Calls NextSibling and ToElement. Will skip all non-Element\n"
  "        nodes. Returns 0 if there is not another element.\n"
  "    */\n"
  "\n"
  "///< STL std::string form.\n"
  "\n"
  "///< STL std::string form.";
#else
static const char *Dtool_TiXmlNode_NextSiblingElement_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlElement *TiXmlNode::FirstChildElement(void)
 * TiXmlElement const *TiXmlNode::FirstChildElement(void) const
 * TiXmlElement *TiXmlNode::FirstChildElement(char const *_value)
 * TiXmlElement const *TiXmlNode::FirstChildElement(char const *_value) const
 * TiXmlElement *TiXmlNode::FirstChildElement(std::string const &_value)
 * TiXmlElement const *TiXmlNode::FirstChildElement(std::string const &_value) const
 */
static PyObject *Dtool_TiXmlNode_FirstChildElement_33(PyObject *self, PyObject *args) {
  TiXmlNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlNode)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      if (!DtoolInstance_IS_CONST(self)) {
        // -2 TiXmlElement *TiXmlNode::FirstChildElement(void)
        TiXmlElement *return_value = ((*local_this).FirstChildElement)();
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlElement, false, false);
      }

      {
        // -2 TiXmlElement const *TiXmlNode::FirstChildElement(void) const
        TiXmlElement const *return_value = ((*(const TiXmlNode*)local_this).FirstChildElement)();
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlElement, false, true);
      }

      // No coercion possible: TiXmlElement *TiXmlNode::FirstChildElement(void)
      // No coercion possible: TiXmlElement const *TiXmlNode::FirstChildElement(void) const
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      if (!DtoolInstance_IS_CONST(self)) {
        // -2 TiXmlElement *TiXmlNode::FirstChildElement(std::string const &_value)
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
        param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
          param1_str = nullptr;
        }
#endif
        if (param1_str != nullptr) {
          TiXmlElement *return_value = ((*local_this).FirstChildElement)(std::string(param1_str, param1_len));
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlElement, false, false);
        }
        PyErr_Clear();
      }

      if (!DtoolInstance_IS_CONST(self)) {
        // -2 TiXmlElement *TiXmlNode::FirstChildElement(char const *_value)
        char const *param1;
        if (PyArg_Parse(arg, "z:FirstChildElement", &param1)) {
          TiXmlElement *return_value = ((*local_this).FirstChildElement)((char const *)param1);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlElement, false, false);
        }
        PyErr_Clear();
      }

      {
        // -2 TiXmlElement const *TiXmlNode::FirstChildElement(std::string const &_value) const
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
        param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
          param1_str = nullptr;
        }
#endif
        if (param1_str != nullptr) {
          TiXmlElement const *return_value = ((*(const TiXmlNode*)local_this).FirstChildElement)(std::string(param1_str, param1_len));
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlElement, false, true);
        }
        PyErr_Clear();
      }

      {
        // -2 TiXmlElement const *TiXmlNode::FirstChildElement(char const *_value) const
        char const *param1;
        if (PyArg_Parse(arg, "z:FirstChildElement", &param1)) {
          TiXmlElement const *return_value = ((*(const TiXmlNode*)local_this).FirstChildElement)((char const *)param1);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlElement, false, true);
        }
        PyErr_Clear();
      }

      // No coercion possible: TiXmlElement *TiXmlNode::FirstChildElement(std::string const &_value)
      // No coercion possible: TiXmlElement *TiXmlNode::FirstChildElement(char const *_value)
      // No coercion possible: TiXmlElement const *TiXmlNode::FirstChildElement(std::string const &_value) const
      // No coercion possible: TiXmlElement const *TiXmlNode::FirstChildElement(char const *_value) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "FirstChildElement() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "FirstChildElement(const TiXmlNode self)\n"
      "FirstChildElement(TiXmlNode self)\n"
      "FirstChildElement(const TiXmlNode self, str _value)\n"
      "FirstChildElement(const TiXmlNode self, str _value)\n"
      "FirstChildElement(TiXmlNode self, str _value)\n"
      "FirstChildElement(TiXmlNode self, str _value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlNode_FirstChildElement_33_comment =
  "C++ Interface:\n"
  "FirstChildElement(const TiXmlNode self)\n"
  "FirstChildElement(TiXmlNode self)\n"
  "FirstChildElement(const TiXmlNode self, str _value)\n"
  "FirstChildElement(const TiXmlNode self, str _value)\n"
  "FirstChildElement(TiXmlNode self, str _value)\n"
  "FirstChildElement(TiXmlNode self, str _value)\n"
  "\n"
  "/// Convenience function to get through elements.\n"
  "\n"
  "/// Convenience function to get through elements.\n"
  "\n"
  "///< STL std::string form.\n"
  "\n"
  "///< STL std::string form.";
#else
static const char *Dtool_TiXmlNode_FirstChildElement_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int TiXmlNode::Type(void) const
 */
static PyObject *Dtool_TiXmlNode_Type_34(PyObject *self, PyObject *) {
  TiXmlNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlNode)) {
    return nullptr;
  }
  // 1-int TiXmlNode::Type(void) const
  int return_value = ((*(const TiXmlNode*)local_this).Type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlNode_Type_34_comment =
  "C++ Interface:\n"
  "Type(TiXmlNode self)\n"
  "\n"
  "/** Query the type (as an enumerated value, above) of this node.\n"
  "        The possible types are: DOCUMENT, ELEMENT, COMMENT,\n"
  "                                UNKNOWN, TEXT, and DECLARATION.\n"
  "    */";
#else
static const char *Dtool_TiXmlNode_Type_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlDocument *TiXmlNode::GetDocument(void)
 * TiXmlDocument const *TiXmlNode::GetDocument(void) const
 */
static PyObject *Dtool_TiXmlNode_GetDocument_35(PyObject *self, PyObject *) {
  TiXmlNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlNode)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 TiXmlDocument *TiXmlNode::GetDocument(void)
    TiXmlDocument *return_value = ((*local_this).GetDocument)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlDocument, false, false);
  }

  {
    // -2 TiXmlDocument const *TiXmlNode::GetDocument(void) const
    TiXmlDocument const *return_value = ((*(const TiXmlNode*)local_this).GetDocument)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlDocument, false, true);
  }

  // No coercion possible: TiXmlDocument *TiXmlNode::GetDocument(void)
  // No coercion possible: TiXmlDocument const *TiXmlNode::GetDocument(void) const
}

#ifndef NDEBUG
static const char *Dtool_TiXmlNode_GetDocument_35_comment =
  "C++ Interface:\n"
  "GetDocument(const TiXmlNode self)\n"
  "GetDocument(TiXmlNode self)\n"
  "\n"
  "/** Return a pointer to the Document this node lives in.\n"
  "        Returns null if not in a document.\n"
  "    */";
#else
static const char *Dtool_TiXmlNode_GetDocument_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool TiXmlNode::NoChildren(void) const
 */
static PyObject *Dtool_TiXmlNode_NoChildren_36(PyObject *self, PyObject *) {
  TiXmlNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlNode)) {
    return nullptr;
  }
  // 1-bool TiXmlNode::NoChildren(void) const
  bool return_value = ((*(const TiXmlNode*)local_this).NoChildren)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlNode_NoChildren_36_comment =
  "C++ Interface:\n"
  "NoChildren(TiXmlNode self)\n"
  "\n"
  "/// Returns true if this node has no children.";
#else
static const char *Dtool_TiXmlNode_NoChildren_36_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual TiXmlDocument *TiXmlNode::ToDocument(void)
 * virtual TiXmlDocument const *TiXmlNode::ToDocument(void) const
 */
static PyObject *Dtool_TiXmlNode_ToDocument_37(PyObject *self, PyObject *) {
  TiXmlNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlNode)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 virtual TiXmlDocument *TiXmlNode::ToDocument(void)
    TiXmlDocument *return_value = ((*local_this).ToDocument)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlDocument, false, false);
  }

  {
    // -2 virtual TiXmlDocument const *TiXmlNode::ToDocument(void) const
    TiXmlDocument const *return_value = ((*(const TiXmlNode*)local_this).ToDocument)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlDocument, false, true);
  }

  // No coercion possible: virtual TiXmlDocument *TiXmlNode::ToDocument(void)
  // No coercion possible: virtual TiXmlDocument const *TiXmlNode::ToDocument(void) const
}

#ifndef NDEBUG
static const char *Dtool_TiXmlNode_ToDocument_37_comment =
  "C++ Interface:\n"
  "ToDocument(const TiXmlNode self)\n"
  "ToDocument(TiXmlNode self)\n"
  "\n"
  "///< Cast to a more defined type. Will return null if not of the requested type.\n"
  "\n"
  "///< Cast to a more defined type. Will return null if not of the requested type.";
#else
static const char *Dtool_TiXmlNode_ToDocument_37_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual TiXmlElement *TiXmlNode::ToElement(void)
 * virtual TiXmlElement const *TiXmlNode::ToElement(void) const
 */
static PyObject *Dtool_TiXmlNode_ToElement_38(PyObject *self, PyObject *) {
  TiXmlNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlNode)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 virtual TiXmlElement *TiXmlNode::ToElement(void)
    TiXmlElement *return_value = ((*local_this).ToElement)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlElement, false, false);
  }

  {
    // -2 virtual TiXmlElement const *TiXmlNode::ToElement(void) const
    TiXmlElement const *return_value = ((*(const TiXmlNode*)local_this).ToElement)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlElement, false, true);
  }

  // No coercion possible: virtual TiXmlElement *TiXmlNode::ToElement(void)
  // No coercion possible: virtual TiXmlElement const *TiXmlNode::ToElement(void) const
}

#ifndef NDEBUG
static const char *Dtool_TiXmlNode_ToElement_38_comment =
  "C++ Interface:\n"
  "ToElement(const TiXmlNode self)\n"
  "ToElement(TiXmlNode self)\n"
  "\n"
  "///< Cast to a more defined type. Will return null if not of the requested type.\n"
  "\n"
  "///< Cast to a more defined type. Will return null if not of the requested type.";
#else
static const char *Dtool_TiXmlNode_ToElement_38_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual TiXmlComment *TiXmlNode::ToComment(void)
 * virtual TiXmlComment const *TiXmlNode::ToComment(void) const
 */
static PyObject *Dtool_TiXmlNode_ToComment_39(PyObject *self, PyObject *) {
  TiXmlNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlNode)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 virtual TiXmlComment *TiXmlNode::ToComment(void)
    TiXmlComment *return_value = ((*local_this).ToComment)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlComment, false, false);
  }

  {
    // -2 virtual TiXmlComment const *TiXmlNode::ToComment(void) const
    TiXmlComment const *return_value = ((*(const TiXmlNode*)local_this).ToComment)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlComment, false, true);
  }

  // No coercion possible: virtual TiXmlComment *TiXmlNode::ToComment(void)
  // No coercion possible: virtual TiXmlComment const *TiXmlNode::ToComment(void) const
}

#ifndef NDEBUG
static const char *Dtool_TiXmlNode_ToComment_39_comment =
  "C++ Interface:\n"
  "ToComment(const TiXmlNode self)\n"
  "ToComment(TiXmlNode self)\n"
  "\n"
  "///< Cast to a more defined type. Will return null if not of the requested type.\n"
  "\n"
  "///< Cast to a more defined type. Will return null if not of the requested type.";
#else
static const char *Dtool_TiXmlNode_ToComment_39_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual TiXmlUnknown *TiXmlNode::ToUnknown(void)
 * virtual TiXmlUnknown const *TiXmlNode::ToUnknown(void) const
 */
static PyObject *Dtool_TiXmlNode_ToUnknown_40(PyObject *self, PyObject *) {
  TiXmlNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlNode)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 virtual TiXmlUnknown *TiXmlNode::ToUnknown(void)
    TiXmlUnknown *return_value = ((*local_this).ToUnknown)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlUnknown, false, false);
  }

  {
    // -2 virtual TiXmlUnknown const *TiXmlNode::ToUnknown(void) const
    TiXmlUnknown const *return_value = ((*(const TiXmlNode*)local_this).ToUnknown)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlUnknown, false, true);
  }

  // No coercion possible: virtual TiXmlUnknown *TiXmlNode::ToUnknown(void)
  // No coercion possible: virtual TiXmlUnknown const *TiXmlNode::ToUnknown(void) const
}

#ifndef NDEBUG
static const char *Dtool_TiXmlNode_ToUnknown_40_comment =
  "C++ Interface:\n"
  "ToUnknown(const TiXmlNode self)\n"
  "ToUnknown(TiXmlNode self)\n"
  "\n"
  "///< Cast to a more defined type. Will return null if not of the requested type.\n"
  "\n"
  "///< Cast to a more defined type. Will return null if not of the requested type.";
#else
static const char *Dtool_TiXmlNode_ToUnknown_40_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual TiXmlText *TiXmlNode::ToText(void)
 * virtual TiXmlText const *TiXmlNode::ToText(void) const
 */
static PyObject *Dtool_TiXmlNode_ToText_41(PyObject *self, PyObject *) {
  TiXmlNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlNode)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 virtual TiXmlText *TiXmlNode::ToText(void)
    TiXmlText *return_value = ((*local_this).ToText)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlText, false, false);
  }

  {
    // -2 virtual TiXmlText const *TiXmlNode::ToText(void) const
    TiXmlText const *return_value = ((*(const TiXmlNode*)local_this).ToText)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlText, false, true);
  }

  // No coercion possible: virtual TiXmlText *TiXmlNode::ToText(void)
  // No coercion possible: virtual TiXmlText const *TiXmlNode::ToText(void) const
}

#ifndef NDEBUG
static const char *Dtool_TiXmlNode_ToText_41_comment =
  "C++ Interface:\n"
  "ToText(const TiXmlNode self)\n"
  "ToText(TiXmlNode self)\n"
  "\n"
  "///< Cast to a more defined type. Will return null if not of the requested type.\n"
  "\n"
  "///< Cast to a more defined type. Will return null if not of the requested type.";
#else
static const char *Dtool_TiXmlNode_ToText_41_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual TiXmlDeclaration *TiXmlNode::ToDeclaration(void)
 * virtual TiXmlDeclaration const *TiXmlNode::ToDeclaration(void) const
 */
static PyObject *Dtool_TiXmlNode_ToDeclaration_42(PyObject *self, PyObject *) {
  TiXmlNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlNode)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 virtual TiXmlDeclaration *TiXmlNode::ToDeclaration(void)
    TiXmlDeclaration *return_value = ((*local_this).ToDeclaration)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlDeclaration, false, false);
  }

  {
    // -2 virtual TiXmlDeclaration const *TiXmlNode::ToDeclaration(void) const
    TiXmlDeclaration const *return_value = ((*(const TiXmlNode*)local_this).ToDeclaration)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlDeclaration, false, true);
  }

  // No coercion possible: virtual TiXmlDeclaration *TiXmlNode::ToDeclaration(void)
  // No coercion possible: virtual TiXmlDeclaration const *TiXmlNode::ToDeclaration(void) const
}

#ifndef NDEBUG
static const char *Dtool_TiXmlNode_ToDeclaration_42_comment =
  "C++ Interface:\n"
  "ToDeclaration(const TiXmlNode self)\n"
  "ToDeclaration(TiXmlNode self)\n"
  "\n"
  "///< Cast to a more defined type. Will return null if not of the requested type.\n"
  "\n"
  "///< Cast to a more defined type. Will return null if not of the requested type.";
#else
static const char *Dtool_TiXmlNode_ToDeclaration_42_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual TiXmlNode *TiXmlNode::Clone(void) const = 0
 */
static PyObject *Dtool_TiXmlNode_Clone_43(PyObject *self, PyObject *) {
  TiXmlNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlNode)) {
    return nullptr;
  }
  // 1-virtual TiXmlNode *TiXmlNode::Clone(void) const = 0
  TiXmlNode *return_value = ((*(const TiXmlNode*)local_this).Clone)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlNode_Clone_43_comment =
  "C++ Interface:\n"
  "Clone(TiXmlNode self)\n"
  "\n"
  "/** Create an exact duplicate of this node and return it. The memory must be deleted\n"
  "        by the caller.\n"
  "    */";
#else
static const char *Dtool_TiXmlNode_Clone_43_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool TiXmlNode::Accept(TiXmlVisitor *visitor) const = 0
 */
static PyObject *Dtool_TiXmlNode_Accept_44(PyObject *self, PyObject *arg) {
  TiXmlNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlNode)) {
    return nullptr;
  }
  // 1-virtual bool TiXmlNode::Accept(TiXmlVisitor *visitor) const = 0
  TiXmlVisitor *arg_this = (TiXmlVisitor *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TiXmlVisitor, 1, "TiXmlNode.Accept", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const TiXmlNode*)local_this).Accept)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "Accept(TiXmlNode self, TiXmlVisitor visitor)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlNode_Accept_44_comment =
  "C++ Interface:\n"
  "Accept(TiXmlNode self, TiXmlVisitor visitor)\n"
  "\n"
  "/** Accept a hierchical visit the nodes in the TinyXML DOM. Every node in the\n"
  "        XML tree will be conditionally visited and the host will be called back\n"
  "        via the TiXmlVisitor interface.\n"
  "\n"
  "        This is essentially a SAX interface for TinyXML. (Note however it doesn't re-parse\n"
  "        the XML for the callbacks, so the performance of TinyXML is unchanged by using this\n"
  "        interface versus any other.)\n"
  "\n"
  "        The interface has been based on ideas from:\n"
  "\n"
  "        - http://www.saxproject.org/\n"
  "        - http://c2.com/cgi/wiki?HierarchicalVisitorPattern\n"
  "\n"
  "        Which are both good references for \"visiting\".\n"
  "\n"
  "        An example of using Accept():\n"
  "        @verbatim\n"
  "        TiXmlPrinter printer;\n"
  "        tinyxmlDoc.Accept( &printer );\n"
  "        const char* xmlcstr = printer.CStr();\n"
  "        @endverbatim\n"
  "    */";
#else
static const char *Dtool_TiXmlNode_Accept_44_comment = nullptr;
#endif

static int Dtool_Init_TiXmlNode(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_TiXmlNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TiXmlNode) {
    printf("TiXmlNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TiXmlNode *local_this = (TiXmlNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TiXmlNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TiXmlBase) {
    return (TiXmlBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TiXmlNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TiXmlNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TiXmlBase) {
    TiXmlBase* other_this = (TiXmlBase*)from_this;
    return (TiXmlNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TiXmlDocument
 */
/**
 * Python function wrapper for:
 * void TiXmlDocument::operator =(TiXmlDocument const &copy)
 */
static PyObject *Dtool_TiXmlDocument_operator_53(PyObject *self, PyObject *arg) {
  TiXmlDocument *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlDocument, (void **)&local_this, "TiXmlDocument.assign")) {
    return nullptr;
  }
  // 1-void TiXmlDocument::operator =(TiXmlDocument const &copy)
  TiXmlDocument arg_local;
  TiXmlDocument const *arg_this = Dtool_Coerce_TiXmlDocument(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "TiXmlDocument.assign", "TiXmlDocument");
  }
  ((*local_this).operator =)(*arg_this);
  TiXmlDocument *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlDocument, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const TiXmlDocument self, const TiXmlDocument copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlDocument_operator_53_comment =
  "C++ Interface:\n"
  "assign(const TiXmlDocument self, const TiXmlDocument copy)\n";
#else
static const char *Dtool_TiXmlDocument_operator_53_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Rejected Remap [bool TiXmlDocument::LoadFile(FILE *, TiXmlEncoding encoding)]
 * bool TiXmlDocument::LoadFile(TiXmlEncoding encoding = ::TIXML_DEFAULT_ENCODING)
 * bool TiXmlDocument::LoadFile(char const *filename, TiXmlEncoding encoding = ::TIXML_DEFAULT_ENCODING)
 * bool TiXmlDocument::LoadFile(std::string const &filename, TiXmlEncoding encoding = ::TIXML_DEFAULT_ENCODING)
 */
static PyObject *Dtool_TiXmlDocument_LoadFile_54(PyObject *self, PyObject *args, PyObject *kwds) {
  TiXmlDocument *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlDocument, (void **)&local_this, "TiXmlDocument.LoadFile")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-bool TiXmlDocument::LoadFile(TiXmlEncoding encoding)
      bool return_value = ((*local_this).LoadFile)();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 bool TiXmlDocument::LoadFile(std::string const &filename, TiXmlEncoding encoding = ::TIXML_DEFAULT_ENCODING)
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        int param2 = ::TIXML_DEFAULT_ENCODING;
        static const char *keyword_list[] = {"filename", "encoding", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|i:LoadFile", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
          bool return_value = ((*local_this).LoadFile)(std::string(param1_str, param1_len), (TiXmlEncoding)param2);
          return Dtool_Return_Bool(return_value);
        }
        PyErr_Clear();
      }

      {
        // -2 bool TiXmlDocument::LoadFile(char const *filename, TiXmlEncoding encoding = ::TIXML_DEFAULT_ENCODING)
        char const *param1;
        int param2 = ::TIXML_DEFAULT_ENCODING;
        static const char *keyword_list[] = {"filename", "encoding", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "z|i:LoadFile", (char **)keyword_list, &param1, &param2)) {
          bool return_value = ((*local_this).LoadFile)((char const *)param1, (TiXmlEncoding)param2);
          return Dtool_Return_Bool(return_value);
        }
        PyErr_Clear();
      }

      {
        // -2 bool TiXmlDocument::LoadFile(TiXmlEncoding encoding = ::TIXML_DEFAULT_ENCODING)
        int param1;
        static const char *keyword_list[] = {"encoding", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:LoadFile", (char **)keyword_list, &param1)) {
          bool return_value = ((*local_this).LoadFile)((TiXmlEncoding)param1);
          return Dtool_Return_Bool(return_value);
        }
        PyErr_Clear();
      }

      // No coercion possible: bool TiXmlDocument::LoadFile(std::string const &filename, TiXmlEncoding encoding = ::TIXML_DEFAULT_ENCODING)
      // No coercion possible: bool TiXmlDocument::LoadFile(char const *filename, TiXmlEncoding encoding = ::TIXML_DEFAULT_ENCODING)
      // No coercion possible: bool TiXmlDocument::LoadFile(TiXmlEncoding encoding = ::TIXML_DEFAULT_ENCODING)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "LoadFile() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "LoadFile(const TiXmlDocument self)\n"
      "LoadFile(const TiXmlDocument self, str filename, int encoding)\n"
      "LoadFile(const TiXmlDocument self, str filename, int encoding)\n"
      "LoadFile(const TiXmlDocument self, int encoding)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlDocument_LoadFile_54_comment =
  "C++ Interface:\n"
  "LoadFile(const TiXmlDocument self)\n"
  "LoadFile(const TiXmlDocument self, str filename, int encoding)\n"
  "LoadFile(const TiXmlDocument self, str filename, int encoding)\n"
  "LoadFile(const TiXmlDocument self, int encoding)\n"
  "\n"
  "/** Load a file using the current document value.\n"
  "        Returns true if successful. Will delete any existing\n"
  "        document data before loading.\n"
  "    */\n"
  "\n"
  "/// Load a file using the given filename. Returns true if successful.\n"
  "\n"
  "/** Load a file using the given FILE*. Returns true if successful. Note that this method\n"
  "        doesn't stream - the entire object pointed at by the FILE*\n"
  "        will be interpreted as an XML file. TinyXML doesn't stream in XML from the current\n"
  "        file location. Streaming may be added in the future.\n"
  "    */\n"
  "\n"
  "///< STL std::string version.";
#else
static const char *Dtool_TiXmlDocument_LoadFile_54_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool TiXmlDocument::SaveFile(void) const
 * Rejected Remap [bool TiXmlDocument::SaveFile(FILE *) const]
 * bool TiXmlDocument::SaveFile(char const *filename) const
 * bool TiXmlDocument::SaveFile(std::string const &filename) const
 */
static PyObject *Dtool_TiXmlDocument_SaveFile_55(PyObject *self, PyObject *args) {
  TiXmlDocument *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlDocument)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-bool TiXmlDocument::SaveFile(void) const
      bool return_value = ((*(const TiXmlDocument*)local_this).SaveFile)();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      {
        // -2 bool TiXmlDocument::SaveFile(std::string const &filename) const
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
        param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
          param1_str = nullptr;
        }
#endif
        if (param1_str != nullptr) {
          bool return_value = ((*(const TiXmlDocument*)local_this).SaveFile)(std::string(param1_str, param1_len));
          return Dtool_Return_Bool(return_value);
        }
        PyErr_Clear();
      }

      {
        // -2 bool TiXmlDocument::SaveFile(char const *filename) const
        char const *param1;
        if (PyArg_Parse(arg, "z:SaveFile", &param1)) {
          bool return_value = ((*(const TiXmlDocument*)local_this).SaveFile)((char const *)param1);
          return Dtool_Return_Bool(return_value);
        }
        PyErr_Clear();
      }

      // No coercion possible: bool TiXmlDocument::SaveFile(std::string const &filename) const
      // No coercion possible: bool TiXmlDocument::SaveFile(char const *filename) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "SaveFile() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SaveFile(TiXmlDocument self)\n"
      "SaveFile(TiXmlDocument self, str filename)\n"
      "SaveFile(TiXmlDocument self, str filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlDocument_SaveFile_55_comment =
  "C++ Interface:\n"
  "SaveFile(TiXmlDocument self)\n"
  "SaveFile(TiXmlDocument self, str filename)\n"
  "SaveFile(TiXmlDocument self, str filename)\n"
  "\n"
  "/// Save a file using the current document value. Returns true if successful.\n"
  "\n"
  "/// Save a file using the given filename. Returns true if successful.\n"
  "\n"
  "/// Save a file using the given FILE*. Returns true if successful.\n"
  "\n"
  "///< STL std::string version.";
#else
static const char *Dtool_TiXmlDocument_SaveFile_55_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlElement *TiXmlDocument::RootElement(void)
 * TiXmlElement const *TiXmlDocument::RootElement(void) const
 */
static PyObject *Dtool_TiXmlDocument_RootElement_56(PyObject *self, PyObject *) {
  TiXmlDocument *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlDocument)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 TiXmlElement *TiXmlDocument::RootElement(void)
    TiXmlElement *return_value = ((*local_this).RootElement)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlElement, false, false);
  }

  {
    // -2 TiXmlElement const *TiXmlDocument::RootElement(void) const
    TiXmlElement const *return_value = ((*(const TiXmlDocument*)local_this).RootElement)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlElement, false, true);
  }

  // No coercion possible: TiXmlElement *TiXmlDocument::RootElement(void)
  // No coercion possible: TiXmlElement const *TiXmlDocument::RootElement(void) const
}

#ifndef NDEBUG
static const char *Dtool_TiXmlDocument_RootElement_56_comment =
  "C++ Interface:\n"
  "RootElement(const TiXmlDocument self)\n"
  "RootElement(TiXmlDocument self)\n"
  "\n"
  "/** Get the root element -- the only top level element -- of the document.\n"
  "        In well formed XML, there should only be one. TinyXml is tolerant of\n"
  "        multiple elements at the document level.\n"
  "    */";
#else
static const char *Dtool_TiXmlDocument_RootElement_56_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool TiXmlDocument::Error(void) const
 */
static PyObject *Dtool_TiXmlDocument_Error_57(PyObject *self, PyObject *) {
  TiXmlDocument *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlDocument)) {
    return nullptr;
  }
  // 1-bool TiXmlDocument::Error(void) const
  bool return_value = ((*(const TiXmlDocument*)local_this).Error)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlDocument_Error_57_comment =
  "C++ Interface:\n"
  "Error(TiXmlDocument self)\n"
  "\n"
  "/** If an error occurs, Error will be set to true. Also,\n"
  "        - The ErrorId() will contain the integer identifier of the error (not generally useful)\n"
  "        - The ErrorDesc() method will return the name of the error. (very useful)\n"
  "        - The ErrorRow() and ErrorCol() will return the location of the error (if known)\n"
  "    */";
#else
static const char *Dtool_TiXmlDocument_Error_57_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * char const *TiXmlDocument::ErrorDesc(void) const
 */
static PyObject *Dtool_TiXmlDocument_ErrorDesc_58(PyObject *self, PyObject *) {
  TiXmlDocument *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlDocument)) {
    return nullptr;
  }
  // 1-char const *TiXmlDocument::ErrorDesc(void) const
  char const *return_value = ((*(const TiXmlDocument*)local_this).ErrorDesc)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlDocument_ErrorDesc_58_comment =
  "C++ Interface:\n"
  "ErrorDesc(TiXmlDocument self)\n"
  "\n"
  "/// Contains a textual (english) description of the error if one occurs.";
#else
static const char *Dtool_TiXmlDocument_ErrorDesc_58_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int TiXmlDocument::ErrorId(void) const
 */
static PyObject *Dtool_TiXmlDocument_ErrorId_59(PyObject *self, PyObject *) {
  TiXmlDocument *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlDocument)) {
    return nullptr;
  }
  // 1-int TiXmlDocument::ErrorId(void) const
  int return_value = ((*(const TiXmlDocument*)local_this).ErrorId)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlDocument_ErrorId_59_comment =
  "C++ Interface:\n"
  "ErrorId(TiXmlDocument self)\n"
  "\n"
  "/** Generally, you probably want the error string ( ErrorDesc() ). But if you\n"
  "        prefer the ErrorId, this function will fetch it.\n"
  "    */";
#else
static const char *Dtool_TiXmlDocument_ErrorId_59_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int TiXmlDocument::ErrorRow(void) const
 */
static PyObject *Dtool_TiXmlDocument_ErrorRow_60(PyObject *self, PyObject *) {
  TiXmlDocument *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlDocument)) {
    return nullptr;
  }
  // 1-int TiXmlDocument::ErrorRow(void) const
  int return_value = ((*(const TiXmlDocument*)local_this).ErrorRow)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlDocument_ErrorRow_60_comment =
  "C++ Interface:\n"
  "ErrorRow(TiXmlDocument self)\n"
  "\n"
  "/** Returns the location (if known) of the error. The first column is column 1,\n"
  "        and the first row is row 1. A value of 0 means the row and column wasn't applicable\n"
  "        (memory errors, for example, have no row/column) or the parser lost the error. (An\n"
  "        error in the error reporting, in that case.)\n"
  "\n"
  "        @sa SetTabSize, Row, Column\n"
  "    */";
#else
static const char *Dtool_TiXmlDocument_ErrorRow_60_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int TiXmlDocument::ErrorCol(void) const
 */
static PyObject *Dtool_TiXmlDocument_ErrorCol_61(PyObject *self, PyObject *) {
  TiXmlDocument *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlDocument)) {
    return nullptr;
  }
  // 1-int TiXmlDocument::ErrorCol(void) const
  int return_value = ((*(const TiXmlDocument*)local_this).ErrorCol)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlDocument_ErrorCol_61_comment =
  "C++ Interface:\n"
  "ErrorCol(TiXmlDocument self)\n"
  "\n"
  "///< The column where the error occured. See ErrorRow()";
#else
static const char *Dtool_TiXmlDocument_ErrorCol_61_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TiXmlDocument::SetTabSize(int _tabsize)
 */
static PyObject *Dtool_TiXmlDocument_SetTabSize_62(PyObject *self, PyObject *arg) {
  TiXmlDocument *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlDocument, (void **)&local_this, "TiXmlDocument.SetTabSize")) {
    return nullptr;
  }
  // 1-void TiXmlDocument::SetTabSize(int _tabsize)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).SetTabSize)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetTabSize(const TiXmlDocument self, int _tabsize)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlDocument_SetTabSize_62_comment =
  "C++ Interface:\n"
  "SetTabSize(const TiXmlDocument self, int _tabsize)\n"
  "\n"
  "/** SetTabSize() allows the error reporting functions (ErrorRow() and ErrorCol())\n"
  "        to report the correct values for row and column. It does not change the output\n"
  "        or input in any way.\n"
  "\n"
  "        By calling this method, with a tab size\n"
  "        greater than 0, the row and column of each node and attribute is stored\n"
  "        when the file is loaded. Very useful for tracking the DOM back in to\n"
  "        the source file.\n"
  "\n"
  "        The tab size is required for calculating the location of nodes. If not\n"
  "        set, the default of 4 is used. The tabsize is set per document. Setting\n"
  "        the tabsize to 0 disables row/column tracking.\n"
  "\n"
  "        Note that row and column tracking is not supported when using operator>>.\n"
  "\n"
  "        The tab size needs to be enabled before the parse or load. Correct usage:\n"
  "        @verbatim\n"
  "        TiXmlDocument doc;\n"
  "        doc.SetTabSize( 8 );\n"
  "        doc.Load( \"myfile.xml\" );\n"
  "        @endverbatim\n"
  "\n"
  "        @sa Row, Column\n"
  "    */";
#else
static const char *Dtool_TiXmlDocument_SetTabSize_62_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int TiXmlDocument::TabSize(void) const
 */
static PyObject *Dtool_TiXmlDocument_TabSize_63(PyObject *self, PyObject *) {
  TiXmlDocument *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlDocument)) {
    return nullptr;
  }
  // 1-int TiXmlDocument::TabSize(void) const
  int return_value = ((*(const TiXmlDocument*)local_this).TabSize)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlDocument_TabSize_63_comment =
  "C++ Interface:\n"
  "TabSize(TiXmlDocument self)\n";
#else
static const char *Dtool_TiXmlDocument_TabSize_63_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TiXmlDocument::ClearError(void)
 */
static PyObject *Dtool_TiXmlDocument_ClearError_64(PyObject *self, PyObject *) {
  TiXmlDocument *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlDocument, (void **)&local_this, "TiXmlDocument.ClearError")) {
    return nullptr;
  }
  // 1-void TiXmlDocument::ClearError(void)
  ((*local_this).ClearError)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TiXmlDocument_ClearError_64_comment =
  "C++ Interface:\n"
  "ClearError(const TiXmlDocument self)\n"
  "\n"
  "/** If you have handled the error, it can be reset with this call. The error\n"
  "        state is automatically cleared if you Parse a new XML block.\n"
  "    */";
#else
static const char *Dtool_TiXmlDocument_ClearError_64_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TiXmlDocument::Print(void) const
 */
static PyObject *Dtool_TiXmlDocument_Print_65(PyObject *self, PyObject *) {
  TiXmlDocument *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlDocument)) {
    return nullptr;
  }
  // 1-void TiXmlDocument::Print(void) const
  ((*(const TiXmlDocument*)local_this).Print)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TiXmlDocument_Print_65_comment =
  "C++ Interface:\n"
  "Print(TiXmlDocument self)\n"
  "\n"
  "/** Write the document to standard out using formatted printing (\"pretty print\"). */";
#else
static const char *Dtool_TiXmlDocument_Print_65_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlDocument::TiXmlDocument(void)
 * TiXmlDocument::TiXmlDocument(TiXmlDocument const &copy)
 * TiXmlDocument::TiXmlDocument(char const *documentName)
 * TiXmlDocument::TiXmlDocument(std::string const &documentName)
 */
static int Dtool_Init_TiXmlDocument(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-TiXmlDocument::TiXmlDocument(void)
      TiXmlDocument *return_value = new TiXmlDocument();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlDocument, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 TiXmlDocument::TiXmlDocument(TiXmlDocument const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          TiXmlDocument const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TiXmlDocument);
          if (param0_this != nullptr) {
            TiXmlDocument *return_value = new TiXmlDocument(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlDocument, true, false);
          }
        }
      }

      {
        // -2 TiXmlDocument::TiXmlDocument(std::string const &documentName)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"documentName", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:TiXmlDocument", (char **)keyword_list, &param0_str, &param0_len)) {
          TiXmlDocument *return_value = new TiXmlDocument(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlDocument, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 TiXmlDocument::TiXmlDocument(char const *documentName)
        char const *param0;
        static const char *keyword_list[] = {"documentName", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "z:TiXmlDocument", (char **)keyword_list, &param0)) {
          TiXmlDocument *return_value = new TiXmlDocument((char const *)param0);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlDocument, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 TiXmlDocument::TiXmlDocument(TiXmlDocument const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          TiXmlDocument param0_local;
          TiXmlDocument const *param0_this = Dtool_Coerce_TiXmlDocument(param0, param0_local);
          if ((param0_this != nullptr)) {
            TiXmlDocument *return_value = new TiXmlDocument(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlDocument, true, false);
          }
        }
      }

      // No coercion possible: TiXmlDocument::TiXmlDocument(std::string const &documentName)
      // No coercion possible: TiXmlDocument::TiXmlDocument(char const *documentName)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "TiXmlDocument() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TiXmlDocument()\n"
      "TiXmlDocument(const TiXmlDocument copy)\n"
      "TiXmlDocument(str documentName)\n"
      "TiXmlDocument(str documentName)\n");
  }
  return -1;
}

TiXmlDocument *Dtool_Coerce_TiXmlDocument(PyObject *args, TiXmlDocument &coerced) {
  TiXmlDocument *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_TiXmlDocument)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const TiXmlDocument *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 TiXmlDocument::TiXmlDocument(std::string const &documentName)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
        param0_str = nullptr;
      }
#endif
      if (param0_str != nullptr) {
        coerced = TiXmlDocument(std::string(param0_str, param0_len));
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }

    {
      // -2 TiXmlDocument::TiXmlDocument(char const *documentName)
      char const *param0;
      if (PyArg_Parse(arg, "z:TiXmlDocument", &param0)) {
        coerced = TiXmlDocument((char const *)param0);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }

  }
  return nullptr;
}

static void *Dtool_UpcastInterface_TiXmlDocument(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TiXmlDocument) {
    printf("TiXmlDocument ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TiXmlDocument *local_this = (TiXmlDocument *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TiXmlDocument) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TiXmlBase) {
    return (TiXmlBase *)(TiXmlNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TiXmlNode) {
    return (TiXmlNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TiXmlDocument(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TiXmlDocument) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TiXmlBase) {
    TiXmlBase* other_this = (TiXmlBase*)from_this;
    return (TiXmlDocument*)other_this;
  }
  if (from_type == Dtool_Ptr_TiXmlNode) {
    TiXmlNode* other_this = (TiXmlNode*)from_this;
    return (TiXmlDocument*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TiXmlElement
 */
/**
 * Python function wrapper for:
 * void TiXmlElement::operator =(TiXmlElement const &base)
 */
static PyObject *Dtool_TiXmlElement_operator_69(PyObject *self, PyObject *arg) {
  TiXmlElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlElement, (void **)&local_this, "TiXmlElement.assign")) {
    return nullptr;
  }
  // 1-void TiXmlElement::operator =(TiXmlElement const &base)
  TiXmlElement const *arg_this = (TiXmlElement *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TiXmlElement, 1, "TiXmlElement.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    TiXmlElement *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlElement, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const TiXmlElement self, const TiXmlElement base)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlElement_operator_69_comment =
  "C++ Interface:\n"
  "assign(const TiXmlElement self, const TiXmlElement base)\n";
#else
static const char *Dtool_TiXmlElement_operator_69_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * char const *TiXmlElement::Attribute(char const *name) const
 * std::string const *TiXmlElement::Attribute(std::string const &name) const
 */
static PyObject *Dtool_TiXmlElement_Attribute_70(PyObject *self, PyObject *arg) {
  TiXmlElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlElement)) {
    return nullptr;
  }
  {
    // -2 std::string const *TiXmlElement::Attribute(std::string const &name) const
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      std::string const *return_value = ((*(const TiXmlElement*)local_this).Attribute)(std::string(param1_str, param1_len));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    PyErr_Clear();
  }

  {
    // -2 char const *TiXmlElement::Attribute(char const *name) const
    char const *param1;
    if (PyArg_Parse(arg, "z:Attribute", &param1)) {
      char const *return_value = ((*(const TiXmlElement*)local_this).Attribute)((char const *)param1);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    PyErr_Clear();
  }

  // No coercion possible: std::string const *TiXmlElement::Attribute(std::string const &name) const
  // No coercion possible: char const *TiXmlElement::Attribute(char const *name) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "Attribute(TiXmlElement self, str name)\n"
      "Attribute(TiXmlElement self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlElement_Attribute_70_comment =
  "C++ Interface:\n"
  "Attribute(TiXmlElement self, str name)\n"
  "Attribute(TiXmlElement self, str name)\n"
  "\n"
  "/** Given an attribute name, Attribute() returns the value\n"
  "        for the attribute of that name, or null if none exists.\n"
  "    */\n"
  "\n"
  "/** Given an attribute name, Attribute() returns the value\n"
  "        for the attribute of that name, or null if none exists.\n"
  "        If the attribute exists and can be converted to an integer,\n"
  "        the integer value will be put in the return 'i', if 'i'\n"
  "        is non-null.\n"
  "    */\n"
  "\n"
  "/** Given an attribute name, Attribute() returns the value\n"
  "        for the attribute of that name, or null if none exists.\n"
  "        If the attribute exists and can be converted to an double,\n"
  "        the double value will be put in the return 'd', if 'd'\n"
  "        is non-null.\n"
  "    */";
#else
static const char *Dtool_TiXmlElement_Attribute_70_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TiXmlElement::SetAttribute(char const *name, char const *_value)
 * void TiXmlElement::SetAttribute(char const *name, int value)
 * void TiXmlElement::SetAttribute(std::string const &name, int _value)
 * void TiXmlElement::SetAttribute(std::string const &name, std::string const &_value)
 */
static PyObject *Dtool_TiXmlElement_SetAttribute_76(PyObject *self, PyObject *args, PyObject *kwds) {
  TiXmlElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlElement, (void **)&local_this, "TiXmlElement.SetAttribute")) {
    return nullptr;
  }
  {
    // -2 void TiXmlElement::SetAttribute(std::string const &name, std::string const &_value)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
    const char *param2_str = nullptr;
    Py_ssize_t param2_len;
    static const char *keyword_list[] = {"name", "_value", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:SetAttribute", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
      ((*local_this).SetAttribute)(std::string(param1_str, param1_len), std::string(param2_str, param2_len));
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  {
    // -2 void TiXmlElement::SetAttribute(std::string const &name, int _value)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
    int param2;
    static const char *keyword_list[] = {"name", "_value", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i:SetAttribute", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
      ((*local_this).SetAttribute)(std::string(param1_str, param1_len), (int)param2);
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  {
    // -2 void TiXmlElement::SetAttribute(char const *name, char const *_value)
    char const *param1;
    char const *param2;
    static const char *keyword_list[] = {"name", "_value", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "zz:SetAttribute", (char **)keyword_list, &param1, &param2)) {
      ((*local_this).SetAttribute)((char const *)param1, (char const *)param2);
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  {
    // -2 void TiXmlElement::SetAttribute(char const *name, int value)
    char const *param1;
    int param2;
    static const char *keyword_list[] = {"name", "value", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "zi:SetAttribute", (char **)keyword_list, &param1, &param2)) {
      ((*local_this).SetAttribute)((char const *)param1, (int)param2);
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  // No coercion possible: void TiXmlElement::SetAttribute(std::string const &name, std::string const &_value)
  // No coercion possible: void TiXmlElement::SetAttribute(std::string const &name, int _value)
  // No coercion possible: void TiXmlElement::SetAttribute(char const *name, char const *_value)
  // No coercion possible: void TiXmlElement::SetAttribute(char const *name, int value)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetAttribute(const TiXmlElement self, str name, str _value)\n"
      "SetAttribute(const TiXmlElement self, str name, int _value)\n"
      "SetAttribute(const TiXmlElement self, str name, str _value)\n"
      "SetAttribute(const TiXmlElement self, str name, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlElement_SetAttribute_76_comment =
  "C++ Interface:\n"
  "SetAttribute(const TiXmlElement self, str name, str _value)\n"
  "SetAttribute(const TiXmlElement self, str name, int _value)\n"
  "SetAttribute(const TiXmlElement self, str name, str _value)\n"
  "SetAttribute(const TiXmlElement self, str name, int value)\n"
  "\n"
  "/** Sets an attribute of name to a given value. The attribute\n"
  "        will be created if it does not exist, or changed if it does.\n"
  "    */\n"
  "\n"
  "/// STL std::string form.\n"
  "\n"
  "///< STL std::string form.\n"
  "\n"
  "/** Sets an attribute of name to a given value. The attribute\n"
  "        will be created if it does not exist, or changed if it does.\n"
  "    */";
#else
static const char *Dtool_TiXmlElement_SetAttribute_76_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TiXmlElement::SetDoubleAttribute(char const *name, double value)
 * void TiXmlElement::SetDoubleAttribute(std::string const &name, double value)
 */
static PyObject *Dtool_TiXmlElement_SetDoubleAttribute_77(PyObject *self, PyObject *args, PyObject *kwds) {
  TiXmlElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlElement, (void **)&local_this, "TiXmlElement.SetDoubleAttribute")) {
    return nullptr;
  }
  {
    // -2 void TiXmlElement::SetDoubleAttribute(std::string const &name, double value)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
    double param2;
    static const char *keyword_list[] = {"name", "value", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#d:SetDoubleAttribute", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
      ((*local_this).SetDoubleAttribute)(std::string(param1_str, param1_len), (double)param2);
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  {
    // -2 void TiXmlElement::SetDoubleAttribute(char const *name, double value)
    char const *param1;
    double param2;
    static const char *keyword_list[] = {"name", "value", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "zd:SetDoubleAttribute", (char **)keyword_list, &param1, &param2)) {
      ((*local_this).SetDoubleAttribute)((char const *)param1, (double)param2);
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  // No coercion possible: void TiXmlElement::SetDoubleAttribute(std::string const &name, double value)
  // No coercion possible: void TiXmlElement::SetDoubleAttribute(char const *name, double value)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetDoubleAttribute(const TiXmlElement self, str name, double value)\n"
      "SetDoubleAttribute(const TiXmlElement self, str name, double value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlElement_SetDoubleAttribute_77_comment =
  "C++ Interface:\n"
  "SetDoubleAttribute(const TiXmlElement self, str name, double value)\n"
  "SetDoubleAttribute(const TiXmlElement self, str name, double value)\n"
  "\n"
  "///< STL std::string form.\n"
  "\n"
  "/** Sets an attribute of name to a given value. The attribute\n"
  "        will be created if it does not exist, or changed if it does.\n"
  "    */";
#else
static const char *Dtool_TiXmlElement_SetDoubleAttribute_77_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TiXmlElement::RemoveAttribute(char const *name)
 * void TiXmlElement::RemoveAttribute(std::string const &name)
 */
static PyObject *Dtool_TiXmlElement_RemoveAttribute_78(PyObject *self, PyObject *arg) {
  TiXmlElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlElement, (void **)&local_this, "TiXmlElement.RemoveAttribute")) {
    return nullptr;
  }
  {
    // -2 void TiXmlElement::RemoveAttribute(std::string const &name)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      ((*local_this).RemoveAttribute)(std::string(param1_str, param1_len));
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  {
    // -2 void TiXmlElement::RemoveAttribute(char const *name)
    char const *param1;
    if (PyArg_Parse(arg, "z:RemoveAttribute", &param1)) {
      ((*local_this).RemoveAttribute)((char const *)param1);
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  // No coercion possible: void TiXmlElement::RemoveAttribute(std::string const &name)
  // No coercion possible: void TiXmlElement::RemoveAttribute(char const *name)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "RemoveAttribute(const TiXmlElement self, str name)\n"
      "RemoveAttribute(const TiXmlElement self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlElement_RemoveAttribute_78_comment =
  "C++ Interface:\n"
  "RemoveAttribute(const TiXmlElement self, str name)\n"
  "RemoveAttribute(const TiXmlElement self, str name)\n"
  "\n"
  "/** Deletes an attribute with the given name.\n"
  "    */\n"
  "\n"
  "///< STL std::string form.";
#else
static const char *Dtool_TiXmlElement_RemoveAttribute_78_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlAttribute *TiXmlElement::FirstAttribute(void)
 * TiXmlAttribute const *TiXmlElement::FirstAttribute(void) const
 */
static PyObject *Dtool_TiXmlElement_FirstAttribute_79(PyObject *self, PyObject *) {
  TiXmlElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlElement)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 TiXmlAttribute *TiXmlElement::FirstAttribute(void)
    TiXmlAttribute *return_value = ((*local_this).FirstAttribute)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlAttribute, false, false);
  }

  {
    // -2 TiXmlAttribute const *TiXmlElement::FirstAttribute(void) const
    TiXmlAttribute const *return_value = ((*(const TiXmlElement*)local_this).FirstAttribute)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlAttribute, false, true);
  }

  // No coercion possible: TiXmlAttribute *TiXmlElement::FirstAttribute(void)
  // No coercion possible: TiXmlAttribute const *TiXmlElement::FirstAttribute(void) const
}

#ifndef NDEBUG
static const char *Dtool_TiXmlElement_FirstAttribute_79_comment =
  "C++ Interface:\n"
  "FirstAttribute(const TiXmlElement self)\n"
  "FirstAttribute(TiXmlElement self)\n"
  "\n"
  "///< Access the first attribute in this element.\n"
  "\n"
  "///< Access the first attribute in this element.";
#else
static const char *Dtool_TiXmlElement_FirstAttribute_79_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlAttribute *TiXmlElement::LastAttribute(void)
 * TiXmlAttribute const *TiXmlElement::LastAttribute(void) const
 */
static PyObject *Dtool_TiXmlElement_LastAttribute_80(PyObject *self, PyObject *) {
  TiXmlElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlElement)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 TiXmlAttribute *TiXmlElement::LastAttribute(void)
    TiXmlAttribute *return_value = ((*local_this).LastAttribute)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlAttribute, false, false);
  }

  {
    // -2 TiXmlAttribute const *TiXmlElement::LastAttribute(void) const
    TiXmlAttribute const *return_value = ((*(const TiXmlElement*)local_this).LastAttribute)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlAttribute, false, true);
  }

  // No coercion possible: TiXmlAttribute *TiXmlElement::LastAttribute(void)
  // No coercion possible: TiXmlAttribute const *TiXmlElement::LastAttribute(void) const
}

#ifndef NDEBUG
static const char *Dtool_TiXmlElement_LastAttribute_80_comment =
  "C++ Interface:\n"
  "LastAttribute(const TiXmlElement self)\n"
  "LastAttribute(TiXmlElement self)\n"
  "\n"
  "///< Access the last attribute in this element.\n"
  "\n"
  "///< Access the last attribute in this element.";
#else
static const char *Dtool_TiXmlElement_LastAttribute_80_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * char const *TiXmlElement::GetText(void) const
 */
static PyObject *Dtool_TiXmlElement_GetText_81(PyObject *self, PyObject *) {
  TiXmlElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlElement)) {
    return nullptr;
  }
  // 1-char const *TiXmlElement::GetText(void) const
  char const *return_value = ((*(const TiXmlElement*)local_this).GetText)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlElement_GetText_81_comment =
  "C++ Interface:\n"
  "GetText(TiXmlElement self)\n"
  "\n"
  "/** Convenience function for easy access to the text inside an element. Although easy\n"
  "        and concise, GetText() is limited compared to getting the TiXmlText child\n"
  "        and accessing it directly.\n"
  "\n"
  "        If the first child of 'this' is a TiXmlText, the GetText()\n"
  "        returns the character string of the Text node, else null is returned.\n"
  "\n"
  "        This is a convenient method for getting the text of simple contained text:\n"
  "        @verbatim\n"
  "        <foo>This is text</foo>\n"
  "        const char* str = fooElement->GetText();\n"
  "        @endverbatim\n"
  "\n"
  "        'str' will be a pointer to \"This is text\".\n"
  "\n"
  "        Note that this function can be misleading. If the element foo was created from\n"
  "        this XML:\n"
  "        @verbatim\n"
  "        <foo><b>This is text</b></foo>\n"
  "        @endverbatim\n"
  "\n"
  "        then the value of str would be null. The first child node isn't a text node, it is\n"
  "        another element. From this XML:\n"
  "        @verbatim\n"
  "        <foo>This is <b>text</b></foo>\n"
  "        @endverbatim\n"
  "        GetText() will return \"This is \".\n"
  "\n"
  "        WARNING: GetText() accesses a child node - don't become confused with the\n"
  "                 similarly named TiXmlHandle::Text() and TiXmlNode::ToText() which are\n"
  "                 safe type casts on the referenced node.\n"
  "    */";
#else
static const char *Dtool_TiXmlElement_GetText_81_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlElement::TiXmlElement(TiXmlElement const &)
 * TiXmlElement::TiXmlElement(char const *in_value)
 * TiXmlElement::TiXmlElement(std::string const &_value)
 */
static int Dtool_Init_TiXmlElement(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "TiXmlElement() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 TiXmlElement::TiXmlElement(TiXmlElement const &)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      TiXmlElement const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TiXmlElement);
      if (param0_this != nullptr) {
        TiXmlElement *return_value = new TiXmlElement(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlElement, true, false);
      }
    }
  }

  {
    // -2 TiXmlElement::TiXmlElement(std::string const &_value)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"_value", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:TiXmlElement", (char **)keyword_list, &param0_str, &param0_len)) {
      TiXmlElement *return_value = new TiXmlElement(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlElement, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 TiXmlElement::TiXmlElement(char const *in_value)
    char const *param0;
    static const char *keyword_list[] = {"in_value", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "z:TiXmlElement", (char **)keyword_list, &param0)) {
      TiXmlElement *return_value = new TiXmlElement((char const *)param0);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlElement, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: TiXmlElement::TiXmlElement(TiXmlElement const &)
  // No coercion possible: TiXmlElement::TiXmlElement(std::string const &_value)
  // No coercion possible: TiXmlElement::TiXmlElement(char const *in_value)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TiXmlElement(const TiXmlElement param0)\n"
      "TiXmlElement(str _value)\n"
      "TiXmlElement(str in_value)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TiXmlElement(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TiXmlElement) {
    printf("TiXmlElement ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TiXmlElement *local_this = (TiXmlElement *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TiXmlElement) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TiXmlBase) {
    return (TiXmlBase *)(TiXmlNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TiXmlNode) {
    return (TiXmlNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TiXmlElement(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TiXmlElement) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TiXmlBase) {
    TiXmlBase* other_this = (TiXmlBase*)from_this;
    return (TiXmlElement*)other_this;
  }
  if (from_type == Dtool_Ptr_TiXmlNode) {
    TiXmlNode* other_this = (TiXmlNode*)from_this;
    return (TiXmlElement*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TiXmlCursor
 */
/**
 * Python function wrapper for:
 * inline TiXmlCursor::TiXmlCursor(TiXmlCursor const &) = default
 */
static int Dtool_Init_TiXmlCursor(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("TiXmlCursor() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline TiXmlCursor::TiXmlCursor(TiXmlCursor const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    TiXmlCursor const *param0_this = (TiXmlCursor *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_TiXmlCursor, 0, "TiXmlCursor.TiXmlCursor", true, true);
    if (param0_this != nullptr) {
      TiXmlCursor *return_value = new TiXmlCursor(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlCursor, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TiXmlCursor(const TiXmlCursor param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TiXmlCursor(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TiXmlCursor) {
    printf("TiXmlCursor ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TiXmlCursor *local_this = (TiXmlCursor *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TiXmlCursor) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TiXmlCursor(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TiXmlCursor) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TiXmlVisitor
 */
/**
 * Python function wrapper for:
 * virtual bool TiXmlVisitor::VisitEnter(TiXmlDocument const &)
 * virtual bool TiXmlVisitor::VisitEnter(TiXmlElement const &, TiXmlAttribute const *)
 */
static PyObject *Dtool_TiXmlVisitor_VisitEnter_98(PyObject *self, PyObject *args) {
  TiXmlVisitor *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlVisitor, (void **)&local_this, "TiXmlVisitor.VisitEnter")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-virtual bool TiXmlVisitor::VisitEnter(TiXmlDocument const &)
      TiXmlDocument arg_local;
      TiXmlDocument const *arg_this = Dtool_Coerce_TiXmlDocument(arg, arg_local);
      if (!(arg_this != nullptr)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "TiXmlVisitor.VisitEnter", "TiXmlDocument");
      }
      bool return_value = ((*local_this).VisitEnter)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 2:
    {
      // 1-virtual bool TiXmlVisitor::VisitEnter(TiXmlElement const &, TiXmlAttribute const *)
      PyObject *param1;
      PyObject *param2;
      if (PyArg_UnpackTuple(args, "VisitEnter", 2, 2, &param1, &param2)) {
        TiXmlElement const *param1_this = (TiXmlElement *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TiXmlElement, 1, "TiXmlVisitor.VisitEnter", true, true);
        TiXmlAttribute const *param2_this = (TiXmlAttribute *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TiXmlAttribute, 2, "TiXmlVisitor.VisitEnter", true, true);
        if (param1_this != nullptr && param2_this != nullptr) {
          bool return_value = ((*local_this).VisitEnter)(*param1_this, param2_this);
          return Dtool_Return_Bool(return_value);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "VisitEnter() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "VisitEnter(const TiXmlVisitor self, const TiXmlDocument param0)\n"
      "VisitEnter(const TiXmlVisitor self, const TiXmlElement param0, const TiXmlAttribute param1)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlVisitor_VisitEnter_98_comment =
  "C++ Interface:\n"
  "VisitEnter(const TiXmlVisitor self, const TiXmlDocument param0)\n"
  "VisitEnter(const TiXmlVisitor self, const TiXmlElement param0, const TiXmlAttribute param1)\n"
  "\n"
  "/*doc*/\n"
  "\n"
  "/*firstAttribute*/";
#else
static const char *Dtool_TiXmlVisitor_VisitEnter_98_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool TiXmlVisitor::VisitExit(TiXmlDocument const &)
 * virtual bool TiXmlVisitor::VisitExit(TiXmlElement const &)
 */
static PyObject *Dtool_TiXmlVisitor_VisitExit_99(PyObject *self, PyObject *arg) {
  TiXmlVisitor *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlVisitor, (void **)&local_this, "TiXmlVisitor.VisitExit")) {
    return nullptr;
  }
  {
    // -2 virtual bool TiXmlVisitor::VisitExit(TiXmlDocument const &)
    TiXmlDocument const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TiXmlDocument);
    if (arg_this != nullptr) {
      bool return_value = ((*local_this).VisitExit)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 virtual bool TiXmlVisitor::VisitExit(TiXmlElement const &)
    TiXmlElement const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TiXmlElement);
    if (arg_this != nullptr) {
      bool return_value = ((*local_this).VisitExit)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 virtual bool TiXmlVisitor::VisitExit(TiXmlDocument const &)
    TiXmlDocument arg_local;
    TiXmlDocument const *arg_this = Dtool_Coerce_TiXmlDocument(arg, arg_local);
    if ((arg_this != nullptr)) {
      bool return_value = ((*local_this).VisitExit)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  // No coercion possible: virtual bool TiXmlVisitor::VisitExit(TiXmlElement const &)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "VisitExit(const TiXmlVisitor self, const TiXmlDocument param0)\n"
      "VisitExit(const TiXmlVisitor self, const TiXmlElement param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlVisitor_VisitExit_99_comment =
  "C++ Interface:\n"
  "VisitExit(const TiXmlVisitor self, const TiXmlDocument param0)\n"
  "VisitExit(const TiXmlVisitor self, const TiXmlElement param0)\n"
  "\n"
  "/*doc*/\n"
  "\n"
  "/*element*/";
#else
static const char *Dtool_TiXmlVisitor_VisitExit_99_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool TiXmlVisitor::Visit(TiXmlComment const &)
 * virtual bool TiXmlVisitor::Visit(TiXmlDeclaration const &)
 * virtual bool TiXmlVisitor::Visit(TiXmlText const &)
 * virtual bool TiXmlVisitor::Visit(TiXmlUnknown const &)
 */
static PyObject *Dtool_TiXmlVisitor_Visit_100(PyObject *self, PyObject *arg) {
  TiXmlVisitor *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlVisitor, (void **)&local_this, "TiXmlVisitor.Visit")) {
    return nullptr;
  }
  {
    // -2 virtual bool TiXmlVisitor::Visit(TiXmlComment const &)
    TiXmlComment const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TiXmlComment);
    if (arg_this != nullptr) {
      bool return_value = ((*local_this).Visit)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 virtual bool TiXmlVisitor::Visit(TiXmlDeclaration const &)
    TiXmlDeclaration const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TiXmlDeclaration);
    if (arg_this != nullptr) {
      bool return_value = ((*local_this).Visit)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 virtual bool TiXmlVisitor::Visit(TiXmlText const &)
    TiXmlText const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TiXmlText);
    if (arg_this != nullptr) {
      bool return_value = ((*local_this).Visit)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 virtual bool TiXmlVisitor::Visit(TiXmlUnknown const &)
    TiXmlUnknown const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TiXmlUnknown);
    if (arg_this != nullptr) {
      bool return_value = ((*local_this).Visit)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 virtual bool TiXmlVisitor::Visit(TiXmlComment const &)
    TiXmlComment arg_local;
    TiXmlComment const *arg_this = Dtool_Coerce_TiXmlComment(arg, arg_local);
    if ((arg_this != nullptr)) {
      bool return_value = ((*local_this).Visit)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 virtual bool TiXmlVisitor::Visit(TiXmlDeclaration const &)
    TiXmlDeclaration arg_local;
    TiXmlDeclaration const *arg_this = Dtool_Coerce_TiXmlDeclaration(arg, arg_local);
    if ((arg_this != nullptr)) {
      bool return_value = ((*local_this).Visit)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  // No coercion possible: virtual bool TiXmlVisitor::Visit(TiXmlText const &)
  // No coercion possible: virtual bool TiXmlVisitor::Visit(TiXmlUnknown const &)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "Visit(const TiXmlVisitor self, const TiXmlComment param0)\n"
      "Visit(const TiXmlVisitor self, const TiXmlDeclaration param0)\n"
      "Visit(const TiXmlVisitor self, const TiXmlText param0)\n"
      "Visit(const TiXmlVisitor self, const TiXmlUnknown param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlVisitor_Visit_100_comment =
  "C++ Interface:\n"
  "Visit(const TiXmlVisitor self, const TiXmlComment param0)\n"
  "Visit(const TiXmlVisitor self, const TiXmlDeclaration param0)\n"
  "Visit(const TiXmlVisitor self, const TiXmlText param0)\n"
  "Visit(const TiXmlVisitor self, const TiXmlUnknown param0)\n"
  "\n"
  "/*declaration*/\n"
  "\n"
  "/*text*/\n"
  "\n"
  "/*comment*/\n"
  "\n"
  "/*unknown*/";
#else
static const char *Dtool_TiXmlVisitor_Visit_100_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TiXmlVisitor::TiXmlVisitor(void) = default
 * inline TiXmlVisitor::TiXmlVisitor(TiXmlVisitor const &) = default
 */
static int Dtool_Init_TiXmlVisitor(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("TiXmlVisitor() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline TiXmlVisitor::TiXmlVisitor(void) = default
      TiXmlVisitor *return_value = new TiXmlVisitor();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlVisitor, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline TiXmlVisitor::TiXmlVisitor(TiXmlVisitor const &) = default
      TiXmlVisitor const *arg_this = (TiXmlVisitor *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TiXmlVisitor, 0, "TiXmlVisitor.TiXmlVisitor", true, true);
      if (arg_this != nullptr) {
        TiXmlVisitor *return_value = new TiXmlVisitor(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlVisitor, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "TiXmlVisitor() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TiXmlVisitor()\n"
      "TiXmlVisitor(const TiXmlVisitor param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TiXmlVisitor(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TiXmlVisitor) {
    printf("TiXmlVisitor ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TiXmlVisitor *local_this = (TiXmlVisitor *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TiXmlVisitor) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TiXmlVisitor(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TiXmlVisitor) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TiXmlAttribute
 */
/**
 * Python function wrapper for:
 * char const *TiXmlAttribute::Name(void) const
 */
static PyObject *Dtool_TiXmlAttribute_Name_108(PyObject *self, PyObject *) {
  TiXmlAttribute *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlAttribute)) {
    return nullptr;
  }
  // 1-char const *TiXmlAttribute::Name(void) const
  char const *return_value = ((*(const TiXmlAttribute*)local_this).Name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlAttribute_Name_108_comment =
  "C++ Interface:\n"
  "Name(TiXmlAttribute self)\n"
  "\n"
  "///< Return the name of this attribute.";
#else
static const char *Dtool_TiXmlAttribute_Name_108_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * char const *TiXmlAttribute::Value(void) const
 */
static PyObject *Dtool_TiXmlAttribute_Value_109(PyObject *self, PyObject *) {
  TiXmlAttribute *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlAttribute)) {
    return nullptr;
  }
  // 1-char const *TiXmlAttribute::Value(void) const
  char const *return_value = ((*(const TiXmlAttribute*)local_this).Value)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlAttribute_Value_109_comment =
  "C++ Interface:\n"
  "Value(TiXmlAttribute self)\n"
  "\n"
  "///< Return the value of this attribute.";
#else
static const char *Dtool_TiXmlAttribute_Value_109_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string const &TiXmlAttribute::ValueStr(void) const
 */
static PyObject *Dtool_TiXmlAttribute_ValueStr_110(PyObject *self, PyObject *) {
  TiXmlAttribute *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlAttribute)) {
    return nullptr;
  }
  // 1-std::string const &TiXmlAttribute::ValueStr(void) const
  std::string const &return_value = ((*(const TiXmlAttribute*)local_this).ValueStr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlAttribute_ValueStr_110_comment =
  "C++ Interface:\n"
  "ValueStr(TiXmlAttribute self)\n"
  "\n"
  "///< Return the value of this attribute.";
#else
static const char *Dtool_TiXmlAttribute_ValueStr_110_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int TiXmlAttribute::IntValue(void) const
 */
static PyObject *Dtool_TiXmlAttribute_IntValue_111(PyObject *self, PyObject *) {
  TiXmlAttribute *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlAttribute)) {
    return nullptr;
  }
  // 1-int TiXmlAttribute::IntValue(void) const
  int return_value = ((*(const TiXmlAttribute*)local_this).IntValue)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlAttribute_IntValue_111_comment =
  "C++ Interface:\n"
  "IntValue(TiXmlAttribute self)\n"
  "\n"
  "///< Return the value of this attribute, converted to an integer.";
#else
static const char *Dtool_TiXmlAttribute_IntValue_111_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * double TiXmlAttribute::DoubleValue(void) const
 */
static PyObject *Dtool_TiXmlAttribute_DoubleValue_112(PyObject *self, PyObject *) {
  TiXmlAttribute *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlAttribute)) {
    return nullptr;
  }
  // 1-double TiXmlAttribute::DoubleValue(void) const
  double return_value = ((*(const TiXmlAttribute*)local_this).DoubleValue)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlAttribute_DoubleValue_112_comment =
  "C++ Interface:\n"
  "DoubleValue(TiXmlAttribute self)\n"
  "\n"
  "///< Return the value of this attribute, converted to a double.";
#else
static const char *Dtool_TiXmlAttribute_DoubleValue_112_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string const &TiXmlAttribute::NameTStr(void) const
 */
static PyObject *Dtool_TiXmlAttribute_NameTStr_113(PyObject *self, PyObject *) {
  TiXmlAttribute *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlAttribute)) {
    return nullptr;
  }
  // 1-std::string const &TiXmlAttribute::NameTStr(void) const
  std::string const &return_value = ((*(const TiXmlAttribute*)local_this).NameTStr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlAttribute_NameTStr_113_comment =
  "C++ Interface:\n"
  "NameTStr(TiXmlAttribute self)\n"
  "\n"
  "// Get the tinyxml string representation";
#else
static const char *Dtool_TiXmlAttribute_NameTStr_113_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TiXmlAttribute::SetName(char const *_name)
 * void TiXmlAttribute::SetName(std::string const &_name)
 */
static PyObject *Dtool_TiXmlAttribute_SetName_116(PyObject *self, PyObject *arg) {
  TiXmlAttribute *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlAttribute, (void **)&local_this, "TiXmlAttribute.SetName")) {
    return nullptr;
  }
  {
    // -2 void TiXmlAttribute::SetName(std::string const &_name)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      ((*local_this).SetName)(std::string(param1_str, param1_len));
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  {
    // -2 void TiXmlAttribute::SetName(char const *_name)
    char const *param1;
    if (PyArg_Parse(arg, "z:SetName", &param1)) {
      ((*local_this).SetName)((char const *)param1);
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  // No coercion possible: void TiXmlAttribute::SetName(std::string const &_name)
  // No coercion possible: void TiXmlAttribute::SetName(char const *_name)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetName(const TiXmlAttribute self, str _name)\n"
      "SetName(const TiXmlAttribute self, str _name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlAttribute_SetName_116_comment =
  "C++ Interface:\n"
  "SetName(const TiXmlAttribute self, str _name)\n"
  "SetName(const TiXmlAttribute self, str _name)\n"
  "\n"
  "///< Set the name of this attribute.\n"
  "\n"
  "/// STL std::string form.";
#else
static const char *Dtool_TiXmlAttribute_SetName_116_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TiXmlAttribute::SetValue(char const *_value)
 * void TiXmlAttribute::SetValue(std::string const &_value)
 */
static PyObject *Dtool_TiXmlAttribute_SetValue_117(PyObject *self, PyObject *arg) {
  TiXmlAttribute *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlAttribute, (void **)&local_this, "TiXmlAttribute.SetValue")) {
    return nullptr;
  }
  {
    // -2 void TiXmlAttribute::SetValue(std::string const &_value)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      ((*local_this).SetValue)(std::string(param1_str, param1_len));
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  {
    // -2 void TiXmlAttribute::SetValue(char const *_value)
    char const *param1;
    if (PyArg_Parse(arg, "z:SetValue", &param1)) {
      ((*local_this).SetValue)((char const *)param1);
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  // No coercion possible: void TiXmlAttribute::SetValue(std::string const &_value)
  // No coercion possible: void TiXmlAttribute::SetValue(char const *_value)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetValue(const TiXmlAttribute self, str _value)\n"
      "SetValue(const TiXmlAttribute self, str _value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlAttribute_SetValue_117_comment =
  "C++ Interface:\n"
  "SetValue(const TiXmlAttribute self, str _value)\n"
  "SetValue(const TiXmlAttribute self, str _value)\n"
  "\n"
  "///< Set the value.\n"
  "\n"
  "/// STL std::string form.";
#else
static const char *Dtool_TiXmlAttribute_SetValue_117_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TiXmlAttribute::SetIntValue(int _value)
 */
static PyObject *Dtool_TiXmlAttribute_SetIntValue_118(PyObject *self, PyObject *arg) {
  TiXmlAttribute *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlAttribute, (void **)&local_this, "TiXmlAttribute.SetIntValue")) {
    return nullptr;
  }
  // 1-void TiXmlAttribute::SetIntValue(int _value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).SetIntValue)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetIntValue(const TiXmlAttribute self, int _value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlAttribute_SetIntValue_118_comment =
  "C++ Interface:\n"
  "SetIntValue(const TiXmlAttribute self, int _value)\n"
  "\n"
  "///< Set the value from an integer.";
#else
static const char *Dtool_TiXmlAttribute_SetIntValue_118_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TiXmlAttribute::SetDoubleValue(double _value)
 */
static PyObject *Dtool_TiXmlAttribute_SetDoubleValue_119(PyObject *self, PyObject *arg) {
  TiXmlAttribute *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlAttribute, (void **)&local_this, "TiXmlAttribute.SetDoubleValue")) {
    return nullptr;
  }
  // 1-void TiXmlAttribute::SetDoubleValue(double _value)
  if (PyNumber_Check(arg)) {
    ((*local_this).SetDoubleValue)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetDoubleValue(const TiXmlAttribute self, double _value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlAttribute_SetDoubleValue_119_comment =
  "C++ Interface:\n"
  "SetDoubleValue(const TiXmlAttribute self, double _value)\n"
  "\n"
  "///< Set the value from a double.";
#else
static const char *Dtool_TiXmlAttribute_SetDoubleValue_119_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlAttribute *TiXmlAttribute::Next(void)
 * TiXmlAttribute const *TiXmlAttribute::Next(void) const
 */
static PyObject *Dtool_TiXmlAttribute_Next_120(PyObject *self, PyObject *) {
  TiXmlAttribute *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlAttribute)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 TiXmlAttribute *TiXmlAttribute::Next(void)
    TiXmlAttribute *return_value = ((*local_this).Next)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlAttribute, false, false);
  }

  {
    // -2 TiXmlAttribute const *TiXmlAttribute::Next(void) const
    TiXmlAttribute const *return_value = ((*(const TiXmlAttribute*)local_this).Next)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlAttribute, false, true);
  }

  // No coercion possible: TiXmlAttribute *TiXmlAttribute::Next(void)
  // No coercion possible: TiXmlAttribute const *TiXmlAttribute::Next(void) const
}

#ifndef NDEBUG
static const char *Dtool_TiXmlAttribute_Next_120_comment =
  "C++ Interface:\n"
  "Next(const TiXmlAttribute self)\n"
  "Next(TiXmlAttribute self)\n"
  "\n"
  "/// Get the next sibling attribute in the DOM. Returns null at end.";
#else
static const char *Dtool_TiXmlAttribute_Next_120_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlAttribute *TiXmlAttribute::Previous(void)
 * TiXmlAttribute const *TiXmlAttribute::Previous(void) const
 */
static PyObject *Dtool_TiXmlAttribute_Previous_121(PyObject *self, PyObject *) {
  TiXmlAttribute *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlAttribute)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 TiXmlAttribute *TiXmlAttribute::Previous(void)
    TiXmlAttribute *return_value = ((*local_this).Previous)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlAttribute, false, false);
  }

  {
    // -2 TiXmlAttribute const *TiXmlAttribute::Previous(void) const
    TiXmlAttribute const *return_value = ((*(const TiXmlAttribute*)local_this).Previous)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlAttribute, false, true);
  }

  // No coercion possible: TiXmlAttribute *TiXmlAttribute::Previous(void)
  // No coercion possible: TiXmlAttribute const *TiXmlAttribute::Previous(void) const
}

#ifndef NDEBUG
static const char *Dtool_TiXmlAttribute_Previous_121_comment =
  "C++ Interface:\n"
  "Previous(const TiXmlAttribute self)\n"
  "Previous(TiXmlAttribute self)\n"
  "\n"
  "/// Get the previous sibling attribute in the DOM. Returns null at beginning.";
#else
static const char *Dtool_TiXmlAttribute_Previous_121_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TiXmlAttribute::SetDocument(TiXmlDocument *doc)
 */
static PyObject *Dtool_TiXmlAttribute_SetDocument_126(PyObject *self, PyObject *arg) {
  TiXmlAttribute *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlAttribute, (void **)&local_this, "TiXmlAttribute.SetDocument")) {
    return nullptr;
  }
  // 1-void TiXmlAttribute::SetDocument(TiXmlDocument *doc)
  TiXmlDocument arg_local;
  TiXmlDocument *arg_this = Dtool_Coerce_TiXmlDocument(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "TiXmlAttribute.SetDocument", "TiXmlDocument");
  }
  ((*local_this).SetDocument)(arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetDocument(const TiXmlAttribute self, TiXmlDocument doc)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlAttribute_SetDocument_126_comment =
  "C++ Interface:\n"
  "SetDocument(const TiXmlAttribute self, TiXmlDocument doc)\n"
  "\n"
  "// [internal use]\n"
  "// Set the document pointer so the attribute can report errors.";
#else
static const char *Dtool_TiXmlAttribute_SetDocument_126_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlAttribute::TiXmlAttribute(void)
 * TiXmlAttribute::TiXmlAttribute(char const *_name, char const *_value)
 * TiXmlAttribute::TiXmlAttribute(std::string const &_name, std::string const &_value)
 */
static int Dtool_Init_TiXmlAttribute(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-TiXmlAttribute::TiXmlAttribute(void)
      TiXmlAttribute *return_value = new TiXmlAttribute();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlAttribute, true, false);
    }
    break;
  case 2:
    {
      {
        // -2 TiXmlAttribute::TiXmlAttribute(std::string const &_name, std::string const &_value)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        static const char *keyword_list[] = {"_name", "_value", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:TiXmlAttribute", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len)) {
          TiXmlAttribute *return_value = new TiXmlAttribute(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlAttribute, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 TiXmlAttribute::TiXmlAttribute(char const *_name, char const *_value)
        char const *param0;
        char const *param1;
        static const char *keyword_list[] = {"_name", "_value", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "zz:TiXmlAttribute", (char **)keyword_list, &param0, &param1)) {
          TiXmlAttribute *return_value = new TiXmlAttribute((char const *)param0, (char const *)param1);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlAttribute, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: TiXmlAttribute::TiXmlAttribute(std::string const &_name, std::string const &_value)
      // No coercion possible: TiXmlAttribute::TiXmlAttribute(char const *_name, char const *_value)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "TiXmlAttribute() takes 0 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TiXmlAttribute()\n"
      "TiXmlAttribute(str _name, str _value)\n"
      "TiXmlAttribute(str _name, str _value)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TiXmlAttribute(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TiXmlAttribute) {
    printf("TiXmlAttribute ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TiXmlAttribute *local_this = (TiXmlAttribute *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TiXmlAttribute) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TiXmlBase) {
    return (TiXmlBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TiXmlAttribute(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TiXmlAttribute) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TiXmlBase) {
    TiXmlBase* other_this = (TiXmlBase*)from_this;
    return (TiXmlAttribute*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TiXmlAttributeSet
 */
/**
 * Python function wrapper for:
 * void TiXmlAttributeSet::Add(TiXmlAttribute *attribute)
 */
static PyObject *Dtool_TiXmlAttributeSet_Add_131(PyObject *self, PyObject *arg) {
  TiXmlAttributeSet *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlAttributeSet, (void **)&local_this, "TiXmlAttributeSet.Add")) {
    return nullptr;
  }
  // 1-void TiXmlAttributeSet::Add(TiXmlAttribute *attribute)
  TiXmlAttribute *arg_this = (TiXmlAttribute *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TiXmlAttribute, 1, "TiXmlAttributeSet.Add", false, true);
  if (arg_this != nullptr) {
    ((*local_this).Add)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "Add(const TiXmlAttributeSet self, TiXmlAttribute attribute)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlAttributeSet_Add_131_comment =
  "C++ Interface:\n"
  "Add(const TiXmlAttributeSet self, TiXmlAttribute attribute)\n";
#else
static const char *Dtool_TiXmlAttributeSet_Add_131_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TiXmlAttributeSet::Remove(TiXmlAttribute *attribute)
 */
static PyObject *Dtool_TiXmlAttributeSet_Remove_132(PyObject *self, PyObject *arg) {
  TiXmlAttributeSet *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlAttributeSet, (void **)&local_this, "TiXmlAttributeSet.Remove")) {
    return nullptr;
  }
  // 1-void TiXmlAttributeSet::Remove(TiXmlAttribute *attribute)
  TiXmlAttribute *arg_this = (TiXmlAttribute *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TiXmlAttribute, 1, "TiXmlAttributeSet.Remove", false, true);
  if (arg_this != nullptr) {
    ((*local_this).Remove)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "Remove(const TiXmlAttributeSet self, TiXmlAttribute attribute)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlAttributeSet_Remove_132_comment =
  "C++ Interface:\n"
  "Remove(const TiXmlAttributeSet self, TiXmlAttribute attribute)\n";
#else
static const char *Dtool_TiXmlAttributeSet_Remove_132_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlAttribute *TiXmlAttributeSet::First(void)
 * TiXmlAttribute const *TiXmlAttributeSet::First(void) const
 */
static PyObject *Dtool_TiXmlAttributeSet_First_133(PyObject *self, PyObject *) {
  TiXmlAttributeSet *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlAttributeSet)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 TiXmlAttribute *TiXmlAttributeSet::First(void)
    TiXmlAttribute *return_value = ((*local_this).First)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlAttribute, false, false);
  }

  {
    // -2 TiXmlAttribute const *TiXmlAttributeSet::First(void) const
    TiXmlAttribute const *return_value = ((*(const TiXmlAttributeSet*)local_this).First)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlAttribute, false, true);
  }

  // No coercion possible: TiXmlAttribute *TiXmlAttributeSet::First(void)
  // No coercion possible: TiXmlAttribute const *TiXmlAttributeSet::First(void) const
}

#ifndef NDEBUG
static const char *Dtool_TiXmlAttributeSet_First_133_comment =
  "C++ Interface:\n"
  "First(const TiXmlAttributeSet self)\n"
  "First(TiXmlAttributeSet self)\n";
#else
static const char *Dtool_TiXmlAttributeSet_First_133_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlAttribute *TiXmlAttributeSet::Last(void)
 * TiXmlAttribute const *TiXmlAttributeSet::Last(void) const
 */
static PyObject *Dtool_TiXmlAttributeSet_Last_134(PyObject *self, PyObject *) {
  TiXmlAttributeSet *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlAttributeSet)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 TiXmlAttribute *TiXmlAttributeSet::Last(void)
    TiXmlAttribute *return_value = ((*local_this).Last)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlAttribute, false, false);
  }

  {
    // -2 TiXmlAttribute const *TiXmlAttributeSet::Last(void) const
    TiXmlAttribute const *return_value = ((*(const TiXmlAttributeSet*)local_this).Last)();
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlAttribute, false, true);
  }

  // No coercion possible: TiXmlAttribute *TiXmlAttributeSet::Last(void)
  // No coercion possible: TiXmlAttribute const *TiXmlAttributeSet::Last(void) const
}

#ifndef NDEBUG
static const char *Dtool_TiXmlAttributeSet_Last_134_comment =
  "C++ Interface:\n"
  "Last(const TiXmlAttributeSet self)\n"
  "Last(TiXmlAttributeSet self)\n";
#else
static const char *Dtool_TiXmlAttributeSet_Last_134_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlAttribute *TiXmlAttributeSet::Find(char const *_name) const
 * TiXmlAttribute *TiXmlAttributeSet::Find(std::string const &_name) const
 */
static PyObject *Dtool_TiXmlAttributeSet_Find_135(PyObject *self, PyObject *arg) {
  TiXmlAttributeSet *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlAttributeSet)) {
    return nullptr;
  }
  {
    // -2 TiXmlAttribute *TiXmlAttributeSet::Find(std::string const &_name) const
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      TiXmlAttribute *return_value = ((*(const TiXmlAttributeSet*)local_this).Find)(std::string(param1_str, param1_len));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlAttribute, false, false);
    }
    PyErr_Clear();
  }

  {
    // -2 TiXmlAttribute *TiXmlAttributeSet::Find(char const *_name) const
    char const *param1;
    if (PyArg_Parse(arg, "z:Find", &param1)) {
      TiXmlAttribute *return_value = ((*(const TiXmlAttributeSet*)local_this).Find)((char const *)param1);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlAttribute, false, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: TiXmlAttribute *TiXmlAttributeSet::Find(std::string const &_name) const
  // No coercion possible: TiXmlAttribute *TiXmlAttributeSet::Find(char const *_name) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "Find(TiXmlAttributeSet self, str _name)\n"
      "Find(TiXmlAttributeSet self, str _name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlAttributeSet_Find_135_comment =
  "C++ Interface:\n"
  "Find(TiXmlAttributeSet self, str _name)\n"
  "Find(TiXmlAttributeSet self, str _name)\n";
#else
static const char *Dtool_TiXmlAttributeSet_Find_135_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlAttribute *TiXmlAttributeSet::FindOrCreate(char const *_name)
 * TiXmlAttribute *TiXmlAttributeSet::FindOrCreate(std::string const &_name)
 */
static PyObject *Dtool_TiXmlAttributeSet_FindOrCreate_136(PyObject *self, PyObject *arg) {
  TiXmlAttributeSet *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlAttributeSet, (void **)&local_this, "TiXmlAttributeSet.FindOrCreate")) {
    return nullptr;
  }
  {
    // -2 TiXmlAttribute *TiXmlAttributeSet::FindOrCreate(std::string const &_name)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      TiXmlAttribute *return_value = ((*local_this).FindOrCreate)(std::string(param1_str, param1_len));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlAttribute, false, false);
    }
    PyErr_Clear();
  }

  {
    // -2 TiXmlAttribute *TiXmlAttributeSet::FindOrCreate(char const *_name)
    char const *param1;
    if (PyArg_Parse(arg, "z:FindOrCreate", &param1)) {
      TiXmlAttribute *return_value = ((*local_this).FindOrCreate)((char const *)param1);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlAttribute, false, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: TiXmlAttribute *TiXmlAttributeSet::FindOrCreate(std::string const &_name)
  // No coercion possible: TiXmlAttribute *TiXmlAttributeSet::FindOrCreate(char const *_name)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "FindOrCreate(const TiXmlAttributeSet self, str _name)\n"
      "FindOrCreate(const TiXmlAttributeSet self, str _name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlAttributeSet_FindOrCreate_136_comment =
  "C++ Interface:\n"
  "FindOrCreate(const TiXmlAttributeSet self, str _name)\n"
  "FindOrCreate(const TiXmlAttributeSet self, str _name)\n";
#else
static const char *Dtool_TiXmlAttributeSet_FindOrCreate_136_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlAttributeSet::TiXmlAttributeSet(void)
 */
static int Dtool_Init_TiXmlAttributeSet(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("TiXmlAttributeSet() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "TiXmlAttributeSet() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-TiXmlAttributeSet::TiXmlAttributeSet(void)
  TiXmlAttributeSet *return_value = new TiXmlAttributeSet();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlAttributeSet, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TiXmlAttributeSet()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TiXmlAttributeSet(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TiXmlAttributeSet) {
    printf("TiXmlAttributeSet ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TiXmlAttributeSet *local_this = (TiXmlAttributeSet *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TiXmlAttributeSet) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TiXmlAttributeSet(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TiXmlAttributeSet) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TiXmlComment
 */
/**
 * Python function wrapper for:
 * void TiXmlComment::operator =(TiXmlComment const &base)
 */
static PyObject *Dtool_TiXmlComment_operator_139(PyObject *self, PyObject *arg) {
  TiXmlComment *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlComment, (void **)&local_this, "TiXmlComment.assign")) {
    return nullptr;
  }
  // 1-void TiXmlComment::operator =(TiXmlComment const &base)
  TiXmlComment arg_local;
  TiXmlComment const *arg_this = Dtool_Coerce_TiXmlComment(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "TiXmlComment.assign", "TiXmlComment");
  }
  ((*local_this).operator =)(*arg_this);
  TiXmlComment *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlComment, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const TiXmlComment self, const TiXmlComment base)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlComment_operator_139_comment =
  "C++ Interface:\n"
  "assign(const TiXmlComment self, const TiXmlComment base)\n";
#else
static const char *Dtool_TiXmlComment_operator_139_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlComment::TiXmlComment(void)
 * TiXmlComment::TiXmlComment(TiXmlComment const &)
 * TiXmlComment::TiXmlComment(char const *_value)
 */
static int Dtool_Init_TiXmlComment(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-TiXmlComment::TiXmlComment(void)
      TiXmlComment *return_value = new TiXmlComment();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlComment, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 TiXmlComment::TiXmlComment(TiXmlComment const &)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          TiXmlComment const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TiXmlComment);
          if (param0_this != nullptr) {
            TiXmlComment *return_value = new TiXmlComment(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlComment, true, false);
          }
        }
      }

      {
        // -2 TiXmlComment::TiXmlComment(char const *_value)
        char const *param0;
        static const char *keyword_list[] = {"_value", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "z:TiXmlComment", (char **)keyword_list, &param0)) {
          TiXmlComment *return_value = new TiXmlComment((char const *)param0);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlComment, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 TiXmlComment::TiXmlComment(TiXmlComment const &)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          TiXmlComment param0_local;
          TiXmlComment const *param0_this = Dtool_Coerce_TiXmlComment(param0, param0_local);
          if ((param0_this != nullptr)) {
            TiXmlComment *return_value = new TiXmlComment(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlComment, true, false);
          }
        }
      }

      // No coercion possible: TiXmlComment::TiXmlComment(char const *_value)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "TiXmlComment() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TiXmlComment()\n"
      "TiXmlComment(const TiXmlComment param0)\n"
      "TiXmlComment(str _value)\n");
  }
  return -1;
}

TiXmlComment *Dtool_Coerce_TiXmlComment(PyObject *args, TiXmlComment &coerced) {
  TiXmlComment *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_TiXmlComment)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const TiXmlComment *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-TiXmlComment::TiXmlComment(char const *_value)
    char const *param0;
    if (PyArg_Parse(arg, "z:TiXmlComment", &param0)) {
      coerced = TiXmlComment((char const *)param0);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
    PyErr_Clear();
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_TiXmlComment(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TiXmlComment) {
    printf("TiXmlComment ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TiXmlComment *local_this = (TiXmlComment *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TiXmlComment) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TiXmlBase) {
    return (TiXmlBase *)(TiXmlNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TiXmlNode) {
    return (TiXmlNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TiXmlComment(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TiXmlComment) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TiXmlBase) {
    TiXmlBase* other_this = (TiXmlBase*)from_this;
    return (TiXmlComment*)other_this;
  }
  if (from_type == Dtool_Ptr_TiXmlNode) {
    TiXmlNode* other_this = (TiXmlNode*)from_this;
    return (TiXmlComment*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TiXmlText
 */
/**
 * Python function wrapper for:
 * void TiXmlText::operator =(TiXmlText const &base)
 */
static PyObject *Dtool_TiXmlText_operator_142(PyObject *self, PyObject *arg) {
  TiXmlText *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlText, (void **)&local_this, "TiXmlText.assign")) {
    return nullptr;
  }
  // 1-void TiXmlText::operator =(TiXmlText const &base)
  TiXmlText const *arg_this = (TiXmlText *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TiXmlText, 1, "TiXmlText.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    TiXmlText *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlText, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const TiXmlText self, const TiXmlText base)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlText_operator_142_comment =
  "C++ Interface:\n"
  "assign(const TiXmlText self, const TiXmlText base)\n";
#else
static const char *Dtool_TiXmlText_operator_142_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool TiXmlText::CDATA(void) const
 */
static PyObject *Dtool_TiXmlText_CDATA_143(PyObject *self, PyObject *) {
  TiXmlText *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlText)) {
    return nullptr;
  }
  // 1-bool TiXmlText::CDATA(void) const
  bool return_value = ((*(const TiXmlText*)local_this).CDATA)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlText_CDATA_143_comment =
  "C++ Interface:\n"
  "CDATA(TiXmlText self)\n"
  "\n"
  "/// Queries whether this represents text using a CDATA section.";
#else
static const char *Dtool_TiXmlText_CDATA_143_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TiXmlText::SetCDATA(bool _cdata)
 */
static PyObject *Dtool_TiXmlText_SetCDATA_144(PyObject *self, PyObject *arg) {
  TiXmlText *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlText, (void **)&local_this, "TiXmlText.SetCDATA")) {
    return nullptr;
  }
  // 1-void TiXmlText::SetCDATA(bool _cdata)
  ((*local_this).SetCDATA)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetCDATA(const TiXmlText self, bool _cdata)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlText_SetCDATA_144_comment =
  "C++ Interface:\n"
  "SetCDATA(const TiXmlText self, bool _cdata)\n"
  "\n"
  "/// Turns on or off a CDATA representation of text.";
#else
static const char *Dtool_TiXmlText_SetCDATA_144_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlText::TiXmlText(TiXmlText const &copy)
 * TiXmlText::TiXmlText(char const *initValue)
 * TiXmlText::TiXmlText(std::string const &initValue)
 */
static int Dtool_Init_TiXmlText(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "TiXmlText() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 TiXmlText::TiXmlText(TiXmlText const &copy)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
      TiXmlText const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TiXmlText);
      if (param0_this != nullptr) {
        TiXmlText *return_value = new TiXmlText(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlText, true, false);
      }
    }
  }

  {
    // -2 TiXmlText::TiXmlText(std::string const &initValue)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"initValue", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:TiXmlText", (char **)keyword_list, &param0_str, &param0_len)) {
      TiXmlText *return_value = new TiXmlText(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlText, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 TiXmlText::TiXmlText(char const *initValue)
    char const *param0;
    static const char *keyword_list[] = {"initValue", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "z:TiXmlText", (char **)keyword_list, &param0)) {
      TiXmlText *return_value = new TiXmlText((char const *)param0);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlText, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: TiXmlText::TiXmlText(TiXmlText const &copy)
  // No coercion possible: TiXmlText::TiXmlText(std::string const &initValue)
  // No coercion possible: TiXmlText::TiXmlText(char const *initValue)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TiXmlText(const TiXmlText copy)\n"
      "TiXmlText(str initValue)\n"
      "TiXmlText(str initValue)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TiXmlText(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TiXmlText) {
    printf("TiXmlText ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TiXmlText *local_this = (TiXmlText *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TiXmlText) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TiXmlBase) {
    return (TiXmlBase *)(TiXmlNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TiXmlNode) {
    return (TiXmlNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TiXmlText(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TiXmlText) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TiXmlBase) {
    TiXmlBase* other_this = (TiXmlBase*)from_this;
    return (TiXmlText*)other_this;
  }
  if (from_type == Dtool_Ptr_TiXmlNode) {
    TiXmlNode* other_this = (TiXmlNode*)from_this;
    return (TiXmlText*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TiXmlUnknown
 */
/**
 * Python function wrapper for:
 * void TiXmlUnknown::operator =(TiXmlUnknown const &copy)
 */
static PyObject *Dtool_TiXmlUnknown_operator_147(PyObject *self, PyObject *arg) {
  TiXmlUnknown *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlUnknown, (void **)&local_this, "TiXmlUnknown.assign")) {
    return nullptr;
  }
  // 1-void TiXmlUnknown::operator =(TiXmlUnknown const &copy)
  TiXmlUnknown const *arg_this = (TiXmlUnknown *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TiXmlUnknown, 1, "TiXmlUnknown.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    TiXmlUnknown *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlUnknown, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const TiXmlUnknown self, const TiXmlUnknown copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlUnknown_operator_147_comment =
  "C++ Interface:\n"
  "assign(const TiXmlUnknown self, const TiXmlUnknown copy)\n";
#else
static const char *Dtool_TiXmlUnknown_operator_147_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlUnknown::TiXmlUnknown(void)
 * TiXmlUnknown::TiXmlUnknown(TiXmlUnknown const &copy)
 */
static int Dtool_Init_TiXmlUnknown(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-TiXmlUnknown::TiXmlUnknown(void)
      TiXmlUnknown *return_value = new TiXmlUnknown();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlUnknown, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-TiXmlUnknown::TiXmlUnknown(TiXmlUnknown const &copy)
        TiXmlUnknown const *arg_this = (TiXmlUnknown *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TiXmlUnknown, 0, "TiXmlUnknown.TiXmlUnknown", true, true);
        if (arg_this != nullptr) {
          TiXmlUnknown *return_value = new TiXmlUnknown(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlUnknown, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "TiXmlUnknown() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TiXmlUnknown()\n"
      "TiXmlUnknown(const TiXmlUnknown copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TiXmlUnknown(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TiXmlUnknown) {
    printf("TiXmlUnknown ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TiXmlUnknown *local_this = (TiXmlUnknown *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TiXmlUnknown) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TiXmlBase) {
    return (TiXmlBase *)(TiXmlNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TiXmlNode) {
    return (TiXmlNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TiXmlUnknown(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TiXmlUnknown) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TiXmlBase) {
    TiXmlBase* other_this = (TiXmlBase*)from_this;
    return (TiXmlUnknown*)other_this;
  }
  if (from_type == Dtool_Ptr_TiXmlNode) {
    TiXmlNode* other_this = (TiXmlNode*)from_this;
    return (TiXmlUnknown*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TiXmlHandle
 */
/**
 * Python function wrapper for:
 * void TiXmlHandle::operator =(TiXmlHandle const &ref)
 */
static PyObject *Dtool_TiXmlHandle_operator_150(PyObject *self, PyObject *arg) {
  TiXmlHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlHandle, (void **)&local_this, "TiXmlHandle.assign")) {
    return nullptr;
  }
  // 1-void TiXmlHandle::operator =(TiXmlHandle const &ref)
  TiXmlHandle const *arg_this = (TiXmlHandle *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TiXmlHandle, 1, "TiXmlHandle.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    TiXmlHandle *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlHandle, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const TiXmlHandle self, const TiXmlHandle ref)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlHandle_operator_150_comment =
  "C++ Interface:\n"
  "assign(const TiXmlHandle self, const TiXmlHandle ref)\n";
#else
static const char *Dtool_TiXmlHandle_operator_150_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlHandle TiXmlHandle::FirstChild(void) const
 * TiXmlHandle TiXmlHandle::FirstChild(char const *value) const
 * TiXmlHandle TiXmlHandle::FirstChild(std::string const &_value) const
 */
static PyObject *Dtool_TiXmlHandle_FirstChild_151(PyObject *self, PyObject *args) {
  TiXmlHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlHandle)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-TiXmlHandle TiXmlHandle::FirstChild(void) const
      TiXmlHandle *return_value = new TiXmlHandle(((*(const TiXmlHandle*)local_this).FirstChild)());
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlHandle, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      {
        // -2 TiXmlHandle TiXmlHandle::FirstChild(std::string const &_value) const
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
        param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
          param1_str = nullptr;
        }
#endif
        if (param1_str != nullptr) {
          TiXmlHandle *return_value = new TiXmlHandle(((*(const TiXmlHandle*)local_this).FirstChild)(std::string(param1_str, param1_len)));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlHandle, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 TiXmlHandle TiXmlHandle::FirstChild(char const *value) const
        char const *param1;
        if (PyArg_Parse(arg, "z:FirstChild", &param1)) {
          TiXmlHandle *return_value = new TiXmlHandle(((*(const TiXmlHandle*)local_this).FirstChild)((char const *)param1));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlHandle, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: TiXmlHandle TiXmlHandle::FirstChild(std::string const &_value) const
      // No coercion possible: TiXmlHandle TiXmlHandle::FirstChild(char const *value) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "FirstChild() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "FirstChild(TiXmlHandle self)\n"
      "FirstChild(TiXmlHandle self, str _value)\n"
      "FirstChild(TiXmlHandle self, str value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlHandle_FirstChild_151_comment =
  "C++ Interface:\n"
  "FirstChild(TiXmlHandle self)\n"
  "FirstChild(TiXmlHandle self, str _value)\n"
  "FirstChild(TiXmlHandle self, str value)\n"
  "\n"
  "/// Return a handle to the first child node.\n"
  "\n"
  "/// Return a handle to the first child node with the given name.";
#else
static const char *Dtool_TiXmlHandle_FirstChild_151_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlHandle TiXmlHandle::FirstChildElement(void) const
 * TiXmlHandle TiXmlHandle::FirstChildElement(char const *value) const
 * TiXmlHandle TiXmlHandle::FirstChildElement(std::string const &_value) const
 */
static PyObject *Dtool_TiXmlHandle_FirstChildElement_152(PyObject *self, PyObject *args) {
  TiXmlHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlHandle)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-TiXmlHandle TiXmlHandle::FirstChildElement(void) const
      TiXmlHandle *return_value = new TiXmlHandle(((*(const TiXmlHandle*)local_this).FirstChildElement)());
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlHandle, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      {
        // -2 TiXmlHandle TiXmlHandle::FirstChildElement(std::string const &_value) const
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
        param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
          param1_str = nullptr;
        }
#endif
        if (param1_str != nullptr) {
          TiXmlHandle *return_value = new TiXmlHandle(((*(const TiXmlHandle*)local_this).FirstChildElement)(std::string(param1_str, param1_len)));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlHandle, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 TiXmlHandle TiXmlHandle::FirstChildElement(char const *value) const
        char const *param1;
        if (PyArg_Parse(arg, "z:FirstChildElement", &param1)) {
          TiXmlHandle *return_value = new TiXmlHandle(((*(const TiXmlHandle*)local_this).FirstChildElement)((char const *)param1));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlHandle, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: TiXmlHandle TiXmlHandle::FirstChildElement(std::string const &_value) const
      // No coercion possible: TiXmlHandle TiXmlHandle::FirstChildElement(char const *value) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "FirstChildElement() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "FirstChildElement(TiXmlHandle self)\n"
      "FirstChildElement(TiXmlHandle self, str _value)\n"
      "FirstChildElement(TiXmlHandle self, str value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlHandle_FirstChildElement_152_comment =
  "C++ Interface:\n"
  "FirstChildElement(TiXmlHandle self)\n"
  "FirstChildElement(TiXmlHandle self, str _value)\n"
  "FirstChildElement(TiXmlHandle self, str value)\n"
  "\n"
  "/// Return a handle to the first child element.\n"
  "\n"
  "/// Return a handle to the first child element with the given name.";
#else
static const char *Dtool_TiXmlHandle_FirstChildElement_152_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlHandle TiXmlHandle::Child(char const *value, int index) const
 * TiXmlHandle TiXmlHandle::Child(int index) const
 * TiXmlHandle TiXmlHandle::Child(std::string const &_value, int index) const
 */
static PyObject *Dtool_TiXmlHandle_Child_153(PyObject *self, PyObject *args, PyObject *kwds) {
  TiXmlHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlHandle)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "index")) {
        // 1-TiXmlHandle TiXmlHandle::Child(int index) const
        if (PyLongOrInt_Check(arg)) {
          long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (arg_val < INT_MIN || arg_val > INT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for signed integer",
                                arg_val);
          }
#endif
          TiXmlHandle *return_value = new TiXmlHandle(((*(const TiXmlHandle*)local_this).Child)((int)arg_val));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlHandle, true, false);
        }
      }
    }
    break;
  case 2:
    {
      {
        // -2 TiXmlHandle TiXmlHandle::Child(std::string const &_value, int index) const
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        int param2;
        static const char *keyword_list[] = {"_value", "index", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i:Child", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
          TiXmlHandle *return_value = new TiXmlHandle(((*(const TiXmlHandle*)local_this).Child)(std::string(param1_str, param1_len), (int)param2));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlHandle, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 TiXmlHandle TiXmlHandle::Child(char const *value, int index) const
        char const *param1;
        int param2;
        static const char *keyword_list[] = {"value", "index", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "zi:Child", (char **)keyword_list, &param1, &param2)) {
          TiXmlHandle *return_value = new TiXmlHandle(((*(const TiXmlHandle*)local_this).Child)((char const *)param1, (int)param2));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlHandle, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: TiXmlHandle TiXmlHandle::Child(std::string const &_value, int index) const
      // No coercion possible: TiXmlHandle TiXmlHandle::Child(char const *value, int index) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "Child() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "Child(TiXmlHandle self, int index)\n"
      "Child(TiXmlHandle self, str _value, int index)\n"
      "Child(TiXmlHandle self, str value, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlHandle_Child_153_comment =
  "C++ Interface:\n"
  "Child(TiXmlHandle self, int index)\n"
  "Child(TiXmlHandle self, str _value, int index)\n"
  "Child(TiXmlHandle self, str value, int index)\n"
  "\n"
  "/** Return a handle to the \"index\" child with the given name.\n"
  "        The first child is 0, the second 1, etc.\n"
  "    */\n"
  "\n"
  "/** Return a handle to the \"index\" child.\n"
  "        The first child is 0, the second 1, etc.\n"
  "    */";
#else
static const char *Dtool_TiXmlHandle_Child_153_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlHandle TiXmlHandle::ChildElement(char const *value, int index) const
 * TiXmlHandle TiXmlHandle::ChildElement(int index) const
 * TiXmlHandle TiXmlHandle::ChildElement(std::string const &_value, int index) const
 */
static PyObject *Dtool_TiXmlHandle_ChildElement_154(PyObject *self, PyObject *args, PyObject *kwds) {
  TiXmlHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlHandle)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "index")) {
        // 1-TiXmlHandle TiXmlHandle::ChildElement(int index) const
        if (PyLongOrInt_Check(arg)) {
          long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (arg_val < INT_MIN || arg_val > INT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for signed integer",
                                arg_val);
          }
#endif
          TiXmlHandle *return_value = new TiXmlHandle(((*(const TiXmlHandle*)local_this).ChildElement)((int)arg_val));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlHandle, true, false);
        }
      }
    }
    break;
  case 2:
    {
      {
        // -2 TiXmlHandle TiXmlHandle::ChildElement(std::string const &_value, int index) const
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        int param2;
        static const char *keyword_list[] = {"_value", "index", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i:ChildElement", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
          TiXmlHandle *return_value = new TiXmlHandle(((*(const TiXmlHandle*)local_this).ChildElement)(std::string(param1_str, param1_len), (int)param2));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlHandle, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 TiXmlHandle TiXmlHandle::ChildElement(char const *value, int index) const
        char const *param1;
        int param2;
        static const char *keyword_list[] = {"value", "index", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "zi:ChildElement", (char **)keyword_list, &param1, &param2)) {
          TiXmlHandle *return_value = new TiXmlHandle(((*(const TiXmlHandle*)local_this).ChildElement)((char const *)param1, (int)param2));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlHandle, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: TiXmlHandle TiXmlHandle::ChildElement(std::string const &_value, int index) const
      // No coercion possible: TiXmlHandle TiXmlHandle::ChildElement(char const *value, int index) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "ChildElement() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ChildElement(TiXmlHandle self, int index)\n"
      "ChildElement(TiXmlHandle self, str _value, int index)\n"
      "ChildElement(TiXmlHandle self, str value, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlHandle_ChildElement_154_comment =
  "C++ Interface:\n"
  "ChildElement(TiXmlHandle self, int index)\n"
  "ChildElement(TiXmlHandle self, str _value, int index)\n"
  "ChildElement(TiXmlHandle self, str value, int index)\n"
  "\n"
  "/** Return a handle to the \"index\" child element with the given name.\n"
  "        The first child element is 0, the second 1, etc. Note that only TiXmlElements\n"
  "        are indexed: other types are not counted.\n"
  "    */\n"
  "\n"
  "/** Return a handle to the \"index\" child element.\n"
  "        The first child element is 0, the second 1, etc. Note that only TiXmlElements\n"
  "        are indexed: other types are not counted.\n"
  "    */";
#else
static const char *Dtool_TiXmlHandle_ChildElement_154_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlNode *TiXmlHandle::ToNode(void) const
 */
static PyObject *Dtool_TiXmlHandle_ToNode_155(PyObject *self, PyObject *) {
  TiXmlHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlHandle)) {
    return nullptr;
  }
  // 1-TiXmlNode *TiXmlHandle::ToNode(void) const
  TiXmlNode *return_value = ((*(const TiXmlHandle*)local_this).ToNode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlHandle_ToNode_155_comment =
  "C++ Interface:\n"
  "ToNode(TiXmlHandle self)\n"
  "\n"
  "/** Return the handle as a TiXmlNode. This may return null.\n"
  "    */";
#else
static const char *Dtool_TiXmlHandle_ToNode_155_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlElement *TiXmlHandle::ToElement(void) const
 */
static PyObject *Dtool_TiXmlHandle_ToElement_156(PyObject *self, PyObject *) {
  TiXmlHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlHandle)) {
    return nullptr;
  }
  // 1-TiXmlElement *TiXmlHandle::ToElement(void) const
  TiXmlElement *return_value = ((*(const TiXmlHandle*)local_this).ToElement)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlElement, false, false);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlHandle_ToElement_156_comment =
  "C++ Interface:\n"
  "ToElement(TiXmlHandle self)\n"
  "\n"
  "/** Return the handle as a TiXmlElement. This may return null.\n"
  "    */";
#else
static const char *Dtool_TiXmlHandle_ToElement_156_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlText *TiXmlHandle::ToText(void) const
 */
static PyObject *Dtool_TiXmlHandle_ToText_157(PyObject *self, PyObject *) {
  TiXmlHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlHandle)) {
    return nullptr;
  }
  // 1-TiXmlText *TiXmlHandle::ToText(void) const
  TiXmlText *return_value = ((*(const TiXmlHandle*)local_this).ToText)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlText, false, false);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlHandle_ToText_157_comment =
  "C++ Interface:\n"
  "ToText(TiXmlHandle self)\n"
  "\n"
  "/** Return the handle as a TiXmlText. This may return null.\n"
  "    */";
#else
static const char *Dtool_TiXmlHandle_ToText_157_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlUnknown *TiXmlHandle::ToUnknown(void) const
 */
static PyObject *Dtool_TiXmlHandle_ToUnknown_158(PyObject *self, PyObject *) {
  TiXmlHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlHandle)) {
    return nullptr;
  }
  // 1-TiXmlUnknown *TiXmlHandle::ToUnknown(void) const
  TiXmlUnknown *return_value = ((*(const TiXmlHandle*)local_this).ToUnknown)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlUnknown, false, false);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlHandle_ToUnknown_158_comment =
  "C++ Interface:\n"
  "ToUnknown(TiXmlHandle self)\n"
  "\n"
  "/** Return the handle as a TiXmlUnknown. This may return null.\n"
  "    */";
#else
static const char *Dtool_TiXmlHandle_ToUnknown_158_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlNode *TiXmlHandle::Node(void) const
 */
static PyObject *Dtool_TiXmlHandle_Node_159(PyObject *self, PyObject *) {
  TiXmlHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlHandle)) {
    return nullptr;
  }
  // 1-TiXmlNode *TiXmlHandle::Node(void) const
  TiXmlNode *return_value = ((*(const TiXmlHandle*)local_this).Node)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlNode, false, false);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlHandle_Node_159_comment =
  "C++ Interface:\n"
  "Node(TiXmlHandle self)\n"
  "\n"
  "/** @deprecated use ToNode.\n"
  "        Return the handle as a TiXmlNode. This may return null.\n"
  "    */";
#else
static const char *Dtool_TiXmlHandle_Node_159_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlElement *TiXmlHandle::Element(void) const
 */
static PyObject *Dtool_TiXmlHandle_Element_160(PyObject *self, PyObject *) {
  TiXmlHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlHandle)) {
    return nullptr;
  }
  // 1-TiXmlElement *TiXmlHandle::Element(void) const
  TiXmlElement *return_value = ((*(const TiXmlHandle*)local_this).Element)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlElement, false, false);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlHandle_Element_160_comment =
  "C++ Interface:\n"
  "Element(TiXmlHandle self)\n"
  "\n"
  "/** @deprecated use ToElement.\n"
  "        Return the handle as a TiXmlElement. This may return null.\n"
  "    */";
#else
static const char *Dtool_TiXmlHandle_Element_160_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlText *TiXmlHandle::Text(void) const
 */
static PyObject *Dtool_TiXmlHandle_Text_161(PyObject *self, PyObject *) {
  TiXmlHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlHandle)) {
    return nullptr;
  }
  // 1-TiXmlText *TiXmlHandle::Text(void) const
  TiXmlText *return_value = ((*(const TiXmlHandle*)local_this).Text)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlText, false, false);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlHandle_Text_161_comment =
  "C++ Interface:\n"
  "Text(TiXmlHandle self)\n"
  "\n"
  "/** @deprecated use ToText()\n"
  "        Return the handle as a TiXmlText. This may return null.\n"
  "    */";
#else
static const char *Dtool_TiXmlHandle_Text_161_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlUnknown *TiXmlHandle::Unknown(void) const
 */
static PyObject *Dtool_TiXmlHandle_Unknown_162(PyObject *self, PyObject *) {
  TiXmlHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TiXmlHandle)) {
    return nullptr;
  }
  // 1-TiXmlUnknown *TiXmlHandle::Unknown(void) const
  TiXmlUnknown *return_value = ((*(const TiXmlHandle*)local_this).Unknown)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TiXmlUnknown, false, false);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlHandle_Unknown_162_comment =
  "C++ Interface:\n"
  "Unknown(TiXmlHandle self)\n"
  "\n"
  "/** @deprecated use ToUnknown()\n"
  "        Return the handle as a TiXmlUnknown. This may return null.\n"
  "    */";
#else
static const char *Dtool_TiXmlHandle_Unknown_162_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlHandle::TiXmlHandle(TiXmlHandle const &ref)
 * TiXmlHandle::TiXmlHandle(TiXmlNode *_node)
 */
static int Dtool_Init_TiXmlHandle(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "TiXmlHandle() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 TiXmlHandle::TiXmlHandle(TiXmlNode *_node)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "_node")) {
      TiXmlNode *param0_this = (TiXmlNode *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_TiXmlNode, 0, "TiXmlHandle.TiXmlHandle", false, false);
      if (param0_this != nullptr) {
        TiXmlHandle *return_value = new TiXmlHandle(param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlHandle, true, false);
      }
    }
  }

  {
    // -2 TiXmlHandle::TiXmlHandle(TiXmlHandle const &ref)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "ref")) {
      TiXmlHandle const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TiXmlHandle);
      if (param0_this != nullptr) {
        TiXmlHandle *return_value = new TiXmlHandle(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlHandle, true, false);
      }
    }
  }

  // No coercion possible: TiXmlHandle::TiXmlHandle(TiXmlNode *_node)
  // No coercion possible: TiXmlHandle::TiXmlHandle(TiXmlHandle const &ref)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TiXmlHandle(TiXmlNode _node)\n"
      "TiXmlHandle(const TiXmlHandle ref)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TiXmlHandle(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TiXmlHandle) {
    printf("TiXmlHandle ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TiXmlHandle *local_this = (TiXmlHandle *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TiXmlHandle) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TiXmlHandle(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TiXmlHandle) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TiXmlPrinter
 */
/**
 * Python function wrapper for:
 * void TiXmlPrinter::SetIndent(char const *_indent)
 */
static PyObject *Dtool_TiXmlPrinter_SetIndent_166(PyObject *self, PyObject *arg) {
  TiXmlPrinter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlPrinter, (void **)&local_this, "TiXmlPrinter.SetIndent")) {
    return nullptr;
  }
  // 1-void TiXmlPrinter::SetIndent(char const *_indent)
  char const *param1;
  if (PyArg_Parse(arg, "z:SetIndent", &param1)) {
    ((*local_this).SetIndent)((char const *)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetIndent(const TiXmlPrinter self, str _indent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlPrinter_SetIndent_166_comment =
  "C++ Interface:\n"
  "SetIndent(const TiXmlPrinter self, str _indent)\n"
  "\n"
  "/** Set the indent characters for printing. By default 4 spaces\n"
  "        but tab (\\t) is also useful, or null/empty string for no indentation.\n"
  "    */";
#else
static const char *Dtool_TiXmlPrinter_SetIndent_166_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * char const *TiXmlPrinter::Indent(void)
 */
static PyObject *Dtool_TiXmlPrinter_Indent_167(PyObject *self, PyObject *) {
  TiXmlPrinter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlPrinter, (void **)&local_this, "TiXmlPrinter.Indent")) {
    return nullptr;
  }
  // 1-char const *TiXmlPrinter::Indent(void)
  char const *return_value = ((*local_this).Indent)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlPrinter_Indent_167_comment =
  "C++ Interface:\n"
  "Indent(const TiXmlPrinter self)\n"
  "\n"
  "/// Query the indention string.";
#else
static const char *Dtool_TiXmlPrinter_Indent_167_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TiXmlPrinter::SetLineBreak(char const *_lineBreak)
 */
static PyObject *Dtool_TiXmlPrinter_SetLineBreak_168(PyObject *self, PyObject *arg) {
  TiXmlPrinter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlPrinter, (void **)&local_this, "TiXmlPrinter.SetLineBreak")) {
    return nullptr;
  }
  // 1-void TiXmlPrinter::SetLineBreak(char const *_lineBreak)
  char const *param1;
  if (PyArg_Parse(arg, "z:SetLineBreak", &param1)) {
    ((*local_this).SetLineBreak)((char const *)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetLineBreak(const TiXmlPrinter self, str _lineBreak)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TiXmlPrinter_SetLineBreak_168_comment =
  "C++ Interface:\n"
  "SetLineBreak(const TiXmlPrinter self, str _lineBreak)\n"
  "\n"
  "/** Set the line breaking string. By default set to newline (\\n).\n"
  "        Some operating systems prefer other characters, or can be\n"
  "        set to the null/empty string for no indenation.\n"
  "    */";
#else
static const char *Dtool_TiXmlPrinter_SetLineBreak_168_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * char const *TiXmlPrinter::LineBreak(void)
 */
static PyObject *Dtool_TiXmlPrinter_LineBreak_169(PyObject *self, PyObject *) {
  TiXmlPrinter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlPrinter, (void **)&local_this, "TiXmlPrinter.LineBreak")) {
    return nullptr;
  }
  // 1-char const *TiXmlPrinter::LineBreak(void)
  char const *return_value = ((*local_this).LineBreak)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlPrinter_LineBreak_169_comment =
  "C++ Interface:\n"
  "LineBreak(const TiXmlPrinter self)\n"
  "\n"
  "/// Query the current line breaking string.";
#else
static const char *Dtool_TiXmlPrinter_LineBreak_169_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TiXmlPrinter::SetStreamPrinting(void)
 */
static PyObject *Dtool_TiXmlPrinter_SetStreamPrinting_170(PyObject *self, PyObject *) {
  TiXmlPrinter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlPrinter, (void **)&local_this, "TiXmlPrinter.SetStreamPrinting")) {
    return nullptr;
  }
  // 1-void TiXmlPrinter::SetStreamPrinting(void)
  ((*local_this).SetStreamPrinting)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TiXmlPrinter_SetStreamPrinting_170_comment =
  "C++ Interface:\n"
  "SetStreamPrinting(const TiXmlPrinter self)\n"
  "\n"
  "/** Switch over to \"stream printing\" which is the most dense formatting without\n"
  "        linebreaks. Common when the XML is needed for network transmission.\n"
  "    */";
#else
static const char *Dtool_TiXmlPrinter_SetStreamPrinting_170_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * char const *TiXmlPrinter::CStr(void)
 */
static PyObject *Dtool_TiXmlPrinter_CStr_171(PyObject *self, PyObject *) {
  TiXmlPrinter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlPrinter, (void **)&local_this, "TiXmlPrinter.CStr")) {
    return nullptr;
  }
  // 1-char const *TiXmlPrinter::CStr(void)
  char const *return_value = ((*local_this).CStr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlPrinter_CStr_171_comment =
  "C++ Interface:\n"
  "CStr(const TiXmlPrinter self)\n"
  "\n"
  "/// Return the result.";
#else
static const char *Dtool_TiXmlPrinter_CStr_171_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::size_t TiXmlPrinter::Size(void)
 */
static PyObject *Dtool_TiXmlPrinter_Size_172(PyObject *self, PyObject *) {
  TiXmlPrinter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlPrinter, (void **)&local_this, "TiXmlPrinter.Size")) {
    return nullptr;
  }
  // 1-std::size_t TiXmlPrinter::Size(void)
  std::size_t return_value = ((*local_this).Size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlPrinter_Size_172_comment =
  "C++ Interface:\n"
  "Size(const TiXmlPrinter self)\n"
  "\n"
  "/// Return the length of the result string.";
#else
static const char *Dtool_TiXmlPrinter_Size_172_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string const &TiXmlPrinter::Str(void)
 */
static PyObject *Dtool_TiXmlPrinter_Str_173(PyObject *self, PyObject *) {
  TiXmlPrinter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TiXmlPrinter, (void **)&local_this, "TiXmlPrinter.Str")) {
    return nullptr;
  }
  // 1-std::string const &TiXmlPrinter::Str(void)
  std::string const &return_value = ((*local_this).Str)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TiXmlPrinter_Str_173_comment =
  "C++ Interface:\n"
  "Str(const TiXmlPrinter self)\n"
  "\n"
  "/// Return the result.";
#else
static const char *Dtool_TiXmlPrinter_Str_173_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TiXmlPrinter::TiXmlPrinter(void)
 * inline TiXmlPrinter::TiXmlPrinter(TiXmlPrinter const &) = default
 */
static int Dtool_Init_TiXmlPrinter(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("TiXmlPrinter() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-TiXmlPrinter::TiXmlPrinter(void)
      TiXmlPrinter *return_value = new TiXmlPrinter();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlPrinter, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline TiXmlPrinter::TiXmlPrinter(TiXmlPrinter const &) = default
      TiXmlPrinter const *arg_this = (TiXmlPrinter *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TiXmlPrinter, 0, "TiXmlPrinter.TiXmlPrinter", true, true);
      if (arg_this != nullptr) {
        TiXmlPrinter *return_value = new TiXmlPrinter(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TiXmlPrinter, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "TiXmlPrinter() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TiXmlPrinter()\n"
      "TiXmlPrinter(const TiXmlPrinter param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TiXmlPrinter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TiXmlPrinter) {
    printf("TiXmlPrinter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TiXmlPrinter *local_this = (TiXmlPrinter *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TiXmlPrinter) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TiXmlVisitor) {
    return (TiXmlVisitor *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TiXmlPrinter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TiXmlPrinter) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TiXmlVisitor) {
    TiXmlVisitor* other_this = (TiXmlVisitor*)from_this;
    return (TiXmlPrinter*)other_this;
  }
  return nullptr;
}

/**
 * Python method tables for TiXmlBase (TiXmlBase)
 */
static PyMethodDef Dtool_Methods_TiXmlBase[] = {
  {"SetCondenseWhiteSpace", &Dtool_TiXmlBase_SetCondenseWhiteSpace_4, METH_O | METH_STATIC, (const char *)Dtool_TiXmlBase_SetCondenseWhiteSpace_4_comment},
  {"IsWhiteSpaceCondensed", &Dtool_TiXmlBase_IsWhiteSpaceCondensed_5, METH_NOARGS | METH_STATIC, (const char *)Dtool_TiXmlBase_IsWhiteSpaceCondensed_5_comment},
  {"Row", &Dtool_TiXmlBase_Row_6, METH_NOARGS, (const char *)Dtool_TiXmlBase_Row_6_comment},
  {"Column", &Dtool_TiXmlBase_Column_7, METH_NOARGS, (const char *)Dtool_TiXmlBase_Column_7_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TiXmlBase = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_TiXmlBase = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TiXmlBase",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TiXmlBase,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TiXmlBase,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/** TiXmlBase is a base class for every class in TinyXml.\n"
    "    It does little except to establish that TinyXml classes\n"
    "    can be printed and provide some utility functions.\n"
    "\n"
    "    In XML, the document and elements can contain\n"
    "    other elements and other types of nodes.\n"
    "\n"
    "    @verbatim\n"
    "    A Document can contain: Element (container or leaf)\n"
    "                            Comment (leaf)\n"
    "                            Unknown (leaf)\n"
    "                            Declaration( leaf )\n"
    "\n"
    "    An Element can contain: Element (container or leaf)\n"
    "                            Text    (leaf)\n"
    "                            Attributes (not on tree)\n"
    "                            Comment (leaf)\n"
    "                            Unknown (leaf)\n"
    "\n"
    "    A Decleration contains: Attributes (not on tree)\n"
    "    @endverbatim\n"
    "*/",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TiXmlBase,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TiXmlBase,
    PyType_GenericAlloc,
    Dtool_new_TiXmlBase,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TiXmlBase,
  Dtool_UpcastInterface_TiXmlBase,
  Dtool_DowncastInterface_TiXmlBase,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TiXmlBase(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TiXmlBase._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(35);
    Dtool_TiXmlBase._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum TiXmlBase::;
    PyDict_SetItemString(dict, "TIXML_NO_ERROR", Dtool_WrapValue(TiXmlBase::TIXML_NO_ERROR));
    PyDict_SetItemString(dict, "TIXML_ERROR", Dtool_WrapValue(TiXmlBase::TIXML_ERROR));
    PyDict_SetItemString(dict, "TIXML_ERROR_OPENING_FILE", Dtool_WrapValue(TiXmlBase::TIXML_ERROR_OPENING_FILE));
    PyDict_SetItemString(dict, "TIXML_ERROR_PARSING_ELEMENT", Dtool_WrapValue(TiXmlBase::TIXML_ERROR_PARSING_ELEMENT));
    PyDict_SetItemString(dict, "TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME", Dtool_WrapValue(TiXmlBase::TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME));
    PyDict_SetItemString(dict, "TIXML_ERROR_READING_ELEMENT_VALUE", Dtool_WrapValue(TiXmlBase::TIXML_ERROR_READING_ELEMENT_VALUE));
    PyDict_SetItemString(dict, "TIXML_ERROR_READING_ATTRIBUTES", Dtool_WrapValue(TiXmlBase::TIXML_ERROR_READING_ATTRIBUTES));
    PyDict_SetItemString(dict, "TIXML_ERROR_PARSING_EMPTY", Dtool_WrapValue(TiXmlBase::TIXML_ERROR_PARSING_EMPTY));
    PyDict_SetItemString(dict, "TIXML_ERROR_READING_END_TAG", Dtool_WrapValue(TiXmlBase::TIXML_ERROR_READING_END_TAG));
    PyDict_SetItemString(dict, "TIXML_ERROR_PARSING_UNKNOWN", Dtool_WrapValue(TiXmlBase::TIXML_ERROR_PARSING_UNKNOWN));
    PyDict_SetItemString(dict, "TIXML_ERROR_PARSING_COMMENT", Dtool_WrapValue(TiXmlBase::TIXML_ERROR_PARSING_COMMENT));
    PyDict_SetItemString(dict, "TIXML_ERROR_PARSING_DECLARATION", Dtool_WrapValue(TiXmlBase::TIXML_ERROR_PARSING_DECLARATION));
    PyDict_SetItemString(dict, "TIXML_ERROR_DOCUMENT_EMPTY", Dtool_WrapValue(TiXmlBase::TIXML_ERROR_DOCUMENT_EMPTY));
    PyDict_SetItemString(dict, "TIXML_ERROR_EMBEDDED_NULL", Dtool_WrapValue(TiXmlBase::TIXML_ERROR_EMBEDDED_NULL));
    PyDict_SetItemString(dict, "TIXML_ERROR_PARSING_CDATA", Dtool_WrapValue(TiXmlBase::TIXML_ERROR_PARSING_CDATA));
    PyDict_SetItemString(dict, "TIXML_ERROR_DOCUMENT_TOP_ONLY", Dtool_WrapValue(TiXmlBase::TIXML_ERROR_DOCUMENT_TOP_ONLY));
    PyDict_SetItemString(dict, "TIXML_ERROR_STRING_COUNT", Dtool_WrapValue(TiXmlBase::TIXML_ERROR_STRING_COUNT));
    if (PyType_Ready((PyTypeObject *)&Dtool_TiXmlBase) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TiXmlBase)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TiXmlBase);
  }
}

/**
 * Python method tables for TiXmlDeclaration (TiXmlDeclaration)
 */
static PyMethodDef Dtool_Methods_TiXmlDeclaration[] = {
  {"assign", &Dtool_TiXmlDeclaration_operator_46, METH_O, (const char *)Dtool_TiXmlDeclaration_operator_46_comment},
  {"Version", &Dtool_TiXmlDeclaration_Version_47, METH_NOARGS, (const char *)Dtool_TiXmlDeclaration_Version_47_comment},
  {"Encoding", &Dtool_TiXmlDeclaration_Encoding_48, METH_NOARGS, (const char *)Dtool_TiXmlDeclaration_Encoding_48_comment},
  {"Standalone", &Dtool_TiXmlDeclaration_Standalone_49, METH_NOARGS, (const char *)Dtool_TiXmlDeclaration_Standalone_49_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TiXmlDeclaration = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TiXmlDeclaration = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TiXmlDeclaration = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TiXmlDeclaration = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TiXmlDeclaration = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TiXmlDeclaration = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TiXmlDeclaration",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TiXmlDeclaration,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TiXmlDeclaration,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TiXmlDeclaration,
    &Dtool_SequenceMethods_TiXmlDeclaration,
    &Dtool_MappingMethods_TiXmlDeclaration,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TiXmlDeclaration,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/** In correct XML the declaration is the first entry in the file.\n"
    "    @verbatim\n"
    "        <?xml version=\"1.0\" standalone=\"yes\"?>\n"
    "    @endverbatim\n"
    "\n"
    "    TinyXml will happily read or write files without a declaration,\n"
    "    however. There are 3 possible attributes to the declaration:\n"
    "    version, encoding, and standalone.\n"
    "\n"
    "    Note: In this version of the code, the attributes are\n"
    "    handled as special cases, not generic attributes, simply\n"
    "    because there can only be at most 3 and they are always the same.\n"
    "*/",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TiXmlDeclaration,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TiXmlDeclaration,
    PyType_GenericAlloc,
    Dtool_new_TiXmlDeclaration,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TiXmlDeclaration,
  Dtool_UpcastInterface_TiXmlDeclaration,
  Dtool_DowncastInterface_TiXmlDeclaration,
  nullptr,
  (CoerceFunction)Dtool_Coerce_TiXmlDeclaration,
};

static void Dtool_PyModuleClassInit_TiXmlDeclaration(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TiXmlNode(nullptr);
    Dtool_TiXmlDeclaration._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_TiXmlNode);
    Dtool_TiXmlDeclaration._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TiXmlDeclaration._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TiXmlDeclaration) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TiXmlDeclaration)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TiXmlDeclaration);
  }
}

/**
 * Python method tables for TiXmlNode (TiXmlNode)
 */
static PyMethodDef Dtool_Methods_TiXmlNode[] = {
  {"Value", &Dtool_TiXmlNode_Value_16, METH_NOARGS, (const char *)Dtool_TiXmlNode_Value_16_comment},
  {"ValueStr", &Dtool_TiXmlNode_ValueStr_17, METH_NOARGS, (const char *)Dtool_TiXmlNode_ValueStr_17_comment},
  {"ValueTStr", &Dtool_TiXmlNode_ValueTStr_18, METH_NOARGS, (const char *)Dtool_TiXmlNode_ValueTStr_18_comment},
  {"SetValue", &Dtool_TiXmlNode_SetValue_19, METH_O, (const char *)Dtool_TiXmlNode_SetValue_19_comment},
  {"Clear", &Dtool_TiXmlNode_Clear_20, METH_NOARGS, (const char *)Dtool_TiXmlNode_Clear_20_comment},
  {"Parent", &Dtool_TiXmlNode_Parent_21, METH_NOARGS, (const char *)Dtool_TiXmlNode_Parent_21_comment},
  {"FirstChild", &Dtool_TiXmlNode_FirstChild_22, METH_VARARGS, (const char *)Dtool_TiXmlNode_FirstChild_22_comment},
  {"LastChild", &Dtool_TiXmlNode_LastChild_23, METH_VARARGS, (const char *)Dtool_TiXmlNode_LastChild_23_comment},
  {"IterateChildren", (PyCFunction) &Dtool_TiXmlNode_IterateChildren_24, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TiXmlNode_IterateChildren_24_comment},
  {"InsertEndChild", &Dtool_TiXmlNode_InsertEndChild_25, METH_O, (const char *)Dtool_TiXmlNode_InsertEndChild_25_comment},
  {"InsertBeforeChild", (PyCFunction) &Dtool_TiXmlNode_InsertBeforeChild_26, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TiXmlNode_InsertBeforeChild_26_comment},
  {"InsertAfterChild", (PyCFunction) &Dtool_TiXmlNode_InsertAfterChild_27, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TiXmlNode_InsertAfterChild_27_comment},
  {"ReplaceChild", (PyCFunction) &Dtool_TiXmlNode_ReplaceChild_28, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TiXmlNode_ReplaceChild_28_comment},
  {"RemoveChild", &Dtool_TiXmlNode_RemoveChild_29, METH_O, (const char *)Dtool_TiXmlNode_RemoveChild_29_comment},
  {"PreviousSibling", &Dtool_TiXmlNode_PreviousSibling_30, METH_VARARGS, (const char *)Dtool_TiXmlNode_PreviousSibling_30_comment},
  {"NextSibling", &Dtool_TiXmlNode_NextSibling_31, METH_VARARGS, (const char *)Dtool_TiXmlNode_NextSibling_31_comment},
  {"NextSiblingElement", &Dtool_TiXmlNode_NextSiblingElement_32, METH_VARARGS, (const char *)Dtool_TiXmlNode_NextSiblingElement_32_comment},
  {"FirstChildElement", &Dtool_TiXmlNode_FirstChildElement_33, METH_VARARGS, (const char *)Dtool_TiXmlNode_FirstChildElement_33_comment},
  {"Type", &Dtool_TiXmlNode_Type_34, METH_NOARGS, (const char *)Dtool_TiXmlNode_Type_34_comment},
  {"GetDocument", &Dtool_TiXmlNode_GetDocument_35, METH_NOARGS, (const char *)Dtool_TiXmlNode_GetDocument_35_comment},
  {"NoChildren", &Dtool_TiXmlNode_NoChildren_36, METH_NOARGS, (const char *)Dtool_TiXmlNode_NoChildren_36_comment},
  {"ToDocument", &Dtool_TiXmlNode_ToDocument_37, METH_NOARGS, (const char *)Dtool_TiXmlNode_ToDocument_37_comment},
  {"ToElement", &Dtool_TiXmlNode_ToElement_38, METH_NOARGS, (const char *)Dtool_TiXmlNode_ToElement_38_comment},
  {"ToComment", &Dtool_TiXmlNode_ToComment_39, METH_NOARGS, (const char *)Dtool_TiXmlNode_ToComment_39_comment},
  {"ToUnknown", &Dtool_TiXmlNode_ToUnknown_40, METH_NOARGS, (const char *)Dtool_TiXmlNode_ToUnknown_40_comment},
  {"ToText", &Dtool_TiXmlNode_ToText_41, METH_NOARGS, (const char *)Dtool_TiXmlNode_ToText_41_comment},
  {"ToDeclaration", &Dtool_TiXmlNode_ToDeclaration_42, METH_NOARGS, (const char *)Dtool_TiXmlNode_ToDeclaration_42_comment},
  {"Clone", &Dtool_TiXmlNode_Clone_43, METH_NOARGS, (const char *)Dtool_TiXmlNode_Clone_43_comment},
  {"Accept", &Dtool_TiXmlNode_Accept_44, METH_O, (const char *)Dtool_TiXmlNode_Accept_44_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TiXmlNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TiXmlNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TiXmlNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TiXmlNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TiXmlNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TiXmlNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TiXmlNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TiXmlNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TiXmlNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TiXmlNode,
    &Dtool_SequenceMethods_TiXmlNode,
    &Dtool_MappingMethods_TiXmlNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TiXmlNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/** The parent class for everything in the Document Object Model.\n"
    "    (Except for attributes).\n"
    "    Nodes have siblings, a parent, and children. A node can be\n"
    "    in a document, or stand on its own. The type of a TiXmlNode\n"
    "    can be queried, and it can be cast to its more defined type.\n"
    "*/",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TiXmlNode,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TiXmlNode,
    PyType_GenericAlloc,
    Dtool_new_TiXmlNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TiXmlNode,
  Dtool_UpcastInterface_TiXmlNode,
  Dtool_DowncastInterface_TiXmlNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TiXmlNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TiXmlBase(nullptr);
    Dtool_TiXmlNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_TiXmlBase);
    Dtool_TiXmlNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(15);
    Dtool_TiXmlNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum TiXmlNode::NodeType;
    PyDict_SetItemString(dict, "TINYXML_DOCUMENT", Dtool_WrapValue(TiXmlNode::TINYXML_DOCUMENT));
    PyDict_SetItemString(dict, "TINYXMLDOCUMENT", Dtool_WrapValue(TiXmlNode::TINYXML_DOCUMENT));
    PyDict_SetItemString(dict, "TINYXML_ELEMENT", Dtool_WrapValue(TiXmlNode::TINYXML_ELEMENT));
    PyDict_SetItemString(dict, "TINYXMLELEMENT", Dtool_WrapValue(TiXmlNode::TINYXML_ELEMENT));
    PyDict_SetItemString(dict, "TINYXML_COMMENT", Dtool_WrapValue(TiXmlNode::TINYXML_COMMENT));
    PyDict_SetItemString(dict, "TINYXMLCOMMENT", Dtool_WrapValue(TiXmlNode::TINYXML_COMMENT));
    PyDict_SetItemString(dict, "TINYXML_UNKNOWN", Dtool_WrapValue(TiXmlNode::TINYXML_UNKNOWN));
    PyDict_SetItemString(dict, "TINYXMLUNKNOWN", Dtool_WrapValue(TiXmlNode::TINYXML_UNKNOWN));
    PyDict_SetItemString(dict, "TINYXML_TEXT", Dtool_WrapValue(TiXmlNode::TINYXML_TEXT));
    PyDict_SetItemString(dict, "TINYXMLTEXT", Dtool_WrapValue(TiXmlNode::TINYXML_TEXT));
    PyDict_SetItemString(dict, "TINYXML_DECLARATION", Dtool_WrapValue(TiXmlNode::TINYXML_DECLARATION));
    PyDict_SetItemString(dict, "TINYXMLDECLARATION", Dtool_WrapValue(TiXmlNode::TINYXML_DECLARATION));
    PyDict_SetItemString(dict, "TINYXML_TYPECOUNT", Dtool_WrapValue(TiXmlNode::TINYXML_TYPECOUNT));
    PyDict_SetItemString(dict, "TINYXMLTYPECOUNT", Dtool_WrapValue(TiXmlNode::TINYXML_TYPECOUNT));
    if (PyType_Ready((PyTypeObject *)&Dtool_TiXmlNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TiXmlNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TiXmlNode);
  }
}

/**
 * Python method tables for TiXmlDocument (TiXmlDocument)
 */
static PyMethodDef Dtool_Methods_TiXmlDocument[] = {
  {"assign", &Dtool_TiXmlDocument_operator_53, METH_O, (const char *)Dtool_TiXmlDocument_operator_53_comment},
  {"LoadFile", (PyCFunction) &Dtool_TiXmlDocument_LoadFile_54, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TiXmlDocument_LoadFile_54_comment},
  {"SaveFile", &Dtool_TiXmlDocument_SaveFile_55, METH_VARARGS, (const char *)Dtool_TiXmlDocument_SaveFile_55_comment},
  {"RootElement", &Dtool_TiXmlDocument_RootElement_56, METH_NOARGS, (const char *)Dtool_TiXmlDocument_RootElement_56_comment},
  {"Error", &Dtool_TiXmlDocument_Error_57, METH_NOARGS, (const char *)Dtool_TiXmlDocument_Error_57_comment},
  {"ErrorDesc", &Dtool_TiXmlDocument_ErrorDesc_58, METH_NOARGS, (const char *)Dtool_TiXmlDocument_ErrorDesc_58_comment},
  {"ErrorId", &Dtool_TiXmlDocument_ErrorId_59, METH_NOARGS, (const char *)Dtool_TiXmlDocument_ErrorId_59_comment},
  {"ErrorRow", &Dtool_TiXmlDocument_ErrorRow_60, METH_NOARGS, (const char *)Dtool_TiXmlDocument_ErrorRow_60_comment},
  {"ErrorCol", &Dtool_TiXmlDocument_ErrorCol_61, METH_NOARGS, (const char *)Dtool_TiXmlDocument_ErrorCol_61_comment},
  {"SetTabSize", &Dtool_TiXmlDocument_SetTabSize_62, METH_O, (const char *)Dtool_TiXmlDocument_SetTabSize_62_comment},
  {"TabSize", &Dtool_TiXmlDocument_TabSize_63, METH_NOARGS, (const char *)Dtool_TiXmlDocument_TabSize_63_comment},
  {"ClearError", &Dtool_TiXmlDocument_ClearError_64, METH_NOARGS, (const char *)Dtool_TiXmlDocument_ClearError_64_comment},
  {"Print", &Dtool_TiXmlDocument_Print_65, METH_NOARGS, (const char *)Dtool_TiXmlDocument_Print_65_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TiXmlDocument = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TiXmlDocument = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TiXmlDocument = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TiXmlDocument = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TiXmlDocument = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TiXmlDocument = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TiXmlDocument",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TiXmlDocument,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TiXmlDocument,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TiXmlDocument,
    &Dtool_SequenceMethods_TiXmlDocument,
    &Dtool_MappingMethods_TiXmlDocument,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TiXmlDocument,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/** Always the top level node. A document binds together all the\n"
    "    XML pieces. It can be saved, loaded, and printed to the screen.\n"
    "    The 'value' of a document node is the xml file name.\n"
    "*/",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TiXmlDocument,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TiXmlDocument,
    PyType_GenericAlloc,
    Dtool_new_TiXmlDocument,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TiXmlDocument,
  Dtool_UpcastInterface_TiXmlDocument,
  Dtool_DowncastInterface_TiXmlDocument,
  nullptr,
  (CoerceFunction)Dtool_Coerce_TiXmlDocument,
};

static void Dtool_PyModuleClassInit_TiXmlDocument(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TiXmlNode(nullptr);
    Dtool_TiXmlDocument._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_TiXmlNode);
    Dtool_TiXmlDocument._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TiXmlDocument._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TiXmlDocument) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TiXmlDocument)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TiXmlDocument);
  }
}

/**
 * Python method tables for TiXmlElement (TiXmlElement)
 */
static PyMethodDef Dtool_Methods_TiXmlElement[] = {
  {"assign", &Dtool_TiXmlElement_operator_69, METH_O, (const char *)Dtool_TiXmlElement_operator_69_comment},
  {"Attribute", &Dtool_TiXmlElement_Attribute_70, METH_O, (const char *)Dtool_TiXmlElement_Attribute_70_comment},
  {"SetAttribute", (PyCFunction) &Dtool_TiXmlElement_SetAttribute_76, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TiXmlElement_SetAttribute_76_comment},
  {"SetDoubleAttribute", (PyCFunction) &Dtool_TiXmlElement_SetDoubleAttribute_77, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TiXmlElement_SetDoubleAttribute_77_comment},
  {"RemoveAttribute", &Dtool_TiXmlElement_RemoveAttribute_78, METH_O, (const char *)Dtool_TiXmlElement_RemoveAttribute_78_comment},
  {"FirstAttribute", &Dtool_TiXmlElement_FirstAttribute_79, METH_NOARGS, (const char *)Dtool_TiXmlElement_FirstAttribute_79_comment},
  {"LastAttribute", &Dtool_TiXmlElement_LastAttribute_80, METH_NOARGS, (const char *)Dtool_TiXmlElement_LastAttribute_80_comment},
  {"GetText", &Dtool_TiXmlElement_GetText_81, METH_NOARGS, (const char *)Dtool_TiXmlElement_GetText_81_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TiXmlElement = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TiXmlElement = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TiXmlElement = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TiXmlElement = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TiXmlElement = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TiXmlElement = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TiXmlElement",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TiXmlElement,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TiXmlElement,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TiXmlElement,
    &Dtool_SequenceMethods_TiXmlElement,
    &Dtool_MappingMethods_TiXmlElement,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TiXmlElement,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/** The element is a container class. It has a value, the element name,\n"
    "    and can contain other elements, text, comments, and unknowns.\n"
    "    Elements also contain an arbitrary number of attributes.\n"
    "*/",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TiXmlElement,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TiXmlElement,
    PyType_GenericAlloc,
    Dtool_new_TiXmlElement,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TiXmlElement,
  Dtool_UpcastInterface_TiXmlElement,
  Dtool_DowncastInterface_TiXmlElement,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TiXmlElement(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TiXmlNode(nullptr);
    Dtool_TiXmlElement._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_TiXmlNode);
    Dtool_TiXmlElement._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TiXmlElement._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TiXmlElement) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TiXmlElement)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TiXmlElement);
  }
}

/**
 * Python method tables for TiXmlCursor (TiXmlCursor)
 */
static PyMethodDef Dtool_Methods_TiXmlCursor[] = {
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TiXmlCursor = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_TiXmlCursor = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TiXmlCursor",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TiXmlCursor,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TiXmlCursor,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/*  Internal structure for tracking location of items\n"
    "    in the XML file.\n"
    "*/",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TiXmlCursor,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TiXmlCursor,
    PyType_GenericAlloc,
    Dtool_new_TiXmlCursor,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TiXmlCursor,
  Dtool_UpcastInterface_TiXmlCursor,
  Dtool_DowncastInterface_TiXmlCursor,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TiXmlCursor(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TiXmlCursor._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TiXmlCursor._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TiXmlCursor) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TiXmlCursor)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TiXmlCursor);
  }
}

/**
 * Python method tables for TiXmlVisitor (TiXmlVisitor)
 */
static PyMethodDef Dtool_Methods_TiXmlVisitor[] = {
  {"VisitEnter", &Dtool_TiXmlVisitor_VisitEnter_98, METH_VARARGS, (const char *)Dtool_TiXmlVisitor_VisitEnter_98_comment},
  {"VisitExit", &Dtool_TiXmlVisitor_VisitExit_99, METH_O, (const char *)Dtool_TiXmlVisitor_VisitExit_99_comment},
  {"Visit", &Dtool_TiXmlVisitor_Visit_100, METH_O, (const char *)Dtool_TiXmlVisitor_Visit_100_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TiXmlVisitor = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_TiXmlVisitor = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TiXmlVisitor",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TiXmlVisitor,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TiXmlVisitor,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    "    Implements the interface to the \"Visitor pattern\" (see the Accept() method.)\n"
    "    If you call the Accept() method, it requires being passed a TiXmlVisitor\n"
    "    class to handle callbacks. For nodes that contain other nodes (Document, Element)\n"
    "    you will get called with a VisitEnter/VisitExit pair. Nodes that are always leaves\n"
    "    are simply called with Visit().\n"
    "\n"
    "    If you return 'true' from a Visit method, recursive parsing will continue. If you return\n"
    "    false, <b>no children of this node or its sibilings</b> will be Visited.\n"
    "\n"
    "    All flavors of Visit methods have a default implementation that returns 'true' (continue\n"
    "    visiting). You need to only override methods that are interesting to you.\n"
    "\n"
    "    Generally Accept() is called on the TiXmlDocument, although all nodes suppert Visiting.\n"
    "\n"
    "    You should never change the document from a callback.\n"
    "\n"
    "    @sa TiXmlNode::Accept()\n"
    "*/",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TiXmlVisitor,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TiXmlVisitor,
    PyType_GenericAlloc,
    Dtool_new_TiXmlVisitor,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TiXmlVisitor,
  Dtool_UpcastInterface_TiXmlVisitor,
  Dtool_DowncastInterface_TiXmlVisitor,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TiXmlVisitor(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TiXmlVisitor._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TiXmlVisitor._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TiXmlVisitor) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TiXmlVisitor)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TiXmlVisitor);
  }
}

/**
 * Python method tables for TiXmlAttribute (TiXmlAttribute)
 */
static PyMethodDef Dtool_Methods_TiXmlAttribute[] = {
  {"Name", &Dtool_TiXmlAttribute_Name_108, METH_NOARGS, (const char *)Dtool_TiXmlAttribute_Name_108_comment},
  {"Value", &Dtool_TiXmlAttribute_Value_109, METH_NOARGS, (const char *)Dtool_TiXmlAttribute_Value_109_comment},
  {"ValueStr", &Dtool_TiXmlAttribute_ValueStr_110, METH_NOARGS, (const char *)Dtool_TiXmlAttribute_ValueStr_110_comment},
  {"IntValue", &Dtool_TiXmlAttribute_IntValue_111, METH_NOARGS, (const char *)Dtool_TiXmlAttribute_IntValue_111_comment},
  {"DoubleValue", &Dtool_TiXmlAttribute_DoubleValue_112, METH_NOARGS, (const char *)Dtool_TiXmlAttribute_DoubleValue_112_comment},
  {"NameTStr", &Dtool_TiXmlAttribute_NameTStr_113, METH_NOARGS, (const char *)Dtool_TiXmlAttribute_NameTStr_113_comment},
  {"SetName", &Dtool_TiXmlAttribute_SetName_116, METH_O, (const char *)Dtool_TiXmlAttribute_SetName_116_comment},
  {"SetValue", &Dtool_TiXmlAttribute_SetValue_117, METH_O, (const char *)Dtool_TiXmlAttribute_SetValue_117_comment},
  {"SetIntValue", &Dtool_TiXmlAttribute_SetIntValue_118, METH_O, (const char *)Dtool_TiXmlAttribute_SetIntValue_118_comment},
  {"SetDoubleValue", &Dtool_TiXmlAttribute_SetDoubleValue_119, METH_O, (const char *)Dtool_TiXmlAttribute_SetDoubleValue_119_comment},
  {"Next", &Dtool_TiXmlAttribute_Next_120, METH_NOARGS, (const char *)Dtool_TiXmlAttribute_Next_120_comment},
  {"Previous", &Dtool_TiXmlAttribute_Previous_121, METH_NOARGS, (const char *)Dtool_TiXmlAttribute_Previous_121_comment},
  {"SetDocument", &Dtool_TiXmlAttribute_SetDocument_126, METH_O, (const char *)Dtool_TiXmlAttribute_SetDocument_126_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A rich comparison function
//     TiXmlAttribute
//////////////////
static PyObject *Dtool_RichCompare_TiXmlAttribute(PyObject *self, PyObject *arg, int op) {
  TiXmlAttribute *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TiXmlAttribute, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-bool TiXmlAttribute::operator ==(TiXmlAttribute const &rhs) const
      TiXmlAttribute const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TiXmlAttribute);
      if (arg_this != nullptr) {
        bool return_value = ((*(const TiXmlAttribute*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-bool TiXmlAttribute::operator <(TiXmlAttribute const &rhs) const
      TiXmlAttribute const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TiXmlAttribute);
      if (arg_this != nullptr) {
        bool return_value = ((*(const TiXmlAttribute*)local_this).operator <)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_GT:
    {
      // 1-bool TiXmlAttribute::operator >(TiXmlAttribute const &rhs) const
      TiXmlAttribute const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TiXmlAttribute);
      if (arg_this != nullptr) {
        bool return_value = ((*(const TiXmlAttribute*)local_this).operator >)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_TiXmlAttribute = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TiXmlAttribute = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TiXmlAttribute = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TiXmlAttribute = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TiXmlAttribute = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TiXmlAttribute = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TiXmlAttribute",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TiXmlAttribute,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TiXmlAttribute,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &DtoolInstance_ComparePointers,
#endif
    nullptr,
    &Dtool_NumberMethods_TiXmlAttribute,
    &Dtool_SequenceMethods_TiXmlAttribute,
    &Dtool_MappingMethods_TiXmlAttribute,
    &DtoolInstance_HashPointer,
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TiXmlAttribute,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/** An attribute is a name-value pair. Elements have an arbitrary\n"
    "    number of attributes, each with a unique name.\n"
    "\n"
    "    @note The attributes are not TiXmlNodes, since they are not\n"
    "          part of the tinyXML document object model. There are other\n"
    "          suggested ways to look at this problem.\n"
    "*/",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_TiXmlAttribute,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TiXmlAttribute,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TiXmlAttribute,
    PyType_GenericAlloc,
    Dtool_new_TiXmlAttribute,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TiXmlAttribute,
  Dtool_UpcastInterface_TiXmlAttribute,
  Dtool_DowncastInterface_TiXmlAttribute,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TiXmlAttribute(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TiXmlBase(nullptr);
    Dtool_TiXmlAttribute._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_TiXmlBase);
    Dtool_TiXmlAttribute._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TiXmlAttribute._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TiXmlAttribute) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TiXmlAttribute)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TiXmlAttribute);
  }
}

/**
 * Python method tables for TiXmlAttributeSet (TiXmlAttributeSet)
 */
static PyMethodDef Dtool_Methods_TiXmlAttributeSet[] = {
  {"Add", &Dtool_TiXmlAttributeSet_Add_131, METH_O, (const char *)Dtool_TiXmlAttributeSet_Add_131_comment},
  {"Remove", &Dtool_TiXmlAttributeSet_Remove_132, METH_O, (const char *)Dtool_TiXmlAttributeSet_Remove_132_comment},
  {"First", &Dtool_TiXmlAttributeSet_First_133, METH_NOARGS, (const char *)Dtool_TiXmlAttributeSet_First_133_comment},
  {"Last", &Dtool_TiXmlAttributeSet_Last_134, METH_NOARGS, (const char *)Dtool_TiXmlAttributeSet_Last_134_comment},
  {"Find", &Dtool_TiXmlAttributeSet_Find_135, METH_O, (const char *)Dtool_TiXmlAttributeSet_Find_135_comment},
  {"FindOrCreate", &Dtool_TiXmlAttributeSet_FindOrCreate_136, METH_O, (const char *)Dtool_TiXmlAttributeSet_FindOrCreate_136_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TiXmlAttributeSet = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_TiXmlAttributeSet = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TiXmlAttributeSet",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TiXmlAttributeSet,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TiXmlAttributeSet,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/*  A class used to manage a group of attributes.\n"
    "    It is only used internally, both by the ELEMENT and the DECLARATION.\n"
    "\n"
    "    The set can be changed transparent to the Element and Declaration\n"
    "    classes that use it, but NOT transparent to the Attribute\n"
    "    which has to implement a next() and previous() method. Which makes\n"
    "    it a bit problematic and prevents the use of STL.\n"
    "\n"
    "    This version is implemented with circular lists because:\n"
    "        - I like circular lists\n"
    "        - it demonstrates some independence from the (typical) doubly linked list.\n"
    "*/",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TiXmlAttributeSet,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TiXmlAttributeSet,
    PyType_GenericAlloc,
    Dtool_new_TiXmlAttributeSet,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TiXmlAttributeSet,
  Dtool_UpcastInterface_TiXmlAttributeSet,
  Dtool_DowncastInterface_TiXmlAttributeSet,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TiXmlAttributeSet(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TiXmlAttributeSet._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TiXmlAttributeSet._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TiXmlAttributeSet) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TiXmlAttributeSet)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TiXmlAttributeSet);
  }
}

/**
 * Python method tables for TiXmlComment (TiXmlComment)
 */
static PyMethodDef Dtool_Methods_TiXmlComment[] = {
  {"assign", &Dtool_TiXmlComment_operator_139, METH_O, (const char *)Dtool_TiXmlComment_operator_139_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TiXmlComment = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TiXmlComment = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TiXmlComment = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TiXmlComment = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TiXmlComment = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TiXmlComment = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TiXmlComment",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TiXmlComment,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TiXmlComment,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TiXmlComment,
    &Dtool_SequenceMethods_TiXmlComment,
    &Dtool_MappingMethods_TiXmlComment,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TiXmlComment,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/** An XML comment.\n"
    "*/",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TiXmlComment,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TiXmlComment,
    PyType_GenericAlloc,
    Dtool_new_TiXmlComment,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TiXmlComment,
  Dtool_UpcastInterface_TiXmlComment,
  Dtool_DowncastInterface_TiXmlComment,
  nullptr,
  (CoerceFunction)Dtool_Coerce_TiXmlComment,
};

static void Dtool_PyModuleClassInit_TiXmlComment(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TiXmlNode(nullptr);
    Dtool_TiXmlComment._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_TiXmlNode);
    Dtool_TiXmlComment._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TiXmlComment._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TiXmlComment) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TiXmlComment)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TiXmlComment);
  }
}

/**
 * Python method tables for TiXmlText (TiXmlText)
 */
static PyMethodDef Dtool_Methods_TiXmlText[] = {
  {"assign", &Dtool_TiXmlText_operator_142, METH_O, (const char *)Dtool_TiXmlText_operator_142_comment},
  {"CDATA", &Dtool_TiXmlText_CDATA_143, METH_NOARGS, (const char *)Dtool_TiXmlText_CDATA_143_comment},
  {"SetCDATA", &Dtool_TiXmlText_SetCDATA_144, METH_O, (const char *)Dtool_TiXmlText_SetCDATA_144_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TiXmlText = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TiXmlText = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TiXmlText = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TiXmlText = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TiXmlText = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TiXmlText = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TiXmlText",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TiXmlText,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TiXmlText,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TiXmlText,
    &Dtool_SequenceMethods_TiXmlText,
    &Dtool_MappingMethods_TiXmlText,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TiXmlText,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/** XML text. A text node can have 2 ways to output the next. \"normal\" output\n"
    "    and CDATA. It will default to the mode it was parsed from the XML file and\n"
    "    you generally want to leave it alone, but you can change the output mode with\n"
    "    SetCDATA() and query it with CDATA().\n"
    "*/",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TiXmlText,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TiXmlText,
    PyType_GenericAlloc,
    Dtool_new_TiXmlText,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TiXmlText,
  Dtool_UpcastInterface_TiXmlText,
  Dtool_DowncastInterface_TiXmlText,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TiXmlText(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TiXmlNode(nullptr);
    Dtool_TiXmlText._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_TiXmlNode);
    Dtool_TiXmlText._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TiXmlText._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TiXmlText) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TiXmlText)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TiXmlText);
  }
}

/**
 * Python method tables for TiXmlUnknown (TiXmlUnknown)
 */
static PyMethodDef Dtool_Methods_TiXmlUnknown[] = {
  {"assign", &Dtool_TiXmlUnknown_operator_147, METH_O, (const char *)Dtool_TiXmlUnknown_operator_147_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TiXmlUnknown = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TiXmlUnknown = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TiXmlUnknown = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TiXmlUnknown = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TiXmlUnknown = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TiXmlUnknown = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TiXmlUnknown",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TiXmlUnknown,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TiXmlUnknown,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TiXmlUnknown,
    &Dtool_SequenceMethods_TiXmlUnknown,
    &Dtool_MappingMethods_TiXmlUnknown,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TiXmlUnknown,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/** Any tag that tinyXml doesn't recognize is saved as an\n"
    "    unknown. It is a tag of text, but should not be modified.\n"
    "    It will be written back to the XML, unchanged, when the file\n"
    "    is saved.\n"
    "\n"
    "    DTD tags get thrown into TiXmlUnknowns.\n"
    "*/",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TiXmlUnknown,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TiXmlUnknown,
    PyType_GenericAlloc,
    Dtool_new_TiXmlUnknown,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TiXmlUnknown,
  Dtool_UpcastInterface_TiXmlUnknown,
  Dtool_DowncastInterface_TiXmlUnknown,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TiXmlUnknown(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TiXmlNode(nullptr);
    Dtool_TiXmlUnknown._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_TiXmlNode);
    Dtool_TiXmlUnknown._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TiXmlUnknown._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TiXmlUnknown) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TiXmlUnknown)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TiXmlUnknown);
  }
}

/**
 * Python method tables for TiXmlHandle (TiXmlHandle)
 */
static PyMethodDef Dtool_Methods_TiXmlHandle[] = {
  {"assign", &Dtool_TiXmlHandle_operator_150, METH_O, (const char *)Dtool_TiXmlHandle_operator_150_comment},
  {"FirstChild", &Dtool_TiXmlHandle_FirstChild_151, METH_VARARGS, (const char *)Dtool_TiXmlHandle_FirstChild_151_comment},
  {"FirstChildElement", &Dtool_TiXmlHandle_FirstChildElement_152, METH_VARARGS, (const char *)Dtool_TiXmlHandle_FirstChildElement_152_comment},
  {"Child", (PyCFunction) &Dtool_TiXmlHandle_Child_153, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TiXmlHandle_Child_153_comment},
  {"ChildElement", (PyCFunction) &Dtool_TiXmlHandle_ChildElement_154, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TiXmlHandle_ChildElement_154_comment},
  {"ToNode", &Dtool_TiXmlHandle_ToNode_155, METH_NOARGS, (const char *)Dtool_TiXmlHandle_ToNode_155_comment},
  {"ToElement", &Dtool_TiXmlHandle_ToElement_156, METH_NOARGS, (const char *)Dtool_TiXmlHandle_ToElement_156_comment},
  {"ToText", &Dtool_TiXmlHandle_ToText_157, METH_NOARGS, (const char *)Dtool_TiXmlHandle_ToText_157_comment},
  {"ToUnknown", &Dtool_TiXmlHandle_ToUnknown_158, METH_NOARGS, (const char *)Dtool_TiXmlHandle_ToUnknown_158_comment},
  {"Node", &Dtool_TiXmlHandle_Node_159, METH_NOARGS, (const char *)Dtool_TiXmlHandle_Node_159_comment},
  {"Element", &Dtool_TiXmlHandle_Element_160, METH_NOARGS, (const char *)Dtool_TiXmlHandle_Element_160_comment},
  {"Text", &Dtool_TiXmlHandle_Text_161, METH_NOARGS, (const char *)Dtool_TiXmlHandle_Text_161_comment},
  {"Unknown", &Dtool_TiXmlHandle_Unknown_162, METH_NOARGS, (const char *)Dtool_TiXmlHandle_Unknown_162_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TiXmlHandle = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_TiXmlHandle = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TiXmlHandle",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TiXmlHandle,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TiXmlHandle,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    "    A TiXmlHandle is a class that wraps a node pointer with null checks; this is\n"
    "    an incredibly useful thing. Note that TiXmlHandle is not part of the TinyXml\n"
    "    DOM structure. It is a separate utility class.\n"
    "\n"
    "    Take an example:\n"
    "    @verbatim\n"
    "    <Document>\n"
    "        <Element attributeA = \"valueA\">\n"
    "            <Child attributeB = \"value1\" />\n"
    "            <Child attributeB = \"value2\" />\n"
    "        </Element>\n"
    "    <Document>\n"
    "    @endverbatim\n"
    "\n"
    "    Assuming you want the value of \"attributeB\" in the 2nd \"Child\" element, it's very\n"
    "    easy to write a *lot* of code that looks like:\n"
    "\n"
    "    @verbatim\n"
    "    TiXmlElement* root = document.FirstChildElement( \"Document\" );\n"
    "    if ( root )\n"
    "    {\n"
    "        TiXmlElement* element = root->FirstChildElement( \"Element\" );\n"
    "        if ( element )\n"
    "        {\n"
    "            TiXmlElement* child = element->FirstChildElement( \"Child\" );\n"
    "            if ( child )\n"
    "            {\n"
    "                TiXmlElement* child2 = child->NextSiblingElement( \"Child\" );\n"
    "                if ( child2 )\n"
    "                {\n"
    "                    // Finally do something useful.\n"
    "    @endverbatim\n"
    "\n"
    "    And that doesn't even cover \"else\" cases. TiXmlHandle addresses the verbosity\n"
    "    of such code. A TiXmlHandle checks for null pointers so it is perfectly safe\n"
    "    and correct to use:\n"
    "\n"
    "    @verbatim\n"
    "    TiXmlHandle docHandle( &document );\n"
    "    TiXmlElement* child2 = docHandle.FirstChild( \"Document\" ).FirstChild( \"Element\" ).Child( \"Child\", 1 ).ToElement();\n"
    "    if ( child2 )\n"
    "    {\n"
    "        // do something useful\n"
    "    @endverbatim\n"
    "\n"
    "    Which is MUCH more concise and useful.\n"
    "\n"
    "    It is also safe to copy handles - internally they are nothing more than node pointers.\n"
    "    @verbatim\n"
    "    TiXmlHandle handleCopy = handle;\n"
    "    @endverbatim\n"
    "\n"
    "    What they should not be used for is iteration:\n"
    "\n"
    "    @verbatim\n"
    "    int i=0;\n"
    "    while ( true )\n"
    "    {\n"
    "        TiXmlElement* child = docHandle.FirstChild( \"Document\" ).FirstChild( \"Element\" ).Child( \"Child\", i ).ToElement();\n"
    "        if ( !child )\n"
    "            break;\n"
    "        // do something\n"
    "        ++i;\n"
    "    }\n"
    "    @endverbatim\n"
    "\n"
    "    It seems reasonable, but it is in fact two embedded while loops. The Child method is\n"
    "    a linear walk to find the element, so this code would iterate much more than it needs\n"
    "    to. Instead, prefer:\n"
    "\n"
    "    @verbatim\n"
    "    TiXmlElement* child = docHandle.FirstChild( \"Document\" ).FirstChild( \"Element\" ).FirstChild( \"Child\" ).ToElement();\n"
    "\n"
    "    for( child; child; child=child->NextSiblingElement() )\n"
    "    {\n"
    "        // do something\n"
    "    }\n"
    "    @endverbatim\n"
    "*/",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TiXmlHandle,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TiXmlHandle,
    PyType_GenericAlloc,
    Dtool_new_TiXmlHandle,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TiXmlHandle,
  Dtool_UpcastInterface_TiXmlHandle,
  Dtool_DowncastInterface_TiXmlHandle,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TiXmlHandle(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TiXmlHandle._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TiXmlHandle._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TiXmlHandle) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TiXmlHandle)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TiXmlHandle);
  }
}

/**
 * Python method tables for TiXmlPrinter (TiXmlPrinter)
 */
static PyMethodDef Dtool_Methods_TiXmlPrinter[] = {
  {"SetIndent", &Dtool_TiXmlPrinter_SetIndent_166, METH_O, (const char *)Dtool_TiXmlPrinter_SetIndent_166_comment},
  {"Indent", &Dtool_TiXmlPrinter_Indent_167, METH_NOARGS, (const char *)Dtool_TiXmlPrinter_Indent_167_comment},
  {"SetLineBreak", &Dtool_TiXmlPrinter_SetLineBreak_168, METH_O, (const char *)Dtool_TiXmlPrinter_SetLineBreak_168_comment},
  {"LineBreak", &Dtool_TiXmlPrinter_LineBreak_169, METH_NOARGS, (const char *)Dtool_TiXmlPrinter_LineBreak_169_comment},
  {"SetStreamPrinting", &Dtool_TiXmlPrinter_SetStreamPrinting_170, METH_NOARGS, (const char *)Dtool_TiXmlPrinter_SetStreamPrinting_170_comment},
  {"CStr", &Dtool_TiXmlPrinter_CStr_171, METH_NOARGS, (const char *)Dtool_TiXmlPrinter_CStr_171_comment},
  {"Size", &Dtool_TiXmlPrinter_Size_172, METH_NOARGS, (const char *)Dtool_TiXmlPrinter_Size_172_comment},
  {"Str", &Dtool_TiXmlPrinter_Str_173, METH_NOARGS, (const char *)Dtool_TiXmlPrinter_Str_173_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TiXmlPrinter = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TiXmlPrinter = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TiXmlPrinter = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TiXmlPrinter = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TiXmlPrinter = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TiXmlPrinter = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TiXmlPrinter",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TiXmlPrinter,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TiXmlPrinter,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TiXmlPrinter,
    &Dtool_SequenceMethods_TiXmlPrinter,
    &Dtool_MappingMethods_TiXmlPrinter,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TiXmlPrinter,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/** Print to memory functionality. The TiXmlPrinter is useful when you need to:\n"
    "\n"
    "    -# Print to memory (especially in non-STL mode)\n"
    "    -# Control formatting (line endings, etc.)\n"
    "\n"
    "    When constructed, the TiXmlPrinter is in its default \"pretty printing\" mode.\n"
    "    Before calling Accept() you can call methods to control the printing\n"
    "    of the XML document. After TiXmlNode::Accept() is called, the printed document can\n"
    "    be accessed via the CStr(), Str(), and Size() methods.\n"
    "\n"
    "    TiXmlPrinter uses the Visitor API.\n"
    "    @verbatim\n"
    "    TiXmlPrinter printer;\n"
    "    printer.SetIndent( \"\\t\" );\n"
    "\n"
    "    doc.Accept( &printer );\n"
    "    fprintf( stdout, \"%s\", printer.CStr() );\n"
    "    @endverbatim\n"
    "*/",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TiXmlPrinter,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TiXmlPrinter,
    PyType_GenericAlloc,
    Dtool_new_TiXmlPrinter,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TiXmlPrinter,
  Dtool_UpcastInterface_TiXmlPrinter,
  Dtool_DowncastInterface_TiXmlPrinter,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TiXmlPrinter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TiXmlVisitor(nullptr);
    Dtool_TiXmlPrinter._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_TiXmlVisitor);
    Dtool_TiXmlPrinter._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TiXmlPrinter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TiXmlPrinter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TiXmlPrinter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TiXmlPrinter);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3dxml_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
}

void Dtool_libp3dxml_BuildInstants(PyObject *module) {
  (void) module;
  // enum TiXmlEncoding
  PyModule_AddObject(module, "TIXML_ENCODING_UNKNOWN", Dtool_WrapValue(::TIXML_ENCODING_UNKNOWN));
  PyModule_AddObject(module, "TIXMLENCODINGUNKNOWN", Dtool_WrapValue(::TIXML_ENCODING_UNKNOWN));
  PyModule_AddObject(module, "TIXML_ENCODING_UTF8", Dtool_WrapValue(::TIXML_ENCODING_UTF8));
  PyModule_AddObject(module, "TIXMLENCODINGUTF8", Dtool_WrapValue(::TIXML_ENCODING_UTF8));
  PyModule_AddObject(module, "TIXML_ENCODING_LEGACY", Dtool_WrapValue(::TIXML_ENCODING_LEGACY));
  PyModule_AddObject(module, "TIXMLENCODINGLEGACY", Dtool_WrapValue(::TIXML_ENCODING_LEGACY));
  PyModule_AddStringConstant(module, "TINYXML_INCLUDED", "");
  PyModule_AddStringConstant(module, "TINYXMLINCLUDED", "");
  PyModule_AddStringConstant(module, "TIXML_SAFE", "");
  PyModule_AddStringConstant(module, "TIXMLSAFE", "");
  PyModule_AddStringConstant(module, "TIXML_SNPRINTF", "snprintf");
  PyModule_AddStringConstant(module, "TIXMLSNPRINTF", "snprintf");
  PyModule_AddStringConstant(module, "TIXML_SSCANF", "sscanf");
  PyModule_AddStringConstant(module, "TIXMLSSCANF", "sscanf");
  PyModule_AddStringConstant(module, "TIXML_STRING", "std::string");
  PyModule_AddStringConstant(module, "TIXMLSTRING", "std::string");
  // TiXmlBase
  Dtool_PyModuleClassInit_TiXmlBase(module);
  PyModule_AddObject(module, "TiXmlBase", (PyObject *)&Dtool_TiXmlBase);
  // TiXmlDeclaration
  Dtool_PyModuleClassInit_TiXmlDeclaration(module);
  PyModule_AddObject(module, "TiXmlDeclaration", (PyObject *)&Dtool_TiXmlDeclaration);
  // TiXmlNode
  Dtool_PyModuleClassInit_TiXmlNode(module);
  PyModule_AddObject(module, "TiXmlNode", (PyObject *)&Dtool_TiXmlNode);
  // TiXmlDocument
  Dtool_PyModuleClassInit_TiXmlDocument(module);
  PyModule_AddObject(module, "TiXmlDocument", (PyObject *)&Dtool_TiXmlDocument);
  // TiXmlElement
  Dtool_PyModuleClassInit_TiXmlElement(module);
  PyModule_AddObject(module, "TiXmlElement", (PyObject *)&Dtool_TiXmlElement);
  // TiXmlCursor
  Dtool_PyModuleClassInit_TiXmlCursor(module);
  PyModule_AddObject(module, "TiXmlCursor", (PyObject *)&Dtool_TiXmlCursor);
  // TiXmlVisitor
  Dtool_PyModuleClassInit_TiXmlVisitor(module);
  PyModule_AddObject(module, "TiXmlVisitor", (PyObject *)&Dtool_TiXmlVisitor);
  // TiXmlAttribute
  Dtool_PyModuleClassInit_TiXmlAttribute(module);
  PyModule_AddObject(module, "TiXmlAttribute", (PyObject *)&Dtool_TiXmlAttribute);
  // TiXmlAttributeSet
  Dtool_PyModuleClassInit_TiXmlAttributeSet(module);
  PyModule_AddObject(module, "TiXmlAttributeSet", (PyObject *)&Dtool_TiXmlAttributeSet);
  // TiXmlComment
  Dtool_PyModuleClassInit_TiXmlComment(module);
  PyModule_AddObject(module, "TiXmlComment", (PyObject *)&Dtool_TiXmlComment);
  // TiXmlText
  Dtool_PyModuleClassInit_TiXmlText(module);
  PyModule_AddObject(module, "TiXmlText", (PyObject *)&Dtool_TiXmlText);
  // TiXmlUnknown
  Dtool_PyModuleClassInit_TiXmlUnknown(module);
  PyModule_AddObject(module, "TiXmlUnknown", (PyObject *)&Dtool_TiXmlUnknown);
  // TiXmlHandle
  Dtool_PyModuleClassInit_TiXmlHandle(module);
  PyModule_AddObject(module, "TiXmlHandle", (PyObject *)&Dtool_TiXmlHandle);
  // TiXmlPrinter
  Dtool_PyModuleClassInit_TiXmlPrinter(module);
  PyModule_AddObject(module, "TiXmlPrinter", (PyObject *)&Dtool_TiXmlPrinter);
}

static PyMethodDef python_simple_funcs[] = {
  {"read_xml_stream", &Dtool_read_xml_stream_82, METH_O, (const char *)Dtool_read_xml_stream_82_comment},
  {"readXmlStream", &Dtool_read_xml_stream_82, METH_O, (const char *)Dtool_read_xml_stream_82_comment},
  {"write_xml_stream", (PyCFunction) &Dtool_write_xml_stream_83, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_write_xml_stream_83_comment},
  {"writeXmlStream", (PyCFunction) &Dtool_write_xml_stream_83, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_write_xml_stream_83_comment},
  {"print_xml", &Dtool_print_xml_84, METH_O, (const char *)Dtool_print_xml_84_comment},
  {"printXml", &Dtool_print_xml_84, METH_O, (const char *)Dtool_print_xml_84_comment},
  {"print_xml_to_file", (PyCFunction) &Dtool_print_xml_to_file_85, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_print_xml_to_file_85_comment},
  {"printXmlToFile", (PyCFunction) &Dtool_print_xml_to_file_85, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_print_xml_to_file_85_comment},
  {"get_TIXML_MAJOR_VERSION", &Dtool_get_TIXML_MAJOR_VERSION_87, METH_NOARGS, (const char *)Dtool_get_TIXML_MAJOR_VERSION_87_comment},
  {"getTIXMLMAJORVERSION", &Dtool_get_TIXML_MAJOR_VERSION_87, METH_NOARGS, (const char *)Dtool_get_TIXML_MAJOR_VERSION_87_comment},
  {"get_TIXML_MINOR_VERSION", &Dtool_get_TIXML_MINOR_VERSION_89, METH_NOARGS, (const char *)Dtool_get_TIXML_MINOR_VERSION_89_comment},
  {"getTIXMLMINORVERSION", &Dtool_get_TIXML_MINOR_VERSION_89, METH_NOARGS, (const char *)Dtool_get_TIXML_MINOR_VERSION_89_comment},
  {"get_TIXML_PATCH_VERSION", &Dtool_get_TIXML_PATCH_VERSION_91, METH_NOARGS, (const char *)Dtool_get_TIXML_PATCH_VERSION_91_comment},
  {"getTIXMLPATCHVERSION", &Dtool_get_TIXML_PATCH_VERSION_91, METH_NOARGS, (const char *)Dtool_get_TIXML_PATCH_VERSION_91_comment},
  {"get_TIXML_DEFAULT_ENCODING", &Dtool_get_TIXML_DEFAULT_ENCODING_104, METH_NOARGS, (const char *)Dtool_get_TIXML_DEFAULT_ENCODING_104_comment},
  {"getTIXMLDEFAULTENCODING", &Dtool_get_TIXML_DEFAULT_ENCODING_104, METH_NOARGS, (const char *)Dtool_get_TIXML_DEFAULT_ENCODING_104_comment},
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3dxml_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3dxml_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583613957,  /* file_identifier */
  "libp3dxml",  /* library_name */
  "uZHm",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3dxml.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  471  /* next_index */
};

Configure(_in_configure_libp3dxml);
ConfigureFn(_in_configure_libp3dxml) {
  interrogate_request_module(&_in_module_def);
}

